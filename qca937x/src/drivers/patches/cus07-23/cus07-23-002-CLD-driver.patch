diff -urN qcacld-new.orig/CORE/BAP/src/btampHCI.c qcacld-new/CORE/BAP/src/btampHCI.c
--- qcacld-new.orig/CORE/BAP/src/btampHCI.c	2015-09-24 15:25:20.581038328 +0800
+++ qcacld-new/CORE/BAP/src/btampHCI.c	2015-09-24 15:25:20.609038328 +0800
@@ -635,7 +635,7 @@
     else
     {
         /* Maximum of 5 triplets allowed, based on size of triplets definition */
-        if (tlvlen / 3 > 5)
+        if (tlvlen > 15)
         {
             tlvlen = 15;
         }
diff -urN qcacld-new.orig/CORE/CLD_TXRX/HTT/htt_h2t.c qcacld-new/CORE/CLD_TXRX/HTT/htt_h2t.c
--- qcacld-new.orig/CORE/CLD_TXRX/HTT/htt_h2t.c	2015-09-24 15:25:20.593038328 +0800
+++ qcacld-new/CORE/CLD_TXRX/HTT/htt_h2t.c	2015-09-24 15:25:20.621038328 +0800
@@ -512,6 +512,7 @@
         /* FIX THIS - add more details? */
         adf_os_print("%#x %#x stats not supported\n",
             stats_type_upload_mask, stats_type_reset_mask);
+        htt_htc_pkt_free(pdev, pkt);
         return -1; /* failure */
     }
 
diff -urN qcacld-new.orig/CORE/CLD_TXRX/HTT/htt_rx.c qcacld-new/CORE/CLD_TXRX/HTT/htt_rx.c
--- qcacld-new.orig/CORE/CLD_TXRX/HTT/htt_rx.c	2015-09-24 15:25:20.593038328 +0800
+++ qcacld-new/CORE/CLD_TXRX/HTT/htt_rx.c	2015-09-24 15:25:20.621038328 +0800
@@ -894,7 +894,7 @@
     }
     msdu = *head_msdu = htt_rx_netbuf_pop(pdev);
     while (1) {
-        int last_msdu, msdu_len_invalid, msdu_chained;
+        int last_msdu, msdu_len_invalid, msdu_chained = 0;
         int byte_offset;
 
         /*
@@ -2130,7 +2130,7 @@
         htt_list_remove(pdev->rx_ring.hash_table[i].freepool.next);
     }
     else {
-        hash_element = adf_os_mem_alloc(pdev->osdev, sizeof(hash_element));
+        hash_element = adf_os_mem_alloc(pdev->osdev, sizeof(struct htt_rx_hash_entry));
         if (adf_os_unlikely(NULL == hash_element)) {
             HTT_ASSERT_ALWAYS(0);
             return 1;
diff -urN qcacld-new.orig/CORE/CLD_TXRX/HTT/htt_tx.c qcacld-new/CORE/CLD_TXRX/HTT/htt_tx.c
--- qcacld-new.orig/CORE/CLD_TXRX/HTT/htt_tx.c	2015-09-24 15:25:20.593038328 +0800
+++ qcacld-new/CORE/CLD_TXRX/HTT/htt_tx.c	2015-09-24 15:25:20.617038328 +0800
@@ -78,7 +78,7 @@
 {
     int i, pool_size;
     u_int32_t **p;
-    adf_os_dma_addr_t pool_paddr;
+    adf_os_dma_addr_t pool_paddr = 0;
 
     if (pdev->cfg.is_high_latency) {
         pdev->tx_descs.size = sizeof(struct htt_host_tx_desc_t);
diff -urN qcacld-new.orig/CORE/CLD_TXRX/TXRX/ol_txrx.c qcacld-new/CORE/CLD_TXRX/TXRX/ol_txrx.c
--- qcacld-new.orig/CORE/CLD_TXRX/TXRX/ol_txrx.c	2015-09-24 15:25:20.593038328 +0800
+++ qcacld-new/CORE/CLD_TXRX/TXRX/ol_txrx.c	2015-09-24 15:25:20.621038328 +0800
@@ -154,8 +154,7 @@
     struct ol_txrx_pdev_t *pdev,
     u_int8_t local_peer_id)
 {
-    if ((local_peer_id == OL_TXRX_INVALID_LOCAL_PEER_ID) ||
-        (local_peer_id >= OL_TXRX_NUM_LOCAL_PEER_IDS)) {
+    if (local_peer_id >= OL_TXRX_NUM_LOCAL_PEER_IDS) {
         return NULL;
     }
     return pdev->local_peer_ids.map[local_peer_id];
diff -urN qcacld-new.orig/CORE/CLD_TXRX/TXRX/ol_txrx_peer_find.c qcacld-new/CORE/CLD_TXRX/TXRX/ol_txrx_peer_find.c
--- qcacld-new.orig/CORE/CLD_TXRX/TXRX/ol_txrx_peer_find.c	2015-09-24 15:25:20.593038328 +0800
+++ qcacld-new/CORE/CLD_TXRX/TXRX/ol_txrx_peer_find.c	2015-09-24 15:25:20.621038328 +0800
@@ -417,6 +417,7 @@
     int tx_ready)
 {
     ol_txrx_peer_find_add_id(pdev, peer_mac_addr, peer_id);
+#if 0
     if (pdev->cfg.is_high_latency && !tx_ready) {
         struct ol_txrx_peer_t *peer;
         peer = ol_txrx_peer_find_by_id(pdev, peer_id);
@@ -443,6 +444,7 @@
             }
         }
     }
+#endif
 }
 
 void
diff -urN qcacld-new.orig/CORE/CLD_TXRX/TXRX/ol_txrx_types.h qcacld-new/CORE/CLD_TXRX/TXRX/ol_txrx_types.h
--- qcacld-new.orig/CORE/CLD_TXRX/TXRX/ol_txrx_types.h	2015-09-24 15:25:20.593038328 +0800
+++ qcacld-new/CORE/CLD_TXRX/TXRX/ol_txrx_types.h	2015-09-24 15:25:20.621038328 +0800
@@ -61,8 +61,9 @@
 
 /* OL_TXRX_NUM_EXT_TIDS -
  * 16 "real" TIDs + 3 pseudo-TIDs for mgmt, mcast/bcast & non-QoS data
+ * max tid could be 31, set to 31 to avoid memory corruption
  */
-#define OL_TXRX_NUM_EXT_TIDS 19
+#define OL_TXRX_NUM_EXT_TIDS 31
 
 #define OL_TX_NUM_QOS_TIDS 16 /* 16 regular TIDs */
 #define OL_TX_NON_QOS_TID 16
diff -urN qcacld-new.orig/CORE/CLD_TXRX/TXRX/ol_tx_send.c qcacld-new/CORE/CLD_TXRX/TXRX/ol_tx_send.c
--- qcacld-new.orig/CORE/CLD_TXRX/TXRX/ol_tx_send.c	2015-09-24 15:25:20.593038328 +0800
+++ qcacld-new/CORE/CLD_TXRX/TXRX/ol_tx_send.c	2015-09-24 15:25:20.621038328 +0800
@@ -540,7 +540,7 @@
     }
 
     /* One shot protected access to pdev freelist, when setup */
-    if (lcl_freelist) {
+    if (lcl_freelist && tx_desc_last) {
         adf_os_spin_lock(&pdev->tx_mutex);
         tx_desc_last->next = pdev->tx_desc.freelist;
         pdev->tx_desc.freelist = lcl_freelist;
@@ -665,7 +665,7 @@
         }
     }
 
-    if (lcl_freelist) {
+    if (lcl_freelist && tx_desc_last) {
         adf_os_spin_lock(&pdev->tx_mutex);
         tx_desc_last->next = pdev->tx_desc.freelist;
         pdev->tx_desc.freelist = lcl_freelist;
diff -urN qcacld-new.orig/CORE/EPPING/src/epping_helper.c qcacld-new/CORE/EPPING/src/epping_helper.c
--- qcacld-new.orig/CORE/EPPING/src/epping_helper.c	2015-09-24 15:25:20.581038328 +0800
+++ qcacld-new/CORE/EPPING/src/epping_helper.c	2015-09-24 15:25:20.609038328 +0800
@@ -75,7 +75,7 @@
    for (i = 0; i < MAX_COOKIE_SLOTS_NUM; i++) {
       pEpping_ctx->s_cookie_mem[i] =
          vos_mem_malloc(sizeof(struct epping_cookie)*MAX_COOKIE_SLOT_SIZE);
-      if (pEpping_ctx->s_cookie_mem == NULL) {
+      if (pEpping_ctx->s_cookie_mem[i] == NULL) {
          EPPING_LOG(VOS_TRACE_LEVEL_FATAL,
             "%s: no mem for cookie (idx = %d)", __func__, i);
          goto error;
diff -urN qcacld-new.orig/CORE/EPPING/src/epping_tx.c qcacld-new/CORE/EPPING/src/epping_tx.c
--- qcacld-new.orig/CORE/EPPING/src/epping_tx.c	2015-09-24 15:25:20.581038328 +0800
+++ qcacld-new/CORE/EPPING/src/epping_tx.c	2015-09-24 15:25:20.609038328 +0800
@@ -340,6 +340,7 @@
 
    while (!HTC_QUEUE_EMPTY(pPacketQueue)) {
       htc_pkt = HTC_PACKET_DEQUEUE(pPacketQueue);
+      ASSERT(htc_pkt);
       status=htc_pkt->Status;
       eid=htc_pkt->Endpoint;
       pktSkb=GET_HTC_PACKET_NET_BUF_CONTEXT(htc_pkt);
diff -urN qcacld-new.orig/CORE/HDD/inc/bap_hdd_misc.h qcacld-new/CORE/HDD/inc/bap_hdd_misc.h
--- qcacld-new.orig/CORE/HDD/inc/bap_hdd_misc.h	2015-09-24 15:25:20.585038328 +0800
+++ qcacld-new/CORE/HDD/inc/bap_hdd_misc.h	2015-09-24 15:25:20.613038328 +0800
@@ -26,6 +26,7 @@
  */
 
 #if !defined( BAP_HDD_MISC_H )
+#ifdef WLAN_BTAMP_FEATURE
 #define BAP_HDD_MISC_H
 
 /**===========================================================================
@@ -136,4 +137,5 @@
 
   --------------------------------------------------------------------------*/
 v_BOOL_t WLANBAP_AmpSessionOn(void);
+#endif //WLAN_BTAMP_FEATURE
 #endif    // end #if !defined( BAP_HDD_MISC_H )
diff -urN qcacld-new.orig/CORE/HDD/inc/qc_sap_ioctl.h qcacld-new/CORE/HDD/inc/qc_sap_ioctl.h
--- qcacld-new.orig/CORE/HDD/inc/qc_sap_ioctl.h	2015-09-24 15:25:20.585038328 +0800
+++ qcacld-new/CORE/HDD/inc/qc_sap_ioctl.h	2015-09-24 15:25:20.613038328 +0800
@@ -239,7 +239,9 @@
     QCSAP_PARAM_SET_CHANNEL_CHANGE,
     QCASAP_SET_DFS_TARGET_CHNL,
     QCASAP_SET_RADAR_CMD,
-    QCSAP_GET_ACL
+    QCSAP_GET_ACL,
+    QCSAP_DIRECT_AUDIO_TEST,
+    QCSAP_DBGLOG_FWLOG_FILE_ENABLE,
 };
 
 int iw_softap_get_channel_list(struct net_device *dev,
diff -urN qcacld-new.orig/CORE/HDD/inc/wlan_hdd_cfg.h qcacld-new/CORE/HDD/inc/wlan_hdd_cfg.h
--- qcacld-new.orig/CORE/HDD/inc/wlan_hdd_cfg.h	2015-09-24 15:25:20.585038328 +0800
+++ qcacld-new/CORE/HDD/inc/wlan_hdd_cfg.h	2015-09-24 15:25:20.613038328 +0800
@@ -2755,6 +2755,63 @@
 #define CFG_ENABLE_SAP_SUSPEND_MAX                 ( 1 )
 #define CFG_ENABLE_SAP_SUSPEND_DEFAULT             ( 1 )
 
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+#define CFG_EXTWOW_GO_TO_SUSPEND                   "gExtWoWgotoSuspend"
+#define CFG_EXTWOW_GO_TO_SUSPEND_MIN               ( 0 )
+#define CFG_EXTWOW_GO_TO_SUSPEND_MAX               ( 1 )
+#define CFG_EXTWOW_GO_TO_SUSPEND_DEFAULT           ( 1 )
+
+#define CFG_EXTWOW_APP1_WAKE_PIN_NUMBER            "gExtWowApp1WakeupPinNumber"
+#define CFG_EXTWOW_APP1_WAKE_PIN_NUMBER_MIN        ( 0 )
+#define CFG_EXTWOW_APP1_WAKE_PIN_NUMBER_MAX        ( 255 )
+#define CFG_EXTWOW_APP1_WAKE_PIN_NUMBER_DEFAULT    ( 12 )
+
+#define CFG_EXTWOW_APP2_WAKE_PIN_NUMBER            "gExtWowApp2WakeupPinNumber"
+#define CFG_EXTWOW_APP2_WAKE_PIN_NUMBER_MIN        ( 0 )
+#define CFG_EXTWOW_APP2_WAKE_PIN_NUMBER_MAX        ( 255 )
+#define CFG_EXTWOW_APP2_WAKE_PIN_NUMBER_DEFAULT    ( 16 )
+
+#define CFG_EXTWOW_KA_INIT_PING_INTERVAL           "gExtWoWApp2KAInitPingInterval"
+#define CFG_EXTWOW_KA_INIT_PING_INTERVAL_MIN       ( 0 )
+#define CFG_EXTWOW_KA_INIT_PING_INTERVAL_MAX       ( 0xffffffff )
+#define CFG_EXTWOW_KA_INIT_PING_INTERVAL_DEFAULT   ( 240 )
+
+#define CFG_EXTWOW_KA_MIN_PING_INTERVAL            "gExtWoWApp2KAMinPingInterval"
+#define CFG_EXTWOW_KA_MIN_PING_INTERVAL_MIN        ( 0 )
+#define CFG_EXTWOW_KA_MIN_PING_INTERVAL_MAX        ( 0xffffffff )
+#define CFG_EXTWOW_KA_MIN_PING_INTERVAL_DEFAULT    ( 240 )
+
+#define CFG_EXTWOW_KA_MAX_PING_INTERVAL            "gExtWoWApp2KAMaxPingInterval"
+#define CFG_EXTWOW_KA_MAX_PING_INTERVAL_MIN        ( 0 )
+#define CFG_EXTWOW_KA_MAX_PING_INTERVAL_MAX        ( 0xffffffff )
+#define CFG_EXTWOW_KA_MAX_PING_INTERVAL_DEFAULT    ( 1280 )
+
+#define CFG_EXTWOW_KA_INC_PING_INTERVAL            "gExtWoWApp2KAIncPingInterval"
+#define CFG_EXTWOW_KA_INC_PING_INTERVAL_MIN        ( 0 )
+#define CFG_EXTWOW_KA_INC_PING_INTERVAL_MAX        ( 0xffffffff )
+#define CFG_EXTWOW_KA_INC_PING_INTERVAL_DEFAULT    ( 4 )
+
+#define CFG_EXTWOW_TCP_SRC_PORT                    "gExtWoWApp2TcpSrcPort"
+#define CFG_EXTWOW_TCP_SRC_PORT_MIN                ( 0 )
+#define CFG_EXTWOW_TCP_SRC_PORT_MAX                ( 65535 )
+#define CFG_EXTWOW_TCP_SRC_PORT_DEFAULT            ( 5000 )
+
+#define CFG_EXTWOW_TCP_DST_PORT                    "gExtWoWApp2TcpDstPort"
+#define CFG_EXTWOW_TCP_DST_PORT_MIN                ( 0 )
+#define CFG_EXTWOW_TCP_DST_PORT_MAX                ( 65535 )
+#define CFG_EXTWOW_TCP_DST_PORT_DEFAULT            ( 5001 )
+
+#define CFG_EXTWOW_TCP_TX_TIMEOUT                  "gExtWoWApp2TcpTxTimeout"
+#define CFG_EXTWOW_TCP_TX_TIMEOUT_MIN              ( 0 )
+#define CFG_EXTWOW_TCP_TX_TIMEOUT_MAX              ( 0xffffffff )
+#define CFG_EXTWOW_TCP_TX_TIMEOUT_DEFAULT          ( 200 )
+
+#define CFG_EXTWOW_TCP_RX_TIMEOUT                  "gExtWoWApp2TcpRxTimeout"
+#define CFG_EXTWOW_TCP_RX_TIMEOUT_MIN              ( 0 )
+#define CFG_EXTWOW_TCP_RX_TIMEOUT_MAX              ( 0xffffffff )
+#define CFG_EXTWOW_TCP_RX_TIMEOUT_DEFAULT          ( 200 )
+#endif
+
 #define CFG_ENABLE_DEAUTH_TO_DISASSOC_MAP_NAME    "gEnableDeauthToDisassocMap"
 #define CFG_ENABLE_DEAUTH_TO_DISASSOC_MAP_MIN     ( 0 )
 #define CFG_ENABLE_DEAUTH_TO_DISASSOC_MAP_MAX     ( 1 )
@@ -3472,6 +3529,19 @@
 
    v_BOOL_t                    enableSapSuspend;
 
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+   v_U8_t                      extWowGotoSuspend;
+   v_U8_t                      extWowApp1WakeupPinNumber;
+   v_U8_t                      extWowApp2WakeupPinNumber;
+   v_U32_t                     extWowApp2KAInitPingInterval;
+   v_U32_t                     extWowApp2KAMinPingInterval;
+   v_U32_t                     extWowApp2KAMaxPingInterval;
+   v_U32_t                     extWowApp2KAIncPingInterval;
+   v_U16_t                     extWowApp2TcpSrcPort;
+   v_U16_t                     extWowApp2TcpDstPort;
+   v_U32_t                     extWowApp2TcpTxTimeout;
+   v_U32_t                     extWowApp2TcpRxTimeout;
+#endif
    v_BOOL_t                    gEnableDeauthToDisassocMap;
 
 #ifdef DHCP_SERVER_OFFLOAD
diff -urN qcacld-new.orig/CORE/HDD/inc/wlan_hdd_direct_audio.h qcacld-new/CORE/HDD/inc/wlan_hdd_direct_audio.h
--- qcacld-new.orig/CORE/HDD/inc/wlan_hdd_direct_audio.h	1970-01-01 08:00:00.000000000 +0800
+++ qcacld-new/CORE/HDD/inc/wlan_hdd_direct_audio.h	2015-09-24 15:25:20.613038328 +0800
@@ -0,0 +1,170 @@
+#ifdef DIRECT_AUDIO_SUPPORT
+#ifndef SDA_H
+#define SDA_H
+
+/* direct audio prototype */
+
+typedef struct SDA_Descriptor
+{
+	unsigned char m_ReadyToCopy;
+	unsigned int m_PayloadSize;
+	unsigned int m_TimeStamp;
+}__attribute__((packed)) SDA_Descriptor_t;
+
+
+typedef struct SDA_HeadRoom
+{
+	unsigned char m_DestAddress[6];
+	unsigned char m_SourceAddress[6];
+	unsigned short m_PacketType;
+}__attribute__((packed)) SDA_HeadRoom_t;
+
+
+typedef struct
+{
+	SDA_Descriptor_t   m_Descriptor;
+	unsigned char m_Dummy[50 - sizeof(struct SDA_HeadRoom)];
+	SDA_HeadRoom_t  m_Headroom;
+}__attribute__((packed)) SDA_Header_t;
+
+
+
+/**
+ * @brief Retrieve the time stamp value from the p2p0 or wlan0 interface
+ * @remarks
+ * @param vif_id : get time stamp from wlan0/p2p0(0/1)interface
+ * @return time stamp value (64bits)
+ * @see
+ */
+unsigned long long SDA_getTsf (unsigned char vif_id);
+
+
+
+
+/**
+ * @brief Synchronize p2p0s time stamp value with wlan0s
+ * @remarks
+ * @param none
+ * @return 0 : success, - 1 : fail
+ * @see
+ */
+int SDA_syncTsf (void);
+
+
+
+/**
+ * @brief tsf¸¦ wifi module·Î ºÎÅÍ ¾òÀ½
+ * @remarks
+ * @param pTsf : tsf
+ * @return none
+ * @see
+ */
+void SDA_GetTSF(unsigned int *pTsf);
+
+
+
+
+/**
+ * @brief wifi module¿¡ tx¸¦ À§ÇØ¼­ »ç¿ëÇÒ buffer Á¤º¸¸¦ ¾Ë·ÁÁÜ.
+ * @brief send the buffer info to wifi module for tx.
+ * @remarks
+ * @param BufferId direct audio system¿¡¼­ audio input buffer´Â ÃÖ´ë 5°³·Î °¡Á¤ÇÔ. bufferÀÇ idÀÓ.
+ * @param BufferId is the mazimum 5.
+ * @param pBufferTotal : buffer address
+ * @param BufferTotalSize : buffer size
+ * @param BufferUnitSize : each unit size (descriptor + headroom + audio data size)
+ * @param HeadroomSize : head room size
+ * @return none
+ * @see
+ */
+void SDA_setSharedMemory4Send(unsigned int BufferId, unsigned char *pBufferTotal, unsigned int BufferTotalSize, unsigned int BufferUnitSize, unsigned int HeadroomSize);
+
+
+
+
+
+/**
+ * @brief wifi module¿¡ rx¸¦ À§ÇØ¼­ »ç¿ëÇÒ buffer Á¤º¸¸¦ ¾Ë·ÁÁÜ.
+ * @brief send the buffer info to wifi module for rx.
+ * @remarks
+ * @param pBufferTotal : buffer address
+ * @param BufferTotalSize : buffer size
+ * @param BufferUnitSize : each unit size (descriptor + headroom + audio data size)
+ * @param HeadroomSize : head room size
+ * @return none
+ * @see
+ */
+void SDA_setSharedMemory4Recv(unsigned char *pBufferTotal, unsigned int BufferTotalSize, unsigned int BufferUnitSize, unsigned int HeadroomSize);
+
+
+
+
+
+
+/*
+ * @brief Àü¼ÛÇÒ data¸¦ wifi module¿¡ Àü¼ÛÇÔ.
+ * @send the brief data data to wifi module (dsp --> wifi module)
+ * @remarks
+ * @param BufferId direct audio system¿¡¼­ audio input buffer´Â ÃÖ´ë 5°³·Î °¡Á¤ÇÔ. bufferÀÇ idÀÓ.
+ * @param on BufferId direct audio system, the maximum of audio input buffer is 5. bufferÀÇ idÀÓ.
+ * @param pBuffer : buffer address
+ * @param BufferSize : buffer size
+ * @return none
+ * @see
+ */
+void SDA_function4Send(unsigned int BufferId, unsigned char *pBuffer, unsigned int BufferSize);
+
+
+
+
+/**
+ * @brief wifi module¿¡¼­ data¸¦ Àü¼ÛÇÑ ÈÄ¿¡ callbackÈ£Ãâ (ack)
+ * @brief after sending data on wifi module, call the callback(ack) (wifi module --> dsp)
+ * @remarks
+ * @param BufferId direct audio system¿¡¼­ audio input buffer´Â ÃÖ´ë 5°³·Î °¡Á¤ÇÔ. bufferÀÇ idÀÓ.
+ * @param on BufferId direct audio system, the maximum of audio input buffer is 5.
+ * @param pBuffer : buffer address
+ * @param BufferSize : buffer size
+ * @return none
+ * @see
+ */
+typedef void (*SDA_SendDoneCallBack)(unsigned int BufferId, unsigned char *pBuffer, unsigned int BufferSize);
+
+void SDA_registerCallback4SendDone(SDA_SendDoneCallBack pCallback);
+
+
+
+
+
+
+
+/**
+ * @brief wifi module¿¡¼­ Àü¼Û ¹ÞÀº µ¥ÀÌÅÍ¸¦ soc¿¡ Àü¼ÛÇÔ.
+ * @brief on wifi module, send the receiving data to soc (wifi module --> dsp)
+ * @remarks
+ * @param pBuffer : buffer address
+ * @param BufferSize : buffer size
+ * @return none
+ * @see
+ */
+typedef void (*SDA_RecvCallBack)(unsigned char *pBuffer, unsigned int BufferSize);
+
+void SDA_registerCallback4Recv(SDA_RecvCallBack pCallback);
+
+
+
+
+
+/**
+ * @brief soc¿¡¼­ Àü¼Û ¹ÞÀº µ¥ÀÌÅÍ¸¦ Ã³¸®ÈÄ¿¡ wifi module¿¡ ¾Ë¸². (ack)
+ * @brief after finishing to received data on soc, notifying to wifi module(ack)
+ * @remarks
+ * @param pBuffer : buffer address
+ * @param BufferSize : buffer size
+ * @return none
+ * @see
+ */
+void SDA_function4RecvDone(unsigned char *pBuffer, unsigned int BufferSize);
+
+#endif // SDA_H
+#endif //DIRECT_AUDIO_SUPPORT
diff -urN qcacld-new.orig/CORE/HDD/inc/wlan_hdd_main.h qcacld-new/CORE/HDD/inc/wlan_hdd_main.h
--- qcacld-new.orig/CORE/HDD/inc/wlan_hdd_main.h	2015-09-24 15:25:20.585038328 +0800
+++ qcacld-new/CORE/HDD/inc/wlan_hdd_main.h	2015-09-24 15:25:20.613038328 +0800
@@ -1246,7 +1246,9 @@
     v_U8_t dl_loglevel;
     v_U8_t index;
     v_U32_t dl_mod_loglevel[MAX_MOD_LOGLEVEL];
-
+#ifdef CONFIG_WLAN_FWLOG_FILE
+    v_U8_t dl_fwlog_file;
+#endif
 }fw_log_info;
 
 /** Adapter stucture definition */
@@ -1531,6 +1533,19 @@
 #endif
     fw_log_info fw_log_settings;
 
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+    v_BOOL_t is_extwow_app_type1_param_set;
+#ifdef WLAN_FEATURE_EXTWOW_OUTDOOR_SUPPORT
+    v_BOOL_t is_extwow_app_type2_param_set;
+#endif
+    v_BOOL_t ext_wow_should_suspend;
+    struct completion ready_to_extwow;
+    tSirAppType1Params app_type1_params;
+#ifdef WLAN_FEATURE_EXTWOW_OUTDOOR_SUPPORT
+    tSirAppType2Params app_type2_params;
+#endif
+#endif
+
     /* RoC request queue and work */
     struct work_struct rocReqWork;
     hdd_list_t hdd_roc_req_q;
diff -urN qcacld-new.orig/CORE/HDD/src/wlan_hdd_assoc.c qcacld-new/CORE/HDD/src/wlan_hdd_assoc.c
--- qcacld-new.orig/CORE/HDD/src/wlan_hdd_assoc.c	2015-09-24 15:25:20.585038328 +0800
+++ qcacld-new/CORE/HDD/src/wlan_hdd_assoc.c	2015-09-24 15:25:20.613038328 +0800
@@ -1314,10 +1314,11 @@
         goto done;
     }
 
+    if (pCsrRoamInfo->pbFrames == NULL)
+        goto done;
+
     pFTAssocRsp = (u8 *)(pCsrRoamInfo->pbFrames + pCsrRoamInfo->nBeaconLength +
                     pCsrRoamInfo->nAssocReqLength);
-    if (pFTAssocRsp == NULL)
-        goto done;
 
     //pFTAssocRsp needs to point to the IEs
     pFTAssocRsp += FT_ASSOC_RSP_IES_OFFSET;
diff -urN qcacld-new.orig/CORE/HDD/src/wlan_hdd_cfg80211.c qcacld-new/CORE/HDD/src/wlan_hdd_cfg80211.c
--- qcacld-new.orig/CORE/HDD/src/wlan_hdd_cfg80211.c	2015-09-24 15:25:20.585038328 +0800
+++ qcacld-new/CORE/HDD/src/wlan_hdd_cfg80211.c	2015-09-24 15:25:20.613038328 +0800
@@ -7219,13 +7219,14 @@
 
     ENTER();
 
+    memset(&params, 0, sizeof(params));
+
     MTRACE(vos_trace(VOS_MODULE_ID_HDD,
                      TRACE_CODE_HDD_CFG80211_GET_KEY,
                      pAdapter->sessionId, params.cipher));
     hddLog(VOS_TRACE_LEVEL_INFO, "%s: device_mode = %d",
                                  __func__,pAdapter->device_mode);
 
-    memset(&params, 0, sizeof(params));
 
     if (CSR_MAX_NUM_KEY <= key_index)
     {
@@ -10555,8 +10556,7 @@
                          wiphy->retry_short :
                          wiphy->retry_long;
 
-        if ((WNI_CFG_LONG_RETRY_LIMIT_STAMIN > retry_value) ||
-                (WNI_CFG_LONG_RETRY_LIMIT_STAMAX < retry_value))
+        if (WNI_CFG_LONG_RETRY_LIMIT_STAMAX < retry_value)
         {
             hddLog(VOS_TRACE_LEVEL_ERROR, "%s: Invalid Retry count %hu",
                     __func__, retry_value);
diff -urN qcacld-new.orig/CORE/HDD/src/wlan_hdd_cfg.c qcacld-new/CORE/HDD/src/wlan_hdd_cfg.c
--- qcacld-new.orig/CORE/HDD/src/wlan_hdd_cfg.c	2015-09-24 15:25:20.585038328 +0800
+++ qcacld-new/CORE/HDD/src/wlan_hdd_cfg.c	2015-09-24 15:25:20.613038328 +0800
@@ -3747,6 +3747,85 @@
                CFG_ENABLE_SAP_SUSPEND_MIN,
                CFG_ENABLE_SAP_SUSPEND_MAX ),
 
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+   REG_VARIABLE( CFG_EXTWOW_GO_TO_SUSPEND, WLAN_PARAM_Integer,
+              hdd_config_t, extWowGotoSuspend,
+              VAR_FLAGS_OPTIONAL | VAR_FLAGS_RANGE_CHECK_ASSUME_DEFAULT,
+              CFG_EXTWOW_GO_TO_SUSPEND_DEFAULT,
+              CFG_EXTWOW_GO_TO_SUSPEND_MIN,
+              CFG_EXTWOW_GO_TO_SUSPEND_MAX ),
+
+   REG_VARIABLE( CFG_EXTWOW_APP1_WAKE_PIN_NUMBER, WLAN_PARAM_Integer,
+              hdd_config_t, extWowApp1WakeupPinNumber,
+              VAR_FLAGS_OPTIONAL | VAR_FLAGS_RANGE_CHECK_ASSUME_DEFAULT,
+              CFG_EXTWOW_APP1_WAKE_PIN_NUMBER_DEFAULT,
+              CFG_EXTWOW_APP1_WAKE_PIN_NUMBER_MIN,
+              CFG_EXTWOW_APP1_WAKE_PIN_NUMBER_MAX ),
+
+   REG_VARIABLE( CFG_EXTWOW_APP2_WAKE_PIN_NUMBER, WLAN_PARAM_Integer,
+              hdd_config_t, extWowApp2WakeupPinNumber,
+              VAR_FLAGS_OPTIONAL | VAR_FLAGS_RANGE_CHECK_ASSUME_DEFAULT,
+              CFG_EXTWOW_APP2_WAKE_PIN_NUMBER_DEFAULT,
+              CFG_EXTWOW_APP2_WAKE_PIN_NUMBER_MIN,
+              CFG_EXTWOW_APP2_WAKE_PIN_NUMBER_MAX ),
+
+   REG_VARIABLE( CFG_EXTWOW_KA_INIT_PING_INTERVAL, WLAN_PARAM_Integer,
+              hdd_config_t, extWowApp2KAInitPingInterval,
+              VAR_FLAGS_OPTIONAL | VAR_FLAGS_RANGE_CHECK_ASSUME_DEFAULT,
+              CFG_EXTWOW_KA_INIT_PING_INTERVAL_DEFAULT,
+              CFG_EXTWOW_KA_INIT_PING_INTERVAL_MIN,
+              CFG_EXTWOW_KA_INIT_PING_INTERVAL_MAX ),
+
+   REG_VARIABLE( CFG_EXTWOW_KA_MIN_PING_INTERVAL, WLAN_PARAM_Integer,
+              hdd_config_t, extWowApp2KAMinPingInterval,
+              VAR_FLAGS_OPTIONAL | VAR_FLAGS_RANGE_CHECK_ASSUME_DEFAULT,
+              CFG_EXTWOW_KA_MIN_PING_INTERVAL_DEFAULT,
+              CFG_EXTWOW_KA_MIN_PING_INTERVAL_MIN,
+              CFG_EXTWOW_KA_MIN_PING_INTERVAL_MAX ),
+
+   REG_VARIABLE( CFG_EXTWOW_KA_MAX_PING_INTERVAL, WLAN_PARAM_Integer,
+              hdd_config_t, extWowApp2KAMaxPingInterval,
+              VAR_FLAGS_OPTIONAL | VAR_FLAGS_RANGE_CHECK_ASSUME_DEFAULT,
+              CFG_EXTWOW_KA_MAX_PING_INTERVAL_DEFAULT,
+              CFG_EXTWOW_KA_MAX_PING_INTERVAL_MIN,
+              CFG_EXTWOW_KA_MAX_PING_INTERVAL_MAX ),
+
+   REG_VARIABLE( CFG_EXTWOW_KA_INC_PING_INTERVAL, WLAN_PARAM_Integer,
+              hdd_config_t, extWowApp2KAIncPingInterval,
+              VAR_FLAGS_OPTIONAL | VAR_FLAGS_RANGE_CHECK_ASSUME_DEFAULT,
+              CFG_EXTWOW_KA_INC_PING_INTERVAL_DEFAULT,
+              CFG_EXTWOW_KA_INC_PING_INTERVAL_MIN,
+              CFG_EXTWOW_KA_INC_PING_INTERVAL_MAX ),
+
+   REG_VARIABLE( CFG_EXTWOW_TCP_SRC_PORT, WLAN_PARAM_Integer,
+              hdd_config_t, extWowApp2TcpSrcPort,
+              VAR_FLAGS_OPTIONAL | VAR_FLAGS_RANGE_CHECK_ASSUME_DEFAULT,
+              CFG_EXTWOW_TCP_SRC_PORT_DEFAULT,
+              CFG_EXTWOW_TCP_SRC_PORT_MIN,
+              CFG_EXTWOW_TCP_SRC_PORT_MAX ),
+
+   REG_VARIABLE( CFG_EXTWOW_TCP_DST_PORT, WLAN_PARAM_Integer,
+              hdd_config_t, extWowApp2TcpDstPort,
+              VAR_FLAGS_OPTIONAL | VAR_FLAGS_RANGE_CHECK_ASSUME_DEFAULT,
+              CFG_EXTWOW_TCP_DST_PORT_DEFAULT,
+              CFG_EXTWOW_TCP_DST_PORT_MIN,
+              CFG_EXTWOW_TCP_DST_PORT_MAX ),
+
+   REG_VARIABLE( CFG_EXTWOW_TCP_TX_TIMEOUT, WLAN_PARAM_Integer,
+              hdd_config_t, extWowApp2TcpTxTimeout,
+              VAR_FLAGS_OPTIONAL | VAR_FLAGS_RANGE_CHECK_ASSUME_DEFAULT,
+              CFG_EXTWOW_TCP_TX_TIMEOUT_DEFAULT,
+              CFG_EXTWOW_TCP_TX_TIMEOUT_MIN,
+              CFG_EXTWOW_TCP_TX_TIMEOUT_MAX ),
+
+   REG_VARIABLE( CFG_EXTWOW_TCP_RX_TIMEOUT, WLAN_PARAM_Integer,
+              hdd_config_t, extWowApp2TcpRxTimeout,
+              VAR_FLAGS_OPTIONAL | VAR_FLAGS_RANGE_CHECK_ASSUME_DEFAULT,
+              CFG_EXTWOW_TCP_RX_TIMEOUT_DEFAULT,
+              CFG_EXTWOW_TCP_RX_TIMEOUT_MIN,
+              CFG_EXTWOW_TCP_RX_TIMEOUT_MAX ),
+#endif
+
    REG_VARIABLE( CFG_ENABLE_DEAUTH_TO_DISASSOC_MAP_NAME, WLAN_PARAM_Integer,
               hdd_config_t, gEnableDeauthToDisassocMap,
               VAR_FLAGS_OPTIONAL | VAR_FLAGS_RANGE_CHECK_ASSUME_DEFAULT,
@@ -4417,6 +4496,52 @@
             "Name = [gEnableSapSuspend] Value = [%u]",
             pHddCtx->cfg_ini->enableSapSuspend);
 
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+  VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+           "Name = [gExtWoWgotoSuspend] Value = [%u]",
+                   pHddCtx->cfg_ini->extWowGotoSuspend);
+
+  VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+           "Name = [gExtWowApp1WakeupPinNumber] Value = [%u]",
+                   pHddCtx->cfg_ini->extWowApp1WakeupPinNumber);
+
+  VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+           "Name = [gExtWowApp2WakeupPinNumber] Value = [%u]",
+                   pHddCtx->cfg_ini->extWowApp2WakeupPinNumber);
+
+  VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+           "Name = [gExtWoWApp2KAInitPingInterval] Value = [%u]",
+                   pHddCtx->cfg_ini->extWowApp2KAInitPingInterval);
+
+  VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+           "Name = [gExtWoWApp2KAMinPingInterval] Value = [%u]",
+                   pHddCtx->cfg_ini->extWowApp2KAMinPingInterval);
+
+  VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+           "Name = [gExtWoWApp2KAMaxPingInterval] Value = [%u]",
+                   pHddCtx->cfg_ini->extWowApp2KAMaxPingInterval);
+
+  VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+           "Name = [gExtWoWApp2KAIncPingInterval] Value = [%u]",
+                   pHddCtx->cfg_ini->extWowApp2KAIncPingInterval);
+
+  VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+           "Name = [gExtWoWApp2TcpSrcPort] Value = [%u]",
+                   pHddCtx->cfg_ini->extWowApp2TcpSrcPort);
+
+  VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+           "Name = [gExtWoWApp2TcpDstPort] Value = [%u]",
+                   pHddCtx->cfg_ini->extWowApp2TcpDstPort);
+
+  VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+           "Name = [gExtWoWApp2TcpTxTimeout] Value = [%u]",
+                   pHddCtx->cfg_ini->extWowApp2TcpTxTimeout);
+
+  VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+           "Name = [gExtWoWApp2TcpRxTimeout] Value = [%u]",
+                   pHddCtx->cfg_ini->extWowApp2TcpRxTimeout);
+#endif
+
 #ifdef DHCP_SERVER_OFFLOAD
   VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
            "Name = [gDHCPServerOffloadEnable] Value = [%u]",
@@ -4657,6 +4782,11 @@
    }
 }
 
+#ifdef CONFIG_TIZEN_PLATFORM
+extern int _readwrite_file(const char *filename, char *rbuf,
+	const char *wbuf, size_t length, int mode);
+#endif
+
 /*
  * This function tries to update macaddress from cfg file.
  * It overwrites the MAC address if config file exist.
@@ -4673,6 +4803,17 @@
    VOS_STATUS vos_status = VOS_STATUS_SUCCESS;
 
    memset(macTable, 0, sizeof(macTable));
+
+#ifdef CONFIG_TIZEN_PLATFORM
+	status = _readwrite_file("/lib/firmware/"WLAN_MAC_FILE, NULL, NULL, 0, O_RDONLY);
+	if (status <= 0) {
+		printk(KERN_ERR "%s: request_firmware failed %d\n",
+			__func__, status);
+		vos_status = VOS_STATUS_E_FAILURE;
+		return vos_status;
+	}
+#endif
+
    status = request_firmware(&fw, WLAN_MAC_FILE, pHddCtx->parent_dev);
 
    if (status)
diff -urN qcacld-new.orig/CORE/HDD/src/wlan_hdd_direct_audio.c qcacld-new/CORE/HDD/src/wlan_hdd_direct_audio.c
--- qcacld-new.orig/CORE/HDD/src/wlan_hdd_direct_audio.c	1970-01-01 08:00:00.000000000 +0800
+++ qcacld-new/CORE/HDD/src/wlan_hdd_direct_audio.c	2015-09-24 15:25:20.613038328 +0800
@@ -0,0 +1,632 @@
+#include <wlan_hdd_includes.h>
+#include <vos_api.h>
+#include <vos_sched.h>
+#include <linux/etherdevice.h>
+#include <linux/firmware.h>
+#include <wcnss_api.h>
+#include <wlan_hdd_tx_rx.h>
+#include <wlan_hdd_softap_tx_rx.h>
+#include <palTimer.h>
+#include <wniApi.h>
+#include <wlan_nlink_srv.h>
+#include <wlan_btc_svc.h>
+#include <wlan_hdd_cfg.h>
+#include <wlan_ptt_sock_svc.h>
+#include <dbglog_host.h>
+#include <wlan_logging_sock_svc.h>
+#include <wlan_hdd_wowl.h>
+#include <wlan_hdd_misc.h>
+#include <wlan_hdd_wext.h>
+#include "wlan_hdd_trace.h"
+#include "vos_types.h"
+#include "vos_trace.h"
+#include <net/addrconf.h>
+#include <linux/wireless.h>
+#include <net/cfg80211.h>
+#include <linux/inetdevice.h>
+#include <net/addrconf.h>
+#include <wlan_hdd_direct_audio.h>
+#include "ol_if_athvar.h"
+#include "hif.h"
+#if defined(HIF_PCI)
+#include "if_pci.h"
+#elif defined(HIF_USB)
+#include "if_usb.h"
+#elif defined(HIF_SDIO)
+#include "if_ath_sdio.h"
+#endif
+
+
+#ifdef DIRECT_AUDIO_SUPPORT
+#define SDA_DEBUG	1
+#define TSFDATASIZE	4
+
+#define DIRECT_AUDIO_LLC_TYPE 0x43FF
+#if SDA_DEBUG
+#define MAX_BUF_SIZE 1500 // bytes
+#define MAX_SHARE_MEM_ITEM	32
+#endif
+#define MAX_TX_POOL_ID 5
+
+struct Direct_Audio_Context {
+	u32		last_tx_process_time;
+	u32		max_tx_process_time;
+	u32		last_rx_process_time;
+	u32		max_rx_process_time;
+	hdd_context_t *pHddCtx;
+	u8		vif_id;
+};
+
+static struct Direct_Audio_Context	DA_context;
+SDA_SendDoneCallBack SDA_TX_DONE_CB = NULL;
+SDA_RecvCallBack SDA_RX_READY_CB = NULL;
+
+struct Direct_Audio_Setting_str {
+    u8  *pAddr;
+	u32 sizeTotal;
+	u32 lenUnit;
+	u32 lenHeadroom;
+	u8  *current_pAddr;
+}__packed;
+
+static struct Direct_Audio_Setting_str global_TX_DA_Setting[MAX_TX_POOL_ID];
+static struct Direct_Audio_Setting_str global_RX_DA_Setting;
+
+#define TX_DA_INIT_ADDR(id)   global_TX_DA_Setting[id].pAddr
+#define TX_DA_ADDR(id)        global_TX_DA_Setting[id].current_pAddr
+#define TX_DA_POOL_SIZE(id)   global_TX_DA_Setting[id].sizeTotal
+#define TX_DA_UNIT_LEN(id)    global_TX_DA_Setting[id].lenUnit
+#define TX_DA_HEAD_ROOM(id)   global_TX_DA_Setting[id].lenHeadroom
+
+static void Direct_Audio_Tx_Setting(u32 BufferId,
+                                    u8 *pAddr,
+                                    u32 sizeTotal,
+                                    u16 lenUnit,
+                                    u16 lenHeadroom)
+{
+	if(BufferId >= MAX_TX_POOL_ID)
+	{
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+			"%s: BufferId %d excess MAX_TX_POOL_ID %d\n",
+                          __func__,
+                          BufferId,
+                          MAX_TX_POOL_ID);
+		return;
+	}
+	TX_DA_INIT_ADDR(BufferId) = pAddr;
+	TX_DA_ADDR(BufferId) = pAddr;
+	TX_DA_POOL_SIZE(BufferId) = sizeTotal;
+	TX_DA_UNIT_LEN(BufferId) = lenUnit;
+	TX_DA_HEAD_ROOM(BufferId) = lenHeadroom;
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+		"%s[%d]BufferId=%d,pAddr=0%p,sizeTotal=%d,lenUnit=%d,lenHeadroom=%d\r\n",
+	        __func__, __LINE__, BufferId, pAddr, sizeTotal, lenUnit, lenHeadroom);
+}
+
+#define RX_DA_INIT_ADDR   global_RX_DA_Setting.pAddr
+#define RX_DA_ADDR        global_RX_DA_Setting.current_pAddr
+#define RX_DA_POOL_SIZE   global_RX_DA_Setting.sizeTotal
+#define RX_DA_UNIT_LEN    global_RX_DA_Setting.lenUnit
+#define RX_DA_HEAD_ROOM   global_RX_DA_Setting.lenHeadroom
+
+static void Direct_Audio_Rx_Setting(u8 *pAddr, u32 sizeTotal, u32 lenUnit, u32 lenHeadroom)
+{
+	RX_DA_INIT_ADDR = pAddr;
+	RX_DA_ADDR = pAddr;
+	RX_DA_POOL_SIZE = sizeTotal;
+	RX_DA_UNIT_LEN = lenUnit;
+	RX_DA_HEAD_ROOM = lenHeadroom;
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+		"%s[%d] pAddr=0%p,sizeTotal=%d,lenUnit=%d,lenHeadroom=%d\r\n",
+	    __func__, __LINE__, pAddr, sizeTotal, lenUnit, lenHeadroom);
+}
+
+//SDA_SendDoneCallBack  SDA_TX_DONE_CB = NULL;
+#define SDA_BUF_READY(_desc)      	!!_desc->m_ReadyToCopy
+#define TX_SDA_INIT_ADDR			orig_data_p
+#define TX_SDA_ADDR 				descp_p
+#define TX_SDA_POOL_SIZE			BufferSize
+#define TX_SDA_UNIT_LEN(id)				TX_DA_UNIT_LEN(id)
+#define CLR_SDA_BUF_READY(_desc)  	_desc->m_ReadyToCopy = 0
+#define SET_SDA_BUF_READY(_desc)  	_desc->m_ReadyToCopy = 1
+static void SDA_Tx_fun( struct net_device *dev, u32 BufferId, u8 *pBuffer, u32 BufferSize)
+{
+	u8 *orig_data_p = pBuffer;
+	u8 *data_p = pBuffer;
+	u8 *descp_p = pBuffer;
+	struct SDA_Descriptor *tx_desc = (struct SDA_Descriptor *) data_p;
+	hdd_adapter_t * vif;
+	int status = 0;
+	vif = hdd_get_adapter_by_vdev(DA_context.pHddCtx, DA_context.vif_id);
+	if(!vif)
+		return;
+
+	if(BufferId >= MAX_TX_POOL_ID)
+	{
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_WARN,
+			"%s: BufferId excess %d\n", __func__, MAX_TX_POOL_ID);
+		goto tx_fail;
+	}
+	if (!data_p || !SDA_BUF_READY(tx_desc)) {
+		//Should not into here
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_WARN,
+			"%s: descriptor show not ready\n", __func__);
+		goto tx_fail;
+	}
+	/*Check descriptor*/
+	do {
+		struct sk_buff *skb;
+		int send_len = 0;
+		struct ethhdr *eth_hdr;
+		int alloc_size = 0;
+
+		/* point to RAW_Data
+		* Assume offset include Descriptor & Headroom
+		*/
+		data_p += sizeof(SDA_Header_t);
+		/*Create skb, copy data, fill skb header*/
+		alloc_size = tx_desc->m_PayloadSize+sizeof(struct ethhdr);
+		skb = adf_nbuf_alloc(NULL, alloc_size, 0, sizeof(u_int32_t), 0);
+		if (skb == NULL) {
+			//should not happened
+			VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+				"%s: Allocate skb failed\n", __func__);
+			break;
+		}
+
+		skb_put(skb, alloc_size);
+		memset(skb->data, 0, alloc_size);
+		//Copy data from share buf to skb
+		memcpy(skb->data, data_p-sizeof(struct ethhdr),
+                       tx_desc->m_PayloadSize+sizeof(struct ethhdr));
+		send_len += tx_desc->m_PayloadSize+sizeof(struct ethhdr);
+
+		eth_hdr = (struct ethhdr *)(skb->data);
+
+		//copy mac address as source address
+		memcpy(eth_hdr->h_source,vif->dev->dev_addr,6);
+#if 0 //dest mac is filled by upper layer like virutal sound card
+		if (vif->device_mode == WLAN_HDD_INFRA_STATION || vif->device_mode == WLAN_HDD_P2P_CLIENT)
+		{
+			hdd_station_ctx_t *pHddStaCtx = WLAN_HDD_GET_STATION_CTX_PTR(vif);
+			memcpy(eth_hdr->h_dest, pHddStaCtx->conn_info.bssId, 6);
+		}
+		else
+		{
+			u8 broadcastpeer[6] = {0xff,0xff,0xff,0xff,0xff,0xff};
+			memcpy(eth_hdr->h_dest, broadcastpeer, 6);
+		}
+#endif
+		skb->protocol = ntohs(eth_hdr->h_proto);
+		skb->dev = dev;
+		skb->priority = SME_QOS_WMM_UP_VI;
+		skb->queue_mapping = hddLinuxUpToAcMap[skb->priority];
+
+		/*Adjust the length of data before send*/
+		skb_trim(skb, send_len);
+		//Call normal tx path
+		if (vif->device_mode == WLAN_HDD_INFRA_STATION ||
+                    vif->device_mode == WLAN_HDD_P2P_CLIENT)
+			status = hdd_hard_start_xmit(skb, dev);
+		else if (vif->device_mode == WLAN_HDD_SOFTAP ||
+                         vif->device_mode == WLAN_HDD_P2P_GO)
+			status = hdd_softap_hard_start_xmit(skb, dev);
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_LOW,
+			"%s[%d]BufferId=%d,audio len = %d,status = %d by %d\n",
+		        __func__, __LINE__, BufferId,
+                          tx_desc->m_PayloadSize,
+                          status,
+                          (vif->device_mode));
+		//Clear share buffer Ready flag
+		CLR_SDA_BUF_READY(tx_desc);
+		//To-do: call SS complete routine
+
+		//Next frame & check if need retrun pAddr of DA Share buff
+		if(((TX_SDA_ADDR - TX_SDA_INIT_ADDR)+TX_SDA_UNIT_LEN(BufferId)) >= TX_SDA_POOL_SIZE)
+                {
+			/*Return to Init buf addr*/
+			TX_SDA_ADDR = TX_SDA_INIT_ADDR;
+		} else {
+			/*Go to Next buf*/
+			TX_SDA_ADDR += TX_SDA_UNIT_LEN(BufferId);
+		}
+		data_p = TX_SDA_ADDR;
+		tx_desc = (struct SDA_Descriptor *) data_p;
+	} while(SDA_BUF_READY(tx_desc));//Check if having next
+tx_fail:
+	if (SDA_TX_DONE_CB)
+		SDA_TX_DONE_CB(BufferId,pBuffer,BufferSize);
+}
+
+/*Assume The RX Already to be Packet Mode*/
+void SDA_Rx_fun( struct net_device *dev, struct sk_buff *skb)
+{
+#if (!defined FILE_DEBUG) && (!defined UDPDBG) //call real DA engine
+    u32 tsf_ie=0, tsf_data=0;
+    u8 *data_p = RX_DA_ADDR;
+    struct SDA_Descriptor *rx_desc = (struct SDA_Descriptor *) data_p;
+
+    if (skb == NULL) {
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
+			"%s: input buf should not be NULL\n", __func__);
+		return;
+	}
+#define TSF_IE 0x1234fedc
+	tsf_ie = le32_to_cpu(*((u32 *)(skb->data + skb->len - 2*sizeof(u32))));
+	if (tsf_ie == TSF_IE) {
+		skb_trim(skb, (skb->len - 2*sizeof(u32)));
+
+		tsf_data = le32_to_cpu(*((u32 *)(skb->data + skb->len + sizeof(u32))));
+		//printk("~~current-tsf (%x) \n",tsf_data);
+	}
+
+	if (!data_p) {
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+			"%s: DSP dose not register rx pool\n", __func__);
+		dev_kfree_skb(skb);
+		return;
+	}
+
+	if(SDA_BUF_READY(rx_desc)) {
+	   //the share buf not available. DO NOT PUT PRINT LOG HERE.
+	   goto rx_fail;
+	}
+
+	//Fill derscriptort
+	rx_desc->m_PayloadSize = skb->len;//no ethernet header included and remove TSF_IE
+	rx_desc->m_TimeStamp = 0 ;
+
+	if (skb->len > (RX_DA_UNIT_LEN-sizeof(struct SDA_Descriptor)-RX_DA_HEAD_ROOM)) {
+	    //Should not happen
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+			"%s: Not having enough room for RX DATA\n", __func__);
+		skb->len = RX_DA_UNIT_LEN-sizeof(struct SDA_Descriptor)-RX_DA_HEAD_ROOM;
+	}
+	//copy to share buf & Skip the length of "struct ethhdr"
+	memcpy((data_p + sizeof(struct SDA_Descriptor) + RX_DA_HEAD_ROOM) - sizeof(struct ethhdr),
+		skb->data -sizeof(struct ethhdr),
+		skb->len + sizeof(struct ethhdr));
+
+	// Set rx timestamp
+	memcpy(data_p + sizeof(struct SDA_Descriptor) + RX_DA_HEAD_ROOM +sizeof(u32),
+			&tsf_data, sizeof(u32));
+
+	//To-do: :Call SS Direct Audio RX routine
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+		"%s[%d]audio len=%d\n\r",__func__,__LINE__,rx_desc->m_PayloadSize);
+
+	SET_SDA_BUF_READY(rx_desc);
+	if (SDA_RX_READY_CB)
+		SDA_RX_READY_CB((u8*)rx_desc,RX_DA_UNIT_LEN);
+
+	//Next DA Share buff
+	if(((RX_DA_ADDR - RX_DA_INIT_ADDR)+RX_DA_UNIT_LEN) >= RX_DA_POOL_SIZE ) {
+	    /*Return to Init buf addr*/
+	    RX_DA_ADDR = RX_DA_INIT_ADDR;
+	} else {
+	    /*Go to Next buf*/
+	    RX_DA_ADDR += RX_DA_UNIT_LEN;
+	}
+rx_fail:
+	dev_kfree_skb(skb);
+#endif
+}
+
+void SDA_function4Send(unsigned int BufferId, unsigned char *pBuffer, unsigned int BufferSize)
+{
+	hdd_adapter_t * vif;
+	hdd_station_ctx_t *pHddStaCtx;
+	hdd_ap_ctx_t *pAPCtx;
+
+	u32	entry_time;
+	if (DA_context.pHddCtx == NULL) {
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_WARN,
+			"%s: DA_context.ar should not be NULL\n", __func__);
+		return;
+	}
+
+	vif = hdd_get_adapter_by_vdev(DA_context.pHddCtx, DA_context.vif_id);
+	if (!vif) {
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_WARN,
+			"%s: Failed to find vif for DA, DA_context.ar=%p, DA_context.vif_id=%d\n"
+			, __func__,
+			DA_context.pHddCtx,
+			DA_context.vif_id);
+		return;
+	}
+	if (vif->device_mode == WLAN_HDD_INFRA_STATION || vif->device_mode == WLAN_HDD_P2P_CLIENT) {
+		pHddStaCtx = WLAN_HDD_GET_STATION_CTX_PTR(vif);
+		if (!pHddStaCtx || !hdd_connIsConnected(pHddStaCtx)) {
+			VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+				"%s: STA %p is not connected\n", __func__, pHddStaCtx);
+			return;
+		}
+	}
+	if (vif->device_mode == WLAN_HDD_SOFTAP || vif->device_mode == WLAN_HDD_P2P_GO) {
+		pAPCtx = WLAN_HDD_GET_AP_CTX_PTR(vif);
+	}
+	entry_time = jiffies;
+	SDA_Tx_fun(vif->dev,BufferId,pBuffer,BufferSize);
+	DA_context.last_tx_process_time = jiffies - entry_time;
+
+	if (DA_context.max_tx_process_time < DA_context.last_tx_process_time)
+		DA_context.max_tx_process_time = DA_context.last_tx_process_time;
+}
+
+void SDA_function4RecvDone(unsigned char *pBuffer, unsigned int BufferSize)
+{
+	//what should we do in this API
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+		"%s[%d]pBuffer=0x%p,BufferSize=%d\n\r",__func__,__LINE__,pBuffer,BufferSize);
+}
+
+void SDA_setSharedMemory4Send(unsigned int BufferId,
+                                  unsigned char *pBufferTotal,
+                                  unsigned int BufferTotalSize,
+                                  unsigned int BufferUnitSize,
+                                  unsigned int HeadroomSize)
+{
+	Direct_Audio_Tx_Setting(BufferId,
+                                pBufferTotal,
+                                BufferTotalSize,
+                                BufferUnitSize,
+                                HeadroomSize);
+}
+
+void SDA_setSharedMemory4Recv(unsigned char *pBufferTotal,
+                                  unsigned int BufferTotalSize,
+                                  unsigned int BufferUnitSize,
+                                  unsigned int HeadroomSize)
+{
+	Direct_Audio_Rx_Setting(pBufferTotal,
+                                BufferTotalSize,
+                                BufferUnitSize,
+                                HeadroomSize);
+}
+
+//Register callback which CLD notify DSP that CLD has received the audio packet
+void SDA_registerCallback4Recv(SDA_RecvCallBack pCallback)
+{
+	SDA_RX_READY_CB = pCallback;
+}
+
+//Register callback which Mck notify DSP that Mck has sent the audio packet
+void SDA_registerCallback4SendDone(SDA_SendDoneCallBack pCallback)
+{
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+		"%s[%d]\n\r",__func__,__LINE__);
+	SDA_TX_DONE_CB = pCallback;
+}
+
+void Direct_Audio_debug_dump(void)
+{
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,"DA_context.pHddCtx = 0x%x\n\r",(int)DA_context.pHddCtx);
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,"DA_context.last_tx_process_time = %u\n\r",DA_context.last_tx_process_time);
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,"DA_context.max_tx_process_time = %u\n\r",DA_context.max_tx_process_time);
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,"DA_context.last_rx_process_time = %u\n\r",DA_context.last_rx_process_time);
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,"DA_context.max_rx_process_time = %u\n\r",DA_context.max_rx_process_time);
+}
+
+void Direct_Audio_init(hdd_context_t *pHddCtx)
+{
+	int i;
+
+	memset(&global_RX_DA_Setting, 0x0, sizeof(global_RX_DA_Setting));
+	for (i = 0; i < MAX_TX_POOL_ID; i++)
+	    memset(&global_TX_DA_Setting[i], 0x0, sizeof(global_TX_DA_Setting[0]));
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,"%s[%d]\n\r",__func__,__LINE__);
+
+	memset(&DA_context,0x00,sizeof(DA_context));
+	DA_context.pHddCtx = pHddCtx;
+	DA_context.vif_id = 1;//use p2p0 as default
+}
+
+void Direct_Audio_deinit(hdd_context_t *pHddCtx)
+{
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,"%s[%d]\n\r",__func__,__LINE__);
+}
+
+#define TSF_TO_TU(_h,_l)    ((((u64)(_h)) << 32) | ((u64)(_l)))
+#define REG_TSF_L 0x1054
+#define REG_TSF_H 0x1058
+#define REG_TSF2_L 0x10d4
+#define REG_TSF2_H 0x10d8
+
+
+void SDA_GetTSF(unsigned int *pTsf)
+{
+	*((u64 *)pTsf) = SDA_getTsf(0);
+}
+
+unsigned long long SDA_getTsf (unsigned char vif_id)
+{
+	A_UINT32 datah = 0, datal = 0;
+	struct hif_usb_softc *sc;
+	struct ol_softc *pOlsc;
+	VosContextType *pHIFContext = NULL;
+	v_CONTEXT_t pVosContext = NULL;
+
+	if (DA_context.pHddCtx == NULL) {
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
+			"%s: DA_context.ar should not be NULL\n", __func__);
+		return 0;
+	}
+
+	pVosContext = DA_context.pHddCtx->pvosContext;
+	pHIFContext = ((VosContextType*)pVosContext)->pHIFContext;
+	pOlsc = (struct ol_softc *)pHIFContext;
+	sc = pOlsc->hif_sc;
+
+	if (vif_id) {
+		HIFDiagReadAccess(sc->hif_device, REG_TSF2_H, &datah);
+		HIFDiagReadAccess(sc->hif_device, REG_TSF2_L, &datal);
+	} else {
+		HIFDiagReadAccess(sc->hif_device, REG_TSF_H, &datah);
+		HIFDiagReadAccess(sc->hif_device, REG_TSF_L, &datal);
+	}
+	return TSF_TO_TU(datah, datal);
+}
+
+int SDA_syncTsf (void)
+{
+	A_UINT32 datah = 0, datal = 0;
+	struct hif_usb_softc *sc;
+	struct ol_softc *pOlsc;
+	VosContextType *pHIFContext = NULL;
+	v_CONTEXT_t pVosContext = NULL;
+
+	if (DA_context.pHddCtx == NULL) {
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
+			"%s: DA_context.ar should not be NULL\n", __func__);
+		return 0;
+	}
+
+	pVosContext = DA_context.pHddCtx->pvosContext;
+	pHIFContext = ((VosContextType*)pVosContext)->pHIFContext;
+	pOlsc = (struct ol_softc *)pHIFContext;
+	sc = pOlsc->hif_sc;
+
+	HIFDiagReadAccess(sc->hif_device, REG_TSF_L, &datal);
+	HIFDiagReadAccess(sc->hif_device, REG_TSF_H, &datah);
+
+	HIFDiagWriteAccess(sc->hif_device, REG_TSF2_L, datal);
+	HIFDiagWriteAccess(sc->hif_device, REG_TSF2_H, datah);
+
+	return 0;
+}
+
+#if SDA_DEBUG//debug use
+struct D_A_SHARE_MEM {
+    SDA_Header_t	desc;
+	u8				data[MAX_BUF_SIZE];
+};
+
+static void debug_tx_done_cb(unsigned int BufferId, unsigned char *pBuffer, unsigned int BufferSize)
+{
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+			"%s[%d]BufferId=%d,pBuffer=0x%p,BufferSize=%d\n\r",
+	        __func__, __LINE__, BufferId, pBuffer, BufferSize);
+}
+
+int Direct_Audio_TX_debug(void)
+{
+	u8	*buf;
+	u32 len,i,BufferSize;
+	u8	*ptr,*eth_ptr;
+	SDA_Descriptor_t *share_mem_ptr;
+	hdd_adapter_t * vif;
+
+	u8	test_peermac[6] = {0x02,0x03,0x7f,0x8b,0x18,0x93};
+	//u8	test_peermac[6] = {0xff,0xff,0xff,0xff,0xff,0xff};
+	struct ethhdr *eth_hdr;
+
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
+		"%s[%d]Simulate TX behavior\n\r",__func__,__LINE__);
+	SDA_registerCallback4SendDone(debug_tx_done_cb);
+
+	len = (sizeof(SDA_Header_t)+MAX_BUF_SIZE)*MAX_SHARE_MEM_ITEM;
+	buf = kmalloc(len, GFP_ATOMIC);
+	if (!buf)
+		return -ENOMEM;
+	SDA_setSharedMemory4Send(0, buf, len, sizeof(SDA_Header_t)+MAX_BUF_SIZE, 50);
+	ptr	= buf;
+	//construct tx share memory
+	vif = hdd_get_adapter_by_vdev(DA_context.pHddCtx, DA_context.vif_id);
+	if(!vif)
+		return -ENOMEM;
+
+
+
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+			"peer %pM mac %pM\n", test_peermac, vif->dev->dev_addr);
+
+	memset(buf,0x00,len);
+	share_mem_ptr = (SDA_Descriptor_t *)buf;
+	BufferSize = 0;
+
+	for (i=0; i < 1; i++) {
+		//fill descript
+		share_mem_ptr->m_ReadyToCopy = 1;
+		share_mem_ptr->m_PayloadSize = 1024;
+		share_mem_ptr->m_TimeStamp = 0;
+		//fill ethernet header
+		eth_ptr = ptr+sizeof(SDA_Header_t)-sizeof(struct ethhdr);
+		eth_hdr = (struct ethhdr *)eth_ptr;
+		memcpy(eth_hdr->h_dest,test_peermac,6);
+		memcpy(eth_hdr->h_source,vif->dev->dev_addr,6);
+		eth_hdr->h_proto = htons(DIRECT_AUDIO_LLC_TYPE);
+		memset(ptr+sizeof(SDA_Header_t),0xa5,share_mem_ptr->m_PayloadSize);
+		BufferSize += sizeof(SDA_Header_t) + MAX_BUF_SIZE;
+		ptr = ptr + sizeof(SDA_Header_t) + MAX_BUF_SIZE;
+		share_mem_ptr = (SDA_Descriptor_t *)ptr;
+	}
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+		"%s[%d]BufferId=%d,pBuffer=0x%p,BufferSize=%d\n\r",
+	    __func__, __LINE__, 0, buf, BufferSize);
+	//notify Direct Audio module to send packet
+	SDA_function4Send(0, buf, BufferSize);
+
+	kfree(buf);
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
+		"%s[%d]Simulate TX finish, wlan tsf %llu, p2p tsf %llu\n",
+		__func__,__LINE__, SDA_getTsf(0), SDA_getTsf(1));
+
+	return 0;
+}
+
+static void debug_rx_ready_cb(unsigned char *pBuffer, unsigned int BufferSize)
+{
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
+		"%s[%d]pBuffer=0x%p,BufferSize=%d\n\r",
+		__func__, __LINE__, pBuffer, BufferSize);
+}
+
+int Direct_Audio_RX_debug(void)
+{
+	u8	*buf;
+	u32 len;
+
+	if(RX_DA_INIT_ADDR) {
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_WARN,
+			"%s[%d]already rx debug\n\r",__func__,__LINE__);
+	}
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
+		"%s[%d]SimulateRX behavior\n\r",__func__,__LINE__);
+	len = sizeof(struct D_A_SHARE_MEM)*MAX_SHARE_MEM_ITEM;
+	buf = kmalloc(len, GFP_ATOMIC);
+	if (!buf)
+		return -ENOMEM;
+	//construct rx share memory
+	memset(buf,0x00,len);
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
+		"%s[%d]buf=0x%p\n\r", __func__, __LINE__, buf);
+	SDA_setSharedMemory4Recv(buf, len, sizeof(struct D_A_SHARE_MEM), 50);
+	//Direct_Audio_RxReady_Notify_cb_Reg(debug_rx_ready_cb);
+	SDA_registerCallback4Recv(debug_rx_ready_cb);
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
+		"%s[%d]Simulate RX finish\n\r",__func__,__LINE__);
+	kfree(buf);
+	return 0;
+}
+#else
+int Direct_Audio_TX_debug(void)
+{
+	return 0;
+}
+
+int Direct_Audio_RX_debug(void)
+{
+	return 0;
+}
+#endif //if SDA_DEBUG
+
+EXPORT_SYMBOL(SDA_function4Send);
+EXPORT_SYMBOL(SDA_function4RecvDone);
+EXPORT_SYMBOL(SDA_setSharedMemory4Send);
+EXPORT_SYMBOL(SDA_setSharedMemory4Recv);
+EXPORT_SYMBOL(SDA_registerCallback4SendDone);
+EXPORT_SYMBOL(SDA_registerCallback4Recv);
+EXPORT_SYMBOL(SDA_GetTSF);
+EXPORT_SYMBOL(SDA_getTsf);
+EXPORT_SYMBOL(SDA_syncTsf);
+#endif //end DIRECT_AUDIO_SUPPORT
diff -urN qcacld-new.orig/CORE/HDD/src/wlan_hdd_hostapd.c qcacld-new/CORE/HDD/src/wlan_hdd_hostapd.c
--- qcacld-new.orig/CORE/HDD/src/wlan_hdd_hostapd.c	2015-09-24 15:25:20.585038328 +0800
+++ qcacld-new/CORE/HDD/src/wlan_hdd_hostapd.c	2015-09-24 15:25:20.613038328 +0800
@@ -1389,6 +1389,8 @@
                 return VOS_STATUS_E_FAULT;
             }
 #endif
+		    break;
+
         case eSAP_DFS_NOL_SET:
             hddLog(VOS_TRACE_LEVEL_INFO, FL("Received eSAP_DFS_NOL_SET event"));
 #if defined CONFIG_CNSS
@@ -1865,6 +1867,11 @@
     return VOS_STATUS_SUCCESS;
 }
 
+#ifdef DIRECT_AUDIO_SUPPORT
+	extern int Direct_Audio_TX_debug(void);
+	extern int Direct_Audio_RX_debug(void);
+#endif
+
 int
 static iw_softap_setparam(struct net_device *dev,
                           struct iw_request_info *info,
@@ -2136,6 +2143,16 @@
                                                set_value, DBG_CMD);
                   break;
              }
+#ifdef CONFIG_WLAN_FWLOG_FILE
+        case QCSAP_DBGLOG_FWLOG_FILE_ENABLE:
+             {
+                  hddLog(LOG1, "QCSAP_DBGLOG_FWLOG_FILE_ENABLE val %d", set_value);
+                  ret = process_wma_set_command((int)pHostapdAdapter->sessionId,
+                                               (int)WMI_DBGLOG_FWLOG_FILE_ENABLE,
+                                               set_value, DBG_CMD);
+                  break;
+             }
+#endif
 #ifdef DEBUG
          case QCSAP_FW_CRASH_INJECT:
              {
@@ -2616,6 +2633,20 @@
                 }
                 break;
             }
+#ifdef DIRECT_AUDIO_SUPPORT
+	case QCSAP_DIRECT_AUDIO_TEST:
+	    {
+		hddLog(LOGW, "%s: SAP Direct_Audio Test %s\n",
+				  __func__, set_value?"TX":"RX");
+		if (set_value) {
+		  ret = Direct_Audio_TX_debug();
+		}
+		else {
+		  ret = Direct_Audio_RX_debug();
+		}
+		break;
+	    }
+#endif
         default:
             hddLog(LOGE, FL("Invalid setparam command %d value %d"),
                     sub_cmd, set_value);
@@ -3811,7 +3842,7 @@
       switch ( wps_genie[0] )
       {
          case DOT11F_EID_WPA:
-            if (wps_genie[1] < 2 + 4)
+            if (wps_genie[1] < 2 + 4 || wps_genie[1] > DOT11F_IE_WPA_MAX_LEN + 2 + 4)
             {
                vos_mem_free(pSap_WPSIe);
                kfree(fwps_genie);
@@ -3913,7 +3944,7 @@
       switch ( wps_genie[0] )
       {
          case DOT11F_EID_WPA:
-            if (wps_genie[1] < 2 + 4)
+            if (wps_genie[1] < 2 + 4 || wps_genie[1] > DOT11F_IE_WPA_MAX_LEN + 2 + 4)
             {
                vos_mem_free(pSap_WPSIe);
                kfree(fwps_genie);
diff -urN qcacld-new.orig/CORE/HDD/src/wlan_hdd_ipa.c qcacld-new/CORE/HDD/src/wlan_hdd_ipa.c
--- qcacld-new.orig/CORE/HDD/src/wlan_hdd_ipa.c	2015-09-24 15:25:20.585038328 +0800
+++ qcacld-new/CORE/HDD/src/wlan_hdd_ipa.c	2015-09-24 15:25:20.613038328 +0800
@@ -1582,6 +1582,7 @@
 	v_U8_t interface_id;
 	hdd_adapter_t  *adapter = NULL;
 
+	iface_context = (struct hdd_ipa_iface_context*) priv;
 	if (evt != IPA_RECEIVE) {
 		skb = (adf_nbuf_t) data;
 		dev_kfree_skb_any(skb);
@@ -1589,7 +1590,6 @@
 		return;
 	}
 
-	iface_context = (struct hdd_ipa_iface_context *) priv;
 	ipa_tx_desc = (struct ipa_rx_data *)data;
 	skb = ipa_tx_desc->skb;
 
diff -urN qcacld-new.orig/CORE/HDD/src/wlan_hdd_main.c qcacld-new/CORE/HDD/src/wlan_hdd_main.c
--- qcacld-new.orig/CORE/HDD/src/wlan_hdd_main.c	2015-09-24 15:25:20.585038328 +0800
+++ qcacld-new/CORE/HDD/src/wlan_hdd_main.c	2015-09-24 15:25:20.613038328 +0800
@@ -249,6 +249,11 @@
    unsigned char data[ANDROID_WIFI_ACTION_FRAME_SIZE];
 } ;
 
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+#define WLAN_HDD_MAX_TCP_PORT            65535
+#define WLAN_WAIT_TIME_READY_TO_EXTWOW   2000
+#endif
+
 static vos_wake_lock_t wlan_wake_lock;
 /* set when SSR is needed after unload */
 static e_hdd_ssr_required isSsrRequired = HDD_SSR_NOT_REQUIRED;
@@ -3062,7 +3067,7 @@
     tANI_U8 *inPtr = pValue;
     int tempInt;
     int v = 0;
-    char buf[32];
+    char buf[33];
     *pRate = 0;
     *pTxFlags = 0;
 
@@ -3403,6 +3408,579 @@
      return eHAL_STATUS_SUCCESS;
 }
 #endif
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+static void wlan_hdd_ready_to_extwow(void *callbackContext,
+                                             boolean is_success)
+{
+    hdd_context_t *pHddCtx = (hdd_context_t *)callbackContext;
+    int rc;
+
+    rc = wlan_hdd_validate_context(pHddCtx);
+    if (0 != rc) {
+       hddLog(VOS_TRACE_LEVEL_ERROR, FL("HDD context is not valid"));
+       return;
+    }
+    pHddCtx->ext_wow_should_suspend = is_success;
+    complete(&pHddCtx->ready_to_extwow);
+}
+
+static int hdd_enable_ext_wow(hdd_adapter_t *pAdapter,
+                               tpSirExtWoWParams arg_params)
+{
+    tSirExtWoWParams params;
+    eHalStatus halStatus = eHAL_STATUS_FAILURE;
+    hdd_context_t  *pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
+    tHalHandle hHal = WLAN_HDD_GET_HAL_CTX(pAdapter);
+    int rc;
+
+    vos_mem_copy(&params, arg_params, sizeof(params));
+
+    INIT_COMPLETION(pHddCtx->ready_to_extwow);
+
+    halStatus = sme_ConfigureExtWoW(hHal, &params,
+                &wlan_hdd_ready_to_extwow, pHddCtx);
+    if (eHAL_STATUS_SUCCESS != halStatus) {
+        hddLog(VOS_TRACE_LEVEL_ERROR,
+               FL("sme_ConfigureExtWoW returned failure %d"), halStatus);
+        return -EPERM;
+    }
+
+    rc = wait_for_completion_timeout(&pHddCtx->ready_to_extwow,
+                             msecs_to_jiffies(WLAN_WAIT_TIME_READY_TO_EXTWOW));
+    if (!rc) {
+        VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+                   "%s: Failed to get ready to extwow", __func__);
+        return -EPERM;
+    }
+
+    if (pHddCtx->ext_wow_should_suspend) {
+       if (pHddCtx->cfg_ini->extWowGotoSuspend) {
+          VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
+              "%s: Received ready to ExtWoW. Going to suspend", __func__);
+
+#if defined(HIF_PCI)
+          wlan_hdd_cfg80211_suspend_wlan(pHddCtx->wiphy, NULL);
+          wlan_hif_pci_suspend();
+#endif
+       }
+    } else {
+        VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+              "%s: Received ready to ExtWoW failure", __func__);
+        return -EPERM;
+    }
+
+    return 0;
+}
+
+static int hdd_enable_ext_wow_parser(hdd_adapter_t *pAdapter, int vdev_id,
+                                                                  int value)
+{
+   tSirExtWoWParams params;
+   hdd_context_t *pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
+   int rc;
+
+   rc = wlan_hdd_validate_context(pHddCtx);
+   if (0 != rc) {
+       hddLog(VOS_TRACE_LEVEL_ERROR, FL("HDD context is not valid"));
+       return -EINVAL;
+   }
+
+#ifdef WLAN_FEATURE_EXTWOW_OUTDOOR_SUPPORT
+   if (value < EXT_WOW_DISABLED || value > EXT_WOW_TYPE_APP_TYPE1_2 ) {
+       hddLog(VOS_TRACE_LEVEL_ERROR, FL("Invalid type"));
+       return -EINVAL;
+   }
+#else
+   if (value < EXT_WOW_DISABLED || value > EXT_WOW_TYPE_APP_TYPE1 ) {
+       hddLog(VOS_TRACE_LEVEL_ERROR, FL("Invalid type"));
+       return -EINVAL;
+   }
+#endif
+
+   if (value == EXT_WOW_DISABLED) {
+        params.type = value;
+   } else if (value == EXT_WOW_TYPE_APP_TYPE1 &&
+        pHddCtx->is_extwow_app_type1_param_set)
+        params.type = value;
+#ifdef WLAN_FEATURE_EXTWOW_OUTDOOR_SUPPORT
+   else if (value == EXT_WOW_TYPE_APP_TYPE2 &&
+        pHddCtx->is_extwow_app_type2_param_set)
+        params.type = value;
+   else if (value == EXT_WOW_TYPE_APP_TYPE1_2 &&
+        pHddCtx->is_extwow_app_type1_param_set &&
+        pHddCtx->is_extwow_app_type2_param_set)
+        params.type = value;
+#endif
+   else {
+        hddLog(VOS_TRACE_LEVEL_ERROR,
+           FL("Set app params before enable it value %d"),value);
+        return -EINVAL;
+   }
+
+   params.vdev_id = vdev_id;
+   params.wakeup_pin_num = pHddCtx->cfg_ini->extWowApp1WakeupPinNumber |
+                      (pHddCtx->cfg_ini->extWowApp2WakeupPinNumber << 8);
+
+   return hdd_enable_ext_wow(pAdapter, &params);
+}
+
+static int hdd_set_app_type1_params(tHalHandle hHal,
+                         tpSirAppType1Params arg_params)
+{
+    tSirAppType1Params params;
+    eHalStatus halStatus = eHAL_STATUS_FAILURE;
+
+    vos_mem_copy(&params, arg_params, sizeof(params));
+
+    halStatus = sme_ConfigureAppType1Params(hHal, &params);
+    if (eHAL_STATUS_SUCCESS != halStatus) {
+        hddLog(VOS_TRACE_LEVEL_ERROR,
+             FL("sme_ConfigureAppType1Params returned failure %d"), halStatus);
+        return -EPERM;
+    }
+
+    return 0;
+}
+
+static int hdd_set_app_type1_parser(hdd_adapter_t *pAdapter,
+                                             char *arg, int len)
+{
+    hdd_context_t *pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
+    tHalHandle hHal = WLAN_HDD_GET_HAL_CTX(pAdapter);
+    char id[20], password[20];
+    tSirAppType1Params params;
+    int ret;
+
+    ret = wlan_hdd_validate_context(pHddCtx);
+    if (0 != ret) {
+       hddLog(VOS_TRACE_LEVEL_ERROR, FL("HDD context is not valid"));
+       return -EINVAL;
+    }
+
+    if (2 != sscanf(arg, "%8s %16s", id, password)) {
+       VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+                 FL("Invalid Number of arguments"));
+       return -EINVAL;
+    }
+
+    memset(&params, 0, sizeof(tSirAppType1Params));
+    params.vdev_id = pAdapter->sessionId;
+
+    params.id_length = strlen(id);
+    vos_mem_copy(params.identification_id, id, params.id_length);
+    params.pass_length = strlen(password);
+    vos_mem_copy(params.password, password, params.pass_length);
+
+    VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
+        "%s: %d %.8s %u %.16s %u",
+        __func__, params.vdev_id, params.identification_id, params.id_length,
+        params.password, params.pass_length);
+
+    ret = hdd_set_app_type1_params(hHal, &params);
+    if (ret == 0) {
+        vos_mem_copy(&pHddCtx->app_type1_params, &params, sizeof(tSirAppType1Params));
+    }
+    return ret;
+}
+
+
+#ifdef WLAN_FEATURE_EXTWOW_OUTDOOR_SUPPORT
+static int hdd_set_app_type2_params(tHalHandle hHal,
+                          tpSirAppType2Params arg_params)
+{
+    tSirAppType2Params params;
+    eHalStatus halStatus = eHAL_STATUS_FAILURE;
+
+    vos_mem_copy(&params, arg_params, sizeof(params));
+
+    halStatus = sme_ConfigureAppType2Params(hHal, &params);
+    if (eHAL_STATUS_SUCCESS != halStatus)
+    {
+        hddLog(VOS_TRACE_LEVEL_ERROR,
+             FL("sme_ConfigureAppType2Params returned failure %d"), halStatus);
+        return -EPERM;
+    }
+
+    return 0;
+}
+
+static int hdd_parse_hex_array(u8* arg, int len, u8* array, u16 array_len)
+{
+        u8* pos;
+        int i;
+
+        for (pos = arg, i = 0;
+             ((*pos) != ' ') && (i < array_len) && ( pos < (arg + len));
+             pos += 2, i++) {
+                if (((*pos) >= '0') && ((*pos) <= '9')) {
+                        array[i] = ((*pos) - '0') << 4;
+                } else if (((*pos) >= 'a') && ((*pos) <= 'f')) {
+                        array[i] = ((((*pos) - 'a') + 10) << 4) ;
+                }
+                if (((*(pos+1)) >= '0') && ((*(pos+1)) <= '9')) {
+                        array[i] += *(pos+1) - '0';
+                } else if (((*(pos+1)) >= 'a') && ((*(pos+1)) <= 'f')) {
+                        array[i] += *(pos+1) - 'a' + 10;
+                }
+        }
+        return i;
+}
+
+static int hdd_set_app_type2_parser(hdd_adapter_t *pAdapter,
+                            char *arg, int len)
+{
+    hdd_context_t *pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
+    tHalHandle hHal = WLAN_HDD_GET_HAL_CTX(pAdapter);
+    char mac_addr[20];
+    tANI_U8 rc4_write_sandbox[256], rc4_read_sandbox[256],
+            ssl_write_seq[8], ssl_read_seq[8],
+            ssl_sha1_write_key[64], ssl_sha1_read_key[64],
+            tcp_options[82];
+    tANI_U16 ssl_sha1_write_key_len, ssl_sha1_read_key_len;
+
+    unsigned int gateway_mac[6], i;
+    tSirAppType2Params* params;
+    int ret;
+
+    params = vos_mem_malloc( sizeof( tSirAppType2Params ) );
+    if (!params) {
+        hddLog(VOS_TRACE_LEVEL_ERROR, FL("No memory"));
+        return -ENOMEM;
+    }
+
+    ret = wlan_hdd_validate_context(pHddCtx);
+    if (0 != ret) {
+        hddLog(VOS_TRACE_LEVEL_ERROR, FL("HDD context is not valid"));
+        vos_mem_free(params);
+        return -EINVAL;
+    }
+
+    memset(params, 0, sizeof(tSirAppType2Params));
+
+    ret = hdd_parse_hex_array(arg, len, rc4_write_sandbox, sizeof(rc4_write_sandbox));
+    if (ret != 256) {
+        hddLog(VOS_TRACE_LEVEL_ERROR, FL("invalid sandbox"));
+        vos_mem_free(params);
+        return -EINVAL;
+    }
+    arg += 513;
+    len -= 513;
+
+    ret = hdd_parse_hex_array(arg, len, rc4_read_sandbox, sizeof(rc4_read_sandbox));
+    if (ret != 256) {
+        hddLog(VOS_TRACE_LEVEL_ERROR, FL("Invalid sandbox"));
+        vos_mem_free(params);
+        return -EINVAL;
+    }
+    arg += 513;
+    len -= 513;
+
+    ret = hdd_parse_hex_array(arg, len, ssl_write_seq, sizeof(ssl_write_seq));
+    if (ret != 8) {
+        hddLog(VOS_TRACE_LEVEL_ERROR, FL("Invalid write seq"));
+        vos_mem_free(params);
+        return -EINVAL;
+    }
+    arg += 17;
+    len -= 17;
+
+    ret = hdd_parse_hex_array(arg, len, ssl_read_seq, sizeof(ssl_read_seq));
+    if (ret != 8) {
+        hddLog(VOS_TRACE_LEVEL_ERROR, FL("Invalid read seq"));
+        vos_mem_free(params);
+        return -EINVAL;
+    }
+    arg += 17;
+    len -= 17;
+
+    ret = hdd_parse_hex_array(arg, len, ssl_sha1_write_key, sizeof(ssl_sha1_write_key));
+    ssl_sha1_write_key_len = ret;
+    arg += ret*2 + 1;
+    len -= ret*2 + 1;
+
+    ret = hdd_parse_hex_array(arg, len, ssl_sha1_read_key, sizeof(ssl_sha1_read_key));
+    ssl_sha1_read_key_len = ret;
+    arg += ret*2 + 1;
+    len -= ret*2 + 1;
+
+    ret = hdd_parse_hex_array(arg, len, &params->rc4_write_x, 1);
+    arg += 3;
+    len -= 3;
+
+    ret = hdd_parse_hex_array(arg, len, &params->rc4_write_y, 1);
+    arg += 3;
+    len -= 3;
+
+    ret = hdd_parse_hex_array(arg, len, &params->rc4_read_x, 1);
+    arg += 3;
+    len -= 3;
+
+    ret = hdd_parse_hex_array(arg, len, &params->rc4_read_y, 1);
+    arg += 3;
+    len -= 3;
+
+
+    ret = sscanf(arg, "%17s %x %x %x %u %u %u %u %u %80s %u %u %u %u %u %u %u",
+        mac_addr,
+        (unsigned int*)&params->ip_id,
+        (unsigned int*)&params->ip_device_ip,
+        (unsigned int*)&params->ip_server_ip,
+        (unsigned int*)&params->tcp_src_port,
+        (unsigned int*)&params->tcp_dst_port,
+        (unsigned int*)&params->tcp_seq,
+        (unsigned int*)&params->tcp_ack_seq,
+        (unsigned int*)&params->tcp_options_len,
+        tcp_options,
+        (unsigned int*)&params->asyncId,
+        (unsigned int*)&params->keepalive_init,
+        (unsigned int*)&params->keepalive_min,
+        (unsigned int*)&params->keepalive_max,
+        (unsigned int*)&params->keepalive_inc,
+        (unsigned int*)&params->tcp_tx_timeout_val,
+        (unsigned int*)&params->tcp_rx_timeout_val);
+
+
+    if (ret != 17 && ret != 11) {
+        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+                 "Invalid Number of arguments");
+        vos_mem_free(params);
+        return -EINVAL;
+    }
+
+    if (params->tcp_options_len) {
+        ret = hdd_parse_hex_array(tcp_options, 80, params->tcp_options, 40);
+        if (ret != 40) {
+            VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+                      "Invalid tcp options");
+            vos_mem_free(params);
+            return -EINVAL;
+        }
+    }
+
+    if (6 != sscanf(mac_addr, "%02x:%02x:%02x:%02x:%02x:%02x", &gateway_mac[0],
+             &gateway_mac[1], &gateway_mac[2], &gateway_mac[3],
+             &gateway_mac[4], &gateway_mac[5])) {
+        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+               "Invalid MacAddress Input %s", mac_addr);
+        vos_mem_free(params);
+        return -EINVAL;
+    }
+
+    if (params->tcp_src_port > WLAN_HDD_MAX_TCP_PORT ||
+           params->tcp_dst_port > WLAN_HDD_MAX_TCP_PORT) {
+        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+             "Invalid TCP Port Number");
+        vos_mem_free(params);
+        return -EINVAL;
+    }
+
+    for (i = 0; i < ETHER_ADDR_LEN; i++)
+        params->gateway_mac[i] = (uint8_t) gateway_mac[i];
+
+    vos_mem_copy(params->rc4_write_sandbox, rc4_write_sandbox, sizeof(params->rc4_write_sandbox));
+    vos_mem_copy(params->rc4_read_sandbox, rc4_read_sandbox, sizeof(params->rc4_read_sandbox));
+    vos_mem_copy(params->ssl_write_seq, ssl_write_seq, sizeof(params->ssl_write_seq));
+    vos_mem_copy(params->ssl_read_seq, ssl_read_seq, sizeof(params->ssl_read_seq));
+    vos_mem_copy(params->ssl_sha1_write_key, ssl_sha1_write_key, sizeof(params->ssl_sha1_write_key));
+    params->ssl_sha1_write_key_len = ssl_sha1_write_key_len;
+    vos_mem_copy(params->ssl_sha1_read_key, ssl_sha1_read_key, sizeof(params->ssl_sha1_read_key));
+    params->ssl_sha1_read_key_len = ssl_sha1_read_key_len;
+
+    params->vdev_id = pAdapter->sessionId;
+    params->tcp_src_port = (params->tcp_src_port != 0)?
+        params->tcp_src_port : pHddCtx->cfg_ini->extWowApp2TcpSrcPort;
+    params->tcp_dst_port = (params->tcp_dst_port != 0)?
+        params->tcp_dst_port : pHddCtx->cfg_ini->extWowApp2TcpDstPort;
+    params->keepalive_init = (params->keepalive_init != 0)?
+        params->keepalive_init : pHddCtx->cfg_ini->extWowApp2KAInitPingInterval;
+    params->keepalive_min = (params->keepalive_min != 0)?
+        params->keepalive_min : pHddCtx->cfg_ini->extWowApp2KAMinPingInterval;
+    params->keepalive_max = (params->keepalive_max != 0)?
+        params->keepalive_max : pHddCtx->cfg_ini->extWowApp2KAMaxPingInterval;
+    params->keepalive_inc = (params->keepalive_inc != 0)?
+        params->keepalive_inc : pHddCtx->cfg_ini->extWowApp2KAIncPingInterval;
+    params->tcp_tx_timeout_val = (params->tcp_tx_timeout_val != 0)?
+        params->tcp_tx_timeout_val : pHddCtx->cfg_ini->extWowApp2TcpTxTimeout;
+    params->tcp_rx_timeout_val = (params->tcp_rx_timeout_val != 0)?
+        params->tcp_rx_timeout_val : pHddCtx->cfg_ini->extWowApp2TcpRxTimeout;
+
+    VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
+        "%s: %pM %u %u %u %u %u %u %u %u %u %u %u %u %u",
+        __func__, gateway_mac, params->ip_id, params->ip_device_ip,
+        params->ip_server_ip, params->tcp_seq, params->tcp_ack_seq,
+        params->tcp_src_port, params->tcp_dst_port, params->keepalive_init,
+        params->keepalive_min, params->keepalive_max,
+        params->keepalive_inc, params->tcp_tx_timeout_val,
+        params->tcp_rx_timeout_val);
+
+    ret = hdd_set_app_type2_params(hHal, params);
+    if (ret == 0) {
+        vos_mem_copy(&pHddCtx->app_type2_params, params, sizeof(tSirAppType2Params));
+    }
+    vos_mem_free(params);
+    return ret;
+}
+#endif
+
+static int hdd_get_app_type1_params(hdd_adapter_t *pAdapter,
+                                             char *arg, int len)
+{
+    hdd_context_t *pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
+    int ret = 0;
+
+    ret = wlan_hdd_validate_context(pHddCtx);
+    if (0 != ret) {
+       hddLog(VOS_TRACE_LEVEL_ERROR, FL("HDD context is not valid"));
+       return -EINVAL;
+    }
+
+    snprintf(arg, len, "%.8s %.16s",
+             pHddCtx->app_type1_params.identification_id,
+             pHddCtx->app_type1_params.password);
+
+
+    return ret;
+}
+
+#ifdef WLAN_FEATURE_EXTWOW_OUTDOOR_SUPPORT
+static int hdd_get_app_type2_params(hdd_adapter_t *pAdapter,
+                            char *arg, int len)
+{
+    hdd_context_t *pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
+    int ret;
+    int i;
+    char tcp_options[82];
+    char* tcp_options_idx;
+    int tcp_options_len;
+
+    ret = wlan_hdd_validate_context(pHddCtx);
+    if (0 != ret) {
+        hddLog(VOS_TRACE_LEVEL_ERROR, FL("HDD context is not valid"));
+        return -EINVAL;
+    }
+
+    if (len < 1529) {
+        return -EINVAL;
+    }
+    for (i = 0; i < 256; i+=8) {
+        ret = snprintf(arg, len, "%02x%02x%02x%02x%02x%02x%02x%02x",
+                       pHddCtx->app_type2_params.rc4_write_sandbox[i],
+                       pHddCtx->app_type2_params.rc4_write_sandbox[i+1],
+                       pHddCtx->app_type2_params.rc4_write_sandbox[i+2],
+                       pHddCtx->app_type2_params.rc4_write_sandbox[i+3],
+                       pHddCtx->app_type2_params.rc4_write_sandbox[i+4],
+                       pHddCtx->app_type2_params.rc4_write_sandbox[i+5],
+                       pHddCtx->app_type2_params.rc4_write_sandbox[i+6],
+                       pHddCtx->app_type2_params.rc4_write_sandbox[i+7]);
+        arg += ret;
+        len -= ret;
+    }
+    arg[0] = ' ';
+    arg++;
+    len--;
+
+
+    for (i = 0; i < 256; i+=8) {
+        ret = snprintf(arg, len, "%02x%02x%02x%02x%02x%02x%02x%02x",
+                       pHddCtx->app_type2_params.rc4_read_sandbox[i],
+                       pHddCtx->app_type2_params.rc4_read_sandbox[i+1],
+                       pHddCtx->app_type2_params.rc4_read_sandbox[i+2],
+                       pHddCtx->app_type2_params.rc4_read_sandbox[i+3],
+                       pHddCtx->app_type2_params.rc4_read_sandbox[i+4],
+                       pHddCtx->app_type2_params.rc4_read_sandbox[i+5],
+                       pHddCtx->app_type2_params.rc4_read_sandbox[i+6],
+                       pHddCtx->app_type2_params.rc4_read_sandbox[i+7]);
+        arg += ret;
+        len -= ret;
+    }
+    arg[0] = ' ';
+    arg++;
+    len--;
+
+
+    ret = snprintf(arg, len, "%02x%02x%02x%02x%02x%02x%02x%02x ",
+                        pHddCtx->app_type2_params.ssl_write_seq[0],
+                        pHddCtx->app_type2_params.ssl_write_seq[1],
+                        pHddCtx->app_type2_params.ssl_write_seq[2],
+                        pHddCtx->app_type2_params.ssl_write_seq[3],
+                        pHddCtx->app_type2_params.ssl_write_seq[4],
+                        pHddCtx->app_type2_params.ssl_write_seq[5],
+                        pHddCtx->app_type2_params.ssl_write_seq[6],
+                        pHddCtx->app_type2_params.ssl_write_seq[7]);
+    arg += ret;
+    len -= ret;
+
+    ret = snprintf(arg, len, "%02x%02x%02x%02x%02x%02x%02x%02x ",
+                        pHddCtx->app_type2_params.ssl_read_seq[0],
+                        pHddCtx->app_type2_params.ssl_read_seq[1],
+                        pHddCtx->app_type2_params.ssl_read_seq[2],
+                        pHddCtx->app_type2_params.ssl_read_seq[3],
+                        pHddCtx->app_type2_params.ssl_read_seq[4],
+                        pHddCtx->app_type2_params.ssl_read_seq[5],
+                        pHddCtx->app_type2_params.ssl_read_seq[6],
+                        pHddCtx->app_type2_params.ssl_read_seq[7]);
+    arg += ret;
+    len -= ret;
+
+    for (i = 0; i < pHddCtx->app_type2_params.ssl_sha1_write_key_len; i++) {
+        ret = snprintf(arg, len, "%02x", pHddCtx->app_type2_params.ssl_sha1_write_key[i]);
+        arg += ret;
+        len -= ret;
+    }
+    arg[0] = ' ';
+    arg++;
+    len--;
+
+    for (i = 0; i < pHddCtx->app_type2_params.ssl_sha1_read_key_len; i++) {
+        ret = snprintf(arg, len, "%02x", pHddCtx->app_type2_params.ssl_sha1_read_key[i]);
+        arg += ret;
+        len -= ret;
+    }
+    arg[0] = ' ';
+    arg++;
+    len--;
+
+    memset(tcp_options, 0, sizeof(tcp_options));
+    tcp_options_idx = tcp_options;
+    tcp_options_len = sizeof(tcp_options);
+    for (i = 0; i <  pHddCtx->app_type2_params.tcp_options_len; i++) {
+        ret = snprintf(tcp_options_idx, tcp_options_len, "%02x", pHddCtx->app_type2_params.tcp_options[i]);
+        tcp_options_idx += ret;
+        tcp_options_len -= ret;
+    }
+
+    ret = snprintf(arg, len, "%02x %02x %02x %02x %02x:%02x:%02x:%02x:%02x:%02x %x %x %x %u %u %u %u %u %s %u %u %u %u %u %u %u",
+             pHddCtx->app_type2_params.rc4_write_x,
+             pHddCtx->app_type2_params.rc4_write_y,
+             pHddCtx->app_type2_params.rc4_read_x,
+             pHddCtx->app_type2_params.rc4_read_y,
+             pHddCtx->app_type2_params.gateway_mac[0],
+             pHddCtx->app_type2_params.gateway_mac[1],
+             pHddCtx->app_type2_params.gateway_mac[2],
+             pHddCtx->app_type2_params.gateway_mac[3],
+             pHddCtx->app_type2_params.gateway_mac[4],
+             pHddCtx->app_type2_params.gateway_mac[5],
+             pHddCtx->app_type2_params.ip_id,
+             pHddCtx->app_type2_params.ip_device_ip,
+             pHddCtx->app_type2_params.ip_server_ip,
+             pHddCtx->app_type2_params.tcp_src_port,
+             pHddCtx->app_type2_params.tcp_dst_port,
+             pHddCtx->app_type2_params.tcp_seq,
+             pHddCtx->app_type2_params.tcp_ack_seq,
+             pHddCtx->app_type2_params.tcp_options_len,
+             tcp_options,
+             pHddCtx->app_type2_params.asyncId,
+             pHddCtx->app_type2_params.keepalive_init,
+             pHddCtx->app_type2_params.keepalive_min,
+             pHddCtx->app_type2_params.keepalive_max,
+             pHddCtx->app_type2_params.keepalive_inc,
+             pHddCtx->app_type2_params.tcp_tx_timeout_val,
+             pHddCtx->app_type2_params.tcp_rx_timeout_val);
+
+    return 0;
+}
+#endif
+#endif
 
 int wlan_hdd_set_mc_rate(hdd_adapter_t *pAdapter, int targetRate)
 {
@@ -5525,8 +6103,7 @@
                goto exit;
            }
 
-           if ((dfsScanMode < CFG_ROAMING_DFS_CHANNEL_MIN) ||
-               (dfsScanMode > CFG_ROAMING_DFS_CHANNEL_MAX))
+           if (dfsScanMode > CFG_ROAMING_DFS_CHANNEL_MAX)
            {
                VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
                       "dfsScanMode value %d is out of range"
@@ -5559,6 +6136,74 @@
                goto exit;
            }
        }
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+       else if (strncmp(command, "ENABLEEXTWOW", 12) == 0) {
+
+           tANI_U8 *value = command;
+           int set_value;
+
+           /* Move pointer to ahead of ENABLEEXTWOW*/
+           value += 12;
+           sscanf(value, "%d", &set_value);
+           ret = hdd_enable_ext_wow_parser(pAdapter,
+                               pAdapter->sessionId, set_value);
+
+       } else if (strncmp(command, "SETAPP1PARAMS", 13) == 0) {
+           tANI_U8 *value = command;
+
+           /* Move pointer to ahead of SETAPP1PARAMS*/
+           value += 13;
+           ret = hdd_set_app_type1_parser(pAdapter,
+                                         value, strlen(value));
+           if (ret >= 0)
+               pHddCtx->is_extwow_app_type1_param_set = TRUE;
+
+#ifdef WLAN_FEATURE_EXTWOW_OUTDOOR_SUPPORT
+       } else if (strncmp(command, "SETAPP2PARAMS", 13) == 0) {
+           tANI_U8 *value = command;
+
+           /* Move pointer to ahead of SETAPP2PARAMS*/
+           value += 13;
+           ret = hdd_set_app_type2_parser(pAdapter,
+                                         value, strlen(value));
+           if (ret >= 0)
+               pHddCtx->is_extwow_app_type2_param_set = TRUE;
+#endif
+       } else if (strncmp(command, "GETAPP1PARAMS", 13) == 0) {
+           if (pHddCtx->is_extwow_app_type1_param_set == TRUE) {
+               ret = hdd_get_app_type1_params(pAdapter,
+                                              command + 13, priv_data.total_len - 13);
+               if (ret == 0) {
+                   if (copy_to_user(priv_data.buf, command, strlen(command))) {
+                       VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+                       "%s: failed to copy data to user buffer", __func__);
+                       ret = -EFAULT;
+                       goto exit;
+                   }
+               }
+           } else {
+               ret = -EFAULT;
+           }
+#ifdef WLAN_FEATURE_EXTWOW_OUTDOOR_SUPPORT
+       } else if (strncmp(command, "GETAPP2PARAMS", 13) == 0) {
+           if (pHddCtx->is_extwow_app_type2_param_set == TRUE) {
+               ret = hdd_get_app_type2_params(pAdapter,
+                                              command + 13, priv_data.total_len - 13);
+               if (ret == 0) {
+                   if (copy_to_user(priv_data.buf, command, strlen(command))) {
+                       VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+                       "%s: failed to copy data to user buffer", __func__);
+                       ret = -EFAULT;
+                       goto exit;
+                   }
+               }
+           } else {
+               ret = -EFAULT;
+           }
+#endif
+       }
+
+#endif
        else {
            MTRACE(vos_trace(VOS_MODULE_ID_HDD,
                             TRACE_CODE_HDD_UNSUPPORTED_IOCTL,
@@ -7336,6 +7981,11 @@
   \return - void
 
   --------------------------------------------------------------------------*/
+
+#ifdef DIRECT_AUDIO_SUPPORT
+	extern void Direct_Audio_init(hdd_context_t *pHddCtx);
+	extern void Direct_Audio_deinit(hdd_context_t *pHddCtx);
+#endif
 static void hdd_uninit (struct net_device *dev)
 {
    hdd_adapter_t *pAdapter = WLAN_HDD_GET_PRIV_PTR(dev);
@@ -7365,6 +8015,11 @@
          /* we haven't validated all cases so let this go for now */
       }
 
+#ifdef DIRECT_AUDIO_SUPPORT
+		Direct_Audio_deinit(pAdapter->pHddCtx);
+#endif
+
+
       hdd_deinit_adapter(pAdapter->pHddCtx, pAdapter);
 
       /* after uninit our adapter structure will no longer be valid */
@@ -7652,6 +8307,10 @@
       init_completion(&pAdapter->ula_complete);
       init_completion(&pAdapter->change_country_code);
 
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+      init_completion(&pHddCtx->ready_to_extwow);
+#endif
+
 #ifdef FEATURE_WLAN_BATCH_SCAN
       init_completion(&pAdapter->hdd_set_batch_scan_req_var);
       init_completion(&pAdapter->hdd_get_batch_scan_req_var);
@@ -9977,6 +10636,7 @@
    vos_mem_zero(&scanReq, sizeof(tCsrScanRequest));
    vos_mem_set(&scanReq.bssid, sizeof(tCsrBssid), 0xff);
    scanReq.BSSType = eCSR_BSS_TYPE_ANY;
+   scanReq.ChannelInfo.ChannelList = NULL;
 
    if(sme_Is11dSupported(pHddCtx->hHal))
    {
@@ -10018,7 +10678,7 @@
          __func__, halStatus );
    }
 
-   if(sme_Is11dSupported(pHddCtx->hHal))
+   if(sme_Is11dSupported(pHddCtx->hHal) && scanReq.ChannelInfo.ChannelList)
         vos_mem_free(scanReq.ChannelInfo.ChannelList);
 }
 
@@ -10476,13 +11136,6 @@
       return;
    }
 
-   if(NULL == pVosContext) {
-      VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
-            "%s:Invalid global VOSS context", __func__);
-      EXIT();
-      return;
-   }
-
    //Get the HDD context.
    pHddCtx = (hdd_context_t *)vos_get_context(VOS_MODULE_ID_HDD,
          pVosContext);
@@ -12095,6 +12748,11 @@
 
 err_free_hdd_context:
    hdd_allow_suspend();
+
+   /* wiphy_free() will free the HDD context so remove global reference */
+   if (pVosContext)
+      ((VosContextType*)(pVosContext))->pHDDContext = NULL;
+
    wiphy_free(wiphy) ;
    //kfree(wdev) ;
    VOS_BUG(1);
@@ -12114,6 +12772,9 @@
    return -EIO;
 
 success:
+#ifdef DIRECT_AUDIO_SUPPORT
+	Direct_Audio_init(pHddCtx);
+#endif
    EXIT();
    return 0;
 }
@@ -12156,6 +12817,15 @@
    pr_info("%s: loading driver v%s\n", WLAN_MODULE_NAME,
            QWLAN_VERSIONSTR TIMER_MANAGER_STR MEMORY_DEBUG_STR);
 
+#ifdef CONFIG_VOS_MEM_PRE_ALLOC
+	status = vos_prealloc_init();
+	if (!VOS_IS_STATUS_SUCCESS(status))
+	{
+		hddLog(VOS_TRACE_LEVEL_FATAL,"%s: Failed to prealloc memory", __func__);
+		ret_status = -1;
+	}
+#endif /* CONFIG_VOS_MEM_PRE_ALLOC */
+
 #ifdef ANI_BUS_TYPE_PCI
 
    dev = wcnss_wlan_get_device();
@@ -12241,6 +12911,10 @@
 #endif
    init_completion(&wlan_start_comp);
    ret_status = hif_register_driver();
+#if defined(CONFIG_USB_PRELOAD)
+   if (ret_status == 0)
+		return 0;
+#else
    if (!ret_status) {
        ret_status = wait_for_completion_interruptible_timeout(
                            &wlan_start_comp,
@@ -12267,6 +12941,7 @@
        pr_info("%s: driver loaded\n", WLAN_MODULE_NAME);
        return 0;
    }
+#endif /* CONFIG_USB_PRELOAD */
 #endif
 
 #ifdef QCA_WIFI_ISOC
@@ -12424,6 +13099,11 @@
 #ifdef TIMER_MANAGER
    vos_timer_exit();
 #endif
+
+#ifdef CONFIG_VOS_MEM_PRE_ALLOC
+	vos_prealloc_deinit();
+#endif /* CONFIG_VOS_MEM_PRE_ALLOC */
+
 #ifdef MEMORY_DEBUG
    vos_mem_exit();
 #endif
@@ -13650,6 +14330,7 @@
 
 MODULE_LICENSE("Dual BSD/GPL");
 MODULE_AUTHOR("Qualcomm Atheros, Inc.");
+MODULE_VERSION("3.0.7.048");
 MODULE_DESCRIPTION("WLAN HOST DEVICE DRIVER");
 
 #if defined(QCA_WIFI_2_0) && defined(QCA_WIFI_FTM) && !defined(QCA_WIFI_ISOC)
diff -urN qcacld-new.orig/CORE/HDD/src/wlan_hdd_oemdata.c qcacld-new/CORE/HDD/src/wlan_hdd_oemdata.c
--- qcacld-new.orig/CORE/HDD/src/wlan_hdd_oemdata.c	2015-09-24 15:25:20.585038328 +0800
+++ qcacld-new/CORE/HDD/src/wlan_hdd_oemdata.c	2015-09-24 15:25:20.613038328 +0800
@@ -659,7 +659,7 @@
    tAniMsgHdr *aniHdr;
    tHddChannelInfo *pHddChanInfo;
    tHddChannelInfo hddChanInfo;
-   tSmeChannelInfo smeChanInfo;
+  tSmeChannelInfo smeChanInfo = {0};
    tANI_U8 chanId;
    eHalStatus status = eHAL_STATUS_FAILURE;
    int i;
@@ -796,6 +796,7 @@
       return;
    }
 
+   memset(&smeChanInfo, 0, sizeof(tSmeChannelInfo));
    status = sme_getChannelInfo(pHddCtx->hHal, chanId, &smeChanInfo);
    if (eHAL_STATUS_SUCCESS != status)
    {
diff -urN qcacld-new.orig/CORE/HDD/src/wlan_hdd_p2p.c qcacld-new/CORE/HDD/src/wlan_hdd_p2p.c
--- qcacld-new.orig/CORE/HDD/src/wlan_hdd_p2p.c	2015-09-24 15:25:20.585038328 +0800
+++ qcacld-new/CORE/HDD/src/wlan_hdd_p2p.c	2015-09-24 15:25:20.613038328 +0800
@@ -383,7 +383,8 @@
 /* Clean up RoC context at hdd_stop_adapter*/
 void wlan_hdd_cleanup_remain_on_channel_ctx(hdd_adapter_t *pAdapter)
 {
-    v_U8_t status,retry = 0;
+    int status = 0;
+    v_U8_t retry = 0;
     hdd_cfg80211_state_t *cfgState = WLAN_HDD_GET_CFG_STATE_PTR(pAdapter);
 
     mutex_lock(&cfgState->remain_on_chan_ctx_lock);
diff -urN qcacld-new.orig/CORE/HDD/src/wlan_hdd_scan.c qcacld-new/CORE/HDD/src/wlan_hdd_scan.c
--- qcacld-new.orig/CORE/HDD/src/wlan_hdd_scan.c	2015-09-24 15:25:20.585038328 +0800
+++ qcacld-new/CORE/HDD/src/wlan_hdd_scan.c	2015-09-24 15:25:20.613038328 +0800
@@ -714,8 +714,7 @@
    }
 
    /* push addIEScan in scanRequset if exist */
-   if (pAdapter->scan_info.scanAddIE.addIEdata &&
-       pAdapter->scan_info.scanAddIE.length)
+   if (pAdapter->scan_info.scanAddIE.length)
    {
        scanRequest.uIEFieldLen = pAdapter->scan_info.scanAddIE.length;
        scanRequest.pIEField = pAdapter->scan_info.scanAddIE.addIEdata;
@@ -1092,8 +1091,7 @@
         }
 
         /* push addIEScan in scanRequset if exist */
-        if (pAdapter->scan_info.scanAddIE.addIEdata &&
-            pAdapter->scan_info.scanAddIE.length)
+        if (pAdapter->scan_info.scanAddIE.length)
         {
             scanRequest.uIEFieldLen = pAdapter->scan_info.scanAddIE.length;
             scanRequest.pIEField = pAdapter->scan_info.scanAddIE.addIEdata;
diff -urN qcacld-new.orig/CORE/HDD/src/wlan_hdd_softap_tx_rx.c qcacld-new/CORE/HDD/src/wlan_hdd_softap_tx_rx.c
--- qcacld-new.orig/CORE/HDD/src/wlan_hdd_softap_tx_rx.c	2015-09-24 15:25:20.585038328 +0800
+++ qcacld-new/CORE/HDD/src/wlan_hdd_softap_tx_rx.c	2015-09-24 15:25:20.613038328 +0800
@@ -605,7 +605,13 @@
    }
    else
    {
-      STAId = *(v_U8_t *)(((v_U8_t *)(skb->data)) - 1);
+#ifdef DIRECT_AUDIO_SUPPORT
+	  #define DIRECT_AUDIO_LLC_TYPE 0x43FF
+      if (skb->protocol == DIRECT_AUDIO_LLC_TYPE)
+	  	STAId = 2; //hack
+	  else
+#endif
+  	  STAId = *(v_U8_t *)(((v_U8_t *)(skb->data)) - 1);
       if (STAId == HDD_WLAN_INVALID_STA_ID)
       {
          VOS_TRACE( VOS_MODULE_ID_HDD_SAP_DATA, VOS_TRACE_LEVEL_WARN,
@@ -1311,7 +1317,7 @@
    *ppVosPacket = NULL;
 
    //Make sure the AC being asked for is sane
-   if( ac > WLANTL_MAX_AC || ac < 0)
+   if( ac >= WLANTL_MAX_AC || ac < 0)
    {
       VOS_TRACE( VOS_MODULE_ID_HDD_SAP_DATA, VOS_TRACE_LEVEL_ERROR,
                  "%s: Invalid AC %d passed by TL", __func__, ac);
@@ -1824,6 +1830,16 @@
    vos_wake_lock_timeout_acquire(&pHddCtx->rx_wake_lock,
                                  HDD_WAKE_LOCK_DURATION);
 #endif
+
+#ifdef DIRECT_AUDIO_SUPPORT
+#define DIRECT_AUDIO_LLC_TYPE 0x43FF
+	if (skb->protocol == htons(DIRECT_AUDIO_LLC_TYPE)) {
+		extern void SDA_Rx_fun( struct net_device *dev, struct sk_buff *skb);
+		SDA_Rx_fun(pAdapter->dev, skb);
+		return VOS_STATUS_SUCCESS;
+	}
+#endif
+
    rxstat = netif_rx_ni(skb);
    if (NET_RX_SUCCESS == rxstat)
    {
diff -urN qcacld-new.orig/CORE/HDD/src/wlan_hdd_tx_rx.c qcacld-new/CORE/HDD/src/wlan_hdd_tx_rx.c
--- qcacld-new.orig/CORE/HDD/src/wlan_hdd_tx_rx.c	2015-09-24 15:25:20.585038328 +0800
+++ qcacld-new/CORE/HDD/src/wlan_hdd_tx_rx.c	2015-09-24 15:25:20.613038328 +0800
@@ -1415,16 +1415,21 @@
 
    //Get the HDD context.
    pHddCtx = (hdd_context_t *)vos_get_context( VOS_MODULE_ID_HDD, vosContext );
-   //Get the Adapter context.
-   pAdapter = hdd_get_adapter(pHddCtx,WLAN_HDD_INFRA_STATION);
-   if(pAdapter == NULL)
-   {
-      VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
-                "%s: HDD adapter context is Null", __func__);
-   }
-   else
-   {
-      ++pAdapter->hdd_stats.hddTxRxStats.txCompleted;
+   if(pHddCtx) {
+     //Get the Adapter context.
+     pAdapter = hdd_get_adapter(pHddCtx,WLAN_HDD_INFRA_STATION);
+     if(pAdapter == NULL)
+     {
+        VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
+                  "%s: HDD adapter context is Null", __func__);
+     }
+     else
+     {
+        ++pAdapter->hdd_stats.hddTxRxStats.txCompleted;
+     }
+   } else {
+     VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
+                  "%s: HDD context is Null", __func__);
    }
 
    kfree_skb((struct sk_buff *)pOsPkt);
@@ -2157,6 +2162,9 @@
   @return                : VOS_STATUS_E_FAILURE if any errors encountered,
                          : VOS_STATUS_SUCCESS otherwise
   ===========================================================================*/
+#ifdef DIRECT_AUDIO_SUPPORT
+extern void SDA_Rx_fun( struct net_device *dev, struct sk_buff *skb);
+#endif
 VOS_STATUS hdd_rx_packet_cbk(v_VOID_t *vosContext,
                              adf_nbuf_t rxBuf, v_U8_t staId)
 {
@@ -2269,6 +2277,15 @@
    vos_wake_lock_timeout_acquire(&pHddCtx->rx_wake_lock,
                                  HDD_WAKE_LOCK_DURATION);
 #endif
+
+#ifdef DIRECT_AUDIO_SUPPORT
+#define DIRECT_AUDIO_LLC_TYPE 0x43FF
+	if (skb->protocol == htons(DIRECT_AUDIO_LLC_TYPE)) {
+		SDA_Rx_fun(pAdapter->dev, skb);
+		return VOS_STATUS_SUCCESS;
+	}
+#endif
+
    rxstat = netif_rx_ni(skb);
    if (NET_RX_SUCCESS == rxstat)
    {
diff -urN qcacld-new.orig/CORE/HDD/src/wlan_hdd_wext.c qcacld-new/CORE/HDD/src/wlan_hdd_wext.c
--- qcacld-new.orig/CORE/HDD/src/wlan_hdd_wext.c	2015-09-24 15:25:20.585038328 +0800
+++ qcacld-new/CORE/HDD/src/wlan_hdd_wext.c	2015-09-24 15:25:20.613038328 +0800
@@ -49,6 +49,7 @@
 #include <linux/wireless.h>
 #include <macTrace.h>
 #include <wlan_hdd_includes.h>
+#include "wlan_hdd_main.h"
 #include <wlan_btc_svc.h>
 #include <wlan_nlink_common.h>
 #ifdef WLAN_BTAMP_FEATURE
@@ -245,6 +246,10 @@
 /* Private ioctl for packet power save */
 #define WE_PPS_5G_EBT                         83
 #define WE_SET_FW_CRASH_INJECT                84
+#define WE_SET_DIRECT_AUDIO_TEST              85
+#ifdef CONFIG_WLAN_FWLOG_FILE
+#define WE_DBGLOG_FWLOG_FILE_ENABLE    86
+#endif
 
 /* Private ioctls and their sub-ioctls */
 #define WLAN_PRIV_SET_NONE_GET_INT    (SIOCIWFIRSTPRIV + 1)
@@ -1366,7 +1371,7 @@
 {
    v_CONTEXT_t pVosContext;
    hdd_context_t *pHddCtx;
-   VOS_STATUS hdd_reconnect_all_adapters( hdd_context_t *pHddCtx );
+
 #if 0
    hdd_wext_state_t *pWextState;
    v_U32_t roamId;
@@ -2112,7 +2117,8 @@
         switch ( elementId )
          {
             case IE_EID_VENDOR:
-                if ((IE_LEN_SIZE+IE_EID_SIZE+IE_VENDOR_OUI_SIZE) > eLen) /* should have at least OUI */
+                if ((IE_LEN_SIZE+IE_EID_SIZE+IE_VENDOR_OUI_SIZE) > eLen ||
+					eLen > MAX_WPA_RSN_IE_LEN-2) /* should have at least OUI */
                 {
                     kfree(base_genie);
                     return -EINVAL;
@@ -4571,6 +4577,12 @@
 #endif
 
 /* set param sub-ioctls */
+
+#ifdef DIRECT_AUDIO_SUPPORT
+	extern int Direct_Audio_TX_debug(void);
+	extern int Direct_Audio_RX_debug(void);
+#endif
+
 static int iw_setint_getnone(struct net_device *dev, struct iw_request_info *info,
                        union iwreq_data *wrqu, char *extra)
 {
@@ -4598,13 +4610,12 @@
         return -EBUSY;
     }
 
+    memset(&smeConfig, 0x00, sizeof(smeConfig));
     switch(sub_cmd)
     {
         case WE_SET_11D_STATE:
         {
             if((ENABLE_11D == set_value) || (DISABLE_11D == set_value)) {
-
-                memset(&smeConfig, 0x00, sizeof(smeConfig));
                 sme_GetConfigParam(hHal, &smeConfig);
                 smeConfig.csrConfig.Is11dSupportEnabled = (v_BOOL_t)set_value;
 
@@ -5236,7 +5247,6 @@
                        phddctx->cfg_ini->nChannelBondingMode5GHz)))
                chwidth = true;
 
-           memset(&smeConfig, 0x00, sizeof(smeConfig));
            sme_GetConfigParam(hHal, &smeConfig);
            switch (set_value) {
            case eHT_CHANNEL_WIDTH_20MHZ:
@@ -5550,6 +5560,17 @@
                                           set_value, DBG_CMD);
              break;
         }
+#ifdef CONFIG_WLAN_FWLOG_FILE
+        case WE_DBGLOG_FWLOG_FILE_ENABLE:
+        {
+             hddLog(LOG1, "WE_DBGLOG_FWLOG_FILE_ENABLE val %d", set_value);
+             pHddCtx->fw_log_settings.dl_fwlog_file = set_value;
+             ret = process_wma_set_command((int)pAdapter->sessionId,
+                                          (int)WMI_DBGLOG_FWLOG_FILE_ENABLE,
+                                          set_value, DBG_CMD);
+             break;
+        }
+#endif
 
 	case WE_SET_TXRX_FWSTATS:
 	{
@@ -5997,6 +6018,20 @@
         }
 #endif
 #endif
+
+#ifdef DIRECT_AUDIO_SUPPORT
+		case WE_SET_DIRECT_AUDIO_TEST:
+			hddLog(LOGW, "%s: Try Direct_Audiofunction %s\n",
+							__func__, set_value?"TX":"RX");
+			if (set_value) {
+				ret = Direct_Audio_TX_debug();
+			}
+			else {
+				ret = Direct_Audio_RX_debug();
+			}
+		break;
+#endif
+
         default:
         {
            hddLog(LOGE, "%s: Invalid sub command %d", __func__, sub_cmd);
@@ -6931,13 +6966,7 @@
                     len += buf;
                     break;
                 }
-                pMac = PMAC_STRUCT( hHal );
-                if (!pMac) {
-                    buf = scnprintf(extra + len,  WE_MAX_STR_LEN - len,
-                            "\n pMac is NULL");
-                    len += buf;
-                    break;
-                }
+
                 pHddStaCtx = WLAN_HDD_GET_STATION_CTX_PTR( useAdapter );
                 if( !pHddStaCtx )
                 {
@@ -6948,7 +6977,7 @@
                 }
 
                 tlState = smeGetTLSTAState(hHal, pHddStaCtx->conn_info.staId[0]);
-
+                pMac = PMAC_STRUCT( hHal );
                 buf = scnprintf(extra + len, WE_MAX_STR_LEN - len,
                         "\n HDD Conn State - %s "
                         "\n \n SME State:"
@@ -10010,7 +10039,6 @@
         IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
         0,
         "dl_report" },
-
     {   WE_SET_TXRX_FWSTATS,
         IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
         0,
@@ -10141,6 +10169,12 @@
 #endif
 #endif
 
+#ifdef DIRECT_AUDIO_SUPPORT
+	{	WE_SET_DIRECT_AUDIO_TEST,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+        0, "aow" },
+#endif
+
     {   WLAN_PRIV_SET_NONE_GET_INT,
         0,
         IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
@@ -10772,6 +10806,12 @@
     {   WE_SET_SMPS_PARAM,
         IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2,
         0, "set_smps_param" },
+#ifdef CONFIG_WLAN_FWLOG_FILE
+    {   WE_DBGLOG_FWLOG_FILE_ENABLE,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+        0,
+        "dl_fwlog_file" },
+#endif
 
 };
 
diff -urN qcacld-new.orig/CORE/MAC/inc/sirApi.h qcacld-new/CORE/MAC/inc/sirApi.h
--- qcacld-new.orig/CORE/MAC/inc/sirApi.h	2015-09-24 15:25:20.589038328 +0800
+++ qcacld-new/CORE/MAC/inc/sirApi.h	2015-09-24 15:25:20.617038328 +0800
@@ -3814,6 +3814,79 @@
     tANI_U8 configuredMcstBcstFilterSetting;
 }tSirWlanResumeParam,*tpSirWlanResumeParam;
 
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+
+typedef enum ext_wow_type
+{
+    EXT_WOW_DISABLED = 0, /* wow type: only enable wakeup for app type1 */
+    EXT_WOW_TYPE_APP_TYPE1 = 1, /* wow type: only enable wakeup for app type1 */
+#ifdef WLAN_FEATURE_EXTWOW_OUTDOOR_SUPPORT
+    EXT_WOW_TYPE_APP_TYPE2 = 2, /* wow type: only enable wakeup for app type2 */
+    EXT_WOW_TYPE_APP_TYPE1_2 = 3, /* wow type: enable wakeup for app type1&2 */
+#endif
+}EXT_WOW_TYPE;
+
+typedef struct
+{
+    tANI_U8 vdev_id;
+    EXT_WOW_TYPE type;
+    tANI_U32 wakeup_pin_num;
+} tSirExtWoWParams, *tpSirExtWoWParams;
+
+typedef struct
+{
+    tANI_U8 vdev_id;
+    tANI_U8 identification_id[8];
+    tANI_U8 password[16];
+    tANI_U32 id_length;
+    tANI_U32 pass_length;
+} tSirAppType1Params, *tpSirAppType1Params;
+
+#ifdef WLAN_FEATURE_EXTWOW_OUTDOOR_SUPPORT
+typedef struct
+{
+    tANI_U8 vdev_id;
+
+    tANI_U8  rc4_write_sandbox[256];
+    tANI_U8  rc4_write_x;
+    tANI_U8  rc4_write_y;
+    tANI_U8  rc4_read_sandbox[256];
+    tANI_U8  rc4_read_x;
+    tANI_U8  rc4_read_y;
+    tANI_U8  ssl_write_seq[8];
+    tANI_U8  ssl_read_seq[8];
+    tANI_U8  ssl_sha1_write_key[64];
+    tANI_U16 ssl_sha1_write_key_len;
+    tANI_U8  ssl_sha1_read_key[64];
+    tANI_U16 ssl_sha1_read_key_len;
+
+
+    /** ip header parameter */
+    tANI_U32 ip_id; /* NC id */
+    tANI_U32 ip_device_ip; /* NC IP address */
+    tANI_U32 ip_server_ip; /* Push server IP address */
+
+    /** tcp header parameter */
+    tANI_U16 tcp_src_port; /* NC TCP port */
+    tANI_U16 tcp_dst_port; /* Push server TCP port */
+    tANI_U32 tcp_seq;
+    tANI_U32 tcp_ack_seq;
+    tANI_U32 tcp_options_len;
+    tANI_U8  tcp_options[40];
+    tANI_U32 asyncId;
+
+    tANI_U32 keepalive_init; /* Initial ping interval */
+    tANI_U32 keepalive_min; /* Minimum ping interval */
+    tANI_U32 keepalive_max; /* Maximum ping interval */
+    tANI_U32 keepalive_inc; /* Increment of ping interval */
+
+    tANI_U32 tcp_tx_timeout_val;
+    tANI_U32 tcp_rx_timeout_val;
+    tSirMacAddr gateway_mac;
+} tSirAppType2Params, *tpSirAppType2Params;
+#endif
+#endif
+
 typedef struct sSirWlanSetRxpFilters
 {
     tANI_U8 configuredMcstBcstFilterSetting;
@@ -4902,6 +4975,14 @@
     tANI_U16      mesgLen;
     tANI_BOOLEAN  suspended;
 }  tSirReadyToSuspendInd, *tpSirReadyToSuspendInd;
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+typedef struct
+{
+    tANI_U16      mesgType;
+    tANI_U16      mesgLen;
+    tANI_BOOLEAN  status;
+}  tSirReadyToExtWoWInd, *tpSirReadyToExtWoWInd;
+#endif
 typedef struct sSirRateUpdateInd
 {
     tANI_U8 nss; /* 0: 1x1, 1: 2x2 */
diff -urN qcacld-new.orig/CORE/MAC/inc/wniApi.h qcacld-new/CORE/MAC/inc/wniApi.h
--- qcacld-new.orig/CORE/MAC/inc/wniApi.h	2015-09-24 15:25:20.589038328 +0800
+++ qcacld-new/CORE/MAC/inc/wniApi.h	2015-09-24 15:25:20.617038328 +0800
@@ -410,6 +410,9 @@
 #ifdef WLAN_FEATURE_NAN
     eWNI_SME_NAN_EVENT,
 #endif
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+    eWNI_SME_READY_TO_EXTWOW_IND,
+#endif
     eWNI_SME_MSG_TYPES_END
 };
 
diff -urN qcacld-new.orig/CORE/MAC/src/include/dot11f.h qcacld-new/CORE/MAC/src/include/dot11f.h
--- qcacld-new.orig/CORE/MAC/src/include/dot11f.h	2015-09-24 15:25:20.589038328 +0800
+++ qcacld-new/CORE/MAC/src/include/dot11f.h	2015-09-24 15:25:20.617038328 +0800
@@ -92,7 +92,7 @@
 #define DOT11F_BUFFER_OVERFLOW       ( 0x10000005 )
 #define DOT11F_MANDATORY_TLV_MISSING ( 0x00001000 )
 #define DOT11F_FAILED(code)          ( (code) & 0x10000000 )
-#define DOT11F_WARNED(code)          ( ( ( 0 == (code) ) & 0x10000000 ) && code)
+#define DOT11F_WARNED(code)          ( (code) & 0xEFFFFFFF )
 #define DOT11F_SUCCEEDED(code)       ( (code) == 0 )
 
 /*********************************************************************
@@ -5239,7 +5239,7 @@
 typedef struct sDot11fIESuppChannels {
     tANI_U8      present;
     tANI_U8      num_bands;
-    tANI_U8      bands[48][2];
+    tANI_U8      bands[WNI_CFG_VALID_CHANNEL_LIST_LEN][2];
 } tDot11fIESuppChannels;
 
 #define DOT11F_EID_SUPPCHANNELS ( 36 )
diff -urN qcacld-new.orig/CORE/MAC/src/include/sirParams.h qcacld-new/CORE/MAC/src/include/sirParams.h
--- qcacld-new.orig/CORE/MAC/src/include/sirParams.h	2015-09-24 15:25:20.589038328 +0800
+++ qcacld-new/CORE/MAC/src/include/sirParams.h	2015-09-24 15:25:20.613038328 +0800
@@ -727,6 +727,13 @@
 #ifdef DHCP_SERVER_OFFLOAD
 #define SIR_HAL_SET_DHCP_SERVER_OFFLOAD    (SIR_HAL_ITC_MSG_TYPES_BEGIN + 284)
 #endif /* DHCP_SERVER_OFFLOAD */
+
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+#define SIR_HAL_CONFIG_EXT_WOW             (SIR_HAL_ITC_MSG_TYPES_BEGIN + 287)
+#define SIR_HAL_CONFIG_APP_TYPE1_PARAMS    (SIR_HAL_ITC_MSG_TYPES_BEGIN + 288)
+#define SIR_HAL_CONFIG_APP_TYPE2_PARAMS    (SIR_HAL_ITC_MSG_TYPES_BEGIN + 289)
+#endif
+
 #define SIR_HAL_LED_FLASHING_REQ           (SIR_HAL_ITC_MSG_TYPES_BEGIN + 293)
 
 #ifdef MDNS_OFFLOAD
diff -urN qcacld-new.orig/CORE/MAC/src/pe/lim/limFT.c qcacld-new/CORE/MAC/src/pe/lim/limFT.c
--- qcacld-new.orig/CORE/MAC/src/pe/lim/limFT.c	2015-09-24 15:25:20.589038328 +0800
+++ qcacld-new/CORE/MAC/src/pe/lim/limFT.c	2015-09-24 15:25:20.617038328 +0800
@@ -913,7 +913,7 @@
     }
     pftSessionEntry->htSupportedChannelWidthSet =
                (pBeaconStruct->HTInfo.present)?
-               (cbEnabledMode && pBeaconStruct->HTInfo.recommendedTxWidthSet):0;
+               ((cbEnabledMode && pBeaconStruct->HTInfo.recommendedTxWidthSet)?1:0):0;
     pftSessionEntry->htRecommendedTxWidthSet =
                pftSessionEntry->htSupportedChannelWidthSet;
 
diff -urN qcacld-new.orig/CORE/MAC/src/pe/lim/limP2P.c qcacld-new/CORE/MAC/src/pe/lim/limP2P.c
--- qcacld-new.orig/CORE/MAC/src/pe/lim/limP2P.c	2015-09-24 15:25:20.589038328 +0800
+++ qcacld-new/CORE/MAC/src/pe/lim/limP2P.c	2015-09-24 15:25:20.617038328 +0800
@@ -810,6 +810,7 @@
     v_U8_t              *pIe=NULL;
     tDot11fIEHTCaps     dot11HtCap;
 
+	vos_mem_set(&dot11HtCap, sizeof(tDot11fIEHTCaps), 0);
     PopulateDot11fHTCaps(pMac, psessionEntry, &dot11HtCap);
     pIe = limGetIEPtr(pMac,pIeStartPtr, nBytes,
                                        DOT11F_EID_HTCAPS,ONE_BYTE);
diff -urN qcacld-new.orig/CORE/MAC/src/pe/lim/limProcessActionFrame.c qcacld-new/CORE/MAC/src/pe/lim/limProcessActionFrame.c
--- qcacld-new.orig/CORE/MAC/src/pe/lim/limProcessActionFrame.c	2015-09-24 15:25:20.589038328 +0800
+++ qcacld-new/CORE/MAC/src/pe/lim/limProcessActionFrame.c	2015-09-24 15:25:20.617038328 +0800
@@ -825,8 +825,7 @@
         pMac->lim.gLimAddtsSent = false;
         return;   //Error handling. send the response with error status. need to send DelTS to tear down the TSPEC status.
     }
-    if((addts.tspec.tsinfo.traffic.accessPolicy != SIR_MAC_ACCESSPOLICY_EDCA) ||
-       ((upToAc(addts.tspec.tsinfo.traffic.userPrio) < MAX_NUM_AC)))
+    if(addts.tspec.tsinfo.traffic.accessPolicy != SIR_MAC_ACCESSPOLICY_EDCA)
     {
 #ifdef FEATURE_WLAN_ESE
         retval = limSendHalMsgAddTs(pMac,
@@ -935,18 +934,6 @@
 
     tsinfo = delts.wmeTspecPresent ? &delts.tspec.tsinfo : &delts.tsinfo;
 
-    // if no Admit Control, ignore the request
-    if ((tsinfo->traffic.accessPolicy == SIR_MAC_ACCESSPOLICY_EDCA))
-    {
-
-        if (upToAc(tsinfo->traffic.userPrio) >= MAX_NUM_AC)
-        {
-            limLog(pMac, LOGW, FL("DelTs with UP %d has no AC - ignoring request"),
-                   tsinfo->traffic.userPrio);
-            return;
-        }
-    }
-
     if ((psessionEntry->limSystemRole != eLIM_AP_ROLE) &&
         (psessionEntry->limSystemRole != eLIM_BT_AMP_AP_ROLE))
         limSendSmeDeltsInd(pMac, &delts, aid,psessionEntry);
@@ -2558,6 +2545,7 @@
                     (tANI_U8*)pHdr, frameLen + sizeof(tSirMacMgmtHdr), 0,
                     WDA_GET_RX_CH( pRxPacketInfo ), psessionEntry, 0);
             }
+            break;
 
 #ifdef FEATURE_WLAN_TDLS
            case SIR_MAC_TDLS_DIS_RSP:
diff -urN qcacld-new.orig/CORE/MAC/src/pe/lim/limProcessAssocReqFrame.c qcacld-new/CORE/MAC/src/pe/lim/limProcessAssocReqFrame.c
--- qcacld-new.orig/CORE/MAC/src/pe/lim/limProcessAssocReqFrame.c	2015-09-24 15:25:20.589038328 +0800
+++ qcacld-new/CORE/MAC/src/pe/lim/limProcessAssocReqFrame.c	2015-09-24 15:25:20.617038328 +0800
@@ -1478,7 +1478,6 @@
 void limSendMlmAssocInd(tpAniSirGlobal pMac, tpDphHashNode pStaDs, tpPESession psessionEntry)
 {
     tpLimMlmAssocInd        pMlmAssocInd = NULL;
-    tpLimMlmReassocInd      pMlmReassocInd;
     tpSirAssocReq           pAssocReq;
     tANI_U16                temp;
     tANI_U32                phyMode;
@@ -1486,7 +1485,10 @@
     tANI_U8                 *wpsIe = NULL;
     tANI_U32                tmp;
 //    tANI_U16                statusCode;
+#if 0 //not current used.
     tANI_U16                i, j=0;
+    tpLimMlmReassocInd      pMlmReassocInd;
+#endif
 
     // Get a copy of the already parsed Assoc Request
     pAssocReq = (tpSirAssocReq) psessionEntry->parsedAssocReq[pStaDs->assocId];
@@ -1618,6 +1620,7 @@
         limPostSmeMessage(pMac, LIM_MLM_ASSOC_IND, (tANI_U32 *) pMlmAssocInd);
         vos_mem_free(pMlmAssocInd);
     }
+#if 0 //currenlty don't have this case, remove them based on code scan result.
     else
     {
         // If its of Reassociation Request, then post LIM_MLM_REASSOC_IND
@@ -1742,7 +1745,7 @@
         limPostSmeMessage(pMac, LIM_MLM_REASSOC_IND, (tANI_U32 *) pMlmReassocInd);
         vos_mem_free(pMlmReassocInd);
     }
-
+#endif
     return;
 
 } /*** end limSendMlmAssocInd() ***/
diff -urN qcacld-new.orig/CORE/MAC/src/pe/lim/limProcessMlmReqMessages.c qcacld-new/CORE/MAC/src/pe/lim/limProcessMlmReqMessages.c
--- qcacld-new.orig/CORE/MAC/src/pe/lim/limProcessMlmReqMessages.c	2015-09-24 15:25:20.589038328 +0800
+++ qcacld-new/CORE/MAC/src/pe/lim/limProcessMlmReqMessages.c	2015-09-24 15:25:20.617038328 +0800
@@ -399,7 +399,6 @@
 void limContinuePostChannelScan(tpAniSirGlobal pMac)
 {
     tANI_U8 channelNum;
-    tANI_U8 handleError = 0;
     tANI_U8 i = 0;
     tSirRetStatus status = eSIR_SUCCESS;
 
@@ -586,26 +585,7 @@
         // Wait for Beacons to arrive
     } // if (pMac->lim.gLimMlmScanReq->scanType == eSIR_ACTIVE_SCAN)
 
-    if( handleError )
-    {
-        //
-        // FIXME - With this, LIM/SoftMAC will try and recover
-        // state, but eWNI_SME_SCAN_CNF maybe reporting an
-        // incorrect status back to the SME. Some of the possible
-        // errors are:
-        // eSIR_SME_HAL_SCAN_INIT_FAILED
-        // eSIR_SME_RESOURCES_UNAVAILABLE
-        //
-        //Set the resume channel to Any valid channel (invalid).
-        //This will instruct HAL to set it to any previous valid channel.
-        peSetResumeChannel(pMac, 0, 0);
-        limSendHalFinishScanReq( pMac, eLIM_HAL_FINISH_SCAN_WAIT_STATE );
-        //limCompleteMlmScan(pMac, eSIR_SME_HAL_SCAN_INIT_FAILED);
-    }
-    else
-    {
-        limAddScanChannelInfo(pMac, channelNum);
-    }
+    limAddScanChannelInfo(pMac, channelNum);
 
     return;
 }
@@ -3797,7 +3777,7 @@
         {
             // This shouldn't be the case, but when this happens, this timeout should be for the last channelId.
             // Get the channelNum as close to correct as possible.
-            if(pMac->lim.gpLimMlmScanReq->channelList.channelNumber)
+            if(pMac->lim.gpLimMlmScanReq->channelList.numChannels)
             {
                 channelNum = pMac->lim.gpLimMlmScanReq->channelList.channelNumber[pMac->lim.gpLimMlmScanReq->channelList.numChannels - 1];
             }
@@ -3873,7 +3853,7 @@
         }
         else
         {
-            if(pMac->lim.gpLimMlmScanReq->channelList.channelNumber)
+            if(pMac->lim.gpLimMlmScanReq->channelList.numChannels)
             {
                 channelNum = pMac->lim.gpLimMlmScanReq->channelList.channelNumber[pMac->lim.gpLimMlmScanReq->channelList.numChannels - 1];
             }
diff -urN qcacld-new.orig/CORE/MAC/src/pe/lim/limProcessMlmRspMessages.c qcacld-new/CORE/MAC/src/pe/lim/limProcessMlmRspMessages.c
--- qcacld-new.orig/CORE/MAC/src/pe/lim/limProcessMlmRspMessages.c	2015-09-24 15:25:20.589038328 +0800
+++ qcacld-new/CORE/MAC/src/pe/lim/limProcessMlmRspMessages.c	2015-09-24 15:25:20.617038328 +0800
@@ -1107,6 +1107,7 @@
         // Log error
         limLog(pMac, LOGP,
            FL("call to AllocateMemory failed for eWNI_SME_AUTH_IND"));
+		return;
     }
     limCopyU16((tANI_U8 *) &pSirSmeAuthInd->messageType, eWNI_SME_AUTH_IND);
     limAuthIndSerDes(pMac, (tpLimMlmAuthInd) pMsgBuf,
@@ -4401,12 +4402,7 @@
         vos_mem_free(pMsgBuf);
         return;
     }
-    if(NULL == pMlmDelBACnf)
-    {
-        limLog( pMac, LOGE,
-        FL( "pMlmDelBACnf is NULL - ignoring DELBA CNF from HAL" ));
-        return;
-    }
+
     // Need to validate baState
     LIM_GET_STA_BA_STATE(pSta, pMlmDelBACnf->baTID, &curBaState);
     if( eLIM_BA_STATE_WT_DEL_RSP != curBaState )
diff -urN qcacld-new.orig/CORE/MAC/src/pe/lim/limProcessSmeReqMessages.c qcacld-new/CORE/MAC/src/pe/lim/limProcessSmeReqMessages.c
--- qcacld-new.orig/CORE/MAC/src/pe/lim/limProcessSmeReqMessages.c	2015-09-24 15:25:20.589038328 +0800
+++ qcacld-new/CORE/MAC/src/pe/lim/limProcessSmeReqMessages.c	2015-09-24 15:25:20.617038328 +0800
@@ -2353,7 +2353,7 @@
          psessionEntry->pLimReAssocReq->bssDescription.channelId;
 
     psessionEntry->reAssocHtSupportedChannelWidthSet =
-         (psessionEntry->pLimReAssocReq->cbMode)?1:0;
+         (psessionEntry->pLimReAssocReq->cbMode != PHY_SINGLE_CHANNEL_CENTERED)?1:0;
     psessionEntry->reAssocHtRecommendedTxWidthSet =
          psessionEntry->reAssocHtSupportedChannelWidthSet;
     psessionEntry->reAssocHtSecondaryChannelOffset =
@@ -3609,7 +3609,7 @@
  */
 void limProcessSmeGetWPSPBCSessions(tpAniSirGlobal pMac, tANI_U32 *pMsgBuf)
 {
-    tSirSmeGetWPSPBCSessionsReq  GetWPSPBCSessionsReq;
+    tSirSmeGetWPSPBCSessionsReq  *pGetWPSPBCSessionsReq;
     tpPESession                  psessionEntry = NULL;
     tSap_Event                   sapEvent;
     tpWLAN_SAPEventCB            pSapEventCallback = NULL;
@@ -3618,7 +3618,15 @@
 
     sapEvent.sapevt.sapGetWPSPBCSessionEvent.status = VOS_STATUS_E_FAULT;
 
-    if (limIsSmeGetWPSPBCSessionsReqValid(pMac,  &GetWPSPBCSessionsReq, (tANI_U8 *) pMsgBuf) != eSIR_SUCCESS)
+	pGetWPSPBCSessionsReq = vos_mem_malloc(sizeof(tSirSmeGetWPSPBCSessionsReq));
+	if ( NULL == pGetWPSPBCSessionsReq ) {
+		limLog(pMac, LOGE,
+			FL("Allocation memeory falied at %s"), __func__);
+		return;
+	}
+	vos_mem_set(pGetWPSPBCSessionsReq, sizeof(pGetWPSPBCSessionsReq), 0);
+
+    if (limIsSmeGetWPSPBCSessionsReqValid(pMac,  pGetWPSPBCSessionsReq, (tANI_U8 *) pMsgBuf) != eSIR_SUCCESS)
     {
         limLog(pMac, LOGE,
                         FL("received invalid eWNI_SME_GET_ASSOC_STAS_REQ message"));
@@ -3627,7 +3635,7 @@
 
     // Get Associated stations from PE
     // Find PE session Entry
-    if ((psessionEntry = peFindSessionByBssid(pMac, GetWPSPBCSessionsReq.bssId, &sessionId)) == NULL)
+	if ((psessionEntry = peFindSessionByBssid(pMac, pGetWPSPBCSessionsReq->bssId, &sessionId)) == NULL)
     {
         limLog(pMac, LOGE,
                         FL("session does not exist for given bssId"));
@@ -3646,7 +3654,7 @@
     sapEvent.sapHddEventCode =  eSAP_GET_WPSPBC_SESSION_EVENT;
     sapEvent.sapevt.sapGetWPSPBCSessionEvent.module = VOS_MODULE_ID_PE;
 
-    if (vos_mem_compare( zeroMac, GetWPSPBCSessionsReq.pRemoveMac, sizeof(tSirMacAddr)))
+	if (vos_mem_compare( zeroMac, pGetWPSPBCSessionsReq->pRemoveMac, sizeof(tSirMacAddr)))
     { //This is GetWpsSession call
 
       limGetWPSPBCSessions(pMac,
@@ -3655,9 +3663,10 @@
     }
     else
     {
-      limRemovePBCSessions(pMac, GetWPSPBCSessionsReq.pRemoveMac,psessionEntry);
-      /* don't have to inform the HDD/Host */
-      return;
+		limRemovePBCSessions(pMac, pGetWPSPBCSessionsReq->pRemoveMac,psessionEntry);
+		/* don't have to inform the HDD/Host */
+		vos_mem_free(pGetWPSPBCSessionsReq);
+		return;
     }
 
     PELOG4(limLog(pMac, LOGE, FL("wpsPBCOverlap %d"), sapEvent.sapevt.sapGetWPSPBCSessionEvent.wpsPBCOverlap);)
@@ -3666,8 +3675,9 @@
     sapEvent.sapevt.sapGetWPSPBCSessionEvent.status = VOS_STATUS_SUCCESS;
 
 limGetWPSPBCSessionsEnd:
-    pSapEventCallback   = (tpWLAN_SAPEventCB)GetWPSPBCSessionsReq.pSapEventCallback;
-    pSapEventCallback(&sapEvent, GetWPSPBCSessionsReq.pUsrContext);
+    pSapEventCallback   = (tpWLAN_SAPEventCB)pGetWPSPBCSessionsReq->pSapEventCallback;
+    pSapEventCallback(&sapEvent, pGetWPSPBCSessionsReq->pUsrContext);
+	vos_mem_free(pGetWPSPBCSessionsReq);
 }
 
 
diff -urN qcacld-new.orig/CORE/MAC/src/pe/lim/limProcessTdls.c qcacld-new/CORE/MAC/src/pe/lim/limProcessTdls.c
--- qcacld-new.orig/CORE/MAC/src/pe/lim/limProcessTdls.c	2015-09-24 15:25:20.589038328 +0800
+++ qcacld-new/CORE/MAC/src/pe/lim/limProcessTdls.c	2015-09-24 15:25:20.617038328 +0800
@@ -2736,6 +2736,7 @@
     tpDphHashNode pSessStaDs = NULL;
     tANI_U16 aid;
 
+    memset(&htCap, 0, sizeof(htCap));
     if (pTdlsAddStaReq->tdlsAddOper == TDLS_OPER_ADD)
     {
         PopulateDot11fHTCaps(pMac, psessionEntry, &htCap);
@@ -5518,7 +5519,7 @@
         return eSIR_MEM_ALLOC_FAILED;
     }
 
-    vos_mem_set( (tANI_U8 *)pMsgTdlsLinkEstablishReq, sizeof(tpTdlsLinkEstablishParams), 0);
+    vos_mem_set( (tANI_U8 *)pMsgTdlsLinkEstablishReq, sizeof(tTdlsLinkEstablishParams), 0);
 
     pMsgTdlsLinkEstablishReq->staIdx = pStaDs->staIndex;
     pMsgTdlsLinkEstablishReq->isResponder = pTdlsLinkEstablishReq->isResponder;
diff -urN qcacld-new.orig/CORE/MAC/src/pe/lim/limSendSmeRspMessages.c qcacld-new/CORE/MAC/src/pe/lim/limSendSmeRspMessages.c
--- qcacld-new.orig/CORE/MAC/src/pe/lim/limSendSmeRspMessages.c	2015-09-24 15:25:20.589038328 +0800
+++ qcacld-new/CORE/MAC/src/pe/lim/limSendSmeRspMessages.c	2015-09-24 15:25:20.617038328 +0800
@@ -2915,6 +2915,10 @@
 
    pStaDs = dphLookupHashEntry(pMac, psessionEntry->bssId, &aid,
                                       &psessionEntry->dph.dphHashTable);
+   if (NULL == pStaDs) {
+          limLog(pMac, LOGE, FL("pStaDs is NULL"));
+          goto err;
+    }
 
    if (psessionEntry->limSystemRole == eLIM_STA_ROLE)
    {
diff -urN qcacld-new.orig/CORE/MAC/src/pe/lim/limSerDesUtils.c qcacld-new/CORE/MAC/src/pe/lim/limSerDesUtils.c
--- qcacld-new.orig/CORE/MAC/src/pe/lim/limSerDesUtils.c	2015-09-24 15:25:20.589038328 +0800
+++ qcacld-new/CORE/MAC/src/pe/lim/limSerDesUtils.c	2015-09-24 15:25:20.617038328 +0800
@@ -2468,14 +2468,14 @@
         return eSIR_FAILURE;
 
     // Extract pUsrContext
-    vos_mem_copy((tANI_U8 *)pGetAssocSTAsReq->pUsrContext, pBuf, sizeof(void*));
+    pGetAssocSTAsReq->pUsrContext = (void *)pBuf;
     pBuf += sizeof(void*);
     len  -= sizeof(void*);
     if (limCheckRemainingLength(pMac, len) == eSIR_FAILURE)
         return eSIR_FAILURE;
 
     // Extract pSapEventCallback
-    vos_mem_copy((tANI_U8 *)pGetAssocSTAsReq->pSapEventCallback, pBuf, sizeof(void*));
+    pGetAssocSTAsReq->pSapEventCallback = (void *)pBuf;
     pBuf += sizeof(void*);
     len  -= sizeof(void*);
     if (limCheckRemainingLength(pMac, len) == eSIR_FAILURE)
@@ -2621,14 +2621,14 @@
         return eSIR_FAILURE;
 
    // Extract pUsrContext
-    vos_mem_copy((tANI_U8 *)pGetWPSPBCSessionsReq->pUsrContext, pBuf, sizeof(void*));
+    pGetWPSPBCSessionsReq->pUsrContext = (void *)pBuf;
     pBuf += sizeof(void*);
     len  -= sizeof(void*);
     if (limCheckRemainingLength(pMac, len) == eSIR_FAILURE)
         return eSIR_FAILURE;
 
     // Extract pSapEventCallback
-    vos_mem_copy((tANI_U8 *)pGetWPSPBCSessionsReq->pSapEventCallback, pBuf, sizeof(void*));
+    pGetWPSPBCSessionsReq->pSapEventCallback = (void *)pBuf;
     pBuf += sizeof(void*);
     len  -= sizeof(void*);
     if (limCheckRemainingLength(pMac, len) == eSIR_FAILURE)
diff -urN qcacld-new.orig/CORE/MAC/src/pe/lim/limTimerUtils.c qcacld-new/CORE/MAC/src/pe/lim/limTimerUtils.c
--- qcacld-new.orig/CORE/MAC/src/pe/lim/limTimerUtils.c	2015-09-24 15:25:20.589038328 +0800
+++ qcacld-new/CORE/MAC/src/pe/lim/limTimerUtils.c	2015-09-24 15:25:20.617038328 +0800
@@ -151,6 +151,11 @@
     }
     cfgValue = SYS_MS_TO_TICKS(cfgValue);
 
+    /* add this check for avoid code scan warning */
+    if (!cfgValue1) {
+        cfgValue1 = 1;
+    }
+
     /* Limiting max numm of probe req for each channel scan */
     pMac->lim.maxProbe = (cfgValue/cfgValue1);
 
diff -urN qcacld-new.orig/CORE/MAC/src/pe/lim/limUtils.c qcacld-new/CORE/MAC/src/pe/lim/limUtils.c
--- qcacld-new.orig/CORE/MAC/src/pe/lim/limUtils.c	2015-09-24 15:25:20.589038328 +0800
+++ qcacld-new/CORE/MAC/src/pe/lim/limUtils.c	2015-09-24 15:25:20.617038328 +0800
@@ -8057,6 +8057,7 @@
     v_U8_t              *p_ie=NULL;
     tDot11fIEHTCaps     dot11_ht_cap;
 
+    vos_mem_set(&dot11_ht_cap, sizeof(tDot11fIEHTCaps), 0);
     PopulateDot11fHTCaps(p_mac, p_session_entry, &dot11_ht_cap);
     p_ie = limGetIEPtr(p_mac, p_ie_start, num_bytes, DOT11F_EID_HTCAPS,
                                                     ONE_BYTE);
diff -urN qcacld-new.orig/CORE/MAC/src/pe/pmm/pmmAP.c qcacld-new/CORE/MAC/src/pe/pmm/pmmAP.c
--- qcacld-new.orig/CORE/MAC/src/pe/pmm/pmmAP.c	2015-09-24 15:25:20.589038328 +0800
+++ qcacld-new/CORE/MAC/src/pe/pmm/pmmAP.c	2015-09-24 15:25:20.617038328 +0800
@@ -77,7 +77,6 @@
     // Generate partial virtual bitmap
     tANI_U8 N1 = minAid / 8;
     tANI_U8 N2 = maxAid / 8;
-    if (N1 & 1) N1--;
 
     *timLength = N2 - N1 + 4;
     val = dtimPeriod;
diff -urN qcacld-new.orig/CORE/MAC/src/pe/pmm/pmmApi.c qcacld-new/CORE/MAC/src/pe/pmm/pmmApi.c
--- qcacld-new.orig/CORE/MAC/src/pe/pmm/pmmApi.c	2015-09-24 15:25:20.589038328 +0800
+++ qcacld-new/CORE/MAC/src/pe/pmm/pmmApi.c	2015-09-24 15:25:20.617038328 +0800
@@ -2081,12 +2081,6 @@
     }
     (void) vos_mem_copy(pDeletePtrn, pMbMsg->data, sizeof(*pDeletePtrn));
 
-    if (NULL == pDeletePtrn)
-    {
-        pmmLog(pMac, LOGE, FL("Delete broadcast pattern message is NULL "));
-        return;
-    }
-
     msgQ.type = WDA_WOWL_DEL_BCAST_PTRN;
     msgQ.reserved = 0;
     msgQ.bodyptr = pDeletePtrn;
diff -urN qcacld-new.orig/CORE/MAC/src/pe/rrm/rrmApi.c qcacld-new/CORE/MAC/src/pe/rrm/rrmApi.c
--- qcacld-new.orig/CORE/MAC/src/pe/rrm/rrmApi.c	2015-09-24 15:25:20.589038328 +0800
+++ qcacld-new/CORE/MAC/src/pe/rrm/rrmApi.c	2015-09-24 15:25:20.617038328 +0800
@@ -637,7 +637,11 @@
    mmhMsg.type    = eWNI_SME_BEACON_REPORT_REQ_IND;
    mmhMsg.bodyptr = pSmeBcnReportReq;
    MTRACE(macTraceMsgTx(pMac, pSessionEntry->peSessionId, mmhMsg.type));
-   return limSysProcessMmhMsgApi(pMac, &mmhMsg, ePROT);
+
+   /* Fix enum type mixing defect, return success since
+      limSysProcessMmhMsgApi always return success now. */
+   limSysProcessMmhMsgApi(pMac, &mmhMsg, ePROT);
+   return eRRM_SUCCESS;
 }
 
 // --------------------------------------------------------------------
diff -urN qcacld-new.orig/CORE/MAC/src/pe/sch/schBeaconGen.c qcacld-new/CORE/MAC/src/pe/sch/schBeaconGen.c
--- qcacld-new.orig/CORE/MAC/src/pe/sch/schBeaconGen.c	2015-09-24 15:25:20.589038328 +0800
+++ qcacld-new/CORE/MAC/src/pe/sch/schBeaconGen.c	2015-09-24 15:25:20.617038328 +0800
@@ -773,7 +773,7 @@
         size = (size + 3) & (~3);
         if( eSIR_SUCCESS != schSendBeaconReq( pMac, psessionEntry->pSchBeaconFrameBegin,
                                               size, psessionEntry))
-            PELOGE(schLog(pMac, LOGE, FL("schSendBeaconReq() returned an error (zsize %d)"), size);)
+            schLog(pMac, LOGE, FL("schSendBeaconReq() returned an error (zsize %d)"), size);
         else
         {
             pMac->sch.gSchBeaconsWritten++;
diff -urN qcacld-new.orig/CORE/MAC/src/pe/sch/schBeaconProcess.c qcacld-new/CORE/MAC/src/pe/sch/schBeaconProcess.c
--- qcacld-new.orig/CORE/MAC/src/pe/sch/schBeaconProcess.c	2015-09-24 15:25:20.589038328 +0800
+++ qcacld-new/CORE/MAC/src/pe/sch/schBeaconProcess.c	2015-09-24 15:25:20.617038328 +0800
@@ -433,7 +433,7 @@
             if(pBeacon->edcaParams.qosInfo.count != psessionEntry->gLimEdcaParamSetCount)
             {
                 if (schBeaconEdcaProcess(pMac, &pBeacon->edcaParams, psessionEntry) != eSIR_SUCCESS)
-                    PELOGE(schLog(pMac, LOGE, FL("EDCA parameter processing error"));)
+                    schLog(pMac, LOGE, FL("EDCA parameter processing error"));
                 else if(pStaDs != NULL)
                 {
                     // If needed, downgrade the EDCA parameters
diff -urN qcacld-new.orig/CORE/SAP/src/sapApiLinkCntl.c qcacld-new/CORE/SAP/src/sapApiLinkCntl.c
--- qcacld-new.orig/CORE/SAP/src/sapApiLinkCntl.c	2015-09-24 15:25:20.565038328 +0800
+++ qcacld-new/CORE/SAP/src/sapApiLinkCntl.c	2015-09-24 15:25:20.601038328 +0800
@@ -140,8 +140,8 @@
     VOS_STATUS sapstatus;
 #ifdef SOFTAP_CHANNEL_RANGE
     v_U32_t operatingBand;
-    v_U32_t event;
 #endif
+    v_U32_t event = eSAP_CHANNEL_SELECTION_FAILED;
 
     /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
     VOS_TRACE( VOS_MODULE_ID_SAP, VOS_TRACE_LEVEL_INFO_HIGH, "In %s, before switch on scanStatus = %d", __func__, scanStatus);
diff -urN qcacld-new.orig/CORE/SERVICES/BMI/ol_fw.c qcacld-new/CORE/SERVICES/BMI/ol_fw.c
--- qcacld-new.orig/CORE/SERVICES/BMI/ol_fw.c	2015-09-24 15:25:20.561038328 +0800
+++ qcacld-new/CORE/SERVICES/BMI/ol_fw.c	2015-09-24 15:25:20.597038328 +0800
@@ -395,7 +395,7 @@
 
 	switch (file) {
 	default:
-		printk("%s: Unknown file type\n", __func__);
+		printk(KERN_ERR "%s: Unknown file type\n", __func__);
 		return -1;
 	case ATH_OTP_FILE:
 #if defined(CONFIG_CNSS) || defined(HIF_SDIO)
@@ -439,7 +439,7 @@
 #endif
 		break;
 	case ATH_PATCH_FILE:
-		printk("%s: no Patch file defined\n", __func__);
+		printk(KERN_ERR "%s: no Patch file defined\n", __func__);
 		return EOK;
 	case ATH_BOARD_DATA_FILE:
 #ifdef QCA_WIFI_FTM
@@ -470,7 +470,7 @@
 		if (vos_get_conparam() != VOS_FTM_MODE &&
 		   !WLAN_IS_EPPING_ENABLED(vos_get_conparam())) {
 #ifdef CONFIG_CNSS
-			printk("%s: no Setup file defined\n", __func__);
+			printk(KERN_ERR "%s: no Setup file defined\n", __func__);
 			return -1;
 #else
 #ifdef HIF_SDIO
@@ -485,7 +485,7 @@
 					__func__, filename);
 #endif /* CONFIG_CNSS */
 		} else {
-			printk("%s: no Setup file needed\n", __func__);
+			printk(KERN_ERR "%s: no Setup file needed\n", __func__);
 			return -1;
 		}
 		break;
@@ -493,7 +493,7 @@
 
 	if (request_firmware(&fw_entry, filename, scn->sc_osdev->device) != 0)
 	{
-		printk("%s: Failed to get %s\n", __func__, filename);
+		printk(KERN_ERR "%s: Failed to get %s\n", __func__, filename);
 
 		if (file == ATH_OTP_FILE)
 			return -ENOENT;
@@ -503,11 +503,11 @@
 		 * board data file is not present. */
 		if (filename == scn->fw_files.utf_board_data) {
 			filename = scn->fw_files.board_data;
-			printk("%s: Trying to load default %s\n",
+			printk(KERN_ERR "%s: Trying to load default %s\n",
 				__func__, filename);
 			if (request_firmware(&fw_entry, filename,
 				scn->sc_osdev->device) != 0) {
-				printk("%s: Failed to get %s\n",
+				printk(KERN_ERR "%s: Failed to get %s\n",
 					__func__, filename);
 				return -1;
 			}
@@ -520,7 +520,7 @@
 	}
 
         if (!fw_entry || !fw_entry->data) {
-               printk("Invalid fw_entries\n");
+               printk(KERN_ERR "Invalid fw_entries\n");
                return A_ERROR;
         }
 
@@ -534,7 +534,7 @@
 
 		tempEeprom = OS_MALLOC(scn->sc_osdev, fw_entry_size, GFP_ATOMIC);
 		if (!tempEeprom) {
-			printk("%s: Memory allocation failed\n", __func__);
+			printk(KERN_ERR "%s: Memory allocation failed\n", __func__);
 			release_firmware(fw_entry);
 			return A_ERROR;
 		}
@@ -559,7 +559,7 @@
 		BMIReadMemory(scn->hif_hdl,
 				HOST_INTEREST_ITEM_ADDRESS(scn->target_type, hi_board_ext_data),
 				(u_int8_t *)&board_ext_address, 4, scn);
-		printk("Board extended Data download address: 0x%x\n", board_ext_address);
+		printk(KERN_INFO "Board extended Data download address: 0x%x\n", board_ext_address);
 
 		/*
 		 * Check whether the target has allocated memory for extended board
@@ -685,7 +685,7 @@
 	}
 
 	if (status != EOK) {
-		printk("%s, BMI operation failed: %d\n", __func__, __LINE__);
+		printk(KERN_ERR "%s, BMI operation failed: %d\n", __func__, __LINE__);
 		release_firmware(fw_entry);
 		return A_ERROR;
 	}
@@ -931,6 +931,185 @@
 A_UINT32 fw_stack_addr;
 void *fw_ram_seg_addr[FW_RAM_SEG_CNT];
 
+#if defined(CONFIG_CRASH_DUMP_CLD) || defined(CONFIG_WLAN_FWLOG_FILE)
+
+#define GET_INODE_FROM_FILEP(filp) ((filp)->f_path.dentry->d_inode)
+
+int _readwrite_file(const char *filename, char *rbuf,
+	const char *wbuf, size_t length, int mode)
+{
+	int ret = 0;
+	struct file *filp = (struct file *)-ENOENT;
+	mm_segment_t oldfs;
+	oldfs = get_fs();
+	set_fs(KERNEL_DS);
+
+	do {
+		filp = filp_open(filename, mode, S_IRUSR);
+
+		if (IS_ERR(filp) || !filp->f_op) {
+			ret = -ENOENT;
+			break;
+		}
+
+		if (!filp->f_op->write || !filp->f_op->read) {
+			filp_close(filp, NULL);
+			ret = -ENOENT;
+			break;
+		}
+
+		if (length == 0) {
+			/* Read the length of the file only */
+			struct inode    *inode;
+
+			inode = GET_INODE_FROM_FILEP(filp);
+			if (!inode) {
+				printk(KERN_ERR
+					"_readwrite_file: Error 2\n");
+				ret = -ENOENT;
+				break;
+			}
+			ret = i_size_read(inode->i_mapping->host);
+			break;
+		}
+
+		if (wbuf) {
+			ret = filp->f_op->write(
+				filp, wbuf, length, &filp->f_pos);
+			if (ret < 0) {
+				printk(KERN_ERR
+					"_readwrite_file: Error 3\n");
+				break;
+			}
+		} else {
+			ret = filp->f_op->read(
+				filp, rbuf, length, &filp->f_pos);
+			if (ret < 0) {
+				printk(KERN_ERR
+					"_readwrite_file: Error 4\n");
+				break;
+			}
+		}
+	} while (0);
+
+	if (!IS_ERR(filp))
+		filp_close(filp, NULL);
+
+	set_fs(oldfs);
+	return ret;
+}
+
+#ifdef CONFIG_CRASH_DUMP_CLD
+#define DUMP_BUF_SIZE 20000 //backtrace + stack size is around 20K
+#define MAX_DUMP_FW_SIZE 100000
+
+#define CRASH_DUMP_FILE "/opt/var/log/cld_fwcrash.log"
+
+
+int check_dump_file_size(void)
+{
+	int status = 0, size = 0;
+	size = _readwrite_file(CRASH_DUMP_FILE, NULL, NULL, 0, O_RDONLY);
+	if (size > (MAX_DUMP_FW_SIZE - DUMP_BUF_SIZE)) {
+
+		printk(KERN_ERR "clean big log 0x%x\n", size);
+		status = _readwrite_file(CRASH_DUMP_FILE, NULL, NULL,
+			0, (O_WRONLY | O_TRUNC));
+	}
+
+	return status;
+}
+
+static int dump_fw_crash_to_file(struct ol_softc *scn)
+{
+	A_UINT32 *reg, pattern, i, start_addr = 0;
+	A_UINT32 MSPId = 0, mSPId = 0, SIId = 0, CRMId = 0, len;
+	A_UINT8 *data;
+	A_UINT32 remaining;
+	char *buf;
+	unsigned int str_len = 0, buf_len = DUMP_BUF_SIZE;
+	int status = 0;
+
+	buf = kmalloc(buf_len, GFP_ATOMIC);
+
+	if (buf == NULL) {
+		printk(KERN_ERR "No buffer available for crash log\n");
+		return -ENOMEM;
+        }
+
+	memset(buf, 0, buf_len);
+
+	data = scn->hif_sc->fw_data;
+	len = scn->hif_sc->fw_data_len;
+	pattern = *((A_UINT32 *) data);
+
+
+	if (pattern == FW_ASSERT_PATTERN) {
+		MSPId = (scn->target_fw_version & 0xf0000000) >> 28;
+		mSPId = (scn->target_fw_version & 0xf000000) >> 24;
+		SIId = (scn->target_fw_version & 0xf00000) >> 20;
+		CRMId = scn->target_fw_version & 0x7fff;
+		status = check_dump_file_size();
+		if (status)
+			printk(KERN_ERR "crash log file check status code 0x%x\n", status);
+		str_len = scnprintf(buf + str_len, buf_len - str_len, "Host SW version: %s\n", QWLAN_VERSIONSTR);
+		str_len += scnprintf(buf + str_len, buf_len - str_len, "FW version: %d.%d.%d.%d\n", MSPId, mSPId, SIId, CRMId);
+		if (vos_is_load_unload_in_progress(VOS_MODULE_ID_VOSS, NULL)) {
+			printk(KERN_INFO "%s: Loading/Unloading is in progress, ignore!\n",
+				__func__);
+			kfree(buf);
+			return 0;
+		}
+		reg = (A_UINT32 *) (data + 4);
+		for (i = 0; i < min_t(A_UINT32, len - 4, FW_REG_DUMP_CNT * 4); i += 16) {
+			A_UINT8 temp_buf[128];
+			hex_dump_to_buffer(reg+i, 16, 16, 4, temp_buf, sizeof(temp_buf), false);
+			str_len += snprintf(buf + str_len, buf_len - str_len, "%#08x: %s\n", i, temp_buf);
+		}
+		scn->fw_ram_dumping = 0;
+
+		if (scn->enableFwSelfRecovery)
+			vos_set_logp_in_progress(VOS_MODULE_ID_VOSS, TRUE);
+	}
+#ifdef CONFIG_CRASH_DUMP_STACK
+	else if (pattern == FW_REG_PATTERN) {
+		reg = (A_UINT32 *) (data + 4);
+		start_addr = *reg++;
+		if (scn->fw_ram_dumping == 0) {
+			str_len += scnprintf(buf + str_len, buf_len - str_len, "Firmware stack dump:\n");
+			scn->fw_ram_dumping = 1;
+			fw_stack_addr = start_addr;
+		}
+		remaining = len - 8;
+		/* len is in byte, but it's printed in double-word. */
+		for (i = 0; i < (len - 8); i += 16) {
+			A_UINT8 temp_buf[128];
+			if ((*reg == FW_REG_END_PATTERN) && (i == len - 12)) {
+				scn->fw_ram_dumping = 0;
+				str_len += scnprintf(buf + str_len, buf_len - str_len, "Stack start address = %#08x\n",
+					fw_stack_addr);
+				break;
+			}
+			hex_dump_to_buffer(reg, remaining, 16, 4, temp_buf,
+						sizeof(temp_buf), false);
+			str_len += scnprintf(buf + str_len, buf_len - str_len, "%#08x: %s\n", start_addr + i, temp_buf);
+			remaining -= 16;
+			reg += 4;
+		}
+	}
+#endif
+	status = _readwrite_file(CRASH_DUMP_FILE, NULL,
+			buf, str_len, (O_WRONLY | O_APPEND | O_CREAT));
+	if (status < 0)
+		printk(KERN_ERR "write failed with status code 0x%x\n", status);
+
+	kfree(buf);
+	return status;
+}
+#endif
+#endif
+
+
 /* ol_ramdump_handler is to receive information of firmware crash dump, and
  * save it in host memory. It consists of 5 parts: registers, call stack,
  * DRAM dump, IRAM dump, and AXI dump, and they are reported to host in order.
@@ -945,6 +1124,12 @@
  *            of the last packet is FW_RAMDUMP_END_PATTERN;
  * IRAM dump and AXI dump are with the same format as DRAM dump.
  */
+#ifdef CONFIG_CRASH_DUMP_CLD
+void ol_ramdump_handler(struct ol_softc *scn)
+{
+	dump_fw_crash_to_file(scn);
+}
+#else
 void ol_ramdump_handler(struct ol_softc *scn)
 {
 	A_UINT32 *reg, pattern, i, start_addr = 0;
@@ -969,7 +1154,7 @@
 		pr_err("FW version: %d.%d.%d.%d", MSPId, mSPId, SIId, CRMId);
 
 		if (vos_is_load_unload_in_progress(VOS_MODULE_ID_VOSS, NULL)) {
-			printk("%s: Loading/Unloading is in progress, ignore!\n",
+			printk(KERN_INFO "%s: Loading/Unloading is in progress, ignore!\n",
 				__func__);
 			return;
 		}
@@ -1051,6 +1236,7 @@
 		}
 	}
 }
+#endif /* CONFIG_CRASH_DUMP_CLD */
 #endif
 
 #define REGISTER_DUMP_LEN_MAX   60
diff -urN qcacld-new.orig/CORE/SERVICES/COMMON/adf/adf_os_mem.h qcacld-new/CORE/SERVICES/COMMON/adf/adf_os_mem.h
--- qcacld-new.orig/CORE/SERVICES/COMMON/adf/adf_os_mem.h	2015-09-24 15:25:20.561038328 +0800
+++ qcacld-new/CORE/SERVICES/COMMON/adf/adf_os_mem.h	2015-09-24 15:25:20.597038328 +0800
@@ -44,6 +44,10 @@
 #endif
 #endif
 
+#ifdef CONFIG_VOS_MEM_PRE_ALLOC
+#include <vos_memory.h>
+#endif
+
 /**
  * @brief Allocate a memory buffer. Note this call can block.
  *
@@ -54,17 +58,24 @@
 static inline void *
 adf_os_mem_alloc(adf_os_device_t osdev, adf_os_size_t size)
 {
-#ifdef CONFIG_WCNSS_MEM_PRE_ALLOC
+#if defined(CONFIG_WCNSS_MEM_PRE_ALLOC) || defined(CONFIG_VOS_MEM_PRE_ALLOC)
     void *p_mem;
 #endif
 
-#ifdef CONFIG_WCNSS_MEM_PRE_ALLOC
+#if defined(CONFIG_WCNSS_MEM_PRE_ALLOC)
    if (size > WCNSS_PRE_ALLOC_GET_THRESHOLD)
    {
        p_mem = wcnss_prealloc_get(size);
        if (NULL != p_mem)
            return p_mem;
    }
+#elif defined(CONFIG_VOS_MEM_PRE_ALLOC)
+	if (size > VOS_PRE_ALLOC_GET_THRESHOLD)
+	{
+		p_mem = vos_prealloc_get(size);
+		if (NULL != p_mem)
+			return p_mem;
+	}
 #endif
 
     return __adf_os_mem_alloc(osdev, size);
@@ -81,11 +92,16 @@
 static inline void
 adf_os_mem_free(void *buf)
 {
-#ifdef CONFIG_WCNSS_MEM_PRE_ALLOC
+#if defined(CONFIG_WCNSS_MEM_PRE_ALLOC)
     if (wcnss_prealloc_put(buf))
     {
         return;
     }
+#elif defined(CONFIG_VOS_MEM_PRE_ALLOC)
+	if (vos_prealloc_put(buf))
+	{
+		return;
+	}
 #endif
 
     __adf_os_mem_free(buf);
diff -urN qcacld-new.orig/CORE/SERVICES/COMMON/dbglog_host.h qcacld-new/CORE/SERVICES/COMMON/dbglog_host.h
--- qcacld-new.orig/CORE/SERVICES/COMMON/dbglog_host.h	2015-09-24 15:25:20.561038328 +0800
+++ qcacld-new/CORE/SERVICES/COMMON/dbglog_host.h	2015-09-24 15:25:20.597038328 +0800
@@ -184,6 +184,11 @@
 int
 dbglog_report_enable(wmi_unified_t  wmi_handle, A_BOOL isenable);
 
+#ifdef CONFIG_WLAN_FWLOG_FILE
+/** Enable write fwlog into a file */
+int
+dbglog_fwlog_file_enable(wmi_unified_t  wmi_handle, A_BOOL isenable);
+#endif
 /** Set the log level
 * @brief DBGLOG_INFO - Information lowest log level
 * @brief DBGLOG_WARNING
diff -urN qcacld-new.orig/CORE/SERVICES/COMMON/wmi_unified.h qcacld-new/CORE/SERVICES/COMMON/wmi_unified.h
--- qcacld-new.orig/CORE/SERVICES/COMMON/wmi_unified.h	2015-09-24 15:25:20.561038328 +0800
+++ qcacld-new/CORE/SERVICES/COMMON/wmi_unified.h	2015-09-24 15:25:20.597038328 +0800
@@ -2451,7 +2451,9 @@
     /** set type of the debug output */
     WMI_DBGLOG_TYPE,
     /** Enable Disable debug */
-    WMI_DBGLOG_REPORT_ENABLE
+    WMI_DBGLOG_REPORT_ENABLE,
+    /** Enable fwlog write to file */
+    WMI_DBGLOG_FWLOG_FILE_ENABLE,
 } WMI_DBG_PARAM;
 
 typedef struct {
@@ -2494,7 +2496,7 @@
     PAUSE_TYPE_STA_ADD_BA =     0x6, /** only peer_id and tid_map are valid, actually only one tid is set at one time */
     PAUSE_TYPE_AP_PS =          0x7, /** for pausing AP vdev when all the connected clients are in PS. only vdev_map is valid */
     PAUSE_TYPE_IBSS_PS =        0x8, /** for pausing IBSS vdev when all the peers are in PS. only vdev_map is valid */
-    PAUSE_TYPE_HOST =           0x15,/** host is requesting vdev pause */
+    PAUSE_TYPE_HOST =           0xF, /** host is requesting vdev pause */
 } wmi_tx_pause_type;
 
 typedef enum {
@@ -5820,7 +5822,6 @@
 typedef struct {
     A_UINT32 tlv_header; /* TLV tag and len; tag equals wmi_extwow_set_app_type1_params_cmd_fixed_param  */
     A_UINT32 vdev_id;
-    wmi_mac_addr  wakee_mac;
     A_UINT8  ident[8];
     A_UINT8  passwd[16];
     A_UINT32 ident_len;
@@ -5831,8 +5832,19 @@
     A_UINT32 tlv_header;  /* TLV tag and len; tag equals wmi_extwow_set_app_type2_params_cmd_fixed_param  */
     A_UINT32 vdev_id;
 
-    A_UINT8  rc4_key[16];
-    A_UINT32 rc4_key_len;
+    A_UINT8  rc4_write_sandbox[256];
+    A_UINT8  rc4_write_x;
+    A_UINT8  rc4_write_y;
+    A_UINT8  rc4_read_sandbox[256];
+    A_UINT8  rc4_read_x;
+    A_UINT8  rc4_read_y;
+    A_UINT8  ssl_write_seq[8];
+    A_UINT8  ssl_read_seq[8];
+    A_UINT8  ssl_sha1_write_key[64];
+    A_UINT16 ssl_sha1_write_key_len;
+    A_UINT8  ssl_sha1_read_key[64];
+    A_UINT16 ssl_sha1_read_key_len;
+
 
     /** ip header parameter */
     A_UINT32 ip_id;         /* NC id */
@@ -5844,15 +5856,18 @@
     A_UINT16 tcp_dst_port;  /* Push server TCP port */
     A_UINT32 tcp_seq;
     A_UINT32 tcp_ack_seq;
+    A_UINT32 tcp_options_len;
+    A_UINT8  tcp_options[40];
+    A_UINT32 asyncId;
 
     A_UINT32 keepalive_init;  /* Initial ping interval */
     A_UINT32 keepalive_min;   /* Minimum ping interval */
     A_UINT32 keepalive_max;   /* Maximum ping interval */
     A_UINT32 keepalive_inc;   /* Increment of ping interval */
 
-    wmi_mac_addr gateway_mac;
     A_UINT32 tcp_tx_timeout_val;
     A_UINT32 tcp_rx_timeout_val;
+    wmi_mac_addr gateway_mac;
 } wmi_extwow_set_app_type2_params_cmd_fixed_param;
 
 
diff -urN qcacld-new.orig/CORE/SERVICES/DFS/src/dfs_process_phyerr.c qcacld-new/CORE/SERVICES/DFS/src/dfs_process_phyerr.c
--- qcacld-new.orig/CORE/SERVICES/DFS/src/dfs_process_phyerr.c	2015-09-24 15:25:20.561038328 +0800
+++ qcacld-new/CORE/SERVICES/DFS/src/dfs_process_phyerr.c	2015-09-24 15:25:20.597038328 +0800
@@ -237,7 +237,7 @@
    const char *cbuf = (const char *) buf;
    u_int8_t dur = 0;
    u_int8_t pulse_bw_info, pulse_length_ext, pulse_length_pri;
-   int pri_found, ext_found;
+   int pri_found = 0, ext_found = 0;
    int early_ext = 0;
    int event_width;
 
diff -urN qcacld-new.orig/CORE/SERVICES/DFS/src/dfs_process_radarevent.c qcacld-new/CORE/SERVICES/DFS/src/dfs_process_radarevent.c
--- qcacld-new.orig/CORE/SERVICES/DFS/src/dfs_process_radarevent.c	2015-09-24 15:25:20.561038328 +0800
+++ qcacld-new/CORE/SERVICES/DFS/src/dfs_process_radarevent.c	2015-09-24 15:25:20.597038328 +0800
@@ -482,7 +482,7 @@
                                             This is normally 2 but can be higher for W53.
                                         */
 
-                                        if ( (deltaT > (dfs->dfs_pri_multiplier * rf->rf_maxpri) ) || (deltaT < rf->rf_minpri) ) {
+                                        if ( (deltaT > (u_int64_t)(dfs->dfs_pri_multiplier * rf->rf_maxpri) ) || (deltaT < rf->rf_minpri) ) {
                                                 DFS_DPRINTK(dfs, ATH_DEBUG_DFS2,
                                                 "filterID %d : Rejecting on individual filter max PRI deltaT=%lld rf->rf_minpri=%u",
                                                 rf->rf_pulseid, (unsigned long long)deltaT, rf->rf_minpri);
diff -urN qcacld-new.orig/CORE/SERVICES/HIF/sdio/linux/if_ath_sdio.c qcacld-new/CORE/SERVICES/HIF/sdio/linux/if_ath_sdio.c
--- qcacld-new.orig/CORE/SERVICES/HIF/sdio/linux/if_ath_sdio.c	2015-09-24 15:25:20.557038328 +0800
+++ qcacld-new/CORE/SERVICES/HIF/sdio/linux/if_ath_sdio.c	2015-09-24 15:25:20.593038328 +0800
@@ -77,7 +77,7 @@
     HIF_DEVICE_OS_DEVICE_INFO os_dev_info;
     struct sdio_func *func = NULL;
     const struct sdio_device_id *id;
-    u_int32_t target_type;
+    u_int32_t target_type = TARGET_TYPE_UNKNOWN;
     ENTER();
 
     sc = (struct ath_hif_sdio_softc *) A_MALLOC(sizeof(*sc));
diff -urN qcacld-new.orig/CORE/SERVICES/HIF/USB/hif_usb.c qcacld-new/CORE/SERVICES/HIF/USB/hif_usb.c
--- qcacld-new.orig/CORE/SERVICES/HIF/USB/hif_usb.c	2015-09-24 15:25:20.561038328 +0800
+++ qcacld-new/CORE/SERVICES/HIF/USB/hif_usb.c	2015-09-24 15:25:20.597038328 +0800
@@ -675,7 +675,7 @@
 		if (A_FAILED(status))
 			break;
 
-		if (NULL == pResponseMessage) {
+		if (NULL == pResponseMessage || NULL == pResponseLength) {
 			/* no expected response */
 			break;
 		}
@@ -891,23 +891,24 @@
 			pr_info("Pipe Type control\n");
 	}
 
-	for (i = 0; i < iface_desc->desc.bNumEndpoints; i++) {
-		ep_desc = &iface_desc->endpoint[i].desc;
-		if (ep_desc) {
-			pr_info(
-			     "ep_desc : %p Index : %d: DescType : %d Addr : %d Maxp : %d Atrrib : %d\n",
-			     ep_desc, i,
-			     ep_desc->bDescriptorType,
-			     ep_desc->bEndpointAddress, ep_desc->wMaxPacketSize,
-			     ep_desc->bmAttributes);
-			if ((ep_desc)
-			    && (usb_endpoint_type(ep_desc) ==
-				USB_ENDPOINT_XFER_ISOC)) {
-				pr_info("ISOC EP Detected\n");
+	if (iface_desc) {
+		for (i = 0; i < iface_desc->desc.bNumEndpoints; i++) {
+			ep_desc = &iface_desc->endpoint[i].desc;
+			if (ep_desc) {
+				pr_info(
+				"ep_desc : %p Index : %d: DescType : %d Addr : %d Maxp : %d Atrrib : %d\n",
+				ep_desc, i,
+				ep_desc->bDescriptorType,
+				ep_desc->bEndpointAddress, ep_desc->wMaxPacketSize,
+				ep_desc->bmAttributes);
+				if ((ep_desc)
+					&& (usb_endpoint_type(ep_desc) ==
+					USB_ENDPOINT_XFER_ISOC)) {
+						pr_info("ISOC EP Detected\n");
+				}
 			}
 		}
-	}
-
+        }
 }
 
 void HIFDump(HIF_DEVICE *hif_device, u_int8_t cmd_id, bool start)
diff -urN qcacld-new.orig/CORE/SERVICES/HIF/USB/if_usb.c qcacld-new/CORE/SERVICES/HIF/USB/if_usb.c
--- qcacld-new.orig/CORE/SERVICES/HIF/USB/if_usb.c	2015-09-24 15:25:20.557038328 +0800
+++ qcacld-new/CORE/SERVICES/HIF/USB/if_usb.c	2015-09-24 15:25:20.593038328 +0800
@@ -40,7 +40,7 @@
 #include "wlan_hdd_main.h"
 #include "epping_main.h"
 
-#ifdef WLAN_BTAMP_FEATURE
+#if defined(WLAN_BTAMP_FEATURE) || defined(CONFIG_USB_PRELOAD)
 #include "wlan_btc_svc.h"
 #include "wlan_nlink_common.h"
 #endif
@@ -200,7 +200,7 @@
 	}
 #endif
 
-#ifdef WLAN_BTAMP_FEATURE
+#if defined(WLAN_BTAMP_FEATURE) || defined(CONFIG_USB_PRELOAD)
 	/* Send WLAN UP indication to Nlink Service */
 	send_btc_nlink_msg(WLAN_MODULE_UP_IND, 0);
 #endif
@@ -385,11 +385,8 @@
 
 static int hif_usb_reset_resume(struct usb_interface *intf)
 {
-	HIF_DEVICE_USB *device = usb_get_intfdata(intf);
-	struct hif_usb_softc *sc = device->sc;
-
 	printk("Enter:%s,Line:%d \n\r", __func__,__LINE__);
-	HIFDiagWriteCOLDRESET(sc->hif_device);
+	hif_usb_resume(usb_sc->interface);
 	printk("Exit:%s,Line:%d \n\r", __func__,__LINE__);
 	return 0;
 }
@@ -474,10 +471,14 @@
 		probe_wait_cnt++;
 	}
 
+#if defined (CONFIG_USB_PRELOAD)
+	return status;
+#else
 	if (usb_sc && status == 0)
 		return 0;
 	else
 		return -1;
+#endif
 }
 
 void hif_unregister_driver(void)
diff -urN qcacld-new.orig/CORE/SERVICES/HTC/htc.c qcacld-new/CORE/SERVICES/HTC/htc.c
--- qcacld-new.orig/CORE/SERVICES/HTC/htc.c	2015-09-24 15:25:20.561038328 +0800
+++ qcacld-new/CORE/SERVICES/HTC/htc.c	2015-09-24 15:25:20.597038328 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013, 2014 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2013, 2014, 2015 The Linux Foundation. All rights reserved.
  *
  * Previously licensed under the ISC license by Qualcomm Atheros, Inc.
  *
@@ -143,7 +143,7 @@
 static void HTCCleanup(HTC_TARGET *target)
 {
     HTC_PACKET *pPacket;
-    //adf_nbuf_t netbuf;
+    adf_nbuf_t netbuf;
 
     if (target->hif_dev != NULL) {
         HIFDetachHTC(target->hif_dev);
@@ -161,6 +161,12 @@
     pPacket = target->pBundleFreeTxList;
     while (pPacket) {
         HTC_PACKET *pPacketTmp = (HTC_PACKET *)pPacket->ListLink.pNext;
+        if(pPacket->pContext != NULL) {
+           A_FREE(pPacket->pContext);
+        }
+        netbuf = GET_HTC_PACKET_NET_BUF_CONTEXT(pPacket);
+        if(netbuf != NULL)
+            adf_nbuf_free(netbuf);
         A_FREE(pPacket);
         pPacket = pPacketTmp;
     }
diff -urN qcacld-new.orig/CORE/SERVICES/WMA/regdomain_common.h qcacld-new/CORE/SERVICES/WMA/regdomain_common.h
--- qcacld-new.orig/CORE/SERVICES/WMA/regdomain_common.h	2015-09-24 15:25:20.561038328 +0800
+++ qcacld-new/CORE/SERVICES/WMA/regdomain_common.h	2015-09-24 15:25:20.597038328 +0800
@@ -99,6 +99,9 @@
     FCC4_FCCA   = 0x12,     /* USA - Public Safety */
     FCC5_FCCA   = 0x13,     /* US with no DFS (UNII-1 + UNII-3 Only)*/
     FCC6_FCCA   = 0x14,     /* Canada for AP only*/
+#ifdef SS_REGULATORY
+    FCC5_WORLD  = 0x15,
+#endif /* SS_REGULATORY */
 
     FCC2_FCCA   = 0x20,     /* Canada */
     FCC2_WORLD  = 0x21,     /* Australia & HK */
@@ -215,6 +218,9 @@
     MKK12_MKKA2 = 0xDD,     /* Japan UNI-1 even + UNI-1 odd + UNI-2 + mid-band + 4.9GHz + MKKA2 */
 
     MKK13_MKKB  = 0xDE,     /* Japan UNI-1 even + UNI-1 odd + UNI-2 + mid-band + MKKB + All passive + no adhoc */
+#ifdef SS_REGULATORY
+    MKK5_MKKA	= 0XDF,
+#endif /* SS_REGULATORY */
 
     /* Following definitions are used only by s/w to map old
      * Japan SKUs.
@@ -344,6 +350,9 @@
 	{FCC3_ETSIC,    FCC3,		ETSIC,		NO_REQ, NO_REQ, PSCAN_DEFER, 0 },
 	{FCC4_FCCA,     FCC4,		FCCA,		DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB, NO_REQ, PSCAN_DEFER, 0 },
 	{FCC5_FCCA,     FCC5,		FCCA,		NO_REQ, NO_REQ, PSCAN_DEFER, 0 },
+#ifdef SS_REGULATORY
+	{FCC5_WORLD,    FCC5,		WORLD,		NO_REQ, NO_REQ, PSCAN_DEFER, 0 },
+#endif /* SS_REGULATORY */
 	{FCC6_FCCA,     FCC6,		FCCA,		NO_REQ, NO_REQ, PSCAN_DEFER, 0 },
 	{FCC6_WORLD,    FCC6,		WORLD,		NO_REQ, NO_REQ, PSCAN_DEFER, 0 },
 
@@ -404,7 +413,9 @@
 	{MKK4_FCCA,     MKK4,           FCCA,           DISALLOW_ADHOC_11A_TURB | NEED_NFC | LIMIT_FRAME_4MS, NEED_NFC, PSCAN_MKK3, CTRY_JAPAN29 },
 
 	/* MKK5 */
-/*	{MKK5_MKKA,     MKK5,           MKKA,           DISALLOW_ADHOC_11A_TURB | NEED_NFC | LIMIT_FRAME_4MS, NEED_NFC, PSCAN_MKK3, CTRY_JAPAN56 },*/
+#ifdef SS_REGULATORY
+	{MKK5_MKKA, MKK5,       MKKA,       DISALLOW_ADHOC_11A_TURB | NEED_NFC | LIMIT_FRAME_4MS, NEED_NFC, PSCAN_MKK3, CTRY_JAPAN56 },
+#endif /* SS_REGULATORY */
 	{MKK5_MKKB,	MKK5,		MKKA,		DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB | NEED_NFC | LIMIT_FRAME_4MS, NEED_NFC, PSCAN_MKK3 | PSCAN_MKKA | PSCAN_MKKA_G, CTRY_JAPAN13 },
 	{MKK5_MKKA2,MKK5,		MKKA,		DISALLOW_ADHOC_11A_TURB | NEED_NFC | LIMIT_FRAME_4MS, NEED_NFC, PSCAN_MKK3 | PSCAN_MKKA2 | PSCAN_MKKA2_G, CTRY_JAPAN14 },
 	{MKK5_MKKC,	MKK5,		MKKC,		DISALLOW_ADHOC_11A_TURB | NEED_NFC | LIMIT_FRAME_4MS, NEED_NFC, PSCAN_MKK3, CTRY_JAPAN15 },
@@ -668,7 +679,44 @@
     {CTRY_VENEZUELA,   FCC1_WORLD,    "VE", "VENEZUELA",      YES,  NO, YES, YES, YES, YES, YES, YES, 7000 },
     {CTRY_VIET_NAM,    ETSI3_WORLD,   "VN", "VIET NAM",       YES,  NO, YES, YES, YES, YES, YES, YES, 7000 },
     {CTRY_YEMEN,       NULL1_WORLD,   "YE", "YEMEN",          YES,  NO, YES, YES, YES,  NO,  NO, NO, 7000 },
-    {CTRY_ZIMBABWE,    NULL1_WORLD,   "ZW", "ZIMBABWE",       YES,  NO, YES, YES, YES,  NO,  NO, NO, 7000 }
+    {CTRY_ZIMBABWE,    NULL1_WORLD,   "ZW", "ZIMBABWE",       YES,  NO, YES, YES, YES,  NO,  NO, NO, 7000 },
+
+#ifdef SS_REGULATORY
+	/*11g, ATu,	GTu, G20, G40, A20, A40, A80*/
+	{CTRY_QM,	NULL1_ETSIB,	"QM", "SS A",       	  YES,  NO, YES, YES,  NO,  NO,  NO,  NO, 7000 },//NO 5G
+	{CTRY_QN,	FCC3_WORLD,		"QN", "SS B",       	  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_QO,	ETSI8_WORLD,	"QO", "SS C", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_QP,	APL10_WORLD,	"QP", "SS D", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_QQ,	ETSI1_WORLD,	"QQ", "SS E", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_QR,	FCC1_WORLD,		"QR", "SS F", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_QS,	FCC2_ETSIC,		"QS", "SS G", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_QT,	ETSI3_WORLD,	"QT", "SS H", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_QU,	ETSI5_WORLD,	"QU", "SS I", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_QV,	APL4_WORLD,		"QV", "SS J", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_QW,	APL5_WORLD,		"QW", "SS K", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_QX,	FCC4_FCCA,		"QX", "SS L", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_QY,	FCC6_WORLD,		"QY", "SS M", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_QZ,	APL2_WORLD,		"QZ", "SS N", 		  YES, YES, YES, YES, YES, YES, YES,  NO, 7000 },//NO AC80
+	{CTRY_XA,	APL9_WORLD,		"XA", "SS O", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XB,	APL8_WORLD,		"XB", "SS P", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XC,	ETSI9_WORLD,	"XC", "SS Q", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XD,	FCC5_WORLD,		"XD", "SS R", 		  YES, YES, YES, YES, YES, YES, YES,  NO, 7000 },//NO AC80
+	{CTRY_XE,	APL6_WORLD,		"XE", "SS S", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XF,	MKK5_MKKA,		"XF", "SS T", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XG,	MKK11_FCCA,		"XG", "SS U", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XH,	APL1_WORLD,		"XH", "SS V", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XI,	APL3_WORLD,		"XI", "SS W", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XJ,	FCC6_FCCA,		"XJ", "SS X", 		   NO, YES,  NO,  NO,  NO, YES, YES,  NO, 7000 },//No 2G, NO AC80
+	{CTRY_XK,	APL7_FCCA,		"XK", "SS Y", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XL,	ETSI2_WORLD,	"XL", "SS Z", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XM,	ETSI6_WORLD,	"XM", "SS AA", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XN,	ETSI4_WORLD,	"XN", "SS AB", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XO,	WOR3_WORLD,		"XO", "SS AC", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XP,	WOR01_WORLD,	"XP", "SS AD", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XQ,	WOR02_WORLD,	"XQ", "SS AE", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XR,	WOR4_WORLD,		"XR", "SS AF", 		  YES, YES, YES, YES, YES, YES, YES,  NO, 7000 },//NO AC80
+#endif /* SS_REGULATORY */
+
 };
 
 
diff -urN qcacld-new.orig/CORE/SERVICES/WMA/regdomain.h qcacld-new/CORE/SERVICES/WMA/regdomain.h
--- qcacld-new.orig/CORE/SERVICES/WMA/regdomain.h	2015-09-24 15:25:20.565038328 +0800
+++ qcacld-new/CORE/SERVICES/WMA/regdomain.h	2015-09-24 15:25:20.601038328 +0800
@@ -1087,7 +1087,41 @@
 
     CTRY_AUSTRALIA2           = 5000,    /* Australia for AP only */
     CTRY_CANADA2              = 5001,    /* Canada for AP only */
-    CTRY_BELGIUM2             = 5002     /* Belgium/Cisco implementation */
+    CTRY_BELGIUM2             = 5002,    /* Belgium/Cisco implementation */
+#ifdef SS_REGULATORY
+    CTRY_QM             	  = 5003,   /* customer_1_spec */
+    CTRY_QN             	  = 5004,   /* customer_1_spec */
+    CTRY_QO             	  = 5005,   /* customer_1_spec */
+    CTRY_QP             	  = 5006,   /* customer_1_spec */
+    CTRY_QQ             	  = 5007,   /* customer_1_spec */
+    CTRY_QR             	  = 5008,   /* customer_1_spec */
+    CTRY_QS             	  = 5009,   /* customer_1_spec */
+    CTRY_QT             	  = 5010,   /* customer_1_spec */
+    CTRY_QU             	  = 5011,   /* customer_1_spec */
+    CTRY_QV             	  = 5012,   /* customer_1_spec */
+    CTRY_QW             	  = 5013,   /* customer_1_spec */
+    CTRY_QX             	  = 5014,   /* customer_1_spec */
+    CTRY_QY             	  = 5015,   /* customer_1_spec */
+    CTRY_QZ             	  = 5016,   /* customer_1_spec */
+    CTRY_XA             	  = 5017,   /* customer_1_spec */
+    CTRY_XB             	  = 5018,   /* customer_1_spec */
+    CTRY_XC             	  = 5019,  	/* customer_1_spec */
+    CTRY_XD            	  	  = 5020,	/* customer_1_spec */
+    CTRY_XE             	  = 5021, 	/* customer_1_spec */
+    CTRY_XF             	  = 5022, 	/* customer_1_spec */
+    CTRY_XG             	  = 5023, 	/* customer_1_spec */
+    CTRY_XH             	  = 5024, 	/* customer_1_spec */
+    CTRY_XI             	  = 5025, 	/* customer_1_spec */
+    CTRY_XJ             	  = 5026,	/* customer_1_spec */
+    CTRY_XK             	  = 5027, 	/* customer_1_spec */
+    CTRY_XL             	  = 5028, 	/* customer_1_spec */
+    CTRY_XM             	  = 5029, 	/* customer_1_spec */
+    CTRY_XN             	  = 5030, 	/* customer_1_spec */
+    CTRY_XO             	  = 5031, 	/* customer_1_spec */
+    CTRY_XP             	  = 5032, 	/* customer_1_spec */
+    CTRY_XQ             	  = 5033, 	/* customer_1_spec */
+    CTRY_XR             	  = 5034, 	/* customer_1_spec */
+#endif /* SS_REGULATORY */
 };
 int32_t regdmn_get_country_alpha2(struct regulatory *reg);
 void regdmn_set_regval(struct regulatory *reg);
diff -urN qcacld-new.orig/CORE/SERVICES/WMA/wlan_nv.c qcacld-new/CORE/SERVICES/WMA/wlan_nv.c
--- qcacld-new.orig/CORE/SERVICES/WMA/wlan_nv.c	2015-09-24 15:25:20.561038328 +0800
+++ qcacld-new/CORE/SERVICES/WMA/wlan_nv.c	2015-09-24 15:25:20.597038328 +0800
@@ -147,74 +147,74 @@
                 {1500},    // HAL_PHY_RATE_11AC_DUP_54_MBPS,
 
                //11ac 20MHZ NG, SG
-                {0000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_6_5_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_13_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_19_5_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_26_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_39_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_52_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_58_5_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_65_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_78_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_6_5_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_13_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_19_5_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_26_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_39_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_52_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_58_5_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_65_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_78_MBPS,
 #ifdef WCN_PRONTO
-                {0000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_NGI_86_5_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_NGI_86_5_MBPS,
 #endif
-                {0000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_SGI_7_2_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_SGI_14_4_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_SGI_21_6_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_SGI_28_8_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_SGI_43_3_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_SGI_57_7_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_SGI_65_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_SGI_72_2_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_SGI_86_6_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_SGI_7_2_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_SGI_14_4_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_SGI_21_6_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_SGI_28_8_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_SGI_43_3_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_SGI_57_7_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_SGI_65_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_SGI_72_2_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_SGI_86_6_MBPS,
 #ifdef WCN_PRONTO
-                {0000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_SGI_96_1_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_SGI_96_1_MBPS,
 #endif
 
                //11ac 40MHZ NG, SG
-                {0000},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_NGI_13_5_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_NGI_27_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_NGI_40_5_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_NGI_54_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_NGI_81_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_NGI_108_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_NGI_121_5_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_NGI_135_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_NGI_162_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_NGI_180_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_SGI_15_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_SGI_30_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_SGI_45_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_SGI_60_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_SGI_90_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_SGI_120_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_SGI_135_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_SGI_150_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_SGI_180_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_SGI_200_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_NGI_13_5_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_NGI_27_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_NGI_40_5_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_NGI_54_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_NGI_81_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_NGI_108_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_NGI_121_5_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_NGI_135_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_NGI_162_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_NGI_180_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_SGI_15_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_SGI_30_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_SGI_45_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_SGI_60_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_SGI_90_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_SGI_120_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_SGI_135_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_SGI_150_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_SGI_180_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_SGI_200_MBPS,
 
                //11ac 80MHZ NG, SG
-                {0000},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_NGI_29_3_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_NGI_58_5_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_NGI_87_8_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_NGI_117_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_NGI_175_5_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_NGI_234_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_NGI_263_3_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_NGI_292_5_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_NGI_351_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_NGI_390_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_SGI_32_5_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_SGI_65_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_SGI_97_5_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_SGI_130_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_SGI_195_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_SGI_260_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_SGI_292_5_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_SGI_325_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_SGI_390_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_SGI_433_3_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_NGI_29_3_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_NGI_58_5_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_NGI_87_8_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_NGI_117_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_NGI_175_5_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_NGI_234_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_NGI_263_3_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_NGI_292_5_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_NGI_351_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_NGI_390_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_SGI_32_5_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_SGI_65_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_SGI_97_5_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_SGI_130_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_SGI_195_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_SGI_260_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_SGI_292_5_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_SGI_325_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_SGI_390_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_SGI_433_3_MBPS,
 #endif
             },  //    RF_SUBBAND_2_4_GHZ
             // 5G Low
@@ -284,7 +284,7 @@
                 {1300},    // HAL_PHY_RATE_MCS_1NSS_MM_SG_CB_135_MBPS,
                 {1200},    // HAL_PHY_RATE_MCS_1NSS_MM_SG_CB_150_MBPS,
 
-#ifdef WLAN_FEATUURE_11AC
+#ifdef WLAN_FEATURE_11AC
                 ///11AC rates
                ///11A duplicate 80MHz Rates
                 {1700},    // HAL_PHY_RATE_11AC_DUP_6_MBPS,
@@ -304,7 +304,7 @@
                 {1250},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_39_MBPS,
                 {1200},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_52_MBPS,
                 {1100},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_58_5_MBPS,
-                {1000,    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_65_MBPS,
+                {1000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_65_MBPS,
                 { 900},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_78_MBPS,
 #ifdef WCN_PRONTO
                 { 800},     // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_NGI_86_5_MBPS,
@@ -434,7 +434,7 @@
                 {1300},    // HAL_PHY_RATE_MCS_1NSS_MM_SG_CB_135_MBPS,
                 {1200},    // HAL_PHY_RATE_MCS_1NSS_MM_SG_CB_150_MBPS,
 
-#ifdef WLAN_FEATUURE_111AC
+#ifdef WLAN_FEATURE_11AC
                 ///11CAC rates
                ///11Ad duplicate 80MHz Rates
                 {1700},    // HAL_PHY_RATE_11AC_DUP_6_MBPS,
@@ -584,7 +584,7 @@
                 {1300},    // HAL_PHY_RATE_MCS_1NSS_MM_SG_CB_135_MBPS,
                 {1200},    // HAL_PHY_RATE_MCS_1NSS_MM_SG_CB_150_MBPS,
 
-#ifdef WLAN_FEATUURE_11AC
+#ifdef WLAN_FEATURE_11AC
                 ///11CAC rates
                ///11Ad duplicate 80MHz Rates
                 {1700},    // HAL_PHY_RATE_11AC_DUP_6_MBPS,
@@ -735,7 +735,7 @@
                 {1300},    // HAL_PHY_RATE_MCS_1NSS_MM_SG_CB_135_MBPS,
                 {1200},    // HAL_PHY_RATE_MCS_1NSS_MM_SG_CB_150_MBPS,
 
-#ifdef WLAN_FEATUURE_11AC
+#ifdef WLAN_FEATURE_11AC
                 ///11CAC rates
                ///11Ad duplicate 80MHz Rates
                 {1700},    // HAL_PHY_RATE_11AC_DUP_6_MBPS,
@@ -745,7 +745,7 @@
                 {1600},    // HAL_PHY_RATE_11AC_DUP_24_MBPS,
                 {1550},    // HAL_PHY_RATE_11AC_DUP_36_MBPS,
                 {1550},    // HAL_PHY_RATE_11AC_DUP_48_MBPS,
-                {1500,,    // HAL_PHY_RATE_11AC_DUP_54_MBPS,
+                {1500},    // HAL_PHY_RATE_11AC_DUP_54_MBPS,
 
                ///11a c 20MHZ NG, SG
                 {1400},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_6_5_MBPS,
diff -urN qcacld-new.orig/CORE/SERVICES/WMA/wma.c qcacld-new/CORE/SERVICES/WMA/wma.c
--- qcacld-new.orig/CORE/SERVICES/WMA/wma.c	2015-09-24 15:25:20.565038328 +0800
+++ qcacld-new/CORE/SERVICES/WMA/wma.c	2015-09-24 15:25:20.601038328 +0800
@@ -1470,6 +1470,217 @@
 	return status;
 }
 
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+static void wma_send_status_of_ext_wow(tp_wma_handle wma, boolean status)
+{
+	tSirReadyToExtWoWInd *ready_to_extwow;
+	VOS_STATUS vstatus;
+	vos_msg_t vos_msg;
+	u_int8_t len;
+
+	WMA_LOGD("Posting ready to suspend indication to umac");
+
+	len = sizeof(tSirReadyToExtWoWInd);
+	ready_to_extwow = (tSirReadyToExtWoWInd *) vos_mem_malloc(len);
+
+	if (NULL == ready_to_extwow) {
+		WMA_LOGE("%s: Memory allocation failure", __func__);
+		return;
+	}
+
+	ready_to_extwow->mesgType = eWNI_SME_READY_TO_EXTWOW_IND;
+	ready_to_extwow->mesgLen = len;
+	ready_to_extwow->status= status;
+
+	vos_msg.type = eWNI_SME_READY_TO_EXTWOW_IND;
+	vos_msg.bodyptr = (void *) ready_to_extwow;
+	vos_msg.bodyval = 0;
+
+	vstatus = vos_mq_post_message(VOS_MQ_ID_SME, &vos_msg);
+	if (vstatus != VOS_STATUS_SUCCESS) {
+		WMA_LOGE("Failed to post ready to suspend");
+		vos_mem_free(ready_to_extwow);
+	}
+}
+
+static int wma_enable_ext_wow(tp_wma_handle wma,
+			 tpSirExtWoWParams params)
+{
+	wmi_extwow_enable_cmd_fixed_param *cmd;
+	wmi_buf_t buf;
+	int32_t len;
+	int ret;
+
+	len = sizeof(wmi_extwow_enable_cmd_fixed_param);
+	buf = wmi_buf_alloc(wma->wmi_handle, len);
+	if (!buf) {
+		WMA_LOGE("%s: Failed allocate wmi buffer", __func__);
+		return VOS_STATUS_E_NOMEM;
+	}
+
+	cmd = (wmi_extwow_enable_cmd_fixed_param *) wmi_buf_data(buf);
+
+	WMITLV_SET_HDR(&cmd->tlv_header,
+		       WMITLV_TAG_STRUC_wmi_extwow_enable_cmd_fixed_param,
+		       WMITLV_GET_STRUCT_TLVLEN(
+				wmi_extwow_enable_cmd_fixed_param));
+
+	cmd->vdev_id = params->vdev_id;
+	cmd->type = params->type;
+	cmd->wakeup_pin_num = params->wakeup_pin_num;
+
+	WMA_LOGD("%s: vdev_id %d type %d Wakeup_pin_num %x",
+		 __func__, cmd->vdev_id,
+		 cmd->type, cmd->wakeup_pin_num);
+
+	ret = wmi_unified_cmd_send(wma->wmi_handle, buf, len,
+				   WMI_EXTWOW_ENABLE_CMDID);
+	if (ret) {
+		WMA_LOGE("%s: Failed to set EXTWOW Enable", __func__);
+		wmi_buf_free(buf);
+		wma_send_status_of_ext_wow(wma, FALSE);
+		return VOS_STATUS_E_FAILURE;
+	}
+
+	wma_send_status_of_ext_wow(wma, TRUE);
+	return VOS_STATUS_SUCCESS;
+
+}
+
+static int wma_set_app_type1_params_in_fw(tp_wma_handle wma,
+			 tpSirAppType1Params appType1Params)
+{
+	wmi_extwow_set_app_type1_params_cmd_fixed_param *cmd;
+	wmi_buf_t buf;
+	int32_t len;
+	int ret;
+
+	len = sizeof(wmi_extwow_set_app_type1_params_cmd_fixed_param);
+	buf = wmi_buf_alloc(wma->wmi_handle, len);
+	if (!buf) {
+		WMA_LOGE("%s: Failed allocate wmi buffer", __func__);
+		return VOS_STATUS_E_NOMEM;
+	}
+
+	cmd = (wmi_extwow_set_app_type1_params_cmd_fixed_param *)
+						    wmi_buf_data(buf);
+
+	WMITLV_SET_HDR(&cmd->tlv_header,
+	    WMITLV_TAG_STRUC_wmi_extwow_set_app_type1_params_cmd_fixed_param,
+	    WMITLV_GET_STRUCT_TLVLEN(
+			wmi_extwow_set_app_type1_params_cmd_fixed_param));
+
+	cmd->vdev_id = appType1Params->vdev_id;
+	vos_mem_copy(cmd->ident, appType1Params->identification_id, 8);
+	cmd->ident_len = appType1Params->id_length;
+	vos_mem_copy(cmd->passwd, appType1Params->password, 16);
+	cmd->passwd_len = appType1Params->pass_length;
+
+	WMA_LOGD("%s: vdev_id %d "
+			 "identification_id %.8s id_length %u "
+			 "password %.16s pass_length %u",
+		__func__, cmd->vdev_id, cmd->ident, cmd->ident_len,
+		cmd->passwd, cmd->passwd_len);
+
+	ret = wmi_unified_cmd_send(wma->wmi_handle, buf, len,
+				   WMI_EXTWOW_SET_APP_TYPE1_PARAMS_CMDID);
+	if (ret) {
+		WMA_LOGE("%s: Failed to set APP TYPE1 PARAMS", __func__);
+		wmi_buf_free(buf);
+		return VOS_STATUS_E_FAILURE;
+	}
+
+	return VOS_STATUS_SUCCESS;
+}
+
+#ifdef WLAN_FEATURE_EXTWOW_OUTDOOR_SUPPORT
+static int wma_set_app_type2_params_in_fw(tp_wma_handle wma,
+			 tpSirAppType2Params appType2Params)
+{
+	wmi_extwow_set_app_type2_params_cmd_fixed_param *cmd;
+	wmi_buf_t buf;
+	int32_t len;
+	int ret;
+
+	len = sizeof(wmi_extwow_set_app_type2_params_cmd_fixed_param);
+	buf = wmi_buf_alloc(wma->wmi_handle, len);
+	if (!buf) {
+		WMA_LOGE("%s: Failed allocate wmi buffer", __func__);
+		return VOS_STATUS_E_NOMEM;
+	}
+
+	cmd = (wmi_extwow_set_app_type2_params_cmd_fixed_param *)
+						    wmi_buf_data(buf);
+
+	WMITLV_SET_HDR(&cmd->tlv_header,
+             WMITLV_TAG_STRUC_wmi_extwow_set_app_type2_params_cmd_fixed_param,
+             WMITLV_GET_STRUCT_TLVLEN(
+			wmi_extwow_set_app_type2_params_cmd_fixed_param));
+
+	cmd->vdev_id = appType2Params->vdev_id;
+
+	vos_mem_copy(cmd->rc4_write_sandbox, appType2Params->rc4_write_sandbox, 256);
+	vos_mem_copy(cmd->rc4_read_sandbox, appType2Params->rc4_read_sandbox, 256);
+	vos_mem_copy(cmd->ssl_write_seq, appType2Params->ssl_write_seq, 8);
+	vos_mem_copy(cmd->ssl_read_seq, appType2Params->ssl_read_seq, 8);
+	vos_mem_copy(cmd->ssl_sha1_write_key, appType2Params->ssl_sha1_write_key, 64);
+	vos_mem_copy(cmd->ssl_sha1_read_key, appType2Params->ssl_sha1_read_key, 64);
+	cmd->rc4_write_x = appType2Params->rc4_write_x;
+	cmd->rc4_write_y = appType2Params->rc4_write_y;
+	cmd->rc4_read_x = appType2Params->rc4_read_x;
+	cmd->rc4_read_y = appType2Params->rc4_read_y;
+	cmd->ssl_sha1_write_key_len = appType2Params->ssl_sha1_write_key_len;
+	cmd->ssl_sha1_read_key_len = appType2Params->ssl_sha1_read_key_len;
+	cmd->tcp_options_len =  appType2Params->tcp_options_len;
+	vos_mem_copy(cmd->tcp_options, appType2Params->tcp_options, sizeof(cmd->tcp_options));
+	cmd->asyncId = appType2Params->asyncId;
+
+	cmd->ip_id = appType2Params->ip_id;
+	cmd->ip_device_ip = appType2Params->ip_device_ip;
+	cmd->ip_server_ip = appType2Params->ip_server_ip;
+
+	cmd->tcp_src_port = appType2Params->tcp_src_port;
+	cmd->tcp_dst_port = appType2Params->tcp_dst_port;
+	cmd->tcp_seq = appType2Params->tcp_seq;
+	cmd->tcp_ack_seq = appType2Params->tcp_ack_seq;
+
+	cmd->keepalive_init = appType2Params->keepalive_init;
+	cmd->keepalive_min = appType2Params->keepalive_min;
+	cmd->keepalive_max = appType2Params->keepalive_max;
+	cmd->keepalive_inc = appType2Params->keepalive_inc;
+
+	WMI_CHAR_ARRAY_TO_MAC_ADDR(appType2Params->gateway_mac,
+						&cmd->gateway_mac);
+	cmd->tcp_tx_timeout_val = appType2Params->tcp_tx_timeout_val;
+	cmd->tcp_rx_timeout_val = appType2Params->tcp_rx_timeout_val;
+
+	WMA_LOGD("%s: vdev_id %d gateway_mac %pM "
+			 "ip_id %x ip_device_ip %x ip_server_ip %x "
+			 "tcp_src_port %u tcp_dst_port %u tcp_seq %u "
+			 "tcp_ack_seq %u tcp_options_len %u keepalive_init %u keepalive_min %u "
+			 "keepalive_max %u keepalive_inc %u "
+			 "tcp_tx_timeout_val %u tcp_rx_timeout_val %u",
+		__func__, cmd->vdev_id, appType2Params->gateway_mac,
+		cmd->ip_id, cmd->ip_device_ip, cmd->ip_server_ip,
+		cmd->tcp_src_port, cmd->tcp_dst_port, cmd->tcp_seq,
+		cmd->tcp_ack_seq, cmd->tcp_options_len, cmd->keepalive_init, cmd->keepalive_min,
+		cmd->keepalive_max, cmd->keepalive_inc,
+		cmd->tcp_tx_timeout_val, cmd->tcp_rx_timeout_val);
+
+
+	ret = wmi_unified_cmd_send(wma->wmi_handle, buf, len,
+				   WMI_EXTWOW_SET_APP_TYPE2_PARAMS_CMDID);
+	if (ret) {
+		WMA_LOGE("%s: Failed to set APP TYPE2 PARAMS", __func__);
+		wmi_buf_free(buf);
+		return VOS_STATUS_E_FAILURE;
+	}
+
+	return VOS_STATUS_SUCCESS;
+
+}
+#endif
+#endif
 static void wma_update_pdev_stats(tp_wma_handle wma,
 					wmi_pdev_stats *pdev_stats)
 {
@@ -3476,6 +3687,7 @@
 	 tdls_event->messageType = WDA_TDLS_PEER_DISCONNECTED;
 	 break;
 	default:
+	 vos_mem_free(tdls_event);
 	 WMA_LOGE("%s: Discarding unknown tdls event(%d) from target",
 	          __func__, peer_event->peer_status);
 	 return -1;
@@ -3720,7 +3932,6 @@
 	int empty;
 	int do_check_chirp = 0;
 	int is_hw_chirp = 0;
-	int is_sw_chirp = 0;
 	int is_pri = 0;
 
 	WMI_DFS_RADAR_EVENTID_param_tlvs *param_tlvs;
@@ -3824,9 +4035,6 @@
 		if (is_hw_chirp) {
 			event->re_flags |= DFS_EVENT_HW_CHIRP;
 		}
-		if (is_sw_chirp) {
-			event->re_flags |= DFS_EVENT_SW_CHIRP;
-		}
 	}
 	/*
 	 * Correctly set which channel is being reported on
@@ -5789,7 +5997,7 @@
 	return vos_status;
 
 fail:
-	if(cfg_bin != NULL)
+	if (file_img)
 		vos_mem_free( file_img );
 
 	WMA_LOGD("%s: Exit", __func__);
@@ -9381,12 +9589,20 @@
 {
     wmi_vdev_txbf_en txbf_en;
 
+    vos_mem_zero(&txbf_en, sizeof(wmi_vdev_txbf_en));
+
     /* This is set when Other partner is Bformer
 	and we are capable bformee(enabled both in ini and fw) */
 	txbf_en.sutxbfee = params->vhtTxBFCapable;
 	txbf_en.mutxbfee = params->vhtTxMUBformeeCapable;
 	txbf_en.sutxbfer = 0;
 	txbf_en.mutxbfer = 0;
+#if defined(AR900B)
+	txbf_en.txb_sts_cap = 0;
+	txbf_en.implicit_bf = 0;
+#else
+	txbf_en.reserved = 0;
+#endif
 
 	/* When MU TxBfee is set, SU TxBfee must be set by default */
 	if (txbf_en.mutxbfee)
@@ -10428,6 +10644,14 @@
 				WMA_LOGE("dbglog_report_enable"
 						" failed ret %d", ret);
 			break;
+#ifdef CONFIG_WLAN_FWLOG_FILE
+		case WMI_DBGLOG_FWLOG_FILE_ENABLE:
+                        ret = dbglog_fwlog_file_enable(wma->wmi_handle, privcmd->param_value);
+			if (ret)
+				WMA_LOGE("dbglog_fwlog_file_enable"
+						" failed ret %d", ret);
+			break;
+#endif
 #ifdef FEATURE_GREEN_AP
 		case WMI_PDEV_GREEN_AP_PS_ENABLE_CMDID:
 			/* Set the Green AP */
@@ -11816,8 +12040,7 @@
 send_bss_resp:
 		ol_txrx_find_peer_by_addr(pdev, add_bss->bssId,
 					  &add_bss->staContext.staIdx);
-		add_bss->status = (add_bss->staContext.staIdx < 0) ?
-				VOS_STATUS_E_FAILURE : VOS_STATUS_SUCCESS;
+		add_bss->status = VOS_STATUS_SUCCESS;
 		add_bss->bssIdx = add_bss->staContext.smesessionId;
 		vos_mem_copy(add_bss->staContext.staMac, add_bss->bssId,
 				 sizeof(add_bss->staContext.staMac));
@@ -12343,7 +12566,7 @@
 	if (0 == add_sta->updateSta) {
 	 /* its a add sta request **/
 #if defined(CONFIG_HL_SUPPORT)
-         if (add_sta->bssId && vdev->last_real_peer &&
+         if (vdev->last_real_peer &&
             (adf_os_mem_cmp((u8 *)add_sta->bssId,
                              vdev->last_real_peer->mac_addr.raw,
                              IEEE80211_ADDR_LEN) == 0)) {
@@ -13227,7 +13450,7 @@
 send_del_rsp:
 	if (del_sta->respReqd) {
 		WMA_LOGD("%s: Sending del rsp to umac (status: %d)",
-			__func__, del_sta->status);
+					__func__, del_sta->status);
 		wma_send_msg(wma, WDA_DELETE_STA_RSP, (void *)del_sta, 0);
 	}
 }
@@ -13289,9 +13512,11 @@
 	del_sta->status = VOS_STATUS_SUCCESS;
 
 send_del_rsp:
-	WMA_LOGD("%s: Sending del rsp to umac (status: %d)",
-	         __func__, del_sta->status);
-	wma_send_msg(wma, WDA_DELETE_STA_RSP, (void *)del_sta, 0);
+	if (del_sta->respReqd) {
+		WMA_LOGD("%s: Sending del rsp to umac (status: %d)",
+					__func__, del_sta->status);
+		wma_send_msg(wma, WDA_DELETE_STA_RSP, (void *)del_sta, 0);
+	}
 }
 #endif
 
@@ -13321,15 +13546,20 @@
 send_del_sta_rsp:
 #endif
 	params->status = status;
-	WMA_LOGD("%s: vdev_id %d status %d", __func__, params->smesessionId, status);
-	wma_send_msg(wma, WDA_DELETE_STA_RSP, (void *)params, 0);
+	if (params->respReqd) {
+		WMA_LOGD("%s: vdev_id %d status %d", __func__,
+				params->smesessionId, status);
+		wma_send_msg(wma, WDA_DELETE_STA_RSP, (void *)params, 0);
+	}
 }
 
 static void wma_delete_sta(tp_wma_handle wma, tpDeleteStaParams del_sta)
 {
 	tANI_U8 oper_mode = BSS_OPERATIONAL_MODE_STA;
+	u_int8_t smesession_id = del_sta->smesessionId;
+	bool rsp_requested = del_sta->respReqd;
 
-	if (wma_is_vdev_in_ap_mode(wma, del_sta->smesessionId)) {
+	if (wma_is_vdev_in_ap_mode(wma, smesession_id)) {
 #ifdef FEATURE_WLAN_D0WOW
 		wma_del_pm_vote(wma);
 #else
@@ -13338,7 +13568,7 @@
 		oper_mode = BSS_OPERATIONAL_MODE_AP;
 	}
 #ifdef QCA_IBSS_SUPPORT
-	if (wma_is_vdev_in_ibss_mode(wma, del_sta->smesessionId)) {
+	if (wma_is_vdev_in_ibss_mode(wma, smesession_id)) {
 		oper_mode = BSS_OPERATIONAL_MODE_IBSS;
 		WMA_LOGD("%s: to delete sta for IBSS mode", __func__);
         }
@@ -13359,12 +13589,19 @@
 
 #ifndef CONFIG_QCA_WIFI_ISOC
 #ifdef QCA_IBSS_SUPPORT
-        /* adjust heart beat thresold timer value for detecting ibss peer departure */
+	/* adjust heart beat thresold timer value for
+	 * detecting ibss peer departure
+	 */
         if (oper_mode == BSS_OPERATIONAL_MODE_IBSS)
-                wma_adjust_ibss_heart_beat_timer(wma, del_sta->smesessionId, -1);
+		wma_adjust_ibss_heart_beat_timer(wma, smesession_id, -1);
 #endif
 #endif
 
+	if (!rsp_requested) {
+		WMA_LOGD("%s: vdev_id %d status %d", __func__,
+			del_sta->smesessionId, del_sta->status);
+		vos_mem_free(del_sta);
+	}
 }
 
 static int32_t wmi_unified_vdev_stop_send(wmi_unified_t wmi, u_int8_t vdev_id)
@@ -14047,7 +14284,7 @@
 	if (VOS_STATUS_SUCCESS !=
 	vos_mq_post_message(VOS_MQ_ID_WDA, &vos_msg)) {
 		WMA_LOGP("%s: Failed to post WDA_TBTT_UPDATE_IND msg", __func__);
-		vos_mem_free(buf);
+		vos_mem_free(tempBuf);
 		return -1;
 	}
 	WMA_LOGD("WDA_TBTT_UPDATE_IND posted");
@@ -20051,7 +20288,7 @@
 	return VOS_STATUS_SUCCESS;
 }
 
-static int wma_get_hotlist_entries_per_page(void *cmd, int numap)
+static int wma_get_hotlist_entries_per_page(int cmd_len, int numap)
 {
 	uint32_t avail_space = 0;
 	int num_entries = 0;
@@ -20060,7 +20297,7 @@
 	 * be passed in  wma message request.
 	 */
 	avail_space = WMA_MAX_EXTSCAN_MSG_SIZE -
-				(sizeof(*cmd) - sizeof(WMI_TLV_HDR_SIZE));
+				(cmd_len - sizeof(WMI_TLV_HDR_SIZE));
 	num_entries = avail_space / sizeof(wmi_extscan_hotlist_entry);
 	return num_entries;
 }
@@ -20082,8 +20319,7 @@
 	int numap = photlist->numAp;
 	int len = sizeof(*cmd);
 
-	len += WMI_TLV_HDR_SIZE;
-	cmd_len = len;
+	cmd_len = len + WMI_TLV_HDR_SIZE;
 
 	/* setbssid hotlist expects the bssid list
 	 * to be non zero value
@@ -20094,7 +20330,7 @@
 		return VOS_STATUS_E_INVAL;
 	}
 	num_entries = wma_get_hotlist_entries_per_page(
-					cmd, numap);
+					len, numap);
 
 	/* Split the hot list entry pages and send multiple command
 	 * requests if the buffer reaches  the maximum request size
@@ -21359,6 +21595,25 @@
 					(tHalHiddenSsidVdevRestart *)msg->bodyptr);
 			vos_mem_free(msg->bodyptr);
 			break;
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+		case WDA_WLAN_EXT_WOW:
+			wma_enable_ext_wow(wma_handle,
+				(tSirExtWoWParams *)msg->bodyptr);
+			vos_mem_free(msg->bodyptr);
+			break;
+		case WDA_WLAN_SET_APP_TYPE1_PARAMS:
+			wma_set_app_type1_params_in_fw(wma_handle,
+				(tSirAppType1Params *)msg->bodyptr);
+			vos_mem_free(msg->bodyptr);
+			break;
+#ifdef WLAN_FEATURE_EXTWOW_OUTDOOR_SUPPORT
+		case WDA_WLAN_SET_APP_TYPE2_PARAMS:
+			wma_set_app_type2_params_in_fw(wma_handle,
+				(tSirAppType2Params *)msg->bodyptr);
+			vos_mem_free(msg->bodyptr);
+			break;
+#endif
+#endif
 		case WDA_VDEV_START_RSP_IND:
 			wma_vdev_start_rsp_ind(wma_handle, msg->bodyptr);
 			vos_mem_free(msg->bodyptr);
@@ -23419,19 +23674,15 @@
 		cfg->vht_max_mpdu = 0;
 
 	/* supported channel width */
-	if (wh->vht_cap_info & IEEE80211_VHTCAP_SUP_CHAN_WIDTH_80)
-		cfg->supp_chan_width = 1 << eHT_CHANNEL_WIDTH_80MHZ;
-
-	else if (wh->vht_cap_info & IEEE80211_VHTCAP_SUP_CHAN_WIDTH_160)
+	if (wh->vht_cap_info & IEEE80211_VHTCAP_SUP_CHAN_WIDTH_160)
 		cfg->supp_chan_width = 1 << eHT_CHANNEL_WIDTH_160MHZ;
 
 	else if (wh->vht_cap_info & IEEE80211_VHTCAP_SUP_CHAN_WIDTH_80_160) {
 		cfg->supp_chan_width = 1 << eHT_CHANNEL_WIDTH_80MHZ;
 		cfg->supp_chan_width |= 1 << eHT_CHANNEL_WIDTH_160MHZ;
 	}
-
 	else
-		cfg->supp_chan_width = 0;
+		cfg->supp_chan_width = 1 << eHT_CHANNEL_WIDTH_80MHZ;
 
 	/* LDPC capability */
 	cfg->vht_rx_ldpc = wh->vht_cap_info & IEEE80211_VHTCAP_RX_LDPC;
@@ -25746,17 +25997,6 @@
 	u_int32_t regdmn = wma->reg_cap.eeprom_rd;
 	u_int32_t regdmn5G;
 
-	if (regdmn < 0)
-	{
-		WMA_LOGE("%s:DFS-Invalid regdomain",__func__);
-		/*
-		 * Set the DFS reg domain to unintlialized domain
-		 * to indicate dfs regdomain configuration failure
-		 */
-		wma->dfs_ic->current_dfs_regdomain = DFS_UNINIT_DOMAIN;
-		return;
-	}
-
 	regdmn5G = get_regdmn_5g(regdmn);
 	ctl = regdmn_get_ctl_for_regdmn(regdmn5G);
 
diff -urN qcacld-new.orig/CORE/SME/inc/csrApi.h qcacld-new/CORE/SME/inc/csrApi.h
--- qcacld-new.orig/CORE/SME/inc/csrApi.h	2015-09-24 15:25:20.581038328 +0800
+++ qcacld-new/CORE/SME/inc/csrApi.h	2015-09-24 15:25:20.609038328 +0800
@@ -1762,6 +1762,11 @@
 eCsrBand csrGetCurrentBand (tHalHandle hHal);
 
 typedef void (*csrReadyToSuspendCallback)(void *pContext, boolean suspended);
+
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+typedef void (*csrReadyToExtWoWCallback)(void *pContext, boolean status);
+#endif
+
 #ifdef WLAN_FEATURE_ROAM_OFFLOAD
 eHalStatus csrRoamIssueFTRoamOffloadSynch(tHalHandle hHal, tANI_U32 sessionId,
                                           tSirBssDescription *pBssDescription);
diff -urN qcacld-new.orig/CORE/SME/inc/sme_Api.h qcacld-new/CORE/SME/inc/sme_Api.h
--- qcacld-new.orig/CORE/SME/inc/sme_Api.h	2015-09-24 15:25:20.581038328 +0800
+++ qcacld-new/CORE/SME/inc/sme_Api.h	2015-09-24 15:25:20.609038328 +0800
@@ -2191,6 +2191,72 @@
 eHalStatus sme_ConfigureResumeReq( tHalHandle hHal,
                              tpSirWlanResumeParam  wlanResumeParam);
 
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+/* ---------------------------------------------------------------------------
+
+  \fn    sme_ConfigureExtWoW
+
+  \brief
+    SME will pass this request to lower mac to configure Indoor WoW parameters.
+
+  \param
+
+    hHal - The handle returned by macOpen.
+
+    wlanExtParams- Depicts the wlan Ext params
+
+  \return eHalStatus
+
+
+--------------------------------------------------------------------------- */
+eHalStatus sme_ConfigureExtWoW( tHalHandle hHal,
+                          tpSirExtWoWParams  wlanExtParams,
+                          csrReadyToSuspendCallback callback,
+                          void *callbackContext);
+
+
+/* ---------------------------------------------------------------------------
+
+  \fn    sme_ConfigureAppType1Params
+
+  \brief
+    SME will pass this request to lower mac to configure Indoor WoW parameters.
+
+  \param
+
+    hHal - The handle returned by macOpen.
+
+    wlanAppType1Params- Depicts the wlan Indoor params
+
+  \return eHalStatus
+
+
+--------------------------------------------------------------------------- */
+eHalStatus sme_ConfigureAppType1Params( tHalHandle hHal,
+                          tpSirAppType1Params  wlanAppType1Params);
+
+#ifdef WLAN_FEATURE_EXTWOW_OUTDOOR_SUPPORT
+/* ---------------------------------------------------------------------------
+
+  \fn    sme_ConfigureAppType2Params
+
+  \brief
+    SME will pass this request to lower mac to configure Indoor WoW parameters.
+
+  \param
+
+    hHal - The handle returned by macOpen.
+
+    wlanAppType2Params- Depicts the wlan Indoor params
+
+  \return eHalStatus
+
+
+--------------------------------------------------------------------------- */
+eHalStatus sme_ConfigureAppType2Params( tHalHandle hHal,
+                          tpSirAppType2Params  wlanAppType2Params);
+#endif
+#endif
 
 /* ---------------------------------------------------------------------------
 
diff -urN qcacld-new.orig/CORE/SME/inc/sme_Trace.h qcacld-new/CORE/SME/inc/sme_Trace.h
--- qcacld-new.orig/CORE/SME/inc/sme_Trace.h	2015-09-24 15:25:20.581038328 +0800
+++ qcacld-new/CORE/SME/inc/sme_Trace.h	2015-09-24 15:25:20.609038328 +0800
@@ -112,6 +112,11 @@
     TRACE_CODE_SME_RX_HDD_CONFIG_RXPFIL,
     TRACE_CODE_SME_RX_HDD_CONFIG_SUSPENDIND,
     TRACE_CODE_SME_RX_HDD_CONFIG_RESUMEREQ,
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+    TRACE_CODE_SME_RX_HDD_CONFIG_EXTWOW,
+    TRACE_CODE_SME_RX_HDD_CONFIG_APP_TYPE1,
+    TRACE_CODE_SME_RX_HDD_CONFIG_APP_TYPE2,
+#endif
     TRACE_CODE_SME_RX_HDD_SET_MAXTXPOW,
     TRACE_CODE_SME_RX_HDD_SET_TXPOW,
     TRACE_CODE_SME_RX_HDD_SET_TMLEVEL,
diff -urN qcacld-new.orig/CORE/SME/src/csr/csrApiRoam.c qcacld-new/CORE/SME/src/csr/csrApiRoam.c
--- qcacld-new.orig/CORE/SME/src/csr/csrApiRoam.c	2015-09-24 15:25:20.581038328 +0800
+++ qcacld-new/CORE/SME/src/csr/csrApiRoam.c	2015-09-24 15:25:20.609038328 +0800
@@ -261,7 +261,9 @@
 void csrRoamJoinRetryTimerHandler(void *pv);
 #endif
 extern void SysProcessMmhMsg(tpAniSirGlobal pMac, tSirMsgQ* pMsg);
+#ifdef WLAN_BTAMP_FEATURE
 extern void btampEstablishLogLinkHdlr(void* pMsg);
+#endif
 static void csrSerDesUnpackDiassocRsp(tANI_U8 *pBuf, tSirSmeDisassocRsp *pRsp);
 void csrReinitPreauthCmd(tpAniSirGlobal pMac, tSmeCmd *pCommand);
 
@@ -2341,8 +2343,9 @@
   tANI_U32 count=0;
   tSirMacChanInfo *pChanInfo;
   tSirMacChanInfo *pChanInfoStart;
+#if 0
   tANI_BOOLEAN applyConfig = TRUE;
-
+#endif
   pMac->scan.currentCountryRSSI = -128;
   if(!ps11dinfo)
   {
@@ -2397,6 +2400,7 @@
       vos_mem_free(pChanInfoStart);
   }
   //Only apply them to CFG when not in STOP state. Otherwise they will be applied later
+#if 0 //currently this is not applied but it should .marked it out first as this is not a target feature at this time.
   if( HAL_STATUS_SUCCESS(status) )
   {
       for( index = 0; index < CSR_ROAM_SESSION_MAX; index++ )
@@ -2414,6 +2418,7 @@
     }
 
   }
+#endif
   return (status);
 }
 /* Initialize the Channel + Power List in the local cache and in the CFG */
@@ -7069,12 +7074,6 @@
             smsLog(pMac, LOG1, FL("Not connected to the same SSID asked in the profile"));
          }
       }
-      else if (!vos_mem_compare(&modProfileFields,
-                                &pSession->connectedProfile.modifyProfileFields,
-                                sizeof(tCsrRoamModifyProfileFields)))
-      {
-         fCallCallback = eANI_BOOLEAN_FALSE;
-      }
       else
       {
          smsLog(pMac, LOG1, FL("Either the profile is NULL or none of the fields "
@@ -8578,9 +8577,7 @@
                           pSmeRsp->messageType, pSmeRsp->messageType,
                           macTraceGetcsrRoamSubState(
                           pMac->roam.curSubState[pSmeRsp->sessionId]));
-    pSmeRsp->messageType = (pSmeRsp->messageType);
-    pSmeRsp->length = (pSmeRsp->length);
-    pSmeRsp->statusCode = (pSmeRsp->statusCode);
+
     switch (pSmeRsp->messageType)
     {
 
@@ -10594,11 +10591,12 @@
             csrRoamCallCallback(pMac, sessionId, &roamInfo, 0,
                     eCSR_ROAM_INFRA_IND, eCSR_ROAM_RESULT_MAX_ASSOC_EXCEEDED);
             break;
-
+#ifdef WLAN_BTAMP_FEATURE
         case eWNI_SME_BTAMP_LOG_LINK_IND:
             smsLog( pMac, LOG1, FL("Establish logical link req from HCI serialized through MC thread"));
             btampEstablishLogLinkHdlr( pSirMsg );
             break;
+#endif
         case eWNI_SME_RSSI_IND:
             smsLog( pMac, LOG1, FL("RSSI indication from TL serialized through MC thread"));
             csrRoamRssiIndHdlr( pMac, pSirMsg );
@@ -10804,11 +10802,19 @@
     tCsrRoamSession *pSession = CSR_GET_SESSION( pMac, pInfo->sessionId );
     eHalStatus status = eHAL_STATUS_FAILURE;
 
-    smsLog(pMac, LOGW, FL("WaitForKey timer expired in state=%s sub-state=%s"),
-           macTraceGetNeighbourRoamState(
-           pMac->roam.neighborRoamInfo.neighborRoamState),
-           macTraceGetcsrRoamSubState(
-           pMac->roam.curSubState[pInfo->sessionId]));
+	
+if (pInfo->sessionId < CSR_ROAM_SESSION_MAX) {
+		smsLog(pMac, LOGW, FL("WaitForKey timer expired in state=%s sub-state=%s"),
+			macTraceGetNeighbourRoamState(
+			pMac->roam.neighborRoamInfo.neighborRoamState),
+			macTraceGetcsrRoamSubState(
+			pMac->roam.curSubState[pInfo->sessionId]));
+	} else {
+		smsLog(pMac, LOGW, FL("WaitForKey timer expired in state=%s pInfo->sessionId (%d) exceed! "),
+			macTraceGetNeighbourRoamState(
+			pMac->roam.neighborRoamInfo.neighborRoamState),
+			pInfo->sessionId);
+	}
 
     if( CSR_IS_WAIT_FOR_KEY( pMac, pInfo->sessionId ) )
     {
@@ -13743,12 +13749,6 @@
         // reasonCode
         wTmp = pal_cpu_to_be16(reasonCode);
         vos_mem_copy(pBuf, &wTmp, sizeof(tANI_U16));
-        status = eHAL_STATUS_SUCCESS;
-        if(!HAL_STATUS_SUCCESS(status))
-        {
-            vos_mem_free(pMsg);
-            break;
-        }
         pBuf += sizeof(tANI_U16);
         /* The state will be DISASSOC_HANDOFF only when we are doing handoff.
                     Here we should not send the disassoc over the air to the AP */
@@ -13790,15 +13790,9 @@
         pBuf += sizeof(tANI_U16);
         // bssid
         vos_mem_copy(pMsg->bssId, bssId, sizeof( tSirMacAddr ));
-        status = eHAL_STATUS_SUCCESS;
         pBuf = pBuf + sizeof ( tSirMacAddr );
         // bEnable
         *pBuf = (tANI_BOOLEAN)bEnable;
-        if(!HAL_STATUS_SUCCESS(status))
-        {
-            vos_mem_free(pMsg);
-            break;
-        }
         status = palSendMBMessage( pMac->hHdd, pMsg );
     } while( 0 );
     return( status );
@@ -14027,21 +14021,9 @@
         }
                 // Set the peer MAC address before sending the message to LIM
         vos_mem_copy( (tSirMacAddr *) pBuf, bssId, sizeof( pMsg->peerMacAddr ) );
-        status = eHAL_STATUS_SUCCESS;
         pBuf =  pBuf + sizeof(tSirMacAddr);
-        if(!HAL_STATUS_SUCCESS(status))
-        {
-            vos_mem_free(pMsg);
-            break;
-        }
         wTmp = pal_cpu_to_be16(reasonCode);
         vos_mem_copy( pBuf, &wTmp,sizeof( tANI_U16 ) );
-        status = eHAL_STATUS_SUCCESS;
-        if(!HAL_STATUS_SUCCESS(status))
-        {
-            vos_mem_free(pMsg);
-            break;
-        }
         status = palSendMBMessage( pMac->hHdd, pMsg );
     } while( 0 );
     return( status );
@@ -14064,20 +14046,8 @@
         pMsg->length = pal_cpu_to_be16((tANI_U16)sizeof( tSirSmeDisassocCnf ));
         vos_mem_copy(pMsg->peerMacAddr, pDisassocInd->peerMacAddr,
                      sizeof(pMsg->peerMacAddr));
-        status = eHAL_STATUS_SUCCESS;
-        if(!HAL_STATUS_SUCCESS(status))
-        {
-            vos_mem_free(pMsg);
-            break;
-        }
 //To test reconn
         vos_mem_copy(pMsg->bssId, pDisassocInd->bssId, sizeof(pMsg->peerMacAddr));
-        status = eHAL_STATUS_SUCCESS;
-        if(!HAL_STATUS_SUCCESS(status))
-        {
-            vos_mem_free(pMsg);
-            break;
-        }
 //To test reconn ends
         status = palSendMBMessage( pMac->hHdd, pMsg );
     } while( 0 );
@@ -14100,20 +14070,8 @@
         pMsg->statusCode = (tSirResultCodes)pal_cpu_to_be32(eSIR_SME_SUCCESS);
         pMsg->length = pal_cpu_to_be16((tANI_U16)sizeof( tSirSmeDeauthCnf ));
         vos_mem_copy(pMsg->bssId, pDeauthInd->bssId, sizeof(pMsg->bssId));
-        status = eHAL_STATUS_SUCCESS;
-        if(!HAL_STATUS_SUCCESS(status))
-        {
-            vos_mem_free(pMsg);
-            break;
-        }
         vos_mem_copy(pMsg->peerMacAddr, pDeauthInd->peerMacAddr,
                      sizeof(pMsg->peerMacAddr));
-        status = eHAL_STATUS_SUCCESS;
-        if(!HAL_STATUS_SUCCESS(status))
-        {
-            vos_mem_free(pMsg);
-            break;
-        }
         status = palSendMBMessage( pMac->hHdd, pMsg );
     } while( 0 );
     return( status );
@@ -18273,7 +18231,6 @@
            FL("Failed to send eWNI_SME_UPDATE_ADDTIONAL_IES msg"
            "!!! status %d"), status);
        vos_mem_free(pLocalBuffer);
-       vos_mem_free(pModifyAddIEInd);
     }
     return status;
 }
@@ -18346,7 +18303,6 @@
            FL("Failed to send eWNI_SME_UPDATE_ADDTIONAL_IES msg"
            "!!! status %d"), status);
        vos_mem_free(pLocalBuffer);
-       vos_mem_free(pUpdateAddIEs);
     }
     return status;
 }
diff -urN qcacld-new.orig/CORE/SME/src/csr/csrApiScan.c qcacld-new/CORE/SME/src/csr/csrApiScan.c
--- qcacld-new.orig/CORE/SME/src/csr/csrApiScan.c	2015-09-24 15:25:20.581038328 +0800
+++ qcacld-new/CORE/SME/src/csr/csrApiScan.c	2015-09-24 15:25:20.609038328 +0800
@@ -428,13 +428,6 @@
             vos_mem_copy(pScanCmd->u.scanCmd.u.scanRequest.ChannelInfo.ChannelList,
                          pMac->scan.baseChannels.channelList, numChn);
             status = eHAL_STATUS_SUCCESS;
-            if( !HAL_STATUS_SUCCESS( status ) )
-            {
-                vos_mem_free(pScanCmd->u.scanCmd.u.scanRequest.ChannelInfo.ChannelList);
-                pScanCmd->u.scanCmd.u.scanRequest.ChannelInfo.ChannelList = NULL;
-                smsLog( pMac, LOGE, FL(" Failed to copy memory to channel list ") );
-                return eHAL_STATUS_FAILURE;
-            }
             pScanCmd->u.scanCmd.u.scanRequest.ChannelInfo.numOfChannels = numChn;
         }
 
diff -urN qcacld-new.orig/CORE/SME/src/oemData/oemDataApi.c qcacld-new/CORE/SME/src/oemData/oemDataApi.c
--- qcacld-new.orig/CORE/SME/src/oemData/oemDataApi.c	2015-09-24 15:25:20.581038328 +0800
+++ qcacld-new/CORE/SME/src/oemData/oemDataApi.c	2015-09-24 15:25:20.609038328 +0800
@@ -61,11 +61,6 @@
     {
         //initialize all the variables to null
         vos_mem_set(&(pMac->oemData), sizeof(tOemDataStruct), 0);
-        if(!HAL_STATUS_SUCCESS(status))
-        {
-            smsLog(pMac, LOGE, "oemData_OemDataReqOpen: Cannot allocate memory for the timer function");
-            break;
-        }
     } while(0);
 
     return status;
@@ -79,16 +74,10 @@
 
 eHalStatus oemData_OemDataReqClose(tHalHandle hHal)
 {
-    eHalStatus status = eHAL_STATUS_SUCCESS;
     tpAniSirGlobal pMac = PMAC_STRUCT(hHal);
 
     do
     {
-        if(!HAL_STATUS_SUCCESS(status))
-        {
-            smsLog(pMac, LOGE, "oemData_OemDataReqClose: Failed in oemData_OemDataReqClose at StopTimers");
-            break;
-        }
 
         if(pMac->oemData.pOemDataRsp != NULL)
         {
diff -urN qcacld-new.orig/CORE/SME/src/pmc/pmcApi.c qcacld-new/CORE/SME/src/pmc/pmcApi.c
--- qcacld-new.orig/CORE/SME/src/pmc/pmcApi.c	2015-09-24 15:25:20.581038328 +0800
+++ qcacld-new/CORE/SME/src/pmc/pmcApi.c	2015-09-24 15:25:20.609038328 +0800
@@ -2151,12 +2151,18 @@
     if(pattern == NULL)
     {
         pmcLog(pMac, LOGE, FL("Null broadcast pattern being passed"));
+#ifdef FEATURE_WLAN_DIAG_SUPPORT
+        WLAN_VOS_DIAG_LOG_FREE(log_ptr);
+#endif
         return eHAL_STATUS_FAILURE;
     }
 
     if( pSession == NULL)
     {
         pmcLog(pMac, LOGE, FL("Session not found "));
+#ifdef FEATURE_WLAN_DIAG_SUPPORT
+        WLAN_VOS_DIAG_LOG_FREE(log_ptr);
+#endif
         return eHAL_STATUS_FAILURE;
     }
 
@@ -2932,12 +2938,6 @@
                *((v_U32_t *) &pRequest->aNetworks[1].ssId.ssId[24]),
                *((v_U32_t *) &pRequest->aNetworks[1].ssId.ssId[28]));
 
-    if (!pSession)
-    {
-        VOS_TRACE(VOS_MODULE_ID_SME, VOS_TRACE_LEVEL_ERROR,
-                  "%s: pSessionis NULL", __func__);
-        return eHAL_STATUS_FAILURE;
-    }
 
     pRequestBuf = vos_mem_malloc(sizeof(tSirPNOScanReq));
     if (NULL == pRequestBuf)
@@ -3047,7 +3047,7 @@
     vos_msg_t msg;
 
 
-    pRequestBuf = vos_mem_malloc(sizeof(tpSirSetRSSIFilterReq));
+    pRequestBuf = vos_mem_malloc(sizeof(tSirSetRSSIFilterReq));
     if (NULL == pRequestBuf)
     {
         VOS_TRACE(VOS_MODULE_ID_SME, VOS_TRACE_LEVEL_ERROR, "%s: Not able to allocate memory for PNO request", __func__);
diff -urN qcacld-new.orig/CORE/SME/src/sme_common/sme_Api.c qcacld-new/CORE/SME/src/sme_common/sme_Api.c
--- qcacld-new.orig/CORE/SME/src/sme_common/sme_Api.c	2015-09-24 15:25:20.581038328 +0800
+++ qcacld-new/CORE/SME/src/sme_common/sme_Api.c	2015-09-24 15:25:20.609038328 +0800
@@ -1725,6 +1725,46 @@
    }
 }
 
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+/*--------------------------------------------------------------------------
+
+  \fn - sme_ProcessReadyToExtWoW
+  \brief - On getting ready to Ext WoW indication, this function calls
+             callback registered (HDD callbacks) with SME to inform
+             ready to ExtWoW indication.
+
+  \param hHal - Handle returned by macOpen.
+   pReadyToExtWoW - Parameter received along with ready to Ext WoW
+                                indication from WMA.
+
+  \return None
+
+  \sa
+
+ --------------------------------------------------------------------------*/
+void sme_ProcessReadyToExtWoW( tHalHandle hHal,
+                                 tpSirReadyToExtWoWInd pReadyToExtWoW)
+{
+   tpAniSirGlobal pMac = PMAC_STRUCT( hHal );
+
+   if (NULL == pMac)
+   {
+       VOS_TRACE(VOS_MODULE_ID_SME, VOS_TRACE_LEVEL_FATAL,
+             "%s: pMac is null", __func__);
+       return ;
+   }
+
+   if (NULL != pMac->readyToExtWoWCallback)
+   {
+       pMac->readyToExtWoWCallback (pMac->readyToExtWoWContext,
+                                    pReadyToExtWoW->status);
+       pMac->readyToExtWoWCallback = NULL;
+       pMac->readyToExtWoWContext = NULL;
+   }
+
+}
+#endif
+
 /* ---------------------------------------------------------------------------
     \fn sme_ChangeConfigParams
     \brief The SME API exposed for HDD to provide config params to SME during
@@ -2648,6 +2688,21 @@
                 }
                 break ;
 
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+           case eWNI_SME_READY_TO_EXTWOW_IND:
+                if (pMsg->bodyptr)
+                {
+                     sme_ProcessReadyToExtWoW(pMac, pMsg->bodyptr);
+                     vos_mem_free(pMsg->bodyptr);
+                }
+                else
+                {
+                     smsLog(pMac, LOGE, "Empty rsp message"
+                     "for (eWNI_SME_READY_TO_EXTWOW_IND), nothing to process");
+                }
+                break ;
+#endif
+
 #ifdef FEATURE_WLAN_CH_AVOID
            /* channel avoid message arrived, send IND to client */
            case eWNI_SME_CH_AVOID_IND:
@@ -6837,7 +6892,7 @@
   tpSmeBtAmpEvent ptrSmeBtAmpEvent = NULL;
   eHalStatus status = eHAL_STATUS_FAILURE;
 
-  ptrSmeBtAmpEvent = vos_mem_malloc(sizeof(tpSmeBtAmpEvent));
+  ptrSmeBtAmpEvent = vos_mem_malloc(sizeof(tSmeBtAmpEvent));
   if (NULL == ptrSmeBtAmpEvent)
      {
         VOS_TRACE(VOS_MODULE_ID_SME, VOS_TRACE_LEVEL_ERROR, "%s: "
@@ -7596,6 +7651,175 @@
     return(status);
 }
 
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+/* ---------------------------------------------------------------------------
+
+  \fn    sme_ConfigureExtWoW
+
+  \brief
+    SME will pass this request to lower mac to configure Extr WoW
+
+  \param
+
+    hHal - The handle returned by macOpen.
+
+    wlanExtParams- Depicts the wlan Ext params
+
+  \return eHalStatus
+
+
+--------------------------------------------------------------------------- */
+eHalStatus sme_ConfigureExtWoW( tHalHandle hHal,
+                          tpSirExtWoWParams  wlanExtParams,
+                          csrReadyToExtWoWCallback callback,
+                             void *callbackContext)
+{
+    eHalStatus status = eHAL_STATUS_SUCCESS;
+    VOS_STATUS vosStatus = VOS_STATUS_SUCCESS;
+    tpAniSirGlobal pMac = PMAC_STRUCT(hHal);
+    vos_msg_t vosMessage;
+    tpSirExtWoWParams MsgPtr = vos_mem_malloc(sizeof(*MsgPtr));
+
+    if (!MsgPtr)
+        return eHAL_STATUS_FAILURE;
+
+    MTRACE(vos_trace(VOS_MODULE_ID_SME,
+                  TRACE_CODE_SME_RX_HDD_CONFIG_EXTWOW, NO_SESSION, 0));
+
+    pMac->readyToExtWoWCallback = callback;
+    pMac->readyToExtWoWContext = callbackContext;
+
+    if ( eHAL_STATUS_SUCCESS ==
+              ( status = sme_AcquireGlobalLock( &pMac->sme ) ) ) {
+
+        /* serialize the req through MC thread */
+        vos_mem_copy(MsgPtr, wlanExtParams, sizeof(*MsgPtr));
+        vosMessage.bodyptr = MsgPtr;
+        vosMessage.type =  WDA_WLAN_EXT_WOW;
+        vosStatus = vos_mq_post_message( VOS_MQ_ID_WDA, &vosMessage );
+        if ( !VOS_IS_STATUS_SUCCESS(vosStatus) ) {
+            pMac->readyToExtWoWCallback = NULL;
+            pMac->readyToExtWoWContext = NULL;
+            vos_mem_free(MsgPtr);
+            status = eHAL_STATUS_FAILURE;
+        }
+        sme_ReleaseGlobalLock( &pMac->sme );
+    } else {
+        pMac->readyToExtWoWCallback = NULL;
+        pMac->readyToExtWoWContext = NULL;
+        vos_mem_free(MsgPtr);
+    }
+
+    return(status);
+}
+
+/* ---------------------------------------------------------------------------
+
+  \fn    sme_ConfigureAppType1Params
+
+  \brief
+   SME will pass this request to lower mac to configure Indoor WoW parameters.
+
+  \param
+
+    hHal - The handle returned by macOpen.
+
+    wlanAppType1Params- Depicts the wlan App Type 1(Indoor) params
+
+  \return eHalStatus
+
+
+--------------------------------------------------------------------------- */
+eHalStatus sme_ConfigureAppType1Params( tHalHandle hHal,
+                          tpSirAppType1Params  wlanAppType1Params)
+{
+    eHalStatus status = eHAL_STATUS_SUCCESS;
+    VOS_STATUS vosStatus = VOS_STATUS_SUCCESS;
+    tpAniSirGlobal pMac = PMAC_STRUCT(hHal);
+    vos_msg_t       vosMessage;
+    tpSirAppType1Params MsgPtr = vos_mem_malloc(sizeof(*MsgPtr));
+
+    if (!MsgPtr)
+        return eHAL_STATUS_FAILURE;
+
+    MTRACE(vos_trace(VOS_MODULE_ID_SME,
+                  TRACE_CODE_SME_RX_HDD_CONFIG_APP_TYPE1, NO_SESSION, 0));
+
+    if ( eHAL_STATUS_SUCCESS ==
+              ( status = sme_AcquireGlobalLock( &pMac->sme ) ) ) {
+
+        /* serialize the req through MC thread */
+        vos_mem_copy(MsgPtr, wlanAppType1Params, sizeof(*MsgPtr));
+        vosMessage.bodyptr = MsgPtr;
+        vosMessage.type    =  WDA_WLAN_SET_APP_TYPE1_PARAMS;
+        vosStatus = vos_mq_post_message( VOS_MQ_ID_WDA, &vosMessage );
+        if ( !VOS_IS_STATUS_SUCCESS(vosStatus) ) {
+           vos_mem_free(MsgPtr);
+           status = eHAL_STATUS_FAILURE;
+        }
+        sme_ReleaseGlobalLock( &pMac->sme );
+    } else {
+        vos_mem_free(MsgPtr);
+    }
+
+    return(status);
+}
+
+#ifdef WLAN_FEATURE_EXTWOW_OUTDOOR_SUPPORT
+/* ---------------------------------------------------------------------------
+
+  \fn    sme_ConfigureAppType2Params
+
+  \brief
+   SME will pass this request to lower mac to configure Indoor WoW parameters.
+
+  \param
+
+    hHal - The handle returned by macOpen.
+
+    wlanAppType2Params- Depicts the wlan App Type 2 (Outdoor) params
+
+  \return eHalStatus
+
+
+--------------------------------------------------------------------------- */
+eHalStatus sme_ConfigureAppType2Params( tHalHandle hHal,
+                          tpSirAppType2Params  wlanAppType2Params)
+{
+    eHalStatus status = eHAL_STATUS_SUCCESS;
+    VOS_STATUS vosStatus = VOS_STATUS_SUCCESS;
+    tpAniSirGlobal pMac = PMAC_STRUCT(hHal);
+    vos_msg_t       vosMessage;
+    tpSirAppType2Params MsgPtr = vos_mem_malloc(sizeof(*MsgPtr));
+
+    if (!MsgPtr)
+        return eHAL_STATUS_FAILURE;
+
+    MTRACE(vos_trace(VOS_MODULE_ID_SME,
+                  TRACE_CODE_SME_RX_HDD_CONFIG_APP_TYPE2, NO_SESSION, 0));
+
+    if ( eHAL_STATUS_SUCCESS ==
+            ( status = sme_AcquireGlobalLock( &pMac->sme ) ) ) {
+
+        /* serialize the req through MC thread */
+        vos_mem_copy(MsgPtr, wlanAppType2Params, sizeof(*MsgPtr));
+        vosMessage.bodyptr = MsgPtr;
+        vosMessage.type =  WDA_WLAN_SET_APP_TYPE2_PARAMS;
+        vosStatus = vos_mq_post_message( VOS_MQ_ID_WDA, &vosMessage );
+        if ( !VOS_IS_STATUS_SUCCESS(vosStatus) ) {
+           vos_mem_free(MsgPtr);
+           status = eHAL_STATUS_FAILURE;
+        }
+        sme_ReleaseGlobalLock( &pMac->sme );
+    } else {
+        vos_mem_free(MsgPtr);
+    }
+
+    return(status);
+}
+#endif
+#endif
+
 /* ---------------------------------------------------------------------------
 
     \fn sme_GetInfraSessionId
@@ -12541,6 +12765,7 @@
         smsLog(pMac, LOGE, "Invalid Channel Change Resp Message: %d\n",
               status);
     }
+    vos_mem_free(pRoamInfo.channelChangeRespEvent);
     return status;
 }
 
@@ -12670,7 +12895,6 @@
     tpAniSirGlobal pMac = PMAC_STRUCT(hHal);
     u_int8_t *pLevel = vos_mem_malloc(sizeof(*pLevel));
 
-    pLevel = vos_mem_malloc(sizeof(*pLevel));
     if (NULL == pLevel)
     {
        VOS_TRACE(VOS_MODULE_ID_SME, VOS_TRACE_LEVEL_ERROR,
@@ -13158,7 +13382,7 @@
         return eHAL_STATUS_INVALID_PARAMETER;
     }
 
-    if ((wifiBand < WIFI_BAND_UNSPECIFIED) || (wifiBand >= WIFI_BAND_MAX)) {
+    if (wifiBand >= WIFI_BAND_MAX) {
         smsLog(pMac, VOS_TRACE_LEVEL_ERROR,
                      FL("Invalid wifiBand (%d)"), wifiBand);
         return eHAL_STATUS_INVALID_PARAMETER;
diff -urN qcacld-new.orig/CORE/SME/src/sme_common/sme_FTApi.c qcacld-new/CORE/SME/src/sme_common/sme_FTApi.c
--- qcacld-new.orig/CORE/SME/src/sme_common/sme_FTApi.c	2015-09-24 15:25:20.581038328 +0800
+++ qcacld-new/CORE/SME/src/sme_common/sme_FTApi.c	2015-09-24 15:25:20.609038328 +0800
@@ -261,7 +261,7 @@
 
     keymaterial->key[ 0 ].keyLength = pFTKeyInfo->keyLength;
 
-    if ( pFTKeyInfo->keyLength && pFTKeyInfo->Key )
+    if ( pFTKeyInfo->keyLength )
     {
         vos_mem_copy(&keymaterial->key[ 0 ].key, pFTKeyInfo->Key, pFTKeyInfo->keyLength);
         if(pFTKeyInfo->keyLength == 16)
diff -urN qcacld-new.orig/CORE/SME/src/sme_common/sme_Trace.c qcacld-new/CORE/SME/src/sme_common/sme_Trace.c
--- qcacld-new.orig/CORE/SME/src/sme_common/sme_Trace.c	2015-09-24 15:25:20.581038328 +0800
+++ qcacld-new/CORE/SME/src/sme_common/sme_Trace.c	2015-09-24 15:25:20.609038328 +0800
@@ -120,6 +120,11 @@
         CASE_RETURN_STRING(TRACE_CODE_SME_RX_HDD_CONFIG_RXPFIL);
         CASE_RETURN_STRING(TRACE_CODE_SME_RX_HDD_CONFIG_SUSPENDIND);
         CASE_RETURN_STRING(TRACE_CODE_SME_RX_HDD_CONFIG_RESUMEREQ);
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+        CASE_RETURN_STRING(TRACE_CODE_SME_RX_HDD_CONFIG_EXTWOW);
+        CASE_RETURN_STRING(TRACE_CODE_SME_RX_HDD_CONFIG_APP_TYPE1);
+        CASE_RETURN_STRING(TRACE_CODE_SME_RX_HDD_CONFIG_APP_TYPE2);
+#endif
         CASE_RETURN_STRING(TRACE_CODE_SME_RX_HDD_SET_MAXTXPOW);
         CASE_RETURN_STRING(TRACE_CODE_SME_RX_HDD_SET_TXPOW);
         CASE_RETURN_STRING(TRACE_CODE_SME_RX_HDD_SET_TMLEVEL);
diff -urN qcacld-new.orig/CORE/SYS/legacy/src/utils/src/logDump.c qcacld-new/CORE/SYS/legacy/src/utils/src/logDump.c
--- qcacld-new.orig/CORE/SYS/legacy/src/utils/src/logDump.c	2015-09-24 15:25:20.569038328 +0800
+++ qcacld-new/CORE/SYS/legacy/src/utils/src/logDump.c	2015-09-24 15:25:20.601038328 +0800
@@ -125,8 +125,10 @@
     va_list args;
     va_start(args, fmt);
 
-    if (pMac->gCurrentLogSize >= MAX_LOGDUMP_SIZE)
+    if (pMac->gCurrentLogSize >= MAX_LOGDUMP_SIZE) {
+        va_end(args);
         return 0;
+    }
 
 #if    defined (ANI_OS_TYPE_ANDROID)
     ret = vsnprintf(pBuf, (MAX_LOGDUMP_SIZE - pMac->gCurrentLogSize), fmt, args);
diff -urN qcacld-new.orig/CORE/SYS/legacy/src/utils/src/macTrace.c qcacld-new/CORE/SYS/legacy/src/utils/src/macTrace.c
--- qcacld-new.orig/CORE/SYS/legacy/src/utils/src/macTrace.c	2015-09-24 15:25:20.573038328 +0800
+++ qcacld-new/CORE/SYS/legacy/src/utils/src/macTrace.c	2015-09-24 15:25:20.601038328 +0800
@@ -735,6 +735,11 @@
         CASE_RETURN_STRING(WDA_TX_COMPLETE_TIMEOUT_IND);
         CASE_RETURN_STRING(WDA_WLAN_SUSPEND_IND);
         CASE_RETURN_STRING(WDA_WLAN_RESUME_REQ);
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+        CASE_RETURN_STRING(WDA_WLAN_EXT_WOW);
+        CASE_RETURN_STRING(WDA_WLAN_SET_APP_TYPE1_PARAMS);
+        CASE_RETURN_STRING(WDA_WLAN_SET_APP_TYPE2_PARAMS);
+#endif
         CASE_RETURN_STRING(WDA_MSG_TYPES_END);
         CASE_RETURN_STRING(WDA_MMH_TXMB_READY_EVT);
         CASE_RETURN_STRING(WDA_MMH_RXMB_DONE_EVT);
diff -urN qcacld-new.orig/CORE/UTILS/FWLOG/dbglog_host.c qcacld-new/CORE/UTILS/FWLOG/dbglog_host.c
--- qcacld-new.orig/CORE/UTILS/FWLOG/dbglog_host.c	2015-09-24 15:25:20.569038328 +0800
+++ qcacld-new/CORE/UTILS/FWLOG/dbglog_host.c	2015-09-24 15:25:20.601038328 +0800
@@ -1162,6 +1162,106 @@
     },
 };
 
+#ifdef CONFIG_WLAN_FWLOG_FILE
+extern int _readwrite_file(const char *filename, char *rbuf,
+	const char *wbuf, size_t length, int mode);
+
+#define FWLOG_FILE_BUF_MAX_DEFAULT_SIZE		(16*1024) /* default 16k */
+#define FWLOG_FILE_BUF_THREHOLD			(12*1024) /* default 12k */
+#define FWLOG_FILE_MAX_DEFAULT_SIZE		(10*1024*1024) /* default 10M */
+#define FWLOG_FILE_DEFAULT_PATH			"/opt/var/log/cld_fw.log"
+
+struct _dbglog_fwlog_file {
+	A_UINT8  print_to_file;
+	A_UINT32 file_max_size;
+	A_UINT8	 file_path_and_name[64];
+	A_UINT32 file_size;
+	A_UINT32 buf_used_size;
+	A_UINT32 buf_free_size;
+	A_UINT8* buf_free_idx;
+	adf_os_spinlock_t buf_spinlock;
+	struct work_struct work;
+	A_UINT8* buf;
+	A_UINT32 overflow;
+} dbglog_fwlog_file_ctx;
+
+void dbglog_fwlog_file_thread(struct work_struct *work)
+{
+	int ret;
+
+	adf_os_spin_lock_bh(&dbglog_fwlog_file_ctx.buf_spinlock);
+	if (dbglog_fwlog_file_ctx.buf_used_size) {
+		adf_os_spin_unlock_bh(&dbglog_fwlog_file_ctx.buf_spinlock);
+		ret = _readwrite_file(dbglog_fwlog_file_ctx.file_path_and_name, NULL,
+					dbglog_fwlog_file_ctx.buf,
+					dbglog_fwlog_file_ctx.buf_used_size,
+					(O_WRONLY | O_APPEND | O_CREAT));
+		if (ret < 0) {
+			printk("%s:%d: fail to write\n", __func__, __LINE__);
+			return;
+		}
+		adf_os_spin_lock_bh(&dbglog_fwlog_file_ctx.buf_spinlock);
+		dbglog_fwlog_file_ctx.buf_free_idx = dbglog_fwlog_file_ctx.buf;
+		dbglog_fwlog_file_ctx.file_size += dbglog_fwlog_file_ctx.buf_used_size;
+		dbglog_fwlog_file_ctx.buf_used_size = 0;
+		dbglog_fwlog_file_ctx.buf_free_size = FWLOG_FILE_BUF_MAX_DEFAULT_SIZE;
+	}
+	adf_os_spin_unlock_bh(&dbglog_fwlog_file_ctx.buf_spinlock);
+}
+
+int dbglog_fwlog_file_init(void)
+{
+	dbglog_fwlog_file_ctx.buf = kmalloc(FWLOG_FILE_BUF_MAX_DEFAULT_SIZE, GFP_KERNEL);
+	if (dbglog_fwlog_file_ctx.buf == NULL) {
+		printk("%s:%d: not enough mem\n", __func__, __LINE__);
+		return -ENOMEM;
+	}
+
+	dbglog_fwlog_file_ctx.print_to_file = 0;
+	dbglog_fwlog_file_ctx.overflow = 0;
+	dbglog_fwlog_file_ctx.file_max_size = FWLOG_FILE_MAX_DEFAULT_SIZE;
+	memcpy(dbglog_fwlog_file_ctx.file_path_and_name,
+		FWLOG_FILE_DEFAULT_PATH,
+		sizeof(dbglog_fwlog_file_ctx.file_path_and_name));
+	dbglog_fwlog_file_ctx.file_size = 0;
+	dbglog_fwlog_file_ctx.buf_used_size = 0;
+	dbglog_fwlog_file_ctx.buf_free_size = FWLOG_FILE_BUF_MAX_DEFAULT_SIZE;
+	dbglog_fwlog_file_ctx.buf_free_idx = dbglog_fwlog_file_ctx.buf;
+	adf_os_spinlock_init(&dbglog_fwlog_file_ctx.buf_spinlock);
+	INIT_WORK(&dbglog_fwlog_file_ctx.work, dbglog_fwlog_file_thread);
+
+	return 0;
+}
+
+void dbglog_fwlog_file_deinit(void)
+{
+	flush_work(&dbglog_fwlog_file_ctx.work);
+	adf_os_spinlock_destroy(&dbglog_fwlog_file_ctx.buf_spinlock);
+	kfree(dbglog_fwlog_file_ctx.buf);
+}
+
+
+void dbglog_fwlog_file_trunc(void)
+{
+	if (dbglog_fwlog_file_ctx.print_to_file) {
+		_readwrite_file(dbglog_fwlog_file_ctx.file_path_and_name, NULL,
+			NULL, 0, (O_WRONLY | O_CREAT | O_TRUNC));
+		dbglog_fwlog_file_ctx.file_size = 0;
+	}
+}
+
+void dbglog_fwlog_file_rename_and_reopen(void)
+{
+
+}
+
+
+void dbglog_fwlog_file_flush_buf(void)
+{
+	schedule_work(&dbglog_fwlog_file_ctx.work);
+}
+#endif
+
 int dbglog_module_log_enable(wmi_unified_t  wmi_handle, A_UINT32 mod_id,
                   bool isenable)
 {
@@ -1299,6 +1399,26 @@
 			mod_enable_bitmap,bitmap_len);
 }
 
+
+#ifdef CONFIG_WLAN_FWLOG_FILE
+int dbglog_fwlog_file_enable(wmi_unified_t  wmi_handle, bool isenable)
+{
+	if (isenable > TRUE) {
+		AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("dbglog_fwlog_file_enable:Invalid value %d\n",
+						isenable));
+		return -EINVAL;
+	}
+
+	if (isenable) {
+		dbglog_fwlog_file_ctx.print_to_file = 1;
+		dbglog_fwlog_file_trunc();
+	} else {
+		dbglog_fwlog_file_ctx.print_to_file = 0;
+	}
+	return 0;
+}
+#endif
+
 int dbglog_report_enable(wmi_unified_t  wmi_handle, bool isenable)
 {
     int bitmap[2] = {0};
@@ -1316,6 +1436,9 @@
 	bitmap[1] = 0x1F;
 	/* set the module level bitmap  */
 	dbglog_set_mod_enable_bitmap(wmi_handle, 0x0, bitmap, 2);
+#ifdef CONFIG_WLAN_FWLOG_FILE
+	dbglog_fwlog_file_trunc();
+#endif
     } else {
         dbglog_set_vap_enable_bitmap(wmi_handle, bitmap[0]);
         dbglog_set_mod_enable_bitmap(wmi_handle, DBGLOG_LVL_MAX, bitmap, 2);
@@ -1342,6 +1465,7 @@
     return unknown_str;
 }
 
+
 void
 dbglog_printf(
         A_UINT32 timestamp,
@@ -1350,18 +1474,67 @@
 {
     char buf[128];
     va_list ap;
+#ifdef CONFIG_WLAN_FWLOG_FILE
+    int len = 0;
 
-    if (vap_id < DBGLOG_MAX_VDEVID) {
-        AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (DBGLOG_PRINT_PREFIX "[%u] vap-%u ", timestamp, vap_id));
+    if (dbglog_fwlog_file_ctx.print_to_file) {
+        adf_os_spin_lock_bh(&dbglog_fwlog_file_ctx.buf_spinlock);
+
+	if (dbglog_fwlog_file_ctx.file_size >= dbglog_fwlog_file_ctx.file_max_size) {
+            adf_os_spin_unlock_bh(&dbglog_fwlog_file_ctx.buf_spinlock);
+            dbglog_fwlog_file_trunc();
+            adf_os_spin_lock_bh(&dbglog_fwlog_file_ctx.buf_spinlock);
+	}
+
+        if (dbglog_fwlog_file_ctx.buf_used_size >= FWLOG_FILE_BUF_MAX_DEFAULT_SIZE) {
+            dbglog_fwlog_file_ctx.overflow++;
+            printk("%s:%d: overflow:%u\n", __func__, __LINE__, dbglog_fwlog_file_ctx.overflow);
+            adf_os_spin_unlock_bh(&dbglog_fwlog_file_ctx.buf_spinlock);
+            return;
+        }
+
+	if (vap_id < DBGLOG_MAX_VDEVID) {
+            len = snprintf(dbglog_fwlog_file_ctx.buf_free_idx, dbglog_fwlog_file_ctx.buf_free_size,
+                           "[%u] vap-%u ", timestamp, vap_id);
+	} else {
+            len = snprintf(dbglog_fwlog_file_ctx.buf_free_idx, dbglog_fwlog_file_ctx.buf_free_size,
+                           "[%u] ", timestamp);
+	}
+
+        va_start(ap, fmt);
+        len += vsnprintf(dbglog_fwlog_file_ctx.buf_free_idx + len, dbglog_fwlog_file_ctx.buf_free_size - len, fmt, ap);
+	dbglog_fwlog_file_ctx.buf_free_idx[len] = '\n';
+	len++;
+        dbglog_fwlog_file_ctx.buf_free_idx += len;
+        dbglog_fwlog_file_ctx.buf_used_size += len;
+        dbglog_fwlog_file_ctx.buf_free_size -= len;
+        va_end(ap);
+        if ((dbglog_fwlog_file_ctx.buf_used_size >= FWLOG_FILE_BUF_THREHOLD) ||
+            ((dbglog_fwlog_file_ctx.file_size + dbglog_fwlog_file_ctx.buf_used_size) >= dbglog_fwlog_file_ctx.file_max_size)) {
+            adf_os_spin_unlock_bh(&dbglog_fwlog_file_ctx.buf_spinlock);
+            dbglog_fwlog_file_flush_buf();
+        } else {
+            adf_os_spin_unlock_bh(&dbglog_fwlog_file_ctx.buf_spinlock);
+	}
     } else {
-        AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (DBGLOG_PRINT_PREFIX "[%u] ", timestamp));
+        if (vap_id < DBGLOG_MAX_VDEVID) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (DBGLOG_PRINT_PREFIX "[%u] vap-%u ", timestamp, vap_id));
+        } else {
+            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (DBGLOG_PRINT_PREFIX "[%u] ", timestamp));
+        }
+        va_start(ap, fmt);
+        vsnprintf(buf, sizeof(buf), fmt, ap);
+        va_end(ap);
+        AR_DEBUG_PRINTF(ATH_DEBUG_INFO, ("%s\n", buf));
     }
+#else
 
     va_start(ap, fmt);
     vsnprintf(buf, sizeof(buf), fmt, ap);
     va_end(ap);
 
     AR_DEBUG_PRINTF(ATH_DEBUG_INFO, ("%s\n", buf));
+#endif
 }
 
 void
@@ -1372,7 +1545,60 @@
 {
     char buf[128];
     va_list ap;
+#ifdef CONFIG_WLAN_FWLOG_FILE
+    int len = 0;
+
+    if (dbglog_fwlog_file_ctx.print_to_file) {
+        adf_os_spin_lock_bh(&dbglog_fwlog_file_ctx.buf_spinlock);
+	if (dbglog_fwlog_file_ctx.file_size >= dbglog_fwlog_file_ctx.file_max_size) {
+            adf_os_spin_unlock_bh(&dbglog_fwlog_file_ctx.buf_spinlock);
+            dbglog_fwlog_file_trunc();
+            adf_os_spin_lock_bh(&dbglog_fwlog_file_ctx.buf_spinlock);
+	}
+        if (dbglog_fwlog_file_ctx.buf_used_size >= FWLOG_FILE_BUF_MAX_DEFAULT_SIZE) {
+            dbglog_fwlog_file_ctx.overflow++;
+            printk("%s:%d: overflow:%u\n", __func__, __LINE__, dbglog_fwlog_file_ctx.overflow);
+            adf_os_spin_unlock_bh(&dbglog_fwlog_file_ctx.buf_spinlock);
+            return;
+        }
 
+	if (vap_id < DBGLOG_MAX_VDEVID) {
+		len = snprintf(dbglog_fwlog_file_ctx.buf_free_idx, dbglog_fwlog_file_ctx.buf_free_size,
+			"[%u] vap-%u ", timestamp, vap_id);
+	} else {
+		len = snprintf(dbglog_fwlog_file_ctx.buf_free_idx, dbglog_fwlog_file_ctx.buf_free_size,
+			"[%u] ", timestamp);
+	}
+
+        va_start(ap, fmt);
+        len += vsnprintf(dbglog_fwlog_file_ctx.buf_free_idx + len, dbglog_fwlog_file_ctx.buf_free_size - len, fmt, ap);
+	dbglog_fwlog_file_ctx.buf_free_idx[len] = '\n';
+	len++;
+        dbglog_fwlog_file_ctx.buf_free_idx += len;
+        dbglog_fwlog_file_ctx.buf_used_size += len;
+        dbglog_fwlog_file_ctx.buf_free_size -= len;
+        va_end(ap);
+        if ((dbglog_fwlog_file_ctx.buf_used_size >= FWLOG_FILE_BUF_THREHOLD) ||
+            ((dbglog_fwlog_file_ctx.file_size + dbglog_fwlog_file_ctx.buf_used_size) >= dbglog_fwlog_file_ctx.file_max_size)) {
+            adf_os_spin_unlock_bh(&dbglog_fwlog_file_ctx.buf_spinlock);
+            dbglog_fwlog_file_flush_buf();
+        } else {
+            adf_os_spin_unlock_bh(&dbglog_fwlog_file_ctx.buf_spinlock);
+	}
+    } else {
+        if (vap_id < DBGLOG_MAX_VDEVID) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (DBGLOG_PRINT_PREFIX "[%u] vap-%u ", timestamp, vap_id));
+        } else {
+            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (DBGLOG_PRINT_PREFIX "[%u] ", timestamp));
+        }
+
+        va_start(ap, fmt);
+        vsnprintf(buf, sizeof(buf), fmt, ap);
+        va_end(ap);
+
+        AR_DEBUG_PRINTF(ATH_DEBUG_INFO, ("%s", buf));
+    }
+#else
     if (vap_id < DBGLOG_MAX_VDEVID) {
         AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (DBGLOG_PRINT_PREFIX "[%u] vap-%u ", timestamp, vap_id));
     } else {
@@ -1384,6 +1610,7 @@
     va_end(ap);
 
     AR_DEBUG_PRINTF(ATH_DEBUG_INFO, ("%s", buf));
+#endif
 }
 
 #define USE_NUMERIC 0
@@ -1393,7 +1620,76 @@
                              A_UINT32 timestamp, A_UINT16 numargs, A_UINT32 *args)
 {
     int i;
+#ifdef CONFIG_WLAN_FWLOG_FILE
+    int len = 0;
+
+    if (dbglog_fwlog_file_ctx.print_to_file) {
+        adf_os_spin_lock_bh(&dbglog_fwlog_file_ctx.buf_spinlock);
+	if (dbglog_fwlog_file_ctx.file_size >= dbglog_fwlog_file_ctx.file_max_size) {
+            adf_os_spin_unlock_bh(&dbglog_fwlog_file_ctx.buf_spinlock);
+            dbglog_fwlog_file_trunc();
+            adf_os_spin_lock_bh(&dbglog_fwlog_file_ctx.buf_spinlock);
+	}
+
+        if (dbglog_fwlog_file_ctx.buf_used_size >= FWLOG_FILE_BUF_MAX_DEFAULT_SIZE) {
+            dbglog_fwlog_file_ctx.overflow++;
+            printk("%s:%d: overflow:%u\n", __func__, __LINE__, dbglog_fwlog_file_ctx.overflow);
+            adf_os_spin_unlock_bh(&dbglog_fwlog_file_ctx.buf_spinlock);
+            return TRUE;
+        }
+
+	if (vap_id < DBGLOG_MAX_VDEVID) {
+            len = snprintf(dbglog_fwlog_file_ctx.buf_free_idx, dbglog_fwlog_file_ctx.buf_free_size,
+                           "[%u] vap-%u %s (", timestamp, vap_id, dbglog_get_msg(mod_id, dbg_id));
+	} else {
+            len = snprintf(dbglog_fwlog_file_ctx.buf_free_idx, dbglog_fwlog_file_ctx.buf_free_size,
+                           "[%u] %s (", timestamp, dbglog_get_msg(mod_id, dbg_id));
+	}
 
+        for (i = 0; i < numargs; i++) {
+#if USE_NUMERIC
+            len += snprintf(dbglog_fwlog_file_ctx.buf_free_idx + len, dbglog_fwlog_file_ctx.buf_free_size - len, "%u", args[i]);
+#else
+            len += snprintf(dbglog_fwlog_file_ctx.buf_free_idx + len, dbglog_fwlog_file_ctx.buf_free_size - len, "%#x", args[i]);
+#endif
+            if ((i + 1) < numargs) {
+                dbglog_fwlog_file_ctx.buf_free_idx[len] = ',';
+                dbglog_fwlog_file_ctx.buf_free_idx[len+1] = ' ';
+                len += 2;
+            }
+        }
+        len += snprintf(dbglog_fwlog_file_ctx.buf_free_idx + len, dbglog_fwlog_file_ctx.buf_free_size - len, " )\n");
+        dbglog_fwlog_file_ctx.buf_free_idx += len;
+        dbglog_fwlog_file_ctx.buf_used_size += len;
+        dbglog_fwlog_file_ctx.buf_free_size -= len;
+        if ((dbglog_fwlog_file_ctx.buf_used_size >= FWLOG_FILE_BUF_THREHOLD) ||
+            ((dbglog_fwlog_file_ctx.file_size + dbglog_fwlog_file_ctx.buf_used_size) >= dbglog_fwlog_file_ctx.file_max_size)) {
+            adf_os_spin_unlock_bh(&dbglog_fwlog_file_ctx.buf_spinlock);
+            dbglog_fwlog_file_flush_buf();
+        } else {
+            adf_os_spin_unlock_bh(&dbglog_fwlog_file_ctx.buf_spinlock);
+	}
+    } else {
+
+        if (vap_id < DBGLOG_MAX_VDEVID) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (DBGLOG_PRINT_PREFIX "[%u] vap-%u %s ( ", timestamp, vap_id, dbglog_get_msg(mod_id, dbg_id)));
+        } else {
+            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (DBGLOG_PRINT_PREFIX "[%u] %s ( ", timestamp, dbglog_get_msg(mod_id, dbg_id)));
+        }
+
+        for (i = 0; i < numargs; i++) {
+#if USE_NUMERIC
+            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, ("%u", args[i]));
+#else
+            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, ("%#x", args[i]));
+#endif
+            if ((i + 1) < numargs) {
+                AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (", "));
+            }
+        }
+        AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (" )\n"));
+    }
+#else
     if (vap_id < DBGLOG_MAX_VDEVID) {
         AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (DBGLOG_PRINT_PREFIX "[%u] vap-%u %s ( ", timestamp, vap_id, dbglog_get_msg(mod_id, dbg_id)));
     } else {
@@ -1411,6 +1707,7 @@
         }
     }
     AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (" )\n"));
+#endif
 
     return TRUE;
 }
@@ -4127,6 +4424,12 @@
     /* Initialize debugfs */
     dbglog_debugfs_init(wmi_handle);
 #endif /* WLAN_OPEN_SOURCE */
+#ifdef CONFIG_WLAN_FWLOG_FILE
+    res = dbglog_fwlog_file_init();
+    if (res != 0) {
+        return res;
+    }
+#endif
 
     return res;
 }
@@ -4136,6 +4439,9 @@
 {
     int res = 0;
 
+#ifdef CONFIG_WLAN_FWLOG_FILE
+    dbglog_fwlog_file_deinit();
+#endif
 #ifdef WLAN_OPEN_SOURCE
     /* DeInitialize the fw debug log queue */
     skb_queue_purge(&wmi_handle->dbglog.fwlog_queue);
diff -urN qcacld-new.orig/CORE/VOSS/inc/vos_memory.h qcacld-new/CORE/VOSS/inc/vos_memory.h
--- qcacld-new.orig/CORE/VOSS/inc/vos_memory.h	2015-09-24 15:25:20.565038328 +0800
+++ qcacld-new/CORE/VOSS/inc/vos_memory.h	2015-09-24 15:25:20.601038328 +0800
@@ -87,6 +87,21 @@
 v_VOID_t * vos_mem_malloc( v_SIZE_t size );
 #endif
 
+#ifdef CONFIG_VOS_MEM_PRE_ALLOC
+#define VOS_PRE_ALLOC_GET_THRESHOLD (16*1024)
+
+struct vos_prealloc {
+	v_UINT_t occupied;
+	v_UINT_t size;
+	v_VOID_t *ptr;
+};
+
+v_UINT_t vos_prealloc_init(v_VOID_t);
+v_VOID_t vos_prealloc_deinit(v_VOID_t);
+v_SINT_t vos_prealloc_put(v_VOID_t *ptr);
+v_VOID_t *vos_prealloc_get(v_UINT_t size);
+
+#endif /* CONFIG_VOS_MEM_PRE_ALLOC */
 
 /*----------------------------------------------------------------------------
 
diff -urN qcacld-new.orig/CORE/VOSS/src/vos_memory.c qcacld-new/CORE/VOSS/src/vos_memory.c
--- qcacld-new.orig/CORE/VOSS/src/vos_memory.c	2015-09-24 15:25:20.565038328 +0800
+++ qcacld-new/CORE/VOSS/src/vos_memory.c	2015-09-24 15:25:20.601038328 +0800
@@ -85,6 +85,33 @@
 /*---------------------------------------------------------------------------
  * Preprocessor Definitions and Constants
  * ------------------------------------------------------------------------*/
+#ifdef CONFIG_VOS_MEM_PRE_ALLOC
+static DEFINE_MUTEX(alloc_lock);
+
+/* pre-alloced at load time
+ * following three definition must fit
+ * to avoid memory corruption */
+#define TOTOTAL_PRELOCATE (32*10 + 64*2 + 128*1 + 256*1)*1024
+static struct vos_prealloc vos_allocs[] = {
+	{0, 32 * 1024, NULL},
+	{0, 32 * 1024, NULL},
+	{0, 32 * 1024, NULL},
+	{0, 32 * 1024, NULL},
+	{0, 32 * 1024, NULL},
+	{0, 32 * 1024, NULL},
+	{0, 32 * 1024, NULL},
+	{0, 32 * 1024, NULL},
+	{0, 32 * 1024, NULL},
+	{0, 32 * 1024, NULL},
+	{0, 64 * 1024, NULL},
+	{0, 64 * 1024, NULL},
+	{0, 128 * 1024, NULL},
+	{0, 256 * 1024, NULL},
+};
+
+v_BYTE_t pre_alloc_pool[TOTOTAL_PRELOCATE];
+
+#endif /* CONFIG_VOS_MEM_PRE_ALLOC */
 
 /*---------------------------------------------------------------------------
  * Type Declarations
@@ -97,6 +124,67 @@
 /*---------------------------------------------------------------------------
  * External Function implementation
  * ------------------------------------------------------------------------*/
+
+#ifdef CONFIG_VOS_MEM_PRE_ALLOC
+
+/* pre-alloced at load time*/
+v_UINT_t vos_prealloc_init(v_VOID_t)
+{
+	v_UINT_t i;
+	v_UINT_t alloc_pos = 0;
+
+	for (i = 0; i < ARRAY_SIZE(vos_allocs); i++) {
+		vos_allocs[i].occupied = 0;
+		vos_allocs[i].ptr = &pre_alloc_pool[alloc_pos];
+		alloc_pos += vos_allocs[i].size;
+		if (alloc_pos > TOTOTAL_PRELOCATE)
+			return -ENOMEM;
+	}
+	return 0;
+}
+v_VOID_t vos_prealloc_deinit(v_VOID_t)
+{
+	v_UINT_t i;
+
+	for (i = 0; i < ARRAY_SIZE(vos_allocs); i++)
+		vos_allocs[i].occupied = 0;
+}
+v_VOID_t *vos_prealloc_get(v_UINT_t size)
+{
+	v_UINT_t i = 0;
+	mutex_lock(&alloc_lock);
+	for (i = 0; i < ARRAY_SIZE(vos_allocs); i++) {
+		if (vos_allocs[i].occupied)
+			continue;
+		if (vos_allocs[i].size > size) {
+			/* we found the slot */
+			vos_allocs[i].occupied = 1;
+			mutex_unlock(&alloc_lock);
+			return vos_allocs[i].ptr;
+		}
+	}
+	VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_FATAL,
+		"vos_pre: %s: prealloc not available at size %d\n", __func__, size);
+	mutex_unlock(&alloc_lock);
+	return NULL;
+}
+
+v_SINT_t vos_prealloc_put(v_VOID_t *ptr)
+{
+	v_UINT_t i = 0;
+	mutex_lock(&alloc_lock);
+	for (i = 0; i < ARRAY_SIZE(vos_allocs); i++) {
+		if (vos_allocs[i].ptr == ptr) {
+			vos_allocs[i].occupied = 0;
+			mutex_unlock(&alloc_lock);
+			return 1;
+		}
+	}
+	mutex_unlock(&alloc_lock);
+	return 0;
+}
+#endif /* CONFIG_VOS_MEM_PRE_ALLOC */
+
 #ifdef MEMORY_DEBUG
 void vos_mem_init()
 {
@@ -206,7 +294,7 @@
 
    if (!memory_dbug_flag)
    {
-#ifdef CONFIG_WCNSS_MEM_PRE_ALLOC
+#if defined(CONFIG_WCNSS_MEM_PRE_ALLOC)
       if (size > WCNSS_PRE_ALLOC_GET_THRESHOLD)
       {
           v_VOID_t *pmem;
@@ -214,6 +302,14 @@
           if (NULL != pmem)
               return pmem;
       }
+#elif defined(CONFIG_VOS_MEM_PRE_ALLOC)
+	if (size > VOS_PRE_ALLOC_GET_THRESHOLD)
+	{
+		v_VOID_t *pmem;
+		pmem = vos_prealloc_get(size);
+		if (NULL != pmem)
+			return pmem;
+	}
 #endif
       return kmalloc(size, flags);
    }
@@ -256,9 +352,12 @@
 
     if (!memory_dbug_flag)
     {
-#ifdef CONFIG_WCNSS_MEM_PRE_ALLOC
+#if defined(CONFIG_WCNSS_MEM_PRE_ALLOC)
         if (wcnss_prealloc_put(ptr))
            return;
+#elif defined(CONFIG_VOS_MEM_PRE_ALLOC)
+		if (vos_prealloc_put(ptr))
+   			return;
 #endif
         kfree(ptr);
     }
@@ -301,7 +400,7 @@
 v_VOID_t * vos_mem_malloc( v_SIZE_t size )
 {
    int flags = GFP_KERNEL;
-#ifdef CONFIG_WCNSS_MEM_PRE_ALLOC
+#if defined(CONFIG_WCNSS_MEM_PRE_ALLOC) || defined(CONFIG_VOS_MEM_PRE_ALLOC)
     v_VOID_t* pmem;
 #endif
    if (size > (1024*1024))
@@ -313,13 +412,20 @@
    {
       flags = GFP_ATOMIC;
    }
-#ifdef CONFIG_WCNSS_MEM_PRE_ALLOC
+#if defined(CONFIG_WCNSS_MEM_PRE_ALLOC)
    if(size > WCNSS_PRE_ALLOC_GET_THRESHOLD)
    {
        pmem = wcnss_prealloc_get(size);
        if(NULL != pmem)
            return pmem;
    }
+#elif defined(CONFIG_VOS_MEM_PRE_ALLOC)
+	if(size > VOS_PRE_ALLOC_GET_THRESHOLD)
+	{
+		pmem = vos_prealloc_get(size);
+		if(NULL != pmem)
+			return pmem;
+	}
 #endif
    return kmalloc(size, flags);
 }
@@ -329,9 +435,12 @@
     if (ptr == NULL)
       return;
 
-#ifdef CONFIG_WCNSS_MEM_PRE_ALLOC
+#if defined(CONFIG_WCNSS_MEM_PRE_ALLOC)
     if(wcnss_prealloc_put(ptr))
         return;
+#elif defined(CONFIG_VOS_MEM_PRE_ALLOC)
+	if(vos_prealloc_put(ptr))
+		return;
 #endif
 
     kfree(ptr);
diff -urN qcacld-new.orig/CORE/WDA/inc/wlan_qct_wda.h qcacld-new/CORE/WDA/inc/wlan_qct_wda.h
--- qcacld-new.orig/CORE/WDA/inc/wlan_qct_wda.h	2015-09-24 15:25:20.569038328 +0800
+++ qcacld-new/CORE/WDA/inc/wlan_qct_wda.h	2015-09-24 15:25:20.601038328 +0800
@@ -1409,6 +1409,12 @@
 #define WDA_APFIND_SET_CMD                    SIR_HAL_APFIND_SET_CMD
 #endif /* WLAN_FEATURE_APFIND */
 
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+#define WDA_WLAN_EXT_WOW                      SIR_HAL_CONFIG_EXT_WOW
+#define WDA_WLAN_SET_APP_TYPE1_PARAMS         SIR_HAL_CONFIG_APP_TYPE1_PARAMS
+#define WDA_WLAN_SET_APP_TYPE2_PARAMS         SIR_HAL_CONFIG_APP_TYPE2_PARAMS
+#endif
+
 tSirRetStatus wdaPostCtrlMsg(tpAniSirGlobal pMac, tSirMsgQ *pMsg);
 
 #define HAL_USE_BD_RATE2_FOR_MANAGEMENT_FRAME 0x40 // Bit 6 will be used to control BD rate for Management frames
diff -urN qcacld-new.orig/firmware_bin/WCNSS_qcom_cfg.usb.ini qcacld-new/firmware_bin/WCNSS_qcom_cfg.usb.ini
--- qcacld-new.orig/firmware_bin/WCNSS_qcom_cfg.usb.ini	2015-09-24 15:25:20.593038328 +0800
+++ qcacld-new/firmware_bin/WCNSS_qcom_cfg.usb.ini	2015-09-24 15:25:20.621038328 +0800
@@ -157,7 +157,7 @@
 
 # 802.11d support
 
-g11dSupportEnabled=1
+g11dSupportEnabled=0
 
 # 802.11h support
 
@@ -335,10 +335,13 @@
 #gGoKeepAlivePeriod/gApKeepAlivePeriod is time to spend to check whether frame are succeed to send or not.
 #Hence total effective detection time is gGoLinkMonitorPeriod+ gGoKeepAlivePeriod/gApLinkMonitorPeriod+ gApKeepAlivePeriod.
 
+gApLinkMonitorPeriod = 45
 
-gGoKeepAlivePeriod = 20
+gGoLinkMonitorPeriod = 45
 
-gApKeepAlivePeriod = 20
+gGoKeepAlivePeriod = 2000
+
+gApKeepAlivePeriod = 2000
 
 
 #If set will start with active scan after driver load, otherwise will start with
@@ -504,13 +507,16 @@
 # Regulatory Setting; 0=STRICT; 1=CUSTOM
 gRegulatoryChangeCountry=1
 
+# Disable change country code from userspace (supplicant)
+gCountryCodePriority = 0
+
 # Disable FW log function by default
 gFwDebugLogType=0
 gFwDebugModuleLoglevel=0,0
 
 # Enable or Disable Rx thread
 # 1=Enable (default), 0=Disable
-gEnableRxThread=0
+gEnableRxThread=1
 
 # Enable or Disable FW self-recovery
 # Currently, It's for USB only.
Binary files qcacld-new.orig/firmware_bin/WCNSS_qcom_wlan_nv.bin and qcacld-new/firmware_bin/WCNSS_qcom_wlan_nv.bin differ
diff -urN qcacld-new.orig/Kbuild qcacld-new/Kbuild
--- qcacld-new.orig/Kbuild	2015-09-24 15:25:20.557038328 +0800
+++ qcacld-new/Kbuild	2015-09-24 15:25:20.593038328 +0800
@@ -211,6 +211,9 @@
 #Enable GTK offload
 CONFIG_GTK_OFFLOAD := 1
 
+ifeq ($(CONFIG_ROME_IF),usb)
+	CONFIG_EXT_WOW := 1
+endif
 #Set this to 1 to catch erroneous Target accesses during debug.
 CONFIG_ATH_PCIE_ACCESS_DEBUG := 0
 endif
@@ -263,6 +266,7 @@
 endif
 
 ############ BAP ############
+ifeq ($(CONFIG_PRIMA_WLAN_BTAMP),y)
 BAP_DIR :=	CORE/BAP
 BAP_INC_DIR :=	$(BAP_DIR)/inc
 BAP_SRC_DIR :=	$(BAP_DIR)/src
@@ -290,6 +294,7 @@
 		$(BAP_SRC_DIR)/bapRsnTxRx.o \
 		$(BAP_SRC_DIR)/btampFsm.o \
 		$(BAP_SRC_DIR)/btampHCI.o
+endif
 
 ifeq ($(CONFIG_QCA_WIFI_SDIO), 1)
 ############ HIF ############
@@ -411,6 +416,11 @@
 HDD_OBJS +=	$(HDD_SRC_DIR)/wlan_hdd_tdls.o
 endif
 
+ifeq ($(CONFIG_DIRECT_AUDIO),y)
+HDD_OBJS +=	$(HDD_SRC_DIR)/wlan_hdd_direct_audio.o
+endif
+
+
 ############ EPPING ############
 EPPING_DIR :=	CORE/EPPING
 EPPING_INC_DIR :=	$(EPPING_DIR)/inc
@@ -933,6 +943,10 @@
 		$(WDI_INC) \
 		$(DFS_INC)
 
+ifeq ($(CONFIG_PRIMA_WLAN_BTAMP),y)
+INCS +=		$(BAP_INC)
+endif
+
 ifeq ($(CONFIG_QCA_WIFI_2_0), 0)
 INCS +=		$(DXE_INC)
 else
@@ -962,8 +976,7 @@
 
 endif
 
-OBJS :=		$(BAP_OBJS) \
-		$(HDD_OBJS) \
+OBJS :=	$(HDD_OBJS) \
 		$(EPPING_OBJS) \
 		$(MAC_OBJS) \
 		$(SAP_OBJS) \
@@ -975,6 +988,10 @@
 		$(WDI_OBJS) \
 		$(DFS_OBJS)
 
+ifeq ($(CONFIG_PRIMA_WLAN_BTAMP),y)
+OBJS +=		$(BAP_OBJS)
+endif
+
 ifeq ($(CONFIG_QCA_WIFI_2_0), 0)
 OBJS +=		$(DXE_OBJS) \
 		$(TL_OBJS)
@@ -1017,7 +1034,6 @@
 		-DWLAN_PERF \
 		-DPTT_SOCK_SVC_ENABLE \
 		-Wall\
-		-Werror\
 		-D__linux__ \
 		-DHAL_SELF_STA_PER_BSS=1 \
 		-DWLAN_FEATURE_VOWIFI_11R \
@@ -1356,6 +1372,11 @@
 CDEFINES += -DIGTK_OFFLOAD
 endif
 
+#Enable GTK Offload
+ifeq ($(CONFIG_EXT_WOW), 1)
+CDEFINES += -DWLAN_FEATURE_EXTWOW_SUPPORT
+endif
+
 #Mark it as SMP Kernel
 ifeq ($(CONFIG_SMP),y)
 CDEFINES += -DQCA_CONFIG_SMP
@@ -1449,6 +1470,31 @@
 endif
 endif
 
+ifeq ($(CONFIG_DIRECT_AUDIO),y)
+CDEFINES += -DDIRECT_AUDIO_SUPPORT
+endif
+
+ifeq ($(CONFIG_VOS_MEM_PRE_ALLOC),y)
+CDEFINES += -DCONFIG_VOS_MEM_PRE_ALLOC
+endif
+
+ifeq ($(CONFIG_USB_PRELOAD),y)
+CDEFINES += -DCONFIG_USB_PRELOAD
+endif
+
+ifeq ($(CONFIG_SS_REGULATORY),y)
+CDEFINES += -DSS_REGULATORY
+endif
+
+ifeq ($(CONFIG_TIZEN_PLATFORM),y)
+CDEFINES += -DCONFIG_TIZEN_PLATFORM
+ifeq ($(CONFIG_FWCRASH_DUMP),y)
+CDEFINES += -DCONFIG_CRASH_DUMP_CLD
+CDEFINES += -DCONFIG_CRASH_DUMP_STACK
+CDEFINES += -DCONFIG_WLAN_FWLOG_FILE
+endif
+endif
+
 KBUILD_CPPFLAGS += $(CDEFINES)
 
 # Currently, for versions of gcc which support it, the kernel Makefile
diff -urN qcacld-new.orig/Kbuild.orig qcacld-new/Kbuild.orig
--- qcacld-new.orig/Kbuild.orig	1970-01-01 08:00:00.000000000 +0800
+++ qcacld-new/Kbuild.orig	2015-09-24 15:25:20.621038328 +0800
@@ -0,0 +1,1478 @@
+# We can build either as part of a standalone Kernel build or as
+# an external module.  Determine which mechanism is being used
+ifeq ($(MODNAME),)
+	KERNEL_BUILD := 1
+else
+	KERNEL_BUILD := 0
+endif
+
+ifeq ($(CONFIG_CLD_HL_SDIO_CORE), y)
+	CONFIG_QCA_WIFI_SDIO := 1
+endif
+
+ifeq ($(CONFIG_QCA_WIFI_SDIO), 1)
+	CONFIG_ROME_IF = sdio
+endif
+
+ifndef CONFIG_ROME_IF
+	#use pci as default interface
+	CONFIG_ROME_IF = pci
+endif
+
+ifeq ($(KERNEL_BUILD),1)
+	# These are provided in external module based builds
+	# Need to explicitly define for Kernel-based builds
+	MODNAME := wlan
+	WLAN_ROOT := drivers/staging/qcacld-2.0
+	WLAN_OPEN_SOURCE := 1
+endif
+
+ifeq ($(KERNEL_BUILD), 0)
+	# These are configurable via Kconfig for kernel-based builds
+	# Need to explicitly configure for Android-based builds
+
+	#Flag to enable BlueTooth AMP feature
+	CONFIG_PRIMA_WLAN_BTAMP := n
+
+	#Flag to enable Legacy Fast Roaming(LFR)
+	CONFIG_PRIMA_WLAN_LFR := y
+
+	#JB kernel has PMKSA patches, hence enabling this flag
+	CONFIG_PRIMA_WLAN_OKC := y
+
+	# JB kernel has CPU enablement patches, so enable
+	ifeq ($(CONFIG_ROME_IF),pci)
+		CONFIG_PRIMA_WLAN_11AC_HIGH_TP := y
+	endif
+	ifeq ($(CONFIG_ROME_IF),usb)
+		CONFIG_PRIMA_WLAN_11AC_HIGH_TP := n
+	endif
+	ifeq ($(CONFIG_ROME_IF),sdio)
+		CONFIG_PRIMA_WLAN_11AC_HIGH_TP := n
+	endif
+	#Flag to enable TDLS feature
+	CONFIG_QCOM_TDLS := y
+
+	#Flag to enable Fast Transition (11r) feature
+	CONFIG_QCOM_VOWIFI_11R := y
+
+        ifneq ($(CONFIG_QCA_CLD_WLAN),)
+                ifeq ($(CONFIG_CNSS),y)
+        #Flag to enable Protected Managment Frames (11w) feature
+                CONFIG_WLAN_FEATURE_11W := y
+        #Flag to enable LTE CoEx feature
+                CONFIG_QCOM_LTE_COEX := y
+        #Flag to enable LPSS feature
+                CONFIG_WLAN_FEATURE_LPSS := y
+                endif
+        endif
+
+	#Flag to enable new Linux Regulatory implementation
+	CONFIG_ENABLE_LINUX_REG := y
+
+        #Flag to enable Protected Managment Frames (11w) feature
+        ifeq ($(CONFIG_ROME_IF),usb)
+                CONFIG_WLAN_FEATURE_11W := y
+        endif
+        ifeq ($(CONFIG_ROME_IF),sdio)
+                CONFIG_WLAN_FEATURE_11W := y
+        endif
+
+	#Flag to enable NAN
+	CONFIG_FEATURE_NAN := y
+
+        #Flag to enable Linux QCMBR feature as default feature
+        ifeq ($(CONFIG_ROME_IF),usb)
+                CONFIG_LINUX_QCMBR :=y
+        endif
+endif
+
+ifeq ($(CONFIG_X86), y)
+CONFIG_NON_QC_PLATFORM := y
+endif
+
+# To enable ESE upload, dependent config
+# CONFIG_QCOM_ESE must be enabled.
+CONFIG_QCOM_ESE := n
+CONFIG_QCOM_ESE_UPLOAD := n
+
+# Feature flags which are not (currently) configurable via Kconfig
+
+#Whether to build debug version
+BUILD_DEBUG_VERSION := 1
+
+#Enable this flag to build driver in diag version
+BUILD_DIAG_VERSION := 1
+
+#Do we panic on bug?  default is to warn
+PANIC_ON_BUG := 1
+
+#Re-enable wifi on WDI timeout
+RE_ENABLE_WIFI_ON_WDI_TIMEOUT := 0
+
+ifeq ($(CONFIG_QCA_WIFI_2_0), 1)
+#Enable OS specific ADF abstraction
+CONFIG_ADF_SUPPORT := 1
+
+#Enable OL debug and wmi unified functions
+CONFIG_ATH_PERF_PWR_OFFLOAD := 1
+
+#Disable packet log
+CONFIG_REMOVE_PKT_LOG := 0
+
+#Enable 11AC TX
+ifeq ($(CONFIG_ROME_IF),pci)
+	CONFIG_ATH_11AC_TXCOMPACT := 1
+endif
+ifeq ($(CONFIG_ROME_IF),usb)
+	CONFIG_ATH_11AC_TXCOMPACT := 0
+endif
+ifeq ($(CONFIG_QCA_WIFI_SDIO), 1)
+CONFIG_ATH_11AC_TXCOMPACT := 0
+endif
+
+#Enable per vdev Tx desc pool
+ifeq ($(CONFIG_ROME_IF),pci)
+	CONFIG_PER_VDEV_TX_DESC_POOL := 0
+endif
+ifeq ($(CONFIG_ROME_IF),usb)
+	CONFIG_PER_VDEV_TX_DESC_POOL := 1
+endif
+ifeq ($(CONFIG_QCA_WIFI_SDIO), 1)
+	CONFIG_PER_VDEV_TX_DESC_POOL := 0
+endif
+
+
+#Enable OS specific IRQ abstraction
+CONFIG_ATH_SUPPORT_SHARED_IRQ := 1
+
+#Enable message based HIF instead of RAW access in BMI
+ifeq ($(CONFIG_QCA_WIFI_SDIO), 1)
+CONFIG_HIF_MESSAGE_BASED := 0
+else
+CONFIG_HIF_MESSAGE_BASED := 1
+endif
+
+#Enable PCI specific APIS (dma, etc)
+ifeq ($(CONFIG_ROME_IF),pci)
+	CONFIG_HIF_PCI := 1
+endif
+#Enable USB specific APIS
+ifeq ($(CONFIG_ROME_IF),usb)
+	CONFIG_HIF_USB := 1
+endif
+
+#Enable pci read/write config functions
+ifeq ($(CONFIG_ROME_IF),pci)
+	CONFIG_ATH_PCI := 1
+endif
+ifeq ($(CONFIG_ROME_IF),usb)
+#CONFIG_ATH_PCI := 1
+endif
+
+#Enable IBSS support on CLD
+CONFIG_QCA_IBSS_SUPPORT := 1
+
+#Enable MDNS Offload
+ifeq ($(CONFIG_QCA_WIFI_SDIO), 1)
+CONFIG_MDNS_OFFLOAD_SUPPORT := 1
+endif
+
+#Enable power management suspend/resume functionality to PCI
+CONFIG_ATH_BUS_PM := 1
+
+#Enable dword alignment for IP header
+CONFIG_IP_HDR_ALIGNMENT := 0
+
+#Enable FLOWMAC module support
+CONFIG_ATH_SUPPORT_FLOWMAC_MODULE := 0
+
+#Enable spectral support
+CONFIG_ATH_SUPPORT_SPECTRAL := 0
+
+#Enable HOST statistics support
+CONFIG_SUPPORT_HOST_STATISTICS := 0
+
+#Enable WDI Event support
+CONFIG_WDI_EVENT_ENABLE := 1
+
+#Endianess selection
+CONFIG_LITTLE_ENDIAN := 1
+
+#Enable TX reclaim support
+CONFIG_TX_CREDIT_RECLAIM_SUPPORT := 0
+
+#Enable FTM support
+CONFIG_QCA_WIFI_FTM := 1
+
+#Enable Checksum Offload
+CONFIG_CHECKSUM_OFFLOAD := 1
+
+#Enable GTK offload
+CONFIG_GTK_OFFLOAD := 1
+
+#Enable EXT WOW
+ifeq ($(CONFIG_ROME_IF),pci)
+	CONFIG_EXT_WOW := 1
+endif
+
+#Set this to 1 to catch erroneous Target accesses during debug.
+CONFIG_ATH_PCIE_ACCESS_DEBUG := 0
+endif
+
+#Enable IPA offload
+ifeq ($(CONFIG_IPA), y)
+CONFIG_IPA_OFFLOAD := 1
+CONFIG_IPA_UC_OFFLOAD := 1
+endif
+
+#Enable Signed firmware support for split binary format
+CONFIG_QCA_SIGNED_SPLIT_BINARY_SUPPORT := 0
+
+#Enable single firmware binary format
+CONFIG_QCA_SINGLE_BINARY_SUPPORT := 0
+
+#Enable collecting target RAM dump after kernel panic
+CONFIG_TARGET_RAMDUMP_AFTER_KERNEL_PANIC := 1
+
+#Flag to enable Stats Ext implementation
+CONFIG_FEATURE_STATS_EXT := 1
+
+
+ifeq ($(CONFIG_CFG80211),y)
+HAVE_CFG80211 := 1
+else
+ifeq ($(CONFIG_CFG80211),m)
+HAVE_CFG80211 := 1
+else
+HAVE_CFG80211 := 0
+endif
+endif
+
+ifeq ($(CONFIG_QCA_WIFI_2_0), 1)
+############ COMMON ############
+COMMON_DIR :=	CORE/SERVICES/COMMON
+COMMON_INC :=	-I$(WLAN_ROOT)/$(COMMON_DIR)
+
+############ ADF ##############
+ADF_DIR	:=	$(COMMON_DIR)/adf
+ADF_INC :=	-I$(WLAN_ROOT)/$(ADF_DIR) \
+		-I$(WLAN_ROOT)/$(ADF_DIR)/linux \
+		-I$(WLAN_ROOT)/$(COMMON_DIR)/asf
+
+ADF_OBJS :=     $(ADF_DIR)/adf_nbuf.o \
+                $(ADF_DIR)/adf_os_lock.o \
+                $(ADF_DIR)/adf_os_mem.o \
+                $(ADF_DIR)/linux/adf_os_defer_pvt.o \
+                $(ADF_DIR)/linux/adf_os_lock_pvt.o
+endif
+
+############ BAP ############
+BAP_DIR :=	CORE/BAP
+BAP_INC_DIR :=	$(BAP_DIR)/inc
+BAP_SRC_DIR :=	$(BAP_DIR)/src
+
+BAP_INC := 	-I$(WLAN_ROOT)/$(BAP_INC_DIR) \
+		-I$(WLAN_ROOT)/$(BAP_SRC_DIR)
+
+BAP_OBJS := 	$(BAP_SRC_DIR)/bapApiData.o \
+		$(BAP_SRC_DIR)/bapApiDebug.o \
+		$(BAP_SRC_DIR)/bapApiExt.o \
+		$(BAP_SRC_DIR)/bapApiHCBB.o \
+		$(BAP_SRC_DIR)/bapApiInfo.o \
+		$(BAP_SRC_DIR)/bapApiLinkCntl.o \
+		$(BAP_SRC_DIR)/bapApiLinkSupervision.o \
+		$(BAP_SRC_DIR)/bapApiStatus.o \
+		$(BAP_SRC_DIR)/bapApiTimer.o \
+		$(BAP_SRC_DIR)/bapModule.o \
+		$(BAP_SRC_DIR)/bapRsn8021xAuthFsm.o \
+		$(BAP_SRC_DIR)/bapRsn8021xPrf.o \
+		$(BAP_SRC_DIR)/bapRsn8021xSuppRsnFsm.o \
+		$(BAP_SRC_DIR)/bapRsnAsfPacket.o \
+		$(BAP_SRC_DIR)/bapRsnSsmAesKeyWrap.o \
+		$(BAP_SRC_DIR)/bapRsnSsmEapol.o \
+		$(BAP_SRC_DIR)/bapRsnSsmReplayCtr.o \
+		$(BAP_SRC_DIR)/bapRsnTxRx.o \
+		$(BAP_SRC_DIR)/btampFsm.o \
+		$(BAP_SRC_DIR)/btampHCI.o
+
+ifeq ($(CONFIG_QCA_WIFI_SDIO), 1)
+############ HIF ############
+HIF_DIR := CORE/SERVICES/HIF
+HIF_DIR_OBJS :=  $(HIF_DIR)/ath_procfs.o
+
+HIF_COMMON_DIR := CORE/SERVICES/HIF/common
+HIF_COMMON_OBJS := $(HIF_COMMON_DIR)/hif_bmi_reg_access.o \
+                   $(HIF_COMMON_DIR)/hif_diag_reg_access.o
+
+HIF_SDIO_DIR := CORE/SERVICES/HIF/sdio
+HIF_SDIO_OBJS := $(HIF_SDIO_DIR)/hif_sdio_send.o \
+                 $(HIF_SDIO_DIR)/hif_sdio_dev.o \
+                 $(HIF_SDIO_DIR)/hif_sdio.o \
+                 $(HIF_SDIO_DIR)/hif_sdio_recv.o \
+                 $(HIF_SDIO_DIR)/regtable.o \
+
+HIF_SDIO_LINUX_DIR := $(HIF_SDIO_DIR)/linux
+HIF_SDIO_LINUX_OBJS := $(HIF_SDIO_LINUX_DIR)/if_ath_sdio.o
+
+
+HIF_SDIO_NATIVE_DIR := $(HIF_SDIO_LINUX_DIR)/native_sdio
+HIF_SDIO_NATIVE_INC_DIR := $(HIF_SDIO_NATIVE_DIR)/include
+HIF_SDIO_NATIVE_SRC_DIR := $(HIF_SDIO_NATIVE_DIR)/src
+
+HIF_SDIO_NATIVE_OBJS := $(HIF_SDIO_NATIVE_SRC_DIR)/hif.o \
+                        $(HIF_SDIO_NATIVE_SRC_DIR)/hif_scatter.o
+
+HIF_INC := -I$(WLAN_ROOT)/$(HIF_COMMON_DIR) \
+           -I$(WLAN_ROOT)/$(HIF_SDIO_DIR) \
+           -I$(WLAN_ROOT)/$(HIF_SDIO_LINUX_DIR) \
+           -I$(WLAN_ROOT)/$(HIF_SDIO_NATIVE_INC_DIR) \
+           -I$(WLAN_ROOT)/$(HIF_SDIO_NATIVE_SRC_DIR)
+
+HIF_OBJS := $(HIF_DIR_OBJS)\
+			$(HIF_COMMON_OBJS)\
+            $(HIF_SDIO_OBJS)\
+            $(HIF_SDIO_LINUX_OBJS)\
+            $(HIF_SDIO_NATIVE_OBJS)
+else
+############ DXE ############
+DXE_DIR :=	CORE/DXE
+DXE_INC_DIR :=	$(DXE_DIR)/inc
+DXE_SRC_DIR :=	$(DXE_DIR)/src
+
+DXE_INC := 	-I$(WLAN_ROOT)/$(DXE_INC_DIR) \
+		-I$(WLAN_ROOT)/$(DXE_SRC_DIR)
+
+HIF_DXE_DIR :=  CORE/SERVICES/HIF/DXE
+HIF_DXE_INC :=  -I$(WLAN_ROOT)/$(HIF_DXE_DIR)
+
+ifeq ($(CONFIG_QCA_WIFI_2_0), 0)
+DXE_OBJS =      $(DXE_SRC_DIR)/wlan_qct_dxe.o \
+                $(DXE_SRC_DIR)/wlan_qct_dxe_cfg_i.o
+else
+ifeq ($(CONFIG_QCA_WIFI_ISOC), 1)
+HIF_DXE_INC :=  -I$(WLAN_ROOT)/$(HIF_DXE_DIR) \
+		-I$(WLAN_ROOT)/$(HIF_DXE_DIR)/linux
+
+HIF_DXE_OBJS:=  $(HIF_DXE_DIR)/hif_dxe.o \
+                $(HIF_DXE_DIR)/hif_dxe_config.o \
+                $(HIF_DXE_DIR)/linux/hif_dxe_os.o \
+                $(HIF_DXE_DIR)/dmux_dxe.o \
+                $(DXE_DIR)/htt_dxe_tx.o \
+                $(DXE_DIR)/htt_dxe_fw_stats.o \
+                $(DXE_DIR)/htt_dxe_h2t.o \
+                $(DXE_DIR)/htt_dxe_t2h.o \
+                $(DXE_DIR)/htt_dxe.o \
+                $(DXE_DIR)/htt_dxe_rx.o
+
+DXE_INC += $(HIF_DXE_INC)
+DXE_OBJS := $(HIF_DXE_OBJS)
+endif
+endif
+endif
+
+############ HDD ############
+HDD_DIR :=	CORE/HDD
+HDD_INC_DIR :=	$(HDD_DIR)/inc
+HDD_SRC_DIR :=	$(HDD_DIR)/src
+
+HDD_INC := 	-I$(WLAN_ROOT)/$(HDD_INC_DIR) \
+		-I$(WLAN_ROOT)/$(HDD_SRC_DIR)
+
+HDD_OBJS := 	$(HDD_SRC_DIR)/bap_hdd_main.o \
+		$(HDD_SRC_DIR)/wlan_hdd_assoc.o \
+		$(HDD_SRC_DIR)/wlan_hdd_cfg.o \
+		$(HDD_SRC_DIR)/wlan_hdd_debugfs.o \
+		$(HDD_SRC_DIR)/wlan_hdd_dev_pwr.o \
+		$(HDD_SRC_DIR)/wlan_hdd_dp_utils.o \
+		$(HDD_SRC_DIR)/wlan_hdd_early_suspend.o \
+		$(HDD_SRC_DIR)/wlan_hdd_ftm.o \
+		$(HDD_SRC_DIR)/wlan_hdd_hostapd.o \
+		$(HDD_SRC_DIR)/wlan_hdd_main.o \
+		$(HDD_SRC_DIR)/wlan_hdd_mib.o \
+		$(HDD_SRC_DIR)/wlan_hdd_oemdata.o \
+		$(HDD_SRC_DIR)/wlan_hdd_scan.o \
+		$(HDD_SRC_DIR)/wlan_hdd_softap_tx_rx.o \
+		$(HDD_SRC_DIR)/wlan_hdd_tx_rx.o \
+		$(HDD_SRC_DIR)/wlan_hdd_trace.o \
+		$(HDD_SRC_DIR)/wlan_hdd_wext.o \
+		$(HDD_SRC_DIR)/wlan_hdd_wmm.o \
+		$(HDD_SRC_DIR)/wlan_hdd_wowl.o
+
+ifeq ($(CONFIG_IPA_OFFLOAD), 1)
+HDD_OBJS +=	$(HDD_SRC_DIR)/wlan_hdd_ipa.o
+endif
+
+ifeq ($(CONFIG_MDNS_OFFLOAD_SUPPORT), 1)
+HDD_OBJS +=	$(HDD_SRC_DIR)/wlan_hdd_mdns_offload.o
+endif
+
+ifeq ($(HAVE_CFG80211),1)
+HDD_OBJS +=	$(HDD_SRC_DIR)/wlan_hdd_cfg80211.o \
+		$(HDD_SRC_DIR)/wlan_hdd_p2p.o
+endif
+
+ifeq ($(CONFIG_QCOM_TDLS),y)
+HDD_OBJS +=	$(HDD_SRC_DIR)/wlan_hdd_tdls.o
+endif
+
+############ EPPING ############
+EPPING_DIR :=	CORE/EPPING
+EPPING_INC_DIR :=	$(EPPING_DIR)/inc
+EPPING_SRC_DIR :=	$(EPPING_DIR)/src
+
+EPPING_INC := 	-I$(WLAN_ROOT)/$(EPPING_INC_DIR)
+
+EPPING_OBJS := $(EPPING_SRC_DIR)/epping_main.o \
+		$(EPPING_SRC_DIR)/epping_txrx.o \
+		$(EPPING_SRC_DIR)/epping_tx.o \
+		$(EPPING_SRC_DIR)/epping_rx.o \
+		$(EPPING_SRC_DIR)/epping_helper.o \
+
+
+############ MAC ############
+MAC_DIR :=	CORE/MAC
+MAC_INC_DIR :=	$(MAC_DIR)/inc
+MAC_SRC_DIR :=	$(MAC_DIR)/src
+
+MAC_INC := 	-I$(WLAN_ROOT)/$(MAC_INC_DIR) \
+		-I$(WLAN_ROOT)/$(MAC_SRC_DIR)/dph \
+		-I$(WLAN_ROOT)/$(MAC_SRC_DIR)/include \
+		-I$(WLAN_ROOT)/$(MAC_SRC_DIR)/pe/include \
+		-I$(WLAN_ROOT)/$(MAC_SRC_DIR)/pe/lim
+
+MAC_CFG_OBJS := $(MAC_SRC_DIR)/cfg/cfgApi.o \
+		$(MAC_SRC_DIR)/cfg/cfgDebug.o \
+		$(MAC_SRC_DIR)/cfg/cfgParamName.o \
+		$(MAC_SRC_DIR)/cfg/cfgProcMsg.o \
+		$(MAC_SRC_DIR)/cfg/cfgSendMsg.o
+
+MAC_DPH_OBJS :=	$(MAC_SRC_DIR)/dph/dphHashTable.o
+
+MAC_LIM_OBJS := $(MAC_SRC_DIR)/pe/lim/limAIDmgmt.o \
+		$(MAC_SRC_DIR)/pe/lim/limAdmitControl.o \
+		$(MAC_SRC_DIR)/pe/lim/limApi.o \
+		$(MAC_SRC_DIR)/pe/lim/limAssocUtils.o \
+		$(MAC_SRC_DIR)/pe/lim/limDebug.o \
+		$(MAC_SRC_DIR)/pe/lim/limFT.o \
+		$(MAC_SRC_DIR)/pe/lim/limIbssPeerMgmt.o \
+		$(MAC_SRC_DIR)/pe/lim/limLinkMonitoringAlgo.o \
+		$(MAC_SRC_DIR)/pe/lim/limLogDump.o \
+		$(MAC_SRC_DIR)/pe/lim/limP2P.o \
+		$(MAC_SRC_DIR)/pe/lim/limProcessActionFrame.o \
+		$(MAC_SRC_DIR)/pe/lim/limProcessAssocReqFrame.o \
+		$(MAC_SRC_DIR)/pe/lim/limProcessAssocRspFrame.o \
+		$(MAC_SRC_DIR)/pe/lim/limProcessAuthFrame.o \
+		$(MAC_SRC_DIR)/pe/lim/limProcessBeaconFrame.o \
+		$(MAC_SRC_DIR)/pe/lim/limProcessCfgUpdates.o \
+		$(MAC_SRC_DIR)/pe/lim/limProcessDeauthFrame.o \
+		$(MAC_SRC_DIR)/pe/lim/limProcessDisassocFrame.o \
+		$(MAC_SRC_DIR)/pe/lim/limProcessLmmMessages.o \
+		$(MAC_SRC_DIR)/pe/lim/limProcessMessageQueue.o \
+		$(MAC_SRC_DIR)/pe/lim/limProcessMlmReqMessages.o \
+		$(MAC_SRC_DIR)/pe/lim/limProcessMlmRspMessages.o \
+		$(MAC_SRC_DIR)/pe/lim/limProcessProbeReqFrame.o \
+		$(MAC_SRC_DIR)/pe/lim/limProcessProbeRspFrame.o \
+		$(MAC_SRC_DIR)/pe/lim/limProcessSmeReqMessages.o \
+		$(MAC_SRC_DIR)/pe/lim/limPropExtsUtils.o \
+		$(MAC_SRC_DIR)/pe/lim/limRoamingAlgo.o \
+		$(MAC_SRC_DIR)/pe/lim/limScanResultUtils.o \
+		$(MAC_SRC_DIR)/pe/lim/limSecurityUtils.o \
+		$(MAC_SRC_DIR)/pe/lim/limSendManagementFrames.o \
+		$(MAC_SRC_DIR)/pe/lim/limSendMessages.o \
+		$(MAC_SRC_DIR)/pe/lim/limSendSmeRspMessages.o \
+		$(MAC_SRC_DIR)/pe/lim/limSerDesUtils.o \
+		$(MAC_SRC_DIR)/pe/lim/limSession.o \
+		$(MAC_SRC_DIR)/pe/lim/limSessionUtils.o \
+		$(MAC_SRC_DIR)/pe/lim/limSmeReqUtils.o \
+		$(MAC_SRC_DIR)/pe/lim/limStaHashApi.o \
+		$(MAC_SRC_DIR)/pe/lim/limTimerUtils.o \
+		$(MAC_SRC_DIR)/pe/lim/limTrace.o \
+		$(MAC_SRC_DIR)/pe/lim/limUtils.o
+
+ifeq ($(CONFIG_QCOM_ESE),y)
+ifneq ($(CONFIG_QCOM_ESE_UPLOAD),y)
+MAC_LIM_OBJS += $(MAC_SRC_DIR)/pe/lim/limProcessEseFrame.o
+endif
+endif
+
+ifeq ($(CONFIG_QCOM_TDLS),y)
+MAC_LIM_OBJS += $(MAC_SRC_DIR)/pe/lim/limProcessTdls.o
+endif
+
+MAC_PMM_OBJS := $(MAC_SRC_DIR)/pe/pmm/pmmAP.o \
+		$(MAC_SRC_DIR)/pe/pmm/pmmApi.o \
+		$(MAC_SRC_DIR)/pe/pmm/pmmDebug.o
+
+MAC_SCH_OBJS := $(MAC_SRC_DIR)/pe/sch/schApi.o \
+		$(MAC_SRC_DIR)/pe/sch/schBeaconGen.o \
+		$(MAC_SRC_DIR)/pe/sch/schBeaconProcess.o \
+		$(MAC_SRC_DIR)/pe/sch/schDebug.o \
+		$(MAC_SRC_DIR)/pe/sch/schMessage.o
+
+MAC_RRM_OBJS :=	$(MAC_SRC_DIR)/pe/rrm/rrmApi.o
+
+MAC_OBJS := 	$(MAC_CFG_OBJS) \
+		$(MAC_DPH_OBJS) \
+		$(MAC_LIM_OBJS) \
+		$(MAC_PMM_OBJS) \
+		$(MAC_SCH_OBJS) \
+		$(MAC_RRM_OBJS)
+
+############ SAP ############
+SAP_DIR :=	CORE/SAP
+SAP_INC_DIR :=	$(SAP_DIR)/inc
+SAP_SRC_DIR :=	$(SAP_DIR)/src
+
+SAP_INC := 	-I$(WLAN_ROOT)/$(SAP_INC_DIR) \
+		-I$(WLAN_ROOT)/$(SAP_SRC_DIR)
+
+SAP_OBJS :=	$(SAP_SRC_DIR)/sapApiLinkCntl.o \
+		$(SAP_SRC_DIR)/sapChSelect.o \
+		$(SAP_SRC_DIR)/sapFsm.o \
+		$(SAP_SRC_DIR)/sapModule.o
+
+############ DFS ############ 350
+DFS_DIR :=	CORE/SERVICES/DFS
+DFS_INC_DIR :=	$(DFS_DIR)/inc
+DFS_SRC_DIR :=	$(DFS_DIR)/src
+
+DFS_INC :=	-I$(WLAN_ROOT)/$(DFS_INC_DIR) \
+		-I$(WLAN_ROOT)/$(DFS_SRC_DIR)
+
+DFS_OBJS :=	$(DFS_SRC_DIR)/dfs_bindetects.o \
+		$(DFS_SRC_DIR)/dfs.o \
+		$(DFS_SRC_DIR)/dfs_debug.o\
+		$(DFS_SRC_DIR)/dfs_fcc_bin5.o\
+		$(DFS_SRC_DIR)/dfs_init.o\
+		$(DFS_SRC_DIR)/dfs_misc.o\
+		$(DFS_SRC_DIR)/dfs_nol.o\
+		$(DFS_SRC_DIR)/dfs_phyerr_tlv.o\
+		$(DFS_SRC_DIR)/dfs_process_phyerr.o\
+		$(DFS_SRC_DIR)/dfs_process_radarevent.o\
+		$(DFS_SRC_DIR)/dfs_staggered.o
+
+############ SME ############
+SME_DIR :=	CORE/SME
+SME_INC_DIR :=	$(SME_DIR)/inc
+SME_SRC_DIR :=	$(SME_DIR)/src
+
+SME_INC := 	-I$(WLAN_ROOT)/$(SME_INC_DIR) \
+		-I$(WLAN_ROOT)/$(SME_SRC_DIR)/csr
+
+SME_CCM_OBJS := $(SME_SRC_DIR)/ccm/ccmApi.o \
+		$(SME_SRC_DIR)/ccm/ccmLogDump.o
+
+SME_CSR_OBJS := $(SME_SRC_DIR)/csr/csrApiRoam.o \
+		$(SME_SRC_DIR)/csr/csrApiScan.o \
+		$(SME_SRC_DIR)/csr/csrCmdProcess.o \
+		$(SME_SRC_DIR)/csr/csrLinkList.o \
+		$(SME_SRC_DIR)/csr/csrLogDump.o \
+		$(SME_SRC_DIR)/csr/csrNeighborRoam.o \
+		$(SME_SRC_DIR)/csr/csrUtil.o
+
+ifeq ($(CONFIG_QCOM_ESE),y)
+ifneq ($(CONFIG_QCOM_ESE_UPLOAD),y)
+SME_CSR_OBJS += $(SME_SRC_DIR)/csr/csrEse.o
+endif
+endif
+
+ifeq ($(CONFIG_QCOM_TDLS),y)
+SME_CSR_OBJS += $(SME_SRC_DIR)/csr/csrTdlsProcess.o
+endif
+
+SME_PMC_OBJS := $(SME_SRC_DIR)/pmc/pmcApi.o \
+		$(SME_SRC_DIR)/pmc/pmc.o \
+		$(SME_SRC_DIR)/pmc/pmcLogDump.o
+
+SME_QOS_OBJS := $(SME_SRC_DIR)/QoS/sme_Qos.o
+
+SME_CMN_OBJS := $(SME_SRC_DIR)/sme_common/sme_Api.o \
+		$(SME_SRC_DIR)/sme_common/sme_FTApi.o \
+		$(SME_SRC_DIR)/sme_common/sme_Trace.o
+
+SME_BTC_OBJS := $(SME_SRC_DIR)/btc/btcApi.o
+
+SME_OEM_DATA_OBJS := $(SME_SRC_DIR)/oemData/oemDataApi.o
+
+SME_P2P_OBJS = $(SME_SRC_DIR)/p2p/p2p_Api.o
+
+SME_RRM_OBJS := $(SME_SRC_DIR)/rrm/sme_rrm.o
+
+ifeq ($(CONFIG_FEATURE_NAN),y)
+SME_NAN_OBJS = $(SME_SRC_DIR)/nan/nan_Api.o
+endif
+
+SME_OBJS :=	$(SME_BTC_OBJS) \
+		$(SME_CCM_OBJS) \
+		$(SME_CMN_OBJS) \
+		$(SME_CSR_OBJS) \
+		$(SME_OEM_DATA_OBJS) \
+		$(SME_P2P_OBJS) \
+		$(SME_PMC_OBJS) \
+		$(SME_QOS_OBJS) \
+		$(SME_RRM_OBJS) \
+		$(SME_NAN_OBJS)
+
+############ SVC ############
+SVC_DIR :=	CORE/SVC
+SVC_INC_DIR :=	$(SVC_DIR)/inc
+SVC_SRC_DIR :=	$(SVC_DIR)/src
+
+SVC_INC := 	-I$(WLAN_ROOT)/$(SVC_INC_DIR) \
+		-I$(WLAN_ROOT)/$(SVC_DIR)/external
+
+BTC_SRC_DIR :=	$(SVC_SRC_DIR)/btc
+BTC_OBJS :=	$(BTC_SRC_DIR)/wlan_btc_svc.o
+
+NLINK_SRC_DIR := $(SVC_SRC_DIR)/nlink
+NLINK_OBJS :=	$(NLINK_SRC_DIR)/wlan_nlink_srv.o
+
+PTT_SRC_DIR :=	$(SVC_SRC_DIR)/ptt
+PTT_OBJS :=	$(PTT_SRC_DIR)/wlan_ptt_sock_svc.o
+
+WLAN_LOGGING_SRC_DIR := $(SVC_SRC_DIR)/logging
+WLAN_LOGGING_OBJS := $(WLAN_LOGGING_SRC_DIR)/wlan_logging_sock_svc.o
+
+SVC_OBJS :=	$(BTC_OBJS) \
+		$(NLINK_OBJS) \
+		$(PTT_OBJS) \
+		$(WLAN_LOGGING_OBJS)
+
+############ SYS ############
+SYS_DIR :=	CORE/SYS
+
+SYS_INC := 	-I$(WLAN_ROOT)/$(SYS_DIR)/common/inc \
+		-I$(WLAN_ROOT)/$(SYS_DIR)/legacy/src/pal/inc \
+		-I$(WLAN_ROOT)/$(SYS_DIR)/legacy/src/platform/inc \
+		-I$(WLAN_ROOT)/$(SYS_DIR)/legacy/src/system/inc \
+		-I$(WLAN_ROOT)/$(SYS_DIR)/legacy/src/utils/inc
+
+SYS_COMMON_SRC_DIR := $(SYS_DIR)/common/src
+SYS_LEGACY_SRC_DIR := $(SYS_DIR)/legacy/src
+SYS_OBJS :=	$(SYS_COMMON_SRC_DIR)/wlan_qct_sys.o \
+		$(SYS_LEGACY_SRC_DIR)/pal/src/palApiComm.o \
+		$(SYS_LEGACY_SRC_DIR)/pal/src/palTimer.o \
+		$(SYS_LEGACY_SRC_DIR)/platform/src/VossWrapper.o \
+		$(SYS_LEGACY_SRC_DIR)/system/src/macInitApi.o \
+		$(SYS_LEGACY_SRC_DIR)/system/src/sysEntryFunc.o \
+		$(SYS_LEGACY_SRC_DIR)/utils/src/dot11f.o \
+		$(SYS_LEGACY_SRC_DIR)/utils/src/logApi.o \
+		$(SYS_LEGACY_SRC_DIR)/utils/src/logDump.o \
+		$(SYS_LEGACY_SRC_DIR)/utils/src/macTrace.o \
+		$(SYS_LEGACY_SRC_DIR)/utils/src/parserApi.o \
+		$(SYS_LEGACY_SRC_DIR)/utils/src/utilsApi.o \
+		$(SYS_LEGACY_SRC_DIR)/utils/src/utilsParser.o
+
+############ TL ############
+TL_DIR :=	CORE/TL
+TL_INC_DIR :=	$(TL_DIR)/inc
+TL_SRC_DIR :=	$(TL_DIR)/src
+
+TL_INC := 	-I$(WLAN_ROOT)/$(TL_INC_DIR) \
+		-I$(WLAN_ROOT)/$(TL_SRC_DIR)
+
+TL_OBJS := 	$(TL_SRC_DIR)/wlan_qct_tl.o \
+		$(TL_SRC_DIR)/wlan_qct_tl_ba.o \
+		$(TL_SRC_DIR)/wlan_qct_tl_hosupport.o
+
+############ VOSS ############
+VOSS_DIR :=	CORE/VOSS
+VOSS_INC_DIR :=	$(VOSS_DIR)/inc
+VOSS_SRC_DIR :=	$(VOSS_DIR)/src
+
+VOSS_INC := 	-I$(WLAN_ROOT)/$(VOSS_INC_DIR) \
+		-I$(WLAN_ROOT)/$(VOSS_SRC_DIR)
+
+VOSS_OBJS :=    $(VOSS_SRC_DIR)/vos_api.o \
+		$(VOSS_SRC_DIR)/vos_event.o \
+		$(VOSS_SRC_DIR)/vos_getBin.o \
+		$(VOSS_SRC_DIR)/vos_list.o \
+		$(VOSS_SRC_DIR)/vos_lock.o \
+		$(VOSS_SRC_DIR)/vos_memory.o \
+		$(VOSS_SRC_DIR)/vos_mq.o \
+		$(VOSS_SRC_DIR)/vos_nvitem.o \
+		$(VOSS_SRC_DIR)/vos_packet.o \
+		$(VOSS_SRC_DIR)/vos_sched.o \
+		$(VOSS_SRC_DIR)/vos_threads.o \
+		$(VOSS_SRC_DIR)/vos_timer.o \
+		$(VOSS_SRC_DIR)/vos_trace.o \
+		$(VOSS_SRC_DIR)/vos_types.o \
+                $(VOSS_SRC_DIR)/vos_utils.o
+
+ifeq ($(BUILD_DIAG_VERSION),1)
+VOSS_OBJS += $(VOSS_SRC_DIR)/vos_diag.o
+endif
+
+ifeq ($(CONFIG_QCA_WIFI_2_0), 1)
+########### BMI ###########
+BMI_DIR := CORE/SERVICES/BMI
+
+BMI_INC := -I$(WLAN_ROOT)/$(BMI_DIR)
+
+BMI_OBJS := $(BMI_DIR)/bmi.o \
+            $(BMI_DIR)/ol_fw.o
+
+########### WMI ###########
+WMI_DIR := CORE/SERVICES/WMI
+
+WMI_INC := -I$(WLAN_ROOT)/$(WMI_DIR)
+
+WMI_OBJS := $(WMI_DIR)/wmi_unified.o \
+	    $(WMI_DIR)/wmi_tlv_helper.o
+
+########### FWLOG ###########
+FWLOG_DIR := CORE/UTILS/FWLOG
+
+FWLOG_INC := -I$(WLAN_ROOT)/$(FWLOG_DIR)
+
+FWLOG_OBJS := $(FWLOG_DIR)/dbglog_host.o
+
+############ TLSHIM ############
+TLSHIM_DIR := CORE/CLD_TXRX/TLSHIM
+TLSHIM_INC := -I$(WLAN_ROOT)/$(TLSHIM_DIR)
+
+TLSHIM_OBJS := $(TLSHIM_DIR)/tl_shim.o
+
+############ TXRX ############
+TXRX_DIR :=     CORE/CLD_TXRX/TXRX
+TXRX_INC :=     -I$(WLAN_ROOT)/$(TXRX_DIR)
+
+TXRX_OBJS := $(TXRX_DIR)/ol_txrx.o \
+                $(TXRX_DIR)/ol_cfg.o \
+                $(TXRX_DIR)/ol_rx.o \
+                $(TXRX_DIR)/ol_rx_fwd.o \
+                $(TXRX_DIR)/ol_txrx.o \
+                $(TXRX_DIR)/ol_rx_defrag.o \
+                $(TXRX_DIR)/ol_tx_desc.o \
+                $(TXRX_DIR)/ol_tx_classify.o \
+                $(TXRX_DIR)/ol_tx.o \
+                $(TXRX_DIR)/ol_rx_reorder_timeout.o \
+                $(TXRX_DIR)/ol_rx_reorder.o \
+                $(TXRX_DIR)/ol_rx_pn.o \
+                $(TXRX_DIR)/ol_tx_queue.o \
+                $(TXRX_DIR)/ol_txrx_peer_find.o \
+                $(TXRX_DIR)/ol_txrx_event.o \
+                $(TXRX_DIR)/ol_txrx_encap.o \
+                $(TXRX_DIR)/ol_tx_send.o \
+                $(TXRX_DIR)/ol_tx_sched.o
+
+############ PKTLOG ############
+PKTLOG_DIR :=      CORE/UTILS/PKTLOG
+PKTLOG_INC :=      -I$(WLAN_ROOT)/$(PKTLOG_DIR)/include
+
+PKTLOG_OBJS :=	$(PKTLOG_DIR)/pktlog_ac.o \
+		$(PKTLOG_DIR)/pktlog_internal.o \
+		$(PKTLOG_DIR)/linux_ac.o
+
+############ HTT ############
+HTT_DIR :=      CORE/CLD_TXRX/HTT
+HTT_INC :=      -I$(WLAN_ROOT)/$(HTT_DIR)
+
+ifeq ($(CONFIG_QCA_WIFI_ISOC), 0)
+HTT_OBJS := $(HTT_DIR)/htt_tx.o \
+            $(HTT_DIR)/htt.o \
+            $(HTT_DIR)/htt_t2h.o \
+            $(HTT_DIR)/htt_h2t.o \
+            $(HTT_DIR)/htt_fw_stats.o \
+            $(HTT_DIR)/htt_rx.o
+endif
+
+############## HTC ##########
+HTC_DIR := CORE/SERVICES/HTC
+
+HTC_INC := -I$(WLAN_ROOT)/$(HTC_DIR)
+
+ifeq ($(CONFIG_QCA_WIFI_ISOC), 1)
+HTC_INC += -I$(WLAN_ROOT)/$(HTC_DIR)/linux/
+HTC_OBJS := $(HTC_DIR)/linux/htc_smd.o
+else
+HTC_OBJS := $(HTC_DIR)/htc.o \
+            $(HTC_DIR)/htc_send.o \
+            $(HTC_DIR)/htc_recv.o \
+            $(HTC_DIR)/htc_services.o
+endif
+
+ifneq ($(CONFIG_QCA_WIFI_SDIO), 1)
+########### HIF ###########
+HIF_DIR := CORE/SERVICES/HIF
+ifeq ($(CONFIG_HIF_PCI), 1)
+HIF_PCIE_DIR := $(HIF_DIR)/PCIe
+
+HIF_INC := -I$(WLAN_ROOT)/$(HIF_PCIE_DIR)
+
+HIF_OBJS := $(HIF_DIR)/ath_procfs.o
+
+HIF_PCIE_OBJS := $(HIF_PCIE_DIR)/copy_engine.o \
+                 $(HIF_PCIE_DIR)/hif_pci.o \
+                 $(HIF_PCIE_DIR)/if_pci.o \
+                 $(HIF_PCIE_DIR)/regtable.o \
+                 $(HIF_PCIE_DIR)/mp_dev.o
+
+HIF_OBJS += $(HIF_PCIE_OBJS)
+endif
+ifeq ($(CONFIG_HIF_USB), 1)
+HIF_USB_DIR := $(HIF_DIR)/USB
+
+HIF_INC := -I$(WLAN_ROOT)/$(HIF_USB_DIR)
+
+HIF_OBJS := $(HIF_DIR)/ath_procfs.o
+
+HIF_USB_OBJS := $(HIF_USB_DIR)/usbdrv.o \
+                 $(HIF_USB_DIR)/hif_usb.o \
+                 $(HIF_USB_DIR)/if_usb.o \
+                 $(HIF_USB_DIR)/regtable.o
+
+HIF_OBJS += $(HIF_USB_OBJS)
+endif
+endif
+
+############ WMA ############
+WMA_DIR :=      CORE/SERVICES/WMA
+
+WMA_INC :=      -I$(WLAN_ROOT)/$(WMA_DIR)
+
+WMA_OBJS :=     $(WMA_DIR)/wma.o \
+		$(WMA_DIR)/wma_dfs_interface.o \
+		$(WMA_DIR)/wlan_nv.o
+
+
+ifeq ($(CONFIG_QCA_WIFI_ISOC), 1)
+WMA_OBJS +=     $(WMA_DIR)/wma_isoc.o
+else
+WMA_OBJS +=     $(WMA_DIR)/regdomain.o
+endif
+endif
+
+############ WDA ############
+WDA_DIR :=	CORE/WDA
+WDA_INC_DIR :=	$(WDA_DIR)/inc
+WDA_SRC_DIR :=	$(WDA_DIR)/src
+
+WDA_INC := 	-I$(WLAN_ROOT)/$(WDA_INC_DIR) \
+		-I$(WLAN_ROOT)/$(WDA_INC_DIR)/legacy \
+		-I$(WLAN_ROOT)/$(WDA_SRC_DIR)
+
+WDA_OBJS :=	$(WDA_SRC_DIR)/wlan_qct_wda_debug.o \
+		$(WDA_SRC_DIR)/wlan_qct_wda_legacy.o
+
+ifeq ($(CONFIG_QCA_WIFI_2_0), 0)
+WDA_OBJS +=	$(WDA_SRC_DIR)/wlan_qct_wda.o \
+		$(WDA_SRC_DIR)/wlan_qct_wda_ds.o
+endif
+
+############ WDI ############
+WDI_DIR :=	CORE/WDI
+
+WDI_CP_INC :=	-I$(WLAN_ROOT)/$(WDI_DIR)/CP/inc/
+
+WDI_CP_SRC_DIR := $(WDI_DIR)/CP/src
+WDI_CP_OBJS :=	$(WDI_CP_SRC_DIR)/wlan_qct_wdi.o \
+		$(WDI_CP_SRC_DIR)/wlan_qct_wdi_dp.o \
+		$(WDI_CP_SRC_DIR)/wlan_qct_wdi_sta.o
+
+WDI_DP_INC := -I$(WLAN_ROOT)/$(WDI_DIR)/DP/inc/
+
+WDI_DP_SRC_DIR := $(WDI_DIR)/DP/src
+WDI_DP_OBJS :=	$(WDI_DP_SRC_DIR)/wlan_qct_wdi_bd.o \
+		$(WDI_DP_SRC_DIR)/wlan_qct_wdi_ds.o
+
+WDI_TRP_INC :=	-I$(WLAN_ROOT)/$(WDI_DIR)/TRP/CTS/inc/ \
+		-I$(WLAN_ROOT)/$(WDI_DIR)/TRP/DTS/inc/
+
+WDI_TRP_CTS_SRC_DIR :=	$(WDI_DIR)/TRP/CTS/src
+WDI_TRP_CTS_OBJS :=	$(WDI_TRP_CTS_SRC_DIR)/wlan_qct_wdi_cts.o
+
+WDI_TRP_DTS_SRC_DIR :=	$(WDI_DIR)/TRP/DTS/src
+WDI_TRP_DTS_OBJS :=	$(WDI_TRP_DTS_SRC_DIR)/wlan_qct_wdi_dts.o
+
+WDI_TRP_OBJS :=	$(WDI_TRP_CTS_OBJS) \
+		$(WDI_TRP_DTS_OBJS)
+
+WDI_WPAL_INC := -I$(WLAN_ROOT)/$(WDI_DIR)/WPAL/inc
+
+WDI_WPAL_SRC_DIR := $(WDI_DIR)/WPAL/src
+WDI_WPAL_OBJS := $(WDI_WPAL_SRC_DIR)/wlan_qct_pal_trace.o
+
+ifeq ($(CONFIG_QCA_WIFI_2_0), 0)
+WDI_WPAL_OBJS += $(WDI_WPAL_SRC_DIR)/wlan_qct_pal_api.o \
+		 $(WDI_WPAL_SRC_DIR)/wlan_qct_pal_device.o \
+		 $(WDI_WPAL_SRC_DIR)/wlan_qct_pal_msg.o \
+		 $(WDI_WPAL_SRC_DIR)/wlan_qct_pal_packet.o \
+		 $(WDI_WPAL_SRC_DIR)/wlan_qct_pal_sync.o \
+		 $(WDI_WPAL_SRC_DIR)/wlan_qct_pal_timer.o
+endif
+
+WDI_INC :=	$(WDI_CP_INC) \
+		$(WDI_DP_INC) \
+		$(WDI_TRP_INC) \
+		$(WDI_WPAL_INC)
+
+WDI_OBJS :=	$(WDI_WPAL_OBJS)
+
+ifeq ($(CONFIG_QCA_WIFI_2_0), 0)
+WDI_OBJS +=	$(WDI_CP_OBJS) \
+		$(WDI_DP_OBJS) \
+		$(WDI_TRP_OBJS)
+endif
+
+
+WCNSS_INC :=	-I$(WLAN_ROOT)/wcnss/inc
+
+LINUX_INC :=	-Iinclude/linux
+
+INCS :=		$(BAP_INC) \
+		$(DXE_INC) \
+		$(HDD_INC) \
+		$(EPPING_INC) \
+		$(LINUX_INC) \
+		$(MAC_INC) \
+		$(WCNSS_INC) \
+		$(SAP_INC) \
+		$(SME_INC) \
+		$(SVC_INC) \
+		$(SYS_INC) \
+		$(TL_INC) \
+		$(VOSS_INC) \
+		$(WDA_INC) \
+		$(WDI_INC) \
+		$(DFS_INC)
+
+ifeq ($(CONFIG_QCA_WIFI_2_0), 0)
+INCS +=		$(DXE_INC)
+else
+INCS +=		$(WMA_INC) \
+		$(COMMON_INC) \
+		$(WMI_INC) \
+		$(FWLOG_INC) \
+		$(ADF_INC) \
+		$(TLSHIM_INC) \
+		$(TXRX_INC) \
+		$(PKTLOG_INC) \
+		$(HTT_INC) \
+		$(HTC_INC) \
+		$(DFS_INC)
+
+ifeq ($(CONFIG_QCA_WIFI_ISOC), 0)
+INCS +=		$(HIF_INC) \
+		$(BMI_INC)
+
+ifeq ($(CONFIG_REMOVE_PKT_LOG), 0)
+INCS +=		$(PKTLOG_INC)
+endif
+
+else
+INCS +=		$(DXE_INC)
+endif
+
+endif
+
+OBJS :=		$(BAP_OBJS) \
+		$(HDD_OBJS) \
+		$(EPPING_OBJS) \
+		$(MAC_OBJS) \
+		$(SAP_OBJS) \
+		$(SME_OBJS) \
+		$(SVC_OBJS) \
+		$(SYS_OBJS) \
+		$(VOSS_OBJS) \
+		$(WDA_OBJS) \
+		$(WDI_OBJS) \
+		$(DFS_OBJS)
+
+ifeq ($(CONFIG_QCA_WIFI_2_0), 0)
+OBJS +=		$(DXE_OBJS) \
+		$(TL_OBJS)
+else
+OBJS +=		$(WMA_OBJS) \
+		$(TLSHIM_OBJS) \
+		$(TXRX_OBJS) \
+		$(WMI_OBJS) \
+		$(FWLOG_OBJS) \
+		$(HTC_OBJS) \
+		$(ADF_OBJS) \
+		$(DFS_OBJS)
+
+ifeq ($(CONFIG_QCA_WIFI_ISOC), 0)
+OBJS +=		$(HIF_OBJS) \
+		$(BMI_OBJS) \
+		$(HTT_OBJS)
+
+ifeq ($(CONFIG_REMOVE_PKT_LOG), 0)
+OBJS +=		$(PKTLOG_OBJS)
+endif
+
+else
+OBJS +=		$(DXE_OBJS)
+endif
+
+endif
+
+EXTRA_CFLAGS += $(INCS)
+
+CDEFINES :=	-DANI_LITTLE_BYTE_ENDIAN \
+		-DANI_LITTLE_BIT_ENDIAN \
+		-DQC_WLAN_CHIPSET_QCA_CLD \
+		-DINTEGRATION_READY \
+		-DDOT11F_LITTLE_ENDIAN_HOST \
+		-DGEN6_ONWARDS \
+		-DANI_COMPILER_TYPE_GCC \
+		-DANI_OS_TYPE_ANDROID=6 \
+		-DANI_LOGDUMP \
+		-DWLAN_PERF \
+		-DPTT_SOCK_SVC_ENABLE \
+		-Wall\
+		-Werror\
+		-D__linux__ \
+		-DHAL_SELF_STA_PER_BSS=1 \
+		-DWLAN_FEATURE_VOWIFI_11R \
+		-DWLAN_FEATURE_NEIGHBOR_ROAMING \
+		-DWLAN_FEATURE_NEIGHBOR_ROAMING_DEBUG \
+		-DWLAN_FEATURE_VOWIFI_11R_DEBUG \
+		-DFEATURE_WLAN_WAPI \
+		-DFEATURE_OEM_DATA_SUPPORT\
+		-DSOFTAP_CHANNEL_RANGE \
+		-DWLAN_AP_STA_CONCURRENCY \
+		-DFEATURE_WLAN_SCAN_PNO \
+		-DWLAN_FEATURE_PACKET_FILTERING \
+		-DWLAN_FEATURE_VOWIFI \
+		-DWLAN_FEATURE_11AC \
+		-DWLAN_FEATURE_P2P_DEBUG \
+		-DWLAN_ENABLE_AGEIE_ON_SCAN_RESULTS \
+		-DWLANTL_DEBUG\
+		-DWLAN_NS_OFFLOAD \
+		-DWLAN_ACTIVEMODE_OFFLOAD_FEATURE \
+		-DWLAN_FEATURE_HOLD_RX_WAKELOCK \
+		-DWLAN_SOFTAP_VSTA_FEATURE \
+		-DWLAN_FEATURE_ROAM_SCAN_OFFLOAD \
+		-DWLAN_FEATURE_GTK_OFFLOAD \
+		-DWLAN_WAKEUP_EVENTS \
+		-DFEATURE_WLAN_RA_FILTERING\
+	        -DWLAN_KD_READY_NOTIFIER \
+		-DWLAN_NL80211_TESTMODE \
+		-DFEATURE_WLAN_BATCH_SCAN \
+		-DFEATURE_WLAN_LPHB \
+		-DFEATURE_WLAN_PAL_TIMER_DISABLE \
+		-DFEATURE_WLAN_PAL_MEM_DISABLE \
+		-DQCA_SUPPORT_TX_THROTTLE \
+		-DWMI_INTERFACE_EVENT_LOGGING \
+		-DATH_SUPPORT_WAPI \
+		-DWLAN_FEATURE_LINK_LAYER_STATS \
+		-DWLAN_LOGGING_SOCK_SVC_ENABLE \
+		-DFEATURE_WLAN_EXTSCAN \
+		-DQCA_LL_TX_FLOW_CT
+
+ifeq ($(CONFIG_QCA_WIFI_SDIO), 1)
+CDEFINES +=     -DCONFIG_HL_SUPPORT \
+                -DCONFIG_AR6320_SUPPORT \
+                -DSDIO_3_0 \
+                -DHIF_SDIO \
+                -DCONFIG_ATH_PROCFS_DIAG_SUPPORT \
+                -DHIF_MBOX_SLEEP_WAR
+endif
+
+ifeq ($(CONFIG_QCA_WIFI_SDIO), 1)
+CDEFINES += -DDHCP_SERVER_OFFLOAD
+CDEFINES += -DWLAN_FEATURE_GPIO_LED_FLASHING
+CDEFINES += -DWLAN_FEATURE_APFIND
+endif
+
+ifeq ($(CONFIG_MDNS_OFFLOAD_SUPPORT), 1)
+CDEFINES += -DMDNS_OFFLOAD
+endif
+
+ifeq ($(CONFIG_ARCH_MSM), y)
+CDEFINES += -DMSM_PLATFORM
+endif
+
+ifeq ($(CONFIG_QCA_WIFI_2_0), 0)
+CDEFINES +=	-DWLANTL_DEBUG
+else
+CDEFINES +=	-DOSIF_NEED_RX_PEER_ID \
+		-DQCA_SUPPORT_TXRX_LOCAL_PEER_ID
+ifeq ($(CONFIG_ROME_IF),pci)
+CDEFINES +=	-DQCA_LL_TX_FLOW_CT \
+		-DQCA_SUPPORT_TXRX_VDEV_PAUSE_LL \
+		-DQCA_SUPPORT_TXRX_VDEV_LL_TXQ
+endif
+endif
+
+ifeq ($(CONFIG_QCA_WIFI_2_0), 1)
+ifeq ($(CONFIG_DEBUG_LL),y)
+CDEFINES +=    	-DQCA_PKT_PROTO_TRACE
+endif
+endif
+
+ifneq ($(CONFIG_QCA_CLD_WLAN),)
+CDEFINES += -DWCN_PRONTO
+CDEFINES += -DWCN_PRONTO_V1
+endif
+
+ifeq ($(BUILD_DEBUG_VERSION),1)
+CDEFINES +=	-DWLAN_DEBUG \
+		-DTRACE_RECORD \
+		-DLIM_TRACE_RECORD \
+		-DSME_TRACE_RECORD \
+		-DPE_DEBUG_LOGW \
+		-DPE_DEBUG_LOGE \
+		-DDEBUG
+endif
+
+ifeq ($(CONFIG_SLUB_DEBUG_ON),y)
+CDEFINES += -DTIMER_MANAGER
+CDEFINES += -DMEMORY_DEBUG
+endif
+
+ifeq ($(HAVE_CFG80211),1)
+CDEFINES += -DWLAN_FEATURE_P2P
+CDEFINES += -DWLAN_FEATURE_WFD
+ifeq ($(CONFIG_QCOM_VOWIFI_11R),y)
+CDEFINES += -DKERNEL_SUPPORT_11R_CFG80211
+CDEFINES += -DUSE_80211_WMMTSPEC_FOR_RIC
+endif
+endif
+
+ifeq ($(CONFIG_QCOM_ESE),y)
+CDEFINES += -DFEATURE_WLAN_ESE
+CDEFINES += -DQCA_COMPUTE_TX_DELAY
+CDEFINES += -DQCA_COMPUTE_TX_DELAY_PER_TID
+ifeq ($(CONFIG_QCOM_ESE_UPLOAD),y)
+CDEFINES += -DFEATURE_WLAN_ESE_UPLOAD
+endif
+endif
+
+#normally, TDLS negative behavior is not needed
+ifeq ($(CONFIG_QCOM_TDLS),y)
+CDEFINES += -DFEATURE_WLAN_TDLS
+ifeq ($(BUILD_DEBUG_VERSION),1)
+CDEFINES += -DWLAN_FEATURE_TDLS_DEBUG
+endif
+CDEFINES += -DCONFIG_TDLS_IMPLICIT
+#CDEFINES += -DFEATURE_WLAN_TDLS_NEGATIVE
+#Code under FEATURE_WLAN_TDLS_INTERNAL is ported from volans, This code
+#is not tested only verifed that it compiles. This is not required for
+#supplicant based implementation
+#CDEFINES += -DFEATURE_WLAN_TDLS_INTERNAL
+endif
+
+ifeq ($(CONFIG_PRIMA_WLAN_BTAMP),y)
+CDEFINES += -DWLAN_BTAMP_FEATURE
+endif
+
+ifeq ($(CONFIG_PRIMA_WLAN_LFR),y)
+CDEFINES += -DFEATURE_WLAN_LFR
+endif
+
+ifeq ($(CONFIG_PRIMA_WLAN_OKC),y)
+CDEFINES += -DFEATURE_WLAN_OKC
+endif
+
+ifeq ($(CONFIG_PRIMA_WLAN_11AC_HIGH_TP),y)
+CDEFINES += -DWLAN_FEATURE_11AC_HIGH_TP
+endif
+
+ifeq ($(BUILD_DIAG_VERSION),1)
+CDEFINES += -DFEATURE_WLAN_DIAG_SUPPORT
+CDEFINES += -DFEATURE_WLAN_DIAG_SUPPORT_CSR
+CDEFINES += -DFEATURE_WLAN_DIAG_SUPPORT_LIM
+ifeq ($(CONFIG_HIF_PCI), 1)
+CDEFINES += -DCONFIG_ATH_PROCFS_DIAG_SUPPORT
+endif
+endif
+
+ifeq ($(CONFIG_HIF_USB), 1)
+CDEFINES += -DCONFIG_ATH_PROCFS_DIAG_SUPPORT
+CDEFINES += -DQCA_SUPPORT_OL_RX_REORDER_TIMEOUT
+CDEFINES += -DCONFIG_ATH_PCIE_MAX_PERF=0 -DCONFIG_ATH_PCIE_AWAKE_WHILE_DRIVER_LOAD=0 -DCONFIG_DISABLE_CDC_MAX_PERF_WAR=0
+CDEFINES += -DQCA_TX_HTT2_SUPPORT
+CDEFINES += -DCONFIG_HDD_INIT_WITH_RTNL_LOCK
+ifeq ($(CONFIG_HIF_USB_TASKLET), 1)
+CDEFINES += -DHIF_USB_TASKLET
+endif
+endif
+
+# enable the MAC Address auto-generation feature
+CDEFINES += -DWLAN_AUTOGEN_MACADDR_FEATURE
+
+ifeq ($(CONFIG_WLAN_FEATURE_11W),y)
+CDEFINES += -DWLAN_FEATURE_11W
+endif
+
+ifeq ($(CONFIG_QCOM_LTE_COEX),y)
+CDEFINES += -DFEATURE_WLAN_CH_AVOID
+endif
+
+ifeq ($(CONFIG_WLAN_FEATURE_LPSS),y)
+CDEFINES += -DWLAN_FEATURE_LPSS
+endif
+
+ifeq ($(PANIC_ON_BUG),1)
+CDEFINES += -DPANIC_ON_BUG
+endif
+
+ifeq ($(RE_ENABLE_WIFI_ON_WDI_TIMEOUT),1)
+CDEFINES += -DWDI_RE_ENABLE_WIFI_ON_WDI_TIMEOUT
+endif
+
+ifeq ($(WLAN_OPEN_SOURCE), 1)
+CDEFINES += -DWLAN_OPEN_SOURCE
+endif
+
+ifeq ($(CONFIG_ENABLE_LINUX_REG), y)
+ifeq ($(CONFIG_QCA_WIFI_2_0), 1)
+CDEFINES += -DCONFIG_ENABLE_LINUX_REG
+endif
+endif
+
+ifeq ($(CONFIG_FEATURE_STATS_EXT), 1)
+CDEFINES += -DWLAN_FEATURE_STATS_EXT
+endif
+
+ifeq ($(CONFIG_FEATURE_NAN),y)
+CDEFINES += -DWLAN_FEATURE_NAN
+endif
+
+ifeq ($(CONFIG_QCA_WIFI_2_0), 1)
+CDEFINES += -DQCA_WIFI_2_0
+endif
+
+ifeq ($(CONFIG_QCA_WIFI_ISOC), 1)
+CDEFINES += -DQCA_WIFI_ISOC
+CDEFINES += -DANI_BUS_TYPE_PLATFORM=1
+endif
+
+ifeq ($(CONFIG_QCA_WIFI_2_0), 1)
+ifeq ($(CONFIG_QCA_IBSS_SUPPORT), 1)
+CDEFINES += -DQCA_IBSS_SUPPORT
+endif
+
+#Enable the OS specific ADF abstraction
+ifeq ($(CONFIG_ADF_SUPPORT), 1)
+CDEFINES += -DADF_SUPPORT
+endif
+
+#Enable OL debug and wmi unified functions
+ifeq ($(CONFIG_ATH_PERF_PWR_OFFLOAD), 1)
+CDEFINES += -DATH_PERF_PWR_OFFLOAD
+endif
+
+#Disable packet log
+ifeq ($(CONFIG_REMOVE_PKT_LOG), 1)
+CDEFINES += -DREMOVE_PKT_LOG
+endif
+
+#Enable 11AC TX
+ifeq ($(CONFIG_ATH_11AC_TXCOMPACT), 1)
+CDEFINES += -DATH_11AC_TXCOMPACT
+endif
+
+#Enable per vdev Tx desc pool
+ifeq ($(CONFIG_PER_VDEV_TX_DESC_POOL), 1)
+CDEFINES += -DCONFIG_PER_VDEV_TX_DESC_POOL
+endif
+
+#Enable OS specific IRQ abstraction
+ifeq ($(CONFIG_ATH_SUPPORT_SHARED_IRQ), 1)
+CDEFINES += -DATH_SUPPORT_SHARED_IRQ
+endif
+
+#Enable message based HIF instead of RAW access in BMI
+ifeq ($(CONFIG_HIF_MESSAGE_BASED), 1)
+CDEFINES += -DHIF_MESSAGE_BASED
+endif
+
+#Enable PCI specific APIS (dma, etc)
+ifeq ($(CONFIG_HIF_PCI), 1)
+CDEFINES += -DHIF_PCI
+endif
+
+#Enable USB specific APIS
+ifeq ($(CONFIG_HIF_USB), 1)
+CDEFINES += -DHIF_USB
+CDEFINES += -DCONFIG_HL_SUPPORT
+CDEFINES += -DCONFIG_FW_LOGS_BASED_ON_INI
+endif
+
+#Enable pci read/write config functions
+ifeq ($(CONFIG_ATH_PCI), 1)
+CDEFINES += -DATH_PCI
+endif
+
+#Enable power management suspend/resume functionality
+ifeq ($(CONFIG_ATH_BUS_PM), 1)
+CDEFINES += -DATH_BUS_PM
+endif
+
+#Enable dword alignment for IP header
+ifeq ($(CONFIG_IP_HDR_ALIGNMENT), 1)
+CDEFINES += -DPERE_IP_HDR_ALIGNMENT_WAR
+endif
+
+#Enable FLOWMAC module support
+ifeq ($(CONFIG_ATH_SUPPORT_FLOWMAC_MODULE), 1)
+CDEFINES += -DATH_SUPPORT_FLOWMAC_MODULE
+endif
+
+#Enable spectral support
+ifeq ($(CONFIG_ATH_SUPPORT_SPECTRAL), 1)
+CDEFINES += -DATH_SUPPORT_SPECTRAL
+endif
+
+#Enable WDI Event support
+ifeq ($(CONFIG_WDI_EVENT_ENABLE), 1)
+CDEFINES += -DWDI_EVENT_ENABLE
+endif
+
+#Endianess selection
+ifeq ($(CONFIG_LITTLE_ENDIAN), 1)
+AH_LITTLE_ENDIAN=1234
+CDEFINES += -DAH_BYTE_ORDER=$(AH_LITTLE_ENDIAN)
+else
+AH_BIG_ENDIAN=4321
+CDEFINES += -DAH_BYTE_ORDER=$(AH_BIG_ENDIAN)
+CDEFINES += -DBIG_ENDIAN_HOST
+endif
+
+#Enable TX reclaim support
+ifeq ($(CONFIG_TX_CREDIT_RECLAIM_SUPPORT), 1)
+CDEFINES += -DTX_CREDIT_RECLAIM_SUPPORT
+endif
+
+#Enable FTM support
+ifeq ($(CONFIG_QCA_WIFI_FTM), 1)
+CDEFINES += -DQCA_WIFI_FTM
+endif
+
+#Enable Checksum Offload support
+ifeq ($(CONFIG_CHECKSUM_OFFLOAD), 1)
+CDEFINES += -DCHECKSUM_OFFLOAD
+endif
+
+#Enable Checksum Offload support
+ifeq ($(CONFIG_IPA_OFFLOAD), 1)
+CDEFINES += -DIPA_OFFLOAD -DHDD_IPA_USE_IPA_RM_TIMER
+endif
+
+ifneq ($(CONFIG_ARCH_MDM9630), y)
+ifeq ($(CONFIG_IPA_UC_OFFLOAD), 1)
+CDEFINES += -DIPA_UC_OFFLOAD
+endif
+endif
+
+#Enable GTK Offload
+ifeq ($(CONFIG_GTK_OFFLOAD), 1)
+CDEFINES += -DWLAN_FEATURE_GTK_OFFLOAD
+CDEFINES += -DIGTK_OFFLOAD
+endif
+
+#Enable GTK Offload
+ifeq ($(CONFIG_EXT_WOW), 1)
+CDEFINES += -DWLAN_FEATURE_EXTWOW_SUPPORT
+endif
+
+#Mark it as SMP Kernel
+ifeq ($(CONFIG_SMP),y)
+CDEFINES += -DQCA_CONFIG_SMP
+endif
+endif
+
+#features specific to mdm9630
+ifeq ($(CONFIG_ARCH_MDM9630), y)
+
+#enable MCC TO SCC switch
+CDEFINES += -DFEATURE_WLAN_MCC_TO_SCC_SWITCH
+
+#enable wlan auto shutdown feature for mdm9630
+CDEFINES += -DFEATURE_WLAN_AUTO_SHUTDOWN
+
+#enable for MBSSID
+CDEFINES += -DWLAN_FEATURE_MBSSID
+
+#Green AP feature
+CDEFINES += -DFEATURE_GREEN_AP
+
+#Enable 4address scheme for mdm9630
+CDEFINES += -DFEATURE_WLAN_STA_4ADDR_SCHEME
+
+#Disable STA-AP Mode DFS support
+CDEFINES += -DFEATURE_WLAN_STA_AP_MODE_DFS_DISABLE
+
+#Enable OBSS feature for mdm9630
+CDEFINES += -DQCA_HT_2040_COEX
+
+else
+
+#Open P2P device interface only for non-MDM9630 platform
+CDEFINES += -DWLAN_OPEN_P2P_INTERFACE
+
+#Enable 2.4 GHz social channels in 5 GHz only mode for p2p usage
+CDEFINES += -DWLAN_ENABLE_SOCIAL_CHANNELS_5G_ONLY
+
+endif
+
+#Enable Signed firmware support for split binary format
+ifeq ($(CONFIG_QCA_SIGNED_SPLIT_BINARY_SUPPORT), 1)
+CDEFINES += -DQCA_SIGNED_SPLIT_BINARY_SUPPORT
+endif
+
+#Enable single firmware binary format
+ifeq ($(CONFIG_QCA_SINGLE_BINARY_SUPPORT), 1)
+CDEFINES += -DQCA_SINGLE_BINARY_SUPPORT
+endif
+
+#Enable collecting target RAM dump after kernel panic
+ifeq ($(CONFIG_TARGET_RAMDUMP_AFTER_KERNEL_PANIC), 1)
+CDEFINES += -DTARGET_RAMDUMP_AFTER_KERNEL_PANIC
+endif
+
+ifeq ($(CONFIG_ATH_PCIE_ACCESS_DEBUG), 1)
+CDEFINES += -DCONFIG_ATH_PCIE_ACCESS_DEBUG
+endif
+
+#Flag to enable/disable WLAN D0-WOW
+ifeq ($(CONFIG_PCI_MSM), y)
+CDEFINES += -DFEATURE_WLAN_D0WOW
+endif
+
+# Some kernel include files are being moved.  Check to see if
+# the old version of the files are present
+
+ifneq ($(wildcard $(srctree)/arch/$(SRCARCH)/mach-msm/include/mach/msm_smd.h),)
+CDEFINES += -DEXISTS_MSM_SMD
+endif
+
+ifneq ($(wildcard $(srctree)/arch/$(SRCARCH)/mach-msm/include/mach/msm_smsm.h),)
+CDEFINES += -DEXISTS_MSM_SMSM
+endif
+
+# Enable feature support fo Linux version QCMBR
+ifeq ($(CONFIG_LINUX_QCMBR),y)
+CDEFINES += -DLINUX_QCMBR
+endif
+
+# Enable feature Software AP Authentication Offload
+ifeq ($(SAP_AUTH_OFFLOAD),1)
+CDEFINES += -DSAP_AUTH_OFFLOAD
+endif
+
+# Enable target dump for non-qualcomm platform
+ifeq ($(CONFIG_NON_QC_PLATFORM), y)
+CDEFINES += -DCONFIG_NON_QC_PLATFORM
+ifeq ($(CONFIG_CLD_HL_SDIO_CORE), y)
+CDEFINES += -DTARGET_DUMP_FOR_NON_QC_PLATFORM
+endif
+endif
+
+KBUILD_CPPFLAGS += $(CDEFINES)
+
+# Currently, for versions of gcc which support it, the kernel Makefile
+# is disabling the maybe-uninitialized warning.  Re-enable it for the
+# WLAN driver.  Note that we must use EXTRA_CFLAGS here so that it
+# will override the kernel settings.
+ifeq ($(call cc-option-yn, -Wmaybe-uninitialized),y)
+EXTRA_CFLAGS += -Wmaybe-uninitialized
+endif
+
+# Module information used by KBuild framework
+obj-$(CONFIG_QCA_CLD_WLAN) += $(MODNAME).o
+$(MODNAME)-y := $(OBJS)
