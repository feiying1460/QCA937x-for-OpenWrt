diff -uNr libnl_kk/Android.mk libnl/Android.mk
--- libnl_kk/Android.mk	1970-01-01 08:00:00.000000000 +0800
+++ libnl/Android.mk	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,41 @@
+LOCAL_PATH:= $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES :=  lib/cache.c \
+	lib/data.c \
+	lib/nl.c \
+	lib/doc.c \
+	lib/cache_mngr.c \
+	lib/addr.c \
+	lib/socket.c \
+	lib/fib_lookup/lookup.c \
+	lib/fib_lookup/request.c \
+	lib/msg.c \
+	lib/object.c \
+	lib/attr.c \
+	lib/utils.c \
+	lib/cache_mngt.c \
+	lib/handlers.c \
+	lib/genl/ctrl.c \
+	lib/genl/mngt.c \
+	lib/genl/family.c \
+	lib/genl/genl.c \
+	lib/route/rtnl.c \
+	lib/route/route_utils.c \
+	lib/netfilter/nfnl.c \
+	lib/error.c
+
+LOCAL_C_INCLUDES := $(LOCAL_PATH)/include
+LOCAL_EXPORT_C_INCLUDE_DIRS := $(LOCAL_PATH)/include
+LOCAL_MODULE := libnl
+
+include $(BUILD_STATIC_LIBRARY)
+
+include $(CLEAR_VARS)
+
+LOCAL_WHOLE_STATIC_LIBRARIES := libnl
+LOCAL_EXPORT_C_INCLUDE_DIRS := $(LOCAL_PATH)/include
+LOCAL_MODULE := libnl
+
+include $(BUILD_SHARED_LIBRARY)
diff -uNr libnl_kk/autogen.sh libnl/autogen.sh
--- libnl_kk/autogen.sh	1970-01-01 08:00:00.000000000 +0800
+++ libnl/autogen.sh	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,4 @@
+#!/bin/bash
+
+autoreconf -fi;
+rm -Rf autom4te.cache;
diff -uNr libnl_kk/ChangeLog libnl/ChangeLog
--- libnl_kk/ChangeLog	1970-01-01 08:00:00.000000000 +0800
+++ libnl/ChangeLog	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,336 @@
+ChangeLog discontinued, git history can be found here:
+http://git.kernel.org/?p=libs/netlink/libnl.git
+
+Summary of Changes from 1.0-pre6 to 1.0-pre7
+================================================
+	Thomas Graf <tgraf@suug.ch>
+	  o Generic netlink support
+	  o Route Addition/Deletion
+	  o Added nl_cache_subset()
+	  o Have nl_object_clone() make real clones without
+	    sharing any data.
+	  o Remove old nl_object_alloc() not based on a object
+	    operations to avoid bugs due to missing init.
+	  o Added nl-list-caches utility
+	  o Removed nlmsg_build_no_hdr(), duplicate
+	  o Reworked message interface
+	  o Fixed nlmsg_put() and genlmsg_put() to correctly reserve
+	    tail room for user specific headers.
+	  o Added nl_cache_move()
+	  o Renamed nl_cache_delete() to nl_cache_remove() (no API break)
+	  o Fixed reference counting while objects stay in caches.
+	  o Object marking
+	  o Moved attribute mask for objects into generic structure
+	  o nl-list-caches: List available dump procedures
+	  o Use PAGE_SIZE as initial buffer size when reading from
+	    netlink socket
+	  o Double buffer size when recv() returns MSG_TRUNC
+	  o Replaced filter object operation with new compare operation
+	    capable of listing differences between two objects
+	  o Added nl_object_identical() to check if two objects are
+	    identical from a uniqueness point of view
+	  o Added nl_object_diff() returning a bitmask of differences in
+	    attributes
+	  o Added nl_object_attr_list() generating a list of attribute
+	    name the object has assigned 
+	  o Cache updates based on event notifications, code based on
+	    Patrick McHardy's patches
+	  o Cache Manager
+	  o Added NL_AUTO_PID, NL_AUTO_SEQ for convenience
+	  o Disable MSG_PEEK by default and provide nl_socket_enable_msg_peek()
+	  o Fixed nl_recvmsgs() to return 0 when interrupted via NL_STOP or
+	    NL_SKIP
+	  o Fixed nl_recvmsgs() to stop reading after parsing if not in the
+	    middle of a multipart message.
+	  o Fixed nl_recvmsgs() to not stop after receving an ACK
+	  o Fixed nl_recvmsgs() to not blindly discard remaining messages
+	    if a NLMSG_DONE message is received.
+	
+	Petr Gotthard <petr.gotthard@siemens.com>
+	Siemens AG Oesterreich
+	  o Fix u32 to properly handle multiple keys
+	  o rtnl_htb_set_(r|c)buffer()
+	  o Fixed MTU handling in HTB class, problem pointed out
+	    by Edouard Thuleau
+	
+	Zilvinas Valinskas <zilvinas@wilibox.com>
+	  o Fix wrong msg_namelen in nl_recv()
+	  o Fix memory leak in flnl_request_put()
+
+	Helmut Schaa <hschaa@suse.de>
+	  o Fix for using libnl from within C++
+
+	Patrick McHardy <kaber@trash.net>
+	  o *_alloc_cache(): Only refill cache if handle is provided
+	
+	James Oakley <jfunk@funktronics.ca>
+	  o Fix rtnl_link_set_arptype() typo
+
+	Philip Craig <philipc@snapgear.com>
+	  o Change address family type from char to int
+	  o Fix the error handling when the build fails.
+	  o add nl_cache_mngr_get_fd()
+	  o add netfilter support
+	  o add netfilter conntrack support
+	  o add netfilter log support
+
+Summary of Changes from 1.0-pre5 to 1.0-pre6
+================================================
+	Christopher Aillon <caillon@redhat.com>
+	  o Use $(libdir) instead of $(prefix)/lib for 64bit awesomeness.
+
+	Thomas Graf <tgraf@suug.ch>
+	  o Extend nl_msg to include source address, destination address
+	    and the protocol being used.
+	  o Make nl_send*() take a nl_msg instead of a nlmsghdr (API BREAK)
+	  o Change callbacks to take a nl_msg instead of source address
+	    and nlmsghdr (API BREAK)
+	  o caches must specify the protocol they're hooked up from now on
+	    if they intend to be associated with message types.
+	  o cache_mngt_associate now takes the protocol besides the message
+	    type to allow for multiple protocols to be supported (API BREAK)
+	  o overwrite destination address in nl_send() when specified in the
+	    message itself, allows for unbound addressing.
+	  o Support for netlink based fib_lookup()
+	  o Documentation fixes
+	  o Fix double nlmsg_free() in nl_recvmsgs() while receiving
+	    a multipart message and the read was interrupted.
+	  o Change cache operations to store names for message types.
+	  o Provide interface to convert message type to character string.
+	  o Add dp_dump_msgtype to prefix each dumped element with a
+	    pretty printed message type.
+	  o netlink fib lookup support
+	  o nl_recvmsgs() debugging
+	  o use nl_cachemngt_type2name() when pretty printing netlink header
+	  o Routing protocol translations.
+	  o Routing metric translations.
+	  o Revised route dumping
+	  o Nexthop flag translations.
+	  o Add support for IFF_DORMANT
+
+	Petr Gotthard <petr.gotthard@siemens.com>
+	Siemens AG Oesterreich
+	  o Fix access to obj after freeing it
+	  o Fix u32 selector access after realloc() 
+	  o Fix missing out-of-memory error handling in various places
+	  o Enhance nl-monitor to have group selection selectable and
+	    demonstrate usage of select()
+	  o Don't ignore IFF_RUNNING any longer
+	  o fw classifier support
+	
+	Patrick McHardy <kaber@trash.net>
+	  o Fix conflicting types for __u64
+	  o Fix printf format string warnings
+	  o Fix object cloning
+	  o Deal with structure padding in nl_object_clone
+	  o Fix nl_addr leak
+	  o Set ce_msgtype in all parsed objects
+	  o Fix addr flag filter
+	  o Fix RTNLGRP definitions (was based on broken kernel version)
+	  o Export nl_get_errno()
+	  o Add function to get/set peer pid
+	  o Add IFF_LOWER_UP
+	  o Add/export some missing accessor functions
+	  o print /0 prefix in nl_addr2str()
+	  o Fix invalid free in nl_addr_parse for AF_UNSPEC addresses
+	  o Use __str2flags instead of __str2type in rtnl_link_str2flags()
+	  o Make sure object and filter types match in nl_object_match()
+	  o Add support for credential passing over netlink sockets (API BREAK)
+	  o Add support for custom dump callbacks
+	  o Add NL_DUMP_ENV format
+
+	Michael Biebl <biebl@teco.edu>
+	"Alex V. Myltsev" <avm@altlinux.ru>
+	  o Makefile fixes
+
+
+Summary of Changes from 1.0-pre4 to 1.0-pre5
+================================================
+	Thomas Graf <tgraf@suug.ch>
+	  o Use minimized local copies for <linux/if.h>, <linux/if_arp.h>,
+	    and <linux/if_ether.h> to avoid compile troubles with
+	    applications including <net/if*.h>
+	    Reported by Christopher Aillon.
+
+Summary of Changes from 1.0-pre3 to 1.0-pre4
+================================================
+	Thomas Graf <tgraf@suug.ch>
+	  o Fix wrong rtnl_addr_set_prefixlen() external declaration,
+	    reported by Dan Williams.
+	  o Fix nl_addr_parse() to not change the original string
+	    for prefixes.
+	  o Do not build documentation per default, but have the user
+	    issue 'make gendoc'
+	  o Assume neighbours to be permanent, set NUD_PERMANENT if not
+	    specified otherwise.
+
+Summary of Changes from 1.0-pre2 to 1.0-pre3
+================================================
+	Thomas Graf <tgraf@suug.ch>
+	  o Fix SFQ parser to allocate qdisc options.
+	  o Fix rule statistics dumping to not call itself.
+	  o Complete Netem qdisc interface.
+	  o Add rtnl_*_put() and rtnl_*_free() to increase readability.
+	  o Cleanup of nl-* tools
+	  o Fix inclusion guards of route/neightbl.h
+	  o Fix nl_connect() to only modify rx/tx socket buffers if not
+	    already modified by the user.
+	  o Fix wrong nl_handle_alloc() prototype.
+	  o Fix typo in route/addr.c causing label to be marked as
+	    local address.
+	  o Use ~0UL as default prefix length instead of 0.
+	  o Fix neighbour message parser to correctly store core.
+	    attributes and provide them again.
+	  o Fix neighbour message parser to correctly guess address family.
+	    to make it compatible with nl_addr_parse() and ether llc
+	    addresses.
+	  o Add rtnl_route_table2str(), rtnl_route_str2table().
+	  o Add nl_cache_nitems_filter() to find out if a filter produces
+	    any matches.
+	  o Remove rtnl_rule_set_(dst|src)_str() (obsolete).
+	  o Remove scope and protocol field of routing rule.
+	  o Complete routing rules module.
+	  o Move realms translations from route to rtnl module.
+
+Summary of Changes from 1.0-pre1 to 1.0-pre2
+================================================
+	Thomas Graf <tgraf@suug.ch>
+	  o More API documentation
+	  o Added flags argument to rtnl_addr_(add|build_add_request)().
+	  o Added rtnl_addr_(set|get)_multicast().
+	  o Moved scope translations routines from route/route.c to
+	    route/rtnl.c, required by other modules as well.
+	  o Removed old rtattr bits from rtnetlink-kernel.h
+	  o Customized libnl.css for doxygen documentation
+	  o Removed non-reentrant translation routines, only bloating
+	    the code and too risky.
+	  o Fixed wrong version number from 1.0-pre1.
+	  o Reenabled unfinished policer module.
+	  o Reworked TBF module, automatic caluclation of transmit times,
+	    limit setable via latency, automatic cell size calculation,
+	    options TLV generation. (untested)
+	  o Renamed nl_xmittime() to rtnl_tc_calc_txtime().
+	  o Renamde nl_build_rtable() to rtnl_tc_build_rate_table()
+
+	Petr Gotthard <petr.gotthard@siemens.com>,
+	Siemens AG Oesterreich
+	  o Fix symlinks to libnl library files to be moveable
+	  o Fix extern struct prototypes meant to be static.
+	  o Add empty install target to src/Makefile
+
+	Simon Stelling <blubb@gentoo.org>
+	  o Use LIBDIR instead of $(prefix)/lib for users to alllow librariers
+	    into $(prefix)/lib64.
+
+Summary of Changes from 0.5.0 to 1.0-pre1
+================================================
+	Thomas Graf <tgraf@suug.ch>
+	  o Uncountable number of changes, rewrite of certain modules,
+	    several major API breakages
+	
+	Petr Gotthard <petr.gotthard@siemens.com>,
+	Siemens AG Oesterreich
+	  o added class_build, rtnl_class_build_add_request, rtnl_class_add
+	  o added HTB (Hierachical Token Bucket) class support
+	  o added nl_xmittime, nl_build_rtable
+	  o added nl_data_append to realloc a nl_data structure
+	  o added rtnl_rcopy_ratespec as reverse to rtnl_copy_ratespec
+	  o fixed byte order conversion of rtnl_filter.protocol
+	  o SuSE and Fedora Linux compile fixes
+	  o fixed u32 classifier support
+	  o added rtnl_u32_set_handle, rtnl_u32_set_classid, rtnl_u32_set_flags
+	    and several rtnl_u32_add_key_... operations to u32 classifier
+
+Summary of Changes from 0.4.4 to 0.5.0
+================================================
+	Thomas Graf <tgraf@suug.ch>
+	  o API documentation
+	  o nl_cache_filter to manually filter on a object
+	  o partial routing support
+	  o routing rules support
+	  o Propely set address family when setting addresses
+	  o debug flag and some rare messages, more to come
+	  o make error mesage verboseness configureable
+	  o tc fixes to wait for ack
+	  o cleanup and adaption of address code to latest internal API
+	  o various cleanups
+	  o dozens of API breakages (better now than later)
+
+	Daniel Hottinger <hotti@hotti.ch>
+	  o arch 64bit printf length modifier fixes
+
+	Baruch Even <baruch@ev-en.org>,
+	Mediatrix Telecom, inc. <ericb@mediatrix.com>
+	  o address support
+
+Summary of changes from 0.4.3 to 0.4.4
+================================================
+	Thomas Graf <tgraf@suug.ch>:
+	  o overall cleanups for better code quality
+	  o replace dump_(brief|full|with_stats) ops with
+	    dump[NL_DUMP_MAX] array to allow further additions without
+	    breaking the ABI.
+	  o add of send_ack callback, called whenever when oppenent
+	    asks for an ACK.
+	  o make nl_parse_rtattr initialize the tb buffer like in the
+	    kernel, caller must no longer take care of it.
+	  o remove nl_addrnattr (obsolete)
+	  o fixed nl_msg_append_raw to correctly calculate length
+	    for raw data not aligned to NLMSG_ALIGN
+	  o fix memory leak in nl_recv in case of errors
+	  o correctly check sequence numbers if more than one message
+	    was sent out before the answer is being received.
+	  o add workaround for buggy netlink applications not properly
+	    setting NLM_F_MULTI.
+
+Summary of changes from 0.4.2 to 0.4.3
+================================================
+
+	Thomas Graf <tgraf@suug.ch>:
+	  o use parser_param in nl_cache_parse
+	  o EGP: dump nfilters attribute
+	  o allow retrieving of filters attached to classes via
+	    FILTER_CACHE_PARENT(C) cache argument
+	  o filter message building API
+
+Summary of changes from 0.4.1 to 0.4.2
+================================================
+
+	Baruch Even <baruch@ev-en.org>:
+	  o memory leak fix in nl_parse_rtattr
+	  o reset padding to 0 when appending raw data to a nl_msg
+	  o avoid overwriting nlmsg ptr when buffer extending fails
+	  o typo fixes
+	  o create symlinks libnl.so.0 and libnl.so
+	
+	Thomas Graf <tgraf@suug.ch>:
+	  o EGP classifier support
+	  o avoid null pointer in printf call
+	  o added nl_cache_parse to put nl_msg's into a cache
+	  o added rtnl_filter_build to build a nl_msg filter message
+	  o correctly install header files
+	  o nl_msg_payload/nl_msg_payloadlen to access nl_msg payload
+	  o nl_parse_nested macro to simplify nested TLV parsing
+	  o NL_ERROR_ASSERT compile flag to assert(0) on errors
+	  o rta alignment fix in nl_msg_append_tlv
+	  o added nl_msg_parse_rtattr as shortcut for nl_parse_rtattr
+	    for nl_msg API
+	  o added nl_parse_nested for nested TLVs
+	  o added RTA_ARRAY_ELEMS macro to calculate array length
+	    for array TLVs
+	  o added nl_wait_for_ack to wait for the next ack
+	  o added rtnl_link_build_change_request(...)
+	  o added rtnl_neigh_build_*_request
+	  o converted neighbour code to use nl_wait_for_ack
+	  o cb_recvmsgs_ow callback to overwrite internal calls to
+	    nl_recvmsgs_def
+	  o cb_seq_check callback to overwrite default sequence checking
+	  o added nl_parser_param as argument for message parsers including
+	    a callback to be called upon successful parsing of a message.
+	    Removes the requirement of having all parsed messages to be added
+	    to a cache.
+	  o added cb_recv_ow and nl_send_ow callbacks to overwrite internal
+	    calls to nl_recv and nl_send.
+
+	Jamal Hadi Salim <hadi@cyberus.ca>
+	  o Linux 2.4 compile fixes
diff -uNr libnl_kk/configure.in libnl/configure.in
--- libnl_kk/configure.in	1970-01-01 08:00:00.000000000 +0800
+++ libnl/configure.in	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,42 @@
+#
+# configure.in
+#
+# 	This library is free software; you can redistribute it and/or
+#	modify it under the terms of the GNU Lesser General Public
+#	License as published by the Free Software Foundation version 2.1
+#	of the License.
+#
+# Copyright (c) 2003-2010 Thomas Graf <tgraf@suug.ch>
+#
+
+AC_INIT(libnl, 2.0, tgraf@suug.ch)
+AC_CONFIG_HEADERS([lib/defs.h])
+AC_CONFIG_MACRO_DIR([m4])
+AM_INIT_AUTOMAKE([-Wall foreign subdir-objects])
+
+AC_PROG_CC
+AM_PROG_CC_C_O
+AC_PROG_INSTALL
+AM_PROG_LIBTOOL
+AM_PROG_LEX
+AC_PROG_YACC
+
+AC_C_CONST
+AC_C_INLINE
+
+AC_ARG_WITH([pkgconfigdir], AS_HELP_STRING([--with-pkgconfigdir=PATH],
+	[Path to the pkgconfig directory [[LIBDIR/pkgconfig]]]),
+	[pkgconfigdir="$withval"], [pkgconfigdir='${libdir}/pkgconfig'])
+AC_SUBST([pkgconfigdir])
+
+AC_ARG_ENABLE([cli],
+	AS_HELP_STRING([--disable-cli], [Do not build command line interface utils]),
+	[enable_cli="$enableval"], [enable_cli="yes"])
+AM_CONDITIONAL([ENABLE_CLI], [test "$enable_cli" = "yes"])
+
+AC_CHECK_LIB([m], [pow], [], AC_MSG_ERROR([libm is required]))
+
+AC_CONFIG_FILES([Makefile doc/Doxyfile doc/Makefile lib/Makefile
+	include/Makefile src/Makefile src/lib/Makefile \
+	libnl-2.0.pc include/netlink/version.h])
+AC_OUTPUT
diff -uNr libnl_kk/COPYING libnl/COPYING
--- libnl_kk/COPYING	1970-01-01 08:00:00.000000000 +0800
+++ libnl/COPYING	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,461 @@
+
+                  GNU LESSER GENERAL PUBLIC LICENSE
+                       Version 2.1, February 1999
+
+ Copyright (C) 1991, 1999 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+[This is the first released version of the Lesser GPL.  It also counts
+ as the successor of the GNU Library Public License, version 2, hence
+ the version number 2.1.]
+
+                            Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+Licenses are intended to guarantee your freedom to share and change
+free software--to make sure the software is free for all its users.
+
+  This license, the Lesser General Public License, applies to some
+specially designated software packages--typically libraries--of the
+Free Software Foundation and other authors who decide to use it.  You
+can use it too, but we suggest you first think carefully about whether
+this license or the ordinary General Public License is the better
+strategy to use in any particular case, based on the explanations
+below.
+
+  When we speak of free software, we are referring to freedom of use,
+not price.  Our General Public Licenses are designed to make sure that
+you have the freedom to distribute copies of free software (and charge
+for this service if you wish); that you receive source code or can get
+it if you want it; that you can change the software and use pieces of
+it in new free programs; and that you are informed that you can do
+these things.
+
+  To protect your rights, we need to make restrictions that forbid
+distributors to deny you these rights or to ask you to surrender these
+rights.  These restrictions translate to certain responsibilities for
+you if you distribute copies of the library or if you modify it.
+
+  For example, if you distribute copies of the library, whether gratis
+or for a fee, you must give the recipients all the rights that we gave
+you.  You must make sure that they, too, receive or can get the source
+code.  If you link other code with the library, you must provide
+complete object files to the recipients, so that they can relink them
+with the library after making changes to the library and recompiling
+it.  And you must show them these terms so they know their rights.
+
+  We protect your rights with a two-step method: (1) we copyright the
+library, and (2) we offer you this license, which gives you legal
+permission to copy, distribute and/or modify the library.
+
+  To protect each distributor, we want to make it very clear that
+there is no warranty for the free library.  Also, if the library is
+modified by someone else and passed on, the recipients should know
+that what they have is not the original version, so that the original
+author's reputation will not be affected by problems that might be
+introduced by others.
+
+  Finally, software patents pose a constant threat to the existence of
+any free program.  We wish to make sure that a company cannot
+effectively restrict the users of a free program by obtaining a
+restrictive license from a patent holder.  Therefore, we insist that
+any patent license obtained for a version of the library must be
+consistent with the full freedom of use specified in this license.
+
+  Most GNU software, including some libraries, is covered by the
+ordinary GNU General Public License.  This license, the GNU Lesser
+General Public License, applies to certain designated libraries, and
+is quite different from the ordinary General Public License.  We use
+this license for certain libraries in order to permit linking those
+libraries into non-free programs.
+
+  When a program is linked with a library, whether statically or using
+a shared library, the combination of the two is legally speaking a
+combined work, a derivative of the original library.  The ordinary
+General Public License therefore permits such linking only if the
+entire combination fits its criteria of freedom.  The Lesser General
+Public License permits more lax criteria for linking other code with
+the library.
+
+  We call this license the "Lesser" General Public License because it
+does Less to protect the user's freedom than the ordinary General
+Public License.  It also provides other free software developers Less
+of an advantage over competing non-free programs.  These disadvantages
+are the reason we use the ordinary General Public License for many
+libraries.  However, the Lesser license provides advantages in certain
+special circumstances.
+
+  For example, on rare occasions, there may be a special need to
+encourage the widest possible use of a certain library, so that it
+becomes a de-facto standard.  To achieve this, non-free programs must
+be allowed to use the library.  A more frequent case is that a free
+library does the same job as widely used non-free libraries.  In this
+case, there is little to gain by limiting the free library to free
+software only, so we use the Lesser General Public License.
+
+  In other cases, permission to use a particular library in non-free
+programs enables a greater number of people to use a large body of
+free software.  For example, permission to use the GNU C Library in
+non-free programs enables many more people to use the whole GNU
+operating system, as well as its variant, the GNU/Linux operating
+system.
+
+  Although the Lesser General Public License is Less protective of the
+users' freedom, it does ensure that the user of a program that is
+linked with the Library has the freedom and the wherewithal to run
+that program using a modified version of the Library.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.  Pay close attention to the difference between a
+"work based on the library" and a "work that uses the library".  The
+former contains code derived from the library, whereas the latter must
+be combined with the library in order to run.
+
+                  GNU LESSER GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License Agreement applies to any software library or other
+program which contains a notice placed by the copyright holder or
+other authorized party saying it may be distributed under the terms of
+this Lesser General Public License (also called "this License").
+Each licensee is addressed as "you".
+
+  A "library" means a collection of software functions and/or data
+prepared so as to be conveniently linked with application programs
+(which use some of those functions and data) to form executables.
+
+  The "Library", below, refers to any such software library or work
+which has been distributed under these terms.  A "work based on the
+Library" means either the Library or any derivative work under
+copyright law: that is to say, a work containing the Library or a
+portion of it, either verbatim or with modifications and/or translated
+straightforwardly into another language.  (Hereinafter, translation is
+included without limitation in the term "modification".)
+
+  "Source code" for a work means the preferred form of the work for
+making modifications to it.  For a library, complete source code means
+all the source code for all modules it contains, plus any associated
+interface definition files, plus the scripts used to control
+compilation and installation of the library.
+
+  Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running a program using the Library is not restricted, and output from
+such a program is covered only if its contents constitute a work based
+on the Library (independent of the use of the Library in a tool for
+writing it).  Whether that is true depends on what the Library does
+and what the program that uses the Library does.
+
+  1. You may copy and distribute verbatim copies of the Library's
+complete source code as you receive it, in any medium, provided that
+you conspicuously and appropriately publish on each copy an
+appropriate copyright notice and disclaimer of warranty; keep intact
+all the notices that refer to this License and to the absence of any
+warranty; and distribute a copy of this License along with the
+Library.
+
+  You may charge a fee for the physical act of transferring a copy,
+and you may at your option offer warranty protection in exchange for a
+fee.
+
+  2. You may modify your copy or copies of the Library or any portion
+of it, thus forming a work based on the Library, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) The modified work must itself be a software library.
+
+    b) You must cause the files modified to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    c) You must cause the whole of the work to be licensed at no
+    charge to all third parties under the terms of this License.
+
+    d) If a facility in the modified Library refers to a function or a
+    table of data to be supplied by an application program that uses
+    the facility, other than as an argument passed when the facility
+    is invoked, then you must make a good faith effort to ensure that,
+    in the event an application does not supply such function or
+    table, the facility still operates, and performs whatever part of
+    its purpose remains meaningful.
+
+    (For example, a function in a library to compute square roots has
+    a purpose that is entirely well-defined independent of the
+    application.  Therefore, Subsection 2d requires that any
+    application-supplied function or table used by this function must
+    be optional: if the application does not supply it, the square
+    root function must still compute square roots.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Library,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Library, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote
+it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Library.
+
+In addition, mere aggregation of another work not based on the Library
+with the Library (or with a work based on the Library) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may opt to apply the terms of the ordinary GNU General Public
+License instead of this License to a given copy of the Library.  To do
+this, you must alter all the notices that refer to this License, so
+that they refer to the ordinary GNU General Public License, version 2,
+instead of to this License.  (If a newer version than version 2 of the
+ordinary GNU General Public License has appeared, then you can specify
+that version instead if you wish.)  Do not make any other change in
+these notices.
+
+  Once this change is made in a given copy, it is irreversible for
+that copy, so the ordinary GNU General Public License applies to all
+subsequent copies and derivative works made from that copy.
+
+  This option is useful when you wish to copy part of the code of
+the Library into a program that is not a library.
+
+  4. You may copy and distribute the Library (or a portion or
+derivative of it, under Section 2) in object code or executable form
+under the terms of Sections 1 and 2 above provided that you accompany
+it with the complete corresponding machine-readable source code, which
+must be distributed under the terms of Sections 1 and 2 above on a
+medium customarily used for software interchange.
+
+  If distribution of object code is made by offering access to copy
+from a designated place, then offering equivalent access to copy the
+source code from the same place satisfies the requirement to
+distribute the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  5. A program that contains no derivative of any portion of the
+Library, but is designed to work with the Library by being compiled or
+linked with it, is called a "work that uses the Library".  Such a
+work, in isolation, is not a derivative work of the Library, and
+therefore falls outside the scope of this License.
+
+  However, linking a "work that uses the Library" with the Library
+creates an executable that is a derivative of the Library (because it
+contains portions of the Library), rather than a "work that uses the
+library".  The executable is therefore covered by this License.
+Section 6 states terms for distribution of such executables.
+
+  When a "work that uses the Library" uses material from a header file
+that is part of the Library, the object code for the work may be a
+derivative work of the Library even though the source code is not.
+Whether this is true is especially significant if the work can be
+linked without the Library, or if the work is itself a library.  The
+threshold for this to be true is not precisely defined by law.
+
+  If such an object file uses only numerical parameters, data
+structure layouts and accessors, and small macros and small inline
+functions (ten lines or less in length), then the use of the object
+file is unrestricted, regardless of whether it is legally a derivative
+work.  (Executables containing this object code plus portions of the
+Library will still fall under Section 6.)
+
+  Otherwise, if the work is a derivative of the Library, you may
+distribute the object code for the work under the terms of Section 6.
+Any executables containing that work also fall under Section 6,
+whether or not they are linked directly with the Library itself.
+
+  6. As an exception to the Sections above, you may also combine or
+link a "work that uses the Library" with the Library to produce a
+work containing portions of the Library, and distribute that work
+under terms of your choice, provided that the terms permit
+modification of the work for the customer's own use and reverse
+engineering for debugging such modifications.
+
+  You must give prominent notice with each copy of the work that the
+Library is used in it and that the Library and its use are covered by
+this License.  You must supply a copy of this License.  If the work
+during execution displays copyright notices, you must include the
+copyright notice for the Library among them, as well as a reference
+directing the user to the copy of this License.  Also, you must do one
+of these things:
+
+    a) Accompany the work with the complete corresponding
+    machine-readable source code for the Library including whatever
+    changes were used in the work (which must be distributed under
+    Sections 1 and 2 above); and, if the work is an executable linked
+    with the Library, with the complete machine-readable "work that
+    uses the Library", as object code and/or source code, so that the
+    user can modify the Library and then relink to produce a modified
+    executable containing the modified Library.  (It is understood
+    that the user who changes the contents of definitions files in the
+    Library will not necessarily be able to recompile the application
+    to use the modified definitions.)
+
+    b) Use a suitable shared library mechanism for linking with the
+    Library.  A suitable mechanism is one that (1) uses at run time a
+    copy of the library already present on the user's computer system,
+    rather than copying library functions into the executable, and (2)
+    will operate properly with a modified version of the library, if
+    the user installs one, as long as the modified version is
+    interface-compatible with the version that the work was made with.
+
+    c) Accompany the work with a written offer, valid for at least
+    three years, to give the same user the materials specified in
+    Subsection 6a, above, for a charge no more than the cost of
+    performing this distribution.
+
+    d) If distribution of the work is made by offering access to copy
+    from a designated place, offer equivalent access to copy the above
+    specified materials from the same place.
+
+    e) Verify that the user has already received a copy of these
+    materials or that you have already sent this user a copy.
+
+  For an executable, the required form of the "work that uses the
+Library" must include any data and utility programs needed for
+reproducing the executable from it.  However, as a special exception,
+the materials to be distributed need not include anything that is
+normally distributed (in either source or binary form) with the major
+components (compiler, kernel, and so on) of the operating system on
+which the executable runs, unless that component itself accompanies
+the executable.
+
+  It may happen that this requirement contradicts the license
+restrictions of other proprietary libraries that do not normally
+accompany the operating system.  Such a contradiction means you cannot
+use both them and the Library together in an executable that you
+distribute.
+
+  7. You may place library facilities that are a work based on the
+Library side-by-side in a single library together with other library
+facilities not covered by this License, and distribute such a combined
+library, provided that the separate distribution of the work based on
+the Library and of the other library facilities is otherwise
+permitted, and provided that you do these two things:
+
+    a) Accompany the combined library with a copy of the same work
+    based on the Library, uncombined with any other library
+    facilities.  This must be distributed under the terms of the
+    Sections above.
+
+    b) Give prominent notice with the combined library of the fact
+    that part of it is a work based on the Library, and explaining
+    where to find the accompanying uncombined form of the same work.
+
+  8. You may not copy, modify, sublicense, link with, or distribute
+the Library except as expressly provided under this License.  Any
+attempt otherwise to copy, modify, sublicense, link with, or
+distribute the Library is void, and will automatically terminate your
+rights under this License.  However, parties who have received copies,
+or rights, from you under this License will not have their licenses
+terminated so long as such parties remain in full compliance.
+
+  9. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Library or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Library (or any work based on the
+Library), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Library or works based on it.
+
+  10. Each time you redistribute the Library (or any work based on the
+Library), the recipient automatically receives a license from the
+original licensor to copy, distribute, link with or modify the Library
+subject to these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties with
+this License.
+
+  11. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Library at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Library by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Library.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply, and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  12. If the distribution and/or use of the Library is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Library under this License
+may add an explicit geographical distribution limitation excluding those
+countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  13. The Free Software Foundation may publish revised and/or new
+versions of the Lesser General Public License from time to time.
+Such new versions will be similar in spirit to the present version,
+but may differ in detail to address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Library
+specifies a version number of this License which applies to it and
+"any later version", you have the option of following the terms and
+conditions either of that version or of any later version published by
+the Free Software Foundation.  If the Library does not specify a
+license version number, you may choose any version ever published by
+the Free Software Foundation.
+
+  14. If you wish to incorporate parts of the Library into other free
+programs whose distribution conditions are incompatible with these,
+write to the author to ask for permission.  For software which is
+copyrighted by the Free Software Foundation, write to the Free
+Software Foundation; we sometimes make exceptions for this.  Our
+decision will be guided by the two goals of preserving the free status
+of all derivatives of our free software and of promoting the sharing
+and reuse of software generally.
+
+                            NO WARRANTY
+
+  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
+WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
+EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
+OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
+KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
+LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
+THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
+WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
+AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
+FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
+CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
+LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
+RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
+FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
+SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGES.
+
+                     END OF TERMS AND CONDITIONS
diff -uNr libnl_kk/doc/Doxyfile.in libnl/doc/Doxyfile.in
--- libnl_kk/doc/Doxyfile.in	1970-01-01 08:00:00.000000000 +0800
+++ libnl/doc/Doxyfile.in	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,1260 @@
+# Doxyfile 1.5.2
+
+# This file describes the settings to be used by the documentation system
+# doxygen (www.doxygen.org) for a project
+#
+# All text after a hash (#) is considered a comment and will be ignored
+# The format is:
+#       TAG = value [value, ...]
+# For lists items can also be appended using:
+#       TAG += value [value, ...]
+# Values that contain spaces should be placed between quotes (" ")
+
+#---------------------------------------------------------------------------
+# Project related configuration options
+#---------------------------------------------------------------------------
+
+# This tag specifies the encoding used for all characters in the config file that 
+# follow. The default is UTF-8 which is also the encoding used for all text before 
+# the first occurrence of this tag. Doxygen uses libiconv (or the iconv built into 
+# libc) for the transcoding. See http://www.gnu.org/software/libiconv for the list of 
+# possible encodings.
+
+DOXYFILE_ENCODING      = UTF-8
+
+# The PROJECT_NAME tag is a single word (or a sequence of words surrounded 
+# by quotes) that should identify the project.
+
+PROJECT_NAME           = libnl
+
+# The PROJECT_NUMBER tag can be used to enter a project or revision number. 
+# This could be handy for archiving the generated documentation or 
+# if some version control system is used.
+
+PROJECT_NUMBER         = @PACKAGE_VERSION@
+
+# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) 
+# base path where the generated documentation will be put. 
+# If a relative path is entered, it will be relative to the location 
+# where doxygen was started. If left blank the current directory will be used.
+
+OUTPUT_DIRECTORY       = ./
+
+# If the CREATE_SUBDIRS tag is set to YES, then doxygen will create 
+# 4096 sub-directories (in 2 levels) under the output directory of each output 
+# format and will distribute the generated files over these directories. 
+# Enabling this option can be useful when feeding doxygen a huge amount of 
+# source files, where putting all generated files in the same directory would 
+# otherwise cause performance problems for the file system.
+
+CREATE_SUBDIRS         = NO
+
+# The OUTPUT_LANGUAGE tag is used to specify the language in which all 
+# documentation generated by doxygen is written. Doxygen will use this 
+# information to generate all constant output in the proper language. 
+# The default language is English, other supported languages are: 
+# Afrikaans, Arabic, Brazilian, Catalan, Chinese, Chinese-Traditional, 
+# Croatian, Czech, Danish, Dutch, Finnish, French, German, Greek, Hungarian, 
+# Italian, Japanese, Japanese-en (Japanese with English messages), Korean, 
+# Korean-en, Lithuanian, Norwegian, Polish, Portuguese, Romanian, Russian, 
+# Serbian, Slovak, Slovene, Spanish, Swedish, and Ukrainian.
+
+OUTPUT_LANGUAGE        = English
+
+# If the BRIEF_MEMBER_DESC tag is set to YES (the default) Doxygen will 
+# include brief member descriptions after the members that are listed in 
+# the file and class documentation (similar to JavaDoc). 
+# Set to NO to disable this.
+
+BRIEF_MEMBER_DESC      = YES
+
+# If the REPEAT_BRIEF tag is set to YES (the default) Doxygen will prepend 
+# the brief description of a member or function before the detailed description. 
+# Note: if both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the 
+# brief descriptions will be completely suppressed.
+
+REPEAT_BRIEF           = NO
+
+# This tag implements a quasi-intelligent brief description abbreviator 
+# that is used to form the text in various listings. Each string 
+# in this list, if found as the leading text of the brief description, will be 
+# stripped from the text and the result after processing the whole list, is 
+# used as the annotated text. Otherwise, the brief description is used as-is. 
+# If left blank, the following values are used ("$name" is automatically 
+# replaced with the name of the entity): "The $name class" "The $name widget" 
+# "The $name file" "is" "provides" "specifies" "contains" 
+# "represents" "a" "an" "the"
+
+ABBREVIATE_BRIEF       = 
+
+# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then 
+# Doxygen will generate a detailed section even if there is only a brief 
+# description.
+
+ALWAYS_DETAILED_SEC    = YES
+
+# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all 
+# inherited members of a class in the documentation of that class as if those 
+# members were ordinary class members. Constructors, destructors and assignment 
+# operators of the base classes will not be shown.
+
+INLINE_INHERITED_MEMB  = YES
+
+# If the FULL_PATH_NAMES tag is set to YES then Doxygen will prepend the full 
+# path before files name in the file list and in the header files. If set 
+# to NO the shortest path that makes the file name unique will be used.
+
+FULL_PATH_NAMES        = YES
+
+# If the FULL_PATH_NAMES tag is set to YES then the STRIP_FROM_PATH tag 
+# can be used to strip a user-defined part of the path. Stripping is 
+# only done if one of the specified strings matches the left-hand part of 
+# the path. The tag can be used to show relative paths in the file list. 
+# If left blank the directory from which doxygen is run is used as the 
+# path to strip.
+
+STRIP_FROM_PATH        = 
+
+# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of 
+# the path mentioned in the documentation of a class, which tells 
+# the reader which header file to include in order to use a class. 
+# If left blank only the name of the header file containing the class 
+# definition is used. Otherwise one should specify the include paths that 
+# are normally passed to the compiler using the -I flag.
+
+STRIP_FROM_INC_PATH    = 
+
+# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter 
+# (but less readable) file names. This can be useful is your file systems 
+# doesn't support long names like on DOS, Mac, or CD-ROM.
+
+SHORT_NAMES            = NO
+
+# If the JAVADOC_AUTOBRIEF tag is set to YES then Doxygen 
+# will interpret the first line (until the first dot) of a JavaDoc-style 
+# comment as the brief description. If set to NO, the JavaDoc 
+# comments will behave just like the Qt-style comments (thus requiring an 
+# explicit @brief command for a brief description.
+
+JAVADOC_AUTOBRIEF      = YES
+
+# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make Doxygen 
+# treat a multi-line C++ special comment block (i.e. a block of //! or /// 
+# comments) as a brief description. This used to be the default behaviour. 
+# The new default is to treat a multi-line C++ comment block as a detailed 
+# description. Set this tag to YES if you prefer the old behaviour instead.
+
+MULTILINE_CPP_IS_BRIEF = NO
+
+# If the DETAILS_AT_TOP tag is set to YES then Doxygen 
+# will output the detailed description near the top, like JavaDoc.
+# If set to NO, the detailed description appears after the member 
+# documentation.
+
+DETAILS_AT_TOP         = YES
+
+# If the INHERIT_DOCS tag is set to YES (the default) then an undocumented 
+# member inherits the documentation from any documented member that it 
+# re-implements.
+
+INHERIT_DOCS           = NO
+
+# If the SEPARATE_MEMBER_PAGES tag is set to YES, then doxygen will produce 
+# a new page for each member. If set to NO, the documentation of a member will 
+# be part of the file/class/namespace that contains it.
+
+SEPARATE_MEMBER_PAGES  = NO
+
+# The TAB_SIZE tag can be used to set the number of spaces in a tab. 
+# Doxygen uses this value to replace tabs by spaces in code fragments.
+
+TAB_SIZE               = 8
+
+# This tag can be used to specify a number of aliases that acts 
+# as commands in the documentation. An alias has the form "name=value". 
+# For example adding "sideeffect=\par Side Effects:\n" will allow you to 
+# put the command \sideeffect (or @sideeffect) in the documentation, which 
+# will result in a user-defined paragraph with heading "Side Effects:". 
+# You can put \n's in the value part of an alias to insert newlines.
+
+ALIASES                = arg=\param
+
+# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C 
+# sources only. Doxygen will then generate output that is more tailored for C. 
+# For instance, some of the names that are used will be different. The list 
+# of all members will be omitted, etc.
+
+OPTIMIZE_OUTPUT_FOR_C  = YES
+
+# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java 
+# sources only. Doxygen will then generate output that is more tailored for Java. 
+# For instance, namespaces will be presented as packages, qualified scopes 
+# will look different, etc.
+
+OPTIMIZE_OUTPUT_JAVA   = NO
+
+# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want to 
+# include (a tag file for) the STL sources as input, then you should 
+# set this tag to YES in order to let doxygen match functions declarations and 
+# definitions whose arguments contain STL classes (e.g. func(std::string); v.s. 
+# func(std::string) {}). This also make the inheritance and collaboration 
+# diagrams that involve STL classes more complete and accurate.
+
+BUILTIN_STL_SUPPORT    = NO
+
+# If you use Microsoft's C++/CLI language, you should set this option to YES to
+# enable parsing support.
+
+CPP_CLI_SUPPORT        = NO
+
+# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC 
+# tag is set to YES, then doxygen will reuse the documentation of the first 
+# member in the group (if any) for the other members of the group. By default 
+# all members of a group must be documented explicitly.
+
+DISTRIBUTE_GROUP_DOC   = NO
+
+# Set the SUBGROUPING tag to YES (the default) to allow class member groups of 
+# the same type (for instance a group of public functions) to be put as a 
+# subgroup of that type (e.g. under the Public Functions section). Set it to 
+# NO to prevent subgrouping. Alternatively, this can be done per class using 
+# the \nosubgrouping command.
+
+SUBGROUPING            = YES
+
+#---------------------------------------------------------------------------
+# Build related configuration options
+#---------------------------------------------------------------------------
+
+# If the EXTRACT_ALL tag is set to YES doxygen will assume all entities in 
+# documentation are documented, even if no documentation was available. 
+# Private class members and static file members will be hidden unless 
+# the EXTRACT_PRIVATE and EXTRACT_STATIC tags are set to YES
+
+EXTRACT_ALL            = NO
+
+# If the EXTRACT_PRIVATE tag is set to YES all private members of a class 
+# will be included in the documentation.
+
+EXTRACT_PRIVATE        = YES
+
+# If the EXTRACT_STATIC tag is set to YES all static members of a file 
+# will be included in the documentation.
+
+EXTRACT_STATIC         = NO
+
+# If the EXTRACT_LOCAL_CLASSES tag is set to YES classes (and structs) 
+# defined locally in source files will be included in the documentation. 
+# If set to NO only classes defined in header files are included.
+
+EXTRACT_LOCAL_CLASSES  = YES
+
+# This flag is only useful for Objective-C code. When set to YES local 
+# methods, which are defined in the implementation section but not in 
+# the interface are included in the documentation. 
+# If set to NO (the default) only methods in the interface are included.
+
+EXTRACT_LOCAL_METHODS  = YES
+
+# If the HIDE_UNDOC_MEMBERS tag is set to YES, Doxygen will hide all 
+# undocumented members of documented classes, files or namespaces. 
+# If set to NO (the default) these members will be included in the 
+# various overviews, but no documentation section is generated. 
+# This option has no effect if EXTRACT_ALL is enabled.
+
+HIDE_UNDOC_MEMBERS     = NO
+
+# If the HIDE_UNDOC_CLASSES tag is set to YES, Doxygen will hide all 
+# undocumented classes that are normally visible in the class hierarchy. 
+# If set to NO (the default) these classes will be included in the various 
+# overviews. This option has no effect if EXTRACT_ALL is enabled.
+
+HIDE_UNDOC_CLASSES     = NO
+
+# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, Doxygen will hide all 
+# friend (class|struct|union) declarations. 
+# If set to NO (the default) these declarations will be included in the 
+# documentation.
+
+HIDE_FRIEND_COMPOUNDS  = NO
+
+# If the HIDE_IN_BODY_DOCS tag is set to YES, Doxygen will hide any 
+# documentation blocks found inside the body of a function. 
+# If set to NO (the default) these blocks will be appended to the 
+# function's detailed documentation block.
+
+HIDE_IN_BODY_DOCS      = NO
+
+# The INTERNAL_DOCS tag determines if documentation 
+# that is typed after a \internal command is included. If the tag is set 
+# to NO (the default) then the documentation will be excluded. 
+# Set it to YES to include the internal documentation.
+
+INTERNAL_DOCS          = NO
+
+# If the CASE_SENSE_NAMES tag is set to NO then Doxygen will only generate 
+# file names in lower-case letters. If set to YES upper-case letters are also 
+# allowed. This is useful if you have classes or files whose names only differ 
+# in case and if your file system supports case sensitive file names. Windows 
+# and Mac users are advised to set this option to NO.
+
+CASE_SENSE_NAMES       = YES
+
+# If the HIDE_SCOPE_NAMES tag is set to NO (the default) then Doxygen 
+# will show members with their full class and namespace scopes in the 
+# documentation. If set to YES the scope will be hidden.
+
+HIDE_SCOPE_NAMES       = NO
+
+# If the SHOW_INCLUDE_FILES tag is set to YES (the default) then Doxygen 
+# will put a list of the files that are included by a file in the documentation 
+# of that file.
+
+SHOW_INCLUDE_FILES     = YES
+
+# If the INLINE_INFO tag is set to YES (the default) then a tag [inline] 
+# is inserted in the documentation for inline members.
+
+INLINE_INFO            = YES
+
+# If the SORT_MEMBER_DOCS tag is set to YES (the default) then doxygen 
+# will sort the (detailed) documentation of file and class members 
+# alphabetically by member name. If set to NO the members will appear in 
+# declaration order.
+
+SORT_MEMBER_DOCS       = NO
+
+# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the 
+# brief documentation of file, namespace and class members alphabetically 
+# by member name. If set to NO (the default) the members will appear in 
+# declaration order.
+
+SORT_BRIEF_DOCS        = NO
+
+# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be 
+# sorted by fully-qualified names, including namespaces. If set to 
+# NO (the default), the class list will be sorted only by class name, 
+# not including the namespace part. 
+# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.
+# Note: This option applies only to the class list, not to the 
+# alphabetical list.
+
+SORT_BY_SCOPE_NAME     = NO
+
+# The GENERATE_TODOLIST tag can be used to enable (YES) or 
+# disable (NO) the todo list. This list is created by putting \todo 
+# commands in the documentation.
+
+GENERATE_TODOLIST      = NO
+
+# The GENERATE_TESTLIST tag can be used to enable (YES) or 
+# disable (NO) the test list. This list is created by putting \test 
+# commands in the documentation.
+
+GENERATE_TESTLIST      = NO
+
+# The GENERATE_BUGLIST tag can be used to enable (YES) or 
+# disable (NO) the bug list. This list is created by putting \bug 
+# commands in the documentation.
+
+GENERATE_BUGLIST       = NO
+
+# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or 
+# disable (NO) the deprecated list. This list is created by putting 
+# \deprecated commands in the documentation.
+
+GENERATE_DEPRECATEDLIST= NO
+
+# The ENABLED_SECTIONS tag can be used to enable conditional 
+# documentation sections, marked by \if sectionname ... \endif.
+
+ENABLED_SECTIONS       = 
+
+# The MAX_INITIALIZER_LINES tag determines the maximum number of lines 
+# the initial value of a variable or define consists of for it to appear in 
+# the documentation. If the initializer consists of more lines than specified 
+# here it will be hidden. Use a value of 0 to hide initializers completely. 
+# The appearance of the initializer of individual variables and defines in the 
+# documentation can be controlled using \showinitializer or \hideinitializer 
+# command in the documentation regardless of this setting.
+
+MAX_INITIALIZER_LINES  = 30
+
+# Set the SHOW_USED_FILES tag to NO to disable the list of files generated 
+# at the bottom of the documentation of classes and structs. If set to YES the 
+# list will mention the files that were used to generate the documentation.
+
+SHOW_USED_FILES        = NO
+
+# If the sources in your project are distributed over multiple directories 
+# then setting the SHOW_DIRECTORIES tag to YES will show the directory hierarchy 
+# in the documentation. The default is NO.
+
+SHOW_DIRECTORIES       = NO
+
+# The FILE_VERSION_FILTER tag can be used to specify a program or script that 
+# doxygen should invoke to get the current version for each file (typically from the 
+# version control system). Doxygen will invoke the program by executing (via 
+# popen()) the command <command> <input-file>, where <command> is the value of 
+# the FILE_VERSION_FILTER tag, and <input-file> is the name of an input file 
+# provided by doxygen. Whatever the program writes to standard output 
+# is used as the file version. See the manual for examples.
+
+FILE_VERSION_FILTER    = 
+
+#---------------------------------------------------------------------------
+# configuration options related to warning and progress messages
+#---------------------------------------------------------------------------
+
+# The QUIET tag can be used to turn on/off the messages that are generated 
+# by doxygen. Possible values are YES and NO. If left blank NO is used.
+
+QUIET                  = YES
+
+# The WARNINGS tag can be used to turn on/off the warning messages that are 
+# generated by doxygen. Possible values are YES and NO. If left blank 
+# NO is used.
+
+WARNINGS               = YES
+
+# If WARN_IF_UNDOCUMENTED is set to YES, then doxygen will generate warnings 
+# for undocumented members. If EXTRACT_ALL is set to YES then this flag will 
+# automatically be disabled.
+
+WARN_IF_UNDOCUMENTED   = NO
+
+# If WARN_IF_DOC_ERROR is set to YES, doxygen will generate warnings for 
+# potential errors in the documentation, such as not documenting some 
+# parameters in a documented function, or documenting parameters that 
+# don't exist or using markup commands wrongly.
+
+WARN_IF_DOC_ERROR      = YES
+
+# This WARN_NO_PARAMDOC option can be abled to get warnings for 
+# functions that are documented, but have no documentation for their parameters 
+# or return value. If set to NO (the default) doxygen will only warn about 
+# wrong or incomplete parameter documentation, but not about the absence of 
+# documentation.
+
+WARN_NO_PARAMDOC       = NO
+
+# The WARN_FORMAT tag determines the format of the warning messages that 
+# doxygen can produce. The string should contain the $file, $line, and $text 
+# tags, which will be replaced by the file and line number from which the 
+# warning originated and the warning text. Optionally the format may contain 
+# $version, which will be replaced by the version of the file (if it could 
+# be obtained via FILE_VERSION_FILTER)
+
+WARN_FORMAT            = "$file:$line: $text"
+
+# The WARN_LOGFILE tag can be used to specify a file to which warning 
+# and error messages should be written. If left blank the output is written 
+# to stderr.
+
+WARN_LOGFILE           = 
+
+#---------------------------------------------------------------------------
+# configuration options related to the input files
+#---------------------------------------------------------------------------
+
+# The INPUT tag can be used to specify the files and/or directories that contain 
+# documented source files. You may enter file names like "myfile.cpp" or 
+# directories like "/usr/src/myproject". Separate the files or directories 
+# with spaces.
+
+INPUT                  = ../lib \
+                         ../src/lib \
+                         ../include/netlink
+
+# This tag can be used to specify the character encoding of the source files that 
+# doxygen parses. Internally doxygen uses the UTF-8 encoding, which is also the default 
+# input encoding. Doxygen uses libiconv (or the iconv built into libc) for the transcoding. 
+# See http://www.gnu.org/software/libiconv for the list of possible encodings.
+
+INPUT_ENCODING         = UTF-8
+
+# If the value of the INPUT tag contains directories, you can use the 
+# FILE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp 
+# and *.h) to filter out the source-files in the directories. If left 
+# blank the following patterns are tested: 
+# *.c *.cc *.cxx *.cpp *.c++ *.java *.ii *.ixx *.ipp *.i++ *.inl *.h *.hh *.hxx 
+# *.hpp *.h++ *.idl *.odl *.cs *.php *.php3 *.inc *.m *.mm *.py
+
+FILE_PATTERNS          = *.c \
+                         *.h
+
+# The RECURSIVE tag can be used to turn specify whether or not subdirectories 
+# should be searched for input files as well. Possible values are YES and NO. 
+# If left blank NO is used.
+
+RECURSIVE              = YES
+
+# The EXCLUDE tag can be used to specify files and/or directories that should 
+# excluded from the INPUT source files. This way you can easily exclude a 
+# subdirectory from a directory tree whose root is specified with the INPUT tag.
+
+EXCLUDE                = SCCS
+
+# The EXCLUDE_SYMLINKS tag can be used select whether or not files or 
+# directories that are symbolic links (a Unix filesystem feature) are excluded 
+# from the input.
+
+EXCLUDE_SYMLINKS       = NO
+
+# If the value of the INPUT tag contains directories, you can use the 
+# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude 
+# certain files from those directories. Note that the wildcards are matched 
+# against the file with absolute path, so to exclude all test directories 
+# for example use the pattern */test/*
+
+EXCLUDE_PATTERNS       = 
+
+# The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names 
+# (namespaces, classes, functions, etc.) that should be excluded from the output. 
+# The symbol name can be a fully qualified name, a word, or if the wildcard * is used, 
+# a substring. Examples: ANamespace, AClass, AClass::ANamespace, ANamespace::*Test
+
+EXCLUDE_SYMBOLS        = 
+
+# The EXAMPLE_PATH tag can be used to specify one or more files or 
+# directories that contain example code fragments that are included (see 
+# the \include command).
+
+EXAMPLE_PATH           = 
+
+# If the value of the EXAMPLE_PATH tag contains directories, you can use the 
+# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp 
+# and *.h) to filter out the source-files in the directories. If left 
+# blank all files are included.
+
+EXAMPLE_PATTERNS       = 
+
+# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be 
+# searched for input files to be used with the \include or \dontinclude 
+# commands irrespective of the value of the RECURSIVE tag. 
+# Possible values are YES and NO. If left blank NO is used.
+
+EXAMPLE_RECURSIVE      = NO
+
+# The IMAGE_PATH tag can be used to specify one or more files or 
+# directories that contain image that are included in the documentation (see 
+# the \image command).
+
+IMAGE_PATH             = 
+
+# The INPUT_FILTER tag can be used to specify a program that doxygen should 
+# invoke to filter for each input file. Doxygen will invoke the filter program 
+# by executing (via popen()) the command <filter> <input-file>, where <filter> 
+# is the value of the INPUT_FILTER tag, and <input-file> is the name of an 
+# input file. Doxygen will then use the output that the filter program writes 
+# to standard output.  If FILTER_PATTERNS is specified, this tag will be 
+# ignored.
+
+INPUT_FILTER           = 
+
+# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern 
+# basis.  Doxygen will compare the file name with each pattern and apply the 
+# filter if there is a match.  The filters are a list of the form: 
+# pattern=filter (like *.cpp=my_cpp_filter). See INPUT_FILTER for further 
+# info on how filters are used. If FILTER_PATTERNS is empty, INPUT_FILTER 
+# is applied to all files.
+
+FILTER_PATTERNS        = 
+
+# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using 
+# INPUT_FILTER) will be used to filter the input files when producing source 
+# files to browse (i.e. when SOURCE_BROWSER is set to YES).
+
+FILTER_SOURCE_FILES    = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to source browsing
+#---------------------------------------------------------------------------
+
+# If the SOURCE_BROWSER tag is set to YES then a list of source files will 
+# be generated. Documented entities will be cross-referenced with these sources. 
+# Note: To get rid of all source code in the generated output, make sure also 
+# VERBATIM_HEADERS is set to NO.
+
+SOURCE_BROWSER         = YES
+
+# Setting the INLINE_SOURCES tag to YES will include the body 
+# of functions and classes directly in the documentation.
+
+INLINE_SOURCES         = NO
+
+# Setting the STRIP_CODE_COMMENTS tag to YES (the default) will instruct 
+# doxygen to hide any special comment blocks from generated source code 
+# fragments. Normal C and C++ comments will always remain visible.
+
+STRIP_CODE_COMMENTS    = NO
+
+# If the REFERENCED_BY_RELATION tag is set to YES (the default) 
+# then for each documented function all documented 
+# functions referencing it will be listed.
+
+REFERENCED_BY_RELATION = YES
+
+# If the REFERENCES_RELATION tag is set to YES (the default) 
+# then for each documented function all documented entities 
+# called/used by that function will be listed.
+
+REFERENCES_RELATION    = YES
+
+# If the REFERENCES_LINK_SOURCE tag is set to YES (the default)
+# and SOURCE_BROWSER tag is set to YES, then the hyperlinks from
+# functions in REFERENCES_RELATION and REFERENCED_BY_RELATION lists will
+# link to the source code.  Otherwise they will link to the documentstion.
+
+REFERENCES_LINK_SOURCE = YES
+
+# If the USE_HTAGS tag is set to YES then the references to source code 
+# will point to the HTML generated by the htags(1) tool instead of doxygen 
+# built-in source browser. The htags tool is part of GNU's global source 
+# tagging system (see http://www.gnu.org/software/global/global.html). You 
+# will need version 4.8.6 or higher.
+
+USE_HTAGS              = NO
+
+# If the VERBATIM_HEADERS tag is set to YES (the default) then Doxygen 
+# will generate a verbatim copy of the header file for each class for 
+# which an include is specified. Set to NO to disable this.
+
+VERBATIM_HEADERS       = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the alphabetical class index
+#---------------------------------------------------------------------------
+
+# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index 
+# of all compounds will be generated. Enable this if the project 
+# contains a lot of classes, structs, unions or interfaces.
+
+ALPHABETICAL_INDEX     = NO
+
+# If the alphabetical index is enabled (see ALPHABETICAL_INDEX) then 
+# the COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns 
+# in which this list will be split (can be a number in the range [1..20])
+
+COLS_IN_ALPHA_INDEX    = 5
+
+# In case all classes in a project start with a common prefix, all 
+# classes will be put under the same header in the alphabetical index. 
+# The IGNORE_PREFIX tag can be used to specify one or more prefixes that 
+# should be ignored while generating the index headers.
+
+IGNORE_PREFIX          = nl_
+
+#---------------------------------------------------------------------------
+# configuration options related to the HTML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_HTML tag is set to YES (the default) Doxygen will 
+# generate HTML output.
+
+GENERATE_HTML          = YES
+
+# The HTML_OUTPUT tag is used to specify where the HTML docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `html' will be used as the default path.
+
+HTML_OUTPUT            = html
+
+# The HTML_FILE_EXTENSION tag can be used to specify the file extension for 
+# each generated HTML page (for example: .htm,.php,.asp). If it is left blank 
+# doxygen will generate files with .html extension.
+
+HTML_FILE_EXTENSION    = .html
+
+# The HTML_HEADER tag can be used to specify a personal HTML header for 
+# each generated HTML page. If it is left blank doxygen will generate a 
+# standard header.
+
+HTML_HEADER            = 
+
+# The HTML_FOOTER tag can be used to specify a personal HTML footer for 
+# each generated HTML page. If it is left blank doxygen will generate a 
+# standard footer.
+
+HTML_FOOTER            = 
+
+# The HTML_STYLESHEET tag can be used to specify a user-defined cascading 
+# style sheet that is used by each HTML page. It can be used to 
+# fine-tune the look of the HTML output. If the tag is left blank doxygen 
+# will generate a default style sheet. Note that doxygen will try to copy 
+# the style sheet file to the HTML output directory, so don't put your own 
+# stylesheet in the HTML output directory as well, or it will be erased!
+
+HTML_STYLESHEET        = 
+
+# If the HTML_ALIGN_MEMBERS tag is set to YES, the members of classes, 
+# files or namespaces will be aligned in HTML using tables. If set to 
+# NO a bullet list will be used.
+
+HTML_ALIGN_MEMBERS     = YES
+
+# If the GENERATE_HTMLHELP tag is set to YES, additional index files 
+# will be generated that can be used as input for tools like the 
+# Microsoft HTML help workshop to generate a compressed HTML help file (.chm) 
+# of the generated HTML documentation.
+
+GENERATE_HTMLHELP      = NO
+
+# If the GENERATE_HTMLHELP tag is set to YES, the CHM_FILE tag can 
+# be used to specify the file name of the resulting .chm file. You 
+# can add a path in front of the file if the result should not be 
+# written to the html output directory.
+
+CHM_FILE               = 
+
+# If the GENERATE_HTMLHELP tag is set to YES, the HHC_LOCATION tag can 
+# be used to specify the location (absolute path including file name) of 
+# the HTML help compiler (hhc.exe). If non-empty doxygen will try to run 
+# the HTML help compiler on the generated index.hhp.
+
+HHC_LOCATION           = 
+
+# If the GENERATE_HTMLHELP tag is set to YES, the GENERATE_CHI flag 
+# controls if a separate .chi index file is generated (YES) or that 
+# it should be included in the master .chm file (NO).
+
+GENERATE_CHI           = NO
+
+# If the GENERATE_HTMLHELP tag is set to YES, the BINARY_TOC flag 
+# controls whether a binary table of contents is generated (YES) or a 
+# normal table of contents (NO) in the .chm file.
+
+BINARY_TOC             = NO
+
+# The TOC_EXPAND flag can be set to YES to add extra items for group members 
+# to the contents of the HTML help documentation and to the tree view.
+
+TOC_EXPAND             = NO
+
+# The DISABLE_INDEX tag can be used to turn on/off the condensed index at 
+# top of each HTML page. The value NO (the default) enables the index and 
+# the value YES disables it.
+
+DISABLE_INDEX          = NO
+
+# This tag can be used to set the number of enum values (range [1..20]) 
+# that doxygen will group on one line in the generated HTML documentation.
+
+ENUM_VALUES_PER_LINE   = 4
+
+# If the GENERATE_TREEVIEW tag is set to YES, a side panel will be
+# generated containing a tree-like index structure (just like the one that 
+# is generated for HTML Help). For this to work a browser that supports 
+# JavaScript, DHTML, CSS and frames is required (for instance Mozilla 1.0+, 
+# Netscape 6.0+, Internet explorer 5.0+, or Konqueror). Windows users are 
+# probably better off using the HTML help feature.
+
+GENERATE_TREEVIEW      = NO
+
+# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be 
+# used to set the initial width (in pixels) of the frame in which the tree 
+# is shown.
+
+TREEVIEW_WIDTH         = 250
+
+#---------------------------------------------------------------------------
+# configuration options related to the LaTeX output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_LATEX tag is set to YES (the default) Doxygen will 
+# generate Latex output.
+
+GENERATE_LATEX         = NO
+
+# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `latex' will be used as the default path.
+
+LATEX_OUTPUT           = latex
+
+# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be 
+# invoked. If left blank `latex' will be used as the default command name.
+
+LATEX_CMD_NAME         = latex
+
+# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to 
+# generate index for LaTeX. If left blank `makeindex' will be used as the 
+# default command name.
+
+MAKEINDEX_CMD_NAME     = makeindex
+
+# If the COMPACT_LATEX tag is set to YES Doxygen generates more compact 
+# LaTeX documents. This may be useful for small projects and may help to 
+# save some trees in general.
+
+COMPACT_LATEX          = NO
+
+# The PAPER_TYPE tag can be used to set the paper type that is used 
+# by the printer. Possible values are: a4, a4wide, letter, legal and 
+# executive. If left blank a4wide will be used.
+
+PAPER_TYPE             = a4wide
+
+# The EXTRA_PACKAGES tag can be to specify one or more names of LaTeX 
+# packages that should be included in the LaTeX output.
+
+EXTRA_PACKAGES         = 
+
+# The LATEX_HEADER tag can be used to specify a personal LaTeX header for 
+# the generated latex document. The header should contain everything until 
+# the first chapter. If it is left blank doxygen will generate a 
+# standard header. Notice: only use this tag if you know what you are doing!
+
+LATEX_HEADER           = 
+
+# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated 
+# is prepared for conversion to pdf (using ps2pdf). The pdf file will 
+# contain links (just like the HTML output) instead of page references 
+# This makes the output suitable for online browsing using a pdf viewer.
+
+PDF_HYPERLINKS         = NO
+
+# If the USE_PDFLATEX tag is set to YES, pdflatex will be used instead of 
+# plain latex in the generated Makefile. Set this option to YES to get a 
+# higher quality PDF documentation.
+
+USE_PDFLATEX           = NO
+
+# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \\batchmode. 
+# command to the generated LaTeX files. This will instruct LaTeX to keep 
+# running if errors occur, instead of asking the user for help. 
+# This option is also used when generating formulas in HTML.
+
+LATEX_BATCHMODE        = NO
+
+# If LATEX_HIDE_INDICES is set to YES then doxygen will not 
+# include the index chapters (such as File Index, Compound Index, etc.) 
+# in the output.
+
+LATEX_HIDE_INDICES     = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the RTF output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_RTF tag is set to YES Doxygen will generate RTF output 
+# The RTF output is optimized for Word 97 and may not look very pretty with 
+# other RTF readers or editors.
+
+GENERATE_RTF           = NO
+
+# The RTF_OUTPUT tag is used to specify where the RTF docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `rtf' will be used as the default path.
+
+RTF_OUTPUT             = rtf
+
+# If the COMPACT_RTF tag is set to YES Doxygen generates more compact 
+# RTF documents. This may be useful for small projects and may help to 
+# save some trees in general.
+
+COMPACT_RTF            = NO
+
+# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated 
+# will contain hyperlink fields. The RTF file will 
+# contain links (just like the HTML output) instead of page references. 
+# This makes the output suitable for online browsing using WORD or other 
+# programs which support those fields. 
+# Note: wordpad (write) and others do not support links.
+
+RTF_HYPERLINKS         = NO
+
+# Load stylesheet definitions from file. Syntax is similar to doxygen's 
+# config file, i.e. a series of assignments. You only have to provide 
+# replacements, missing definitions are set to their default value.
+
+RTF_STYLESHEET_FILE    = 
+
+# Set optional variables used in the generation of an rtf document. 
+# Syntax is similar to doxygen's config file.
+
+RTF_EXTENSIONS_FILE    = 
+
+#---------------------------------------------------------------------------
+# configuration options related to the man page output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_MAN tag is set to YES (the default) Doxygen will 
+# generate man pages
+
+GENERATE_MAN           = NO
+
+# The MAN_OUTPUT tag is used to specify where the man pages will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `man' will be used as the default path.
+
+MAN_OUTPUT             = man
+
+# The MAN_EXTENSION tag determines the extension that is added to 
+# the generated man pages (default is the subroutine's section .3)
+
+MAN_EXTENSION          = .3
+
+# If the MAN_LINKS tag is set to YES and Doxygen generates man output, 
+# then it will generate one additional man file for each entity 
+# documented in the real man page(s). These additional files 
+# only source the real man page, but without them the man command 
+# would be unable to find the correct page. The default is NO.
+
+MAN_LINKS              = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the XML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_XML tag is set to YES Doxygen will 
+# generate an XML file that captures the structure of 
+# the code including all documentation.
+
+GENERATE_XML           = NO
+
+# The XML_OUTPUT tag is used to specify where the XML pages will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `xml' will be used as the default path.
+
+XML_OUTPUT             = xml
+
+# The XML_SCHEMA tag can be used to specify an XML schema, 
+# which can be used by a validating XML parser to check the 
+# syntax of the XML files.
+
+XML_SCHEMA             = 
+
+# The XML_DTD tag can be used to specify an XML DTD, 
+# which can be used by a validating XML parser to check the 
+# syntax of the XML files.
+
+XML_DTD                = 
+
+# If the XML_PROGRAMLISTING tag is set to YES Doxygen will 
+# dump the program listings (including syntax highlighting 
+# and cross-referencing information) to the XML output. Note that 
+# enabling this will significantly increase the size of the XML output.
+
+XML_PROGRAMLISTING     = YES
+
+#---------------------------------------------------------------------------
+# configuration options for the AutoGen Definitions output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_AUTOGEN_DEF tag is set to YES Doxygen will 
+# generate an AutoGen Definitions (see autogen.sf.net) file 
+# that captures the structure of the code including all 
+# documentation. Note that this feature is still experimental 
+# and incomplete at the moment.
+
+GENERATE_AUTOGEN_DEF   = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the Perl module output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_PERLMOD tag is set to YES Doxygen will 
+# generate a Perl module file that captures the structure of 
+# the code including all documentation. Note that this 
+# feature is still experimental and incomplete at the 
+# moment.
+
+GENERATE_PERLMOD       = NO
+
+# If the PERLMOD_LATEX tag is set to YES Doxygen will generate 
+# the necessary Makefile rules, Perl scripts and LaTeX code to be able 
+# to generate PDF and DVI output from the Perl module output.
+
+PERLMOD_LATEX          = NO
+
+# If the PERLMOD_PRETTY tag is set to YES the Perl module output will be 
+# nicely formatted so it can be parsed by a human reader.  This is useful 
+# if you want to understand what is going on.  On the other hand, if this 
+# tag is set to NO the size of the Perl module output will be much smaller 
+# and Perl will parse it just the same.
+
+PERLMOD_PRETTY         = YES
+
+# The names of the make variables in the generated doxyrules.make file 
+# are prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX. 
+# This is useful so different doxyrules.make files included by the same 
+# Makefile don't overwrite each other's variables.
+
+PERLMOD_MAKEVAR_PREFIX = 
+
+#---------------------------------------------------------------------------
+# Configuration options related to the preprocessor   
+#---------------------------------------------------------------------------
+
+# If the ENABLE_PREPROCESSING tag is set to YES (the default) Doxygen will 
+# evaluate all C-preprocessor directives found in the sources and include 
+# files.
+
+ENABLE_PREPROCESSING   = YES
+
+# If the MACRO_EXPANSION tag is set to YES Doxygen will expand all macro 
+# names in the source code. If set to NO (the default) only conditional 
+# compilation will be performed. Macro expansion can be done in a controlled 
+# way by setting EXPAND_ONLY_PREDEF to YES.
+
+MACRO_EXPANSION        = NO
+
+# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES 
+# then the macro expansion is limited to the macros specified with the 
+# PREDEFINED and EXPAND_AS_DEFINED tags.
+
+EXPAND_ONLY_PREDEF     = NO
+
+# If the SEARCH_INCLUDES tag is set to YES (the default) the includes files 
+# in the INCLUDE_PATH (see below) will be search if a #include is found.
+
+SEARCH_INCLUDES        = NO
+
+# The INCLUDE_PATH tag can be used to specify one or more directories that 
+# contain include files that are not input files but should be processed by 
+# the preprocessor.
+
+INCLUDE_PATH           = 
+
+# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard 
+# patterns (like *.h and *.hpp) to filter out the header-files in the 
+# directories. If left blank, the patterns specified with FILE_PATTERNS will 
+# be used.
+
+INCLUDE_FILE_PATTERNS  = 
+
+# The PREDEFINED tag can be used to specify one or more macro names that 
+# are defined before the preprocessor is started (similar to the -D option of 
+# gcc). The argument of the tag is a list of macros of the form: name 
+# or name=definition (no spaces). If the definition and the = are 
+# omitted =1 is assumed. To prevent a macro definition from being 
+# undefined via #undef or recursively expanded use the := operator 
+# instead of the = operator.
+
+PREDEFINED             = 
+
+# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then 
+# this tag can be used to specify a list of macro names that should be expanded. 
+# The macro definition that is found in the sources will be used. 
+# Use the PREDEFINED tag if you want to use a different macro definition.
+
+EXPAND_AS_DEFINED      = 
+
+# If the SKIP_FUNCTION_MACROS tag is set to YES (the default) then 
+# doxygen's preprocessor will remove all function-like macros that are alone 
+# on a line, have an all uppercase name, and do not end with a semicolon. Such 
+# function macros are typically used for boiler-plate code, and will confuse 
+# the parser if not removed.
+
+SKIP_FUNCTION_MACROS   = YES
+
+#---------------------------------------------------------------------------
+# Configuration::additions related to external references   
+#---------------------------------------------------------------------------
+
+# The TAGFILES option can be used to specify one or more tagfiles. 
+# Optionally an initial location of the external documentation 
+# can be added for each tagfile. The format of a tag file without 
+# this location is as follows: 
+#   TAGFILES = file1 file2 ... 
+# Adding location for the tag files is done as follows: 
+#   TAGFILES = file1=loc1 "file2 = loc2" ... 
+# where "loc1" and "loc2" can be relative or absolute paths or 
+# URLs. If a location is present for each tag, the installdox tool 
+# does not have to be run to correct the links.
+# Note that each tag file must have a unique name
+# (where the name does NOT include the path)
+# If a tag file is not located in the directory in which doxygen 
+# is run, you must also specify the path to the tagfile here.
+
+TAGFILES               = 
+
+# When a file name is specified after GENERATE_TAGFILE, doxygen will create 
+# a tag file that is based on the input files it reads.
+
+GENERATE_TAGFILE       = 
+
+# If the ALLEXTERNALS tag is set to YES all external classes will be listed 
+# in the class index. If set to NO only the inherited external classes 
+# will be listed.
+
+ALLEXTERNALS           = YES
+
+# If the EXTERNAL_GROUPS tag is set to YES all external groups will be listed 
+# in the modules index. If set to NO, only the current project's groups will 
+# be listed.
+
+EXTERNAL_GROUPS        = YES
+
+# The PERL_PATH should be the absolute path and name of the perl script 
+# interpreter (i.e. the result of `which perl').
+
+PERL_PATH              = /usr/bin/perl
+
+#---------------------------------------------------------------------------
+# Configuration options related to the dot tool   
+#---------------------------------------------------------------------------
+
+# If the CLASS_DIAGRAMS tag is set to YES (the default) Doxygen will 
+# generate a inheritance diagram (in HTML, RTF and LaTeX) for classes with base 
+# or super classes. Setting the tag to NO turns the diagrams off. Note that 
+# this option is superseded by the HAVE_DOT option below. This is only a 
+# fallback. It is recommended to install and use dot, since it yields more 
+# powerful graphs.
+
+CLASS_DIAGRAMS         = NO
+
+# You can define message sequence charts within doxygen comments using the \msc 
+# command. Doxygen will then run the mscgen tool (see http://www.mcternan.me.uk/mscgen/) to 
+# produce the chart and insert it in the documentation. The MSCGEN_PATH tag allows you to 
+# specify the directory where the mscgen tool resides. If left empty the tool is assumed to 
+# be found in the default search path.
+
+MSCGEN_PATH            = 
+
+# If set to YES, the inheritance and collaboration graphs will hide 
+# inheritance and usage relations if the target is undocumented 
+# or is not a class.
+
+HIDE_UNDOC_RELATIONS   = YES
+
+# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is 
+# available from the path. This tool is part of Graphviz, a graph visualization 
+# toolkit from AT&T and Lucent Bell Labs. The other options in this section 
+# have no effect if this option is set to NO (the default)
+
+HAVE_DOT               = YES
+
+# If the CLASS_GRAPH and HAVE_DOT tags are set to YES then doxygen 
+# will generate a graph for each documented class showing the direct and 
+# indirect inheritance relations. Setting this tag to YES will force the 
+# the CLASS_DIAGRAMS tag to NO.
+
+CLASS_GRAPH            = NO
+
+# If the COLLABORATION_GRAPH and HAVE_DOT tags are set to YES then doxygen 
+# will generate a graph for each documented class showing the direct and 
+# indirect implementation dependencies (inheritance, containment, and 
+# class references variables) of the class with other documented classes.
+
+COLLABORATION_GRAPH    = NO
+
+# If the GROUP_GRAPHS and HAVE_DOT tags are set to YES then doxygen 
+# will generate a graph for groups, showing the direct groups dependencies
+
+GROUP_GRAPHS           = NO
+
+# If the UML_LOOK tag is set to YES doxygen will generate inheritance and 
+# collaboration diagrams in a style similar to the OMG's Unified Modeling 
+# Language.
+
+UML_LOOK               = YES
+
+# If set to YES, the inheritance and collaboration graphs will show the 
+# relations between templates and their instances.
+
+TEMPLATE_RELATIONS     = NO
+
+# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDE_GRAPH, and HAVE_DOT 
+# tags are set to YES then doxygen will generate a graph for each documented 
+# file showing the direct and indirect include dependencies of the file with 
+# other documented files.
+
+INCLUDE_GRAPH          = NO
+
+# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDED_BY_GRAPH, and 
+# HAVE_DOT tags are set to YES then doxygen will generate a graph for each 
+# documented header file showing the documented files that directly or 
+# indirectly include this file.
+
+INCLUDED_BY_GRAPH      = NO
+
+# If the CALL_GRAPH and HAVE_DOT tags are set to YES then doxygen will 
+# generate a call dependency graph for every global function or class method. 
+# Note that enabling this option will significantly increase the time of a run. 
+# So in most cases it will be better to enable call graphs for selected 
+# functions only using the \callgraph command.
+
+CALL_GRAPH             = NO
+
+# If the CALLER_GRAPH and HAVE_DOT tags are set to YES then doxygen will 
+# generate a caller dependency graph for every global function or class method. 
+# Note that enabling this option will significantly increase the time of a run. 
+# So in most cases it will be better to enable caller graphs for selected 
+# functions only using the \callergraph command.
+
+CALLER_GRAPH           = NO
+
+# If the GRAPHICAL_HIERARCHY and HAVE_DOT tags are set to YES then doxygen 
+# will graphical hierarchy of all classes instead of a textual one.
+
+GRAPHICAL_HIERARCHY    = YES
+
+# If the DIRECTORY_GRAPH, SHOW_DIRECTORIES and HAVE_DOT tags are set to YES 
+# then doxygen will show the dependencies a directory has on other directories 
+# in a graphical way. The dependency relations are determined by the #include
+# relations between the files in the directories.
+
+DIRECTORY_GRAPH        = NO
+
+# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images 
+# generated by dot. Possible values are png, jpg, or gif
+# If left blank png will be used.
+
+DOT_IMAGE_FORMAT       = png
+
+# The tag DOT_PATH can be used to specify the path where the dot tool can be 
+# found. If left blank, it is assumed the dot tool can be found in the path.
+
+DOT_PATH               = 
+
+# The DOTFILE_DIRS tag can be used to specify one or more directories that 
+# contain dot files that are included in the documentation (see the 
+# \dotfile command).
+
+DOTFILE_DIRS           = 
+
+# The MAX_DOT_GRAPH_MAX_NODES tag can be used to set the maximum number of 
+# nodes that will be shown in the graph. If the number of nodes in a graph 
+# becomes larger than this value, doxygen will truncate the graph, which is 
+# visualized by representing a node as a red box. Note that doxygen will always 
+# show the root nodes and its direct children regardless of this setting.
+
+DOT_GRAPH_MAX_NODES    = 50
+
+# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent 
+# background. This is disabled by default, which results in a white background. 
+# Warning: Depending on the platform used, enabling this option may lead to 
+# badly anti-aliased labels on the edges of a graph (i.e. they become hard to 
+# read).
+
+DOT_TRANSPARENT        = NO
+
+# Set the DOT_MULTI_TARGETS tag to YES allow dot to generate multiple output 
+# files in one run (i.e. multiple -o and -T options on the command line). This 
+# makes dot run faster, but since only newer versions of dot (>1.8.10) 
+# support this, this feature is disabled by default.
+
+DOT_MULTI_TARGETS      = NO
+
+# If the GENERATE_LEGEND tag is set to YES (the default) Doxygen will 
+# generate a legend page explaining the meaning of the various boxes and 
+# arrows in the dot generated graphs.
+
+GENERATE_LEGEND        = YES
+
+# If the DOT_CLEANUP tag is set to YES (the default) Doxygen will 
+# remove the intermediate dot files that are used to generate 
+# the various graphs.
+
+DOT_CLEANUP            = YES
+
+#---------------------------------------------------------------------------
+# Configuration::additions related to the search engine   
+#---------------------------------------------------------------------------
+
+# The SEARCHENGINE tag specifies whether or not a search engine should be 
+# used. If set to NO the values of all tags below this one will be ignored.
+
+SEARCHENGINE           = NO
diff -uNr libnl_kk/doc/html/.gitignore libnl/doc/html/.gitignore
--- libnl_kk/doc/html/.gitignore	1970-01-01 08:00:00.000000000 +0800
+++ libnl/doc/html/.gitignore	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1 @@
+*
diff -uNr libnl_kk/doc/libnl.css libnl/doc/libnl.css
--- libnl_kk/doc/libnl.css	1970-01-01 08:00:00.000000000 +0800
+++ libnl/doc/libnl.css	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,473 @@
+BODY,H1,H2,H3,H4,H5,H6,P,CENTER,TD,TH,UL,DL,DIV {
+	font-family: Geneva, Arial, Helvetica, sans-serif;
+}
+BODY,TD {
+	font-size: 90%;
+}
+H1 {
+	text-align: center;
+	font-size: 160%;
+}
+H2 {
+	font-size: 120%;
+}
+H3 {
+	font-size: 100%;
+}
+CAPTION { 
+	font-weight: bold 
+}
+DIV.qindex {
+	width: 100%;
+	background-color: #e8eef2;
+	border: 1px solid #84b0c7;
+	text-align: center;
+	margin: 2px;
+	padding: 2px;
+	line-height: 140%;
+}
+DIV.navpath {
+	width: 100%;
+	background-color: #e8eef2;
+	border: 1px solid #84b0c7;
+	text-align: center;
+	margin: 2px;
+	padding: 2px;
+	line-height: 140%;
+}
+DIV.navtab {
+       background-color: #e8eef2;
+       border: 1px solid #84b0c7;
+       text-align: center;
+       margin: 2px;
+       margin-right: 15px;
+       padding: 2px;
+}
+TD.navtab {
+       font-size: 70%;
+}
+A.qindex {
+       text-decoration: none;
+       font-weight: bold;
+       color: #1A419D;
+}
+A.qindex:visited {
+       text-decoration: none;
+       font-weight: bold;
+       color: #1A419D
+}
+A.qindex:hover {
+	text-decoration: none;
+	background-color: #ddddff;
+}
+A.qindexHL {
+	text-decoration: none;
+	font-weight: bold;
+	background-color: #6666cc;
+	color: #ffffff;
+	border: 1px double #9295C2;
+}
+A.qindexHL:hover {
+	text-decoration: none;
+	background-color: #6666cc;
+	color: #ffffff;
+}
+A.qindexHL:visited { 
+	text-decoration: none; 
+	background-color: #6666cc; 
+	color: #ffffff 
+}
+A.el { 
+	text-decoration: none; 
+	font-weight: bold 
+}
+A.elRef { 
+	font-weight: bold 
+}
+A.code:link { 
+	text-decoration: none; 
+	font-weight: normal; 
+	color: #0000FF
+}
+A.code:visited { 
+	text-decoration: none; 
+	font-weight: normal; 
+	color: #0000FF
+}
+A.codeRef:link { 
+	font-weight: normal; 
+	color: #0000FF
+}
+A.codeRef:visited { 
+	font-weight: normal; 
+	color: #0000FF
+}
+A:hover { 
+	text-decoration: none; 	
+	background-color: #f2f2ff 
+}
+DL.el { 
+	margin-left: -1cm 
+}
+.fragment {
+       font-family: monospace, fixed;
+       font-size: 95%;
+}
+PRE.fragment {
+	border: 1px solid #CCCCCC;
+	background-color: #f5f5f5;
+	margin-top: 4px;
+	margin-bottom: 4px;
+	margin-left: 2px;
+	margin-right: 8px;
+	padding-left: 6px;
+	padding-right: 6px;
+	padding-top: 4px;
+	padding-bottom: 4px;
+}
+DIV.ah { 
+	background-color: black; 
+	font-weight: bold; 
+	color: #ffffff; 
+	margin-bottom: 3px; 
+	margin-top: 3px 
+}
+
+DIV.groupHeader {
+       margin-left: 16px;
+       margin-top: 12px;
+       margin-bottom: 6px;
+       font-weight: bold;
+}
+DIV.groupText { 
+	margin-left: 16px; 
+	font-style: italic; 
+	font-size: 90% 
+}
+BODY {
+	background: white;
+	color: black;
+	margin-right: 20px;
+	margin-left: 20px;
+}
+TD.indexkey {
+	background-color: #e8eef2;
+	font-weight: bold;
+	padding-right  : 10px;
+	padding-top    : 2px;
+	padding-left   : 10px;
+	padding-bottom : 2px;
+	margin-left    : 0px;
+	margin-right   : 0px;
+	margin-top     : 2px;
+	margin-bottom  : 2px;
+	border: 1px solid #CCCCCC;
+}
+TD.indexvalue {
+	background-color: #e8eef2;
+	font-style: italic;
+	padding-right  : 10px;
+	padding-top    : 2px;
+	padding-left   : 10px;
+	padding-bottom : 2px;
+	margin-left    : 0px;
+	margin-right   : 0px;
+	margin-top     : 2px;
+	margin-bottom  : 2px;
+	border: 1px solid #CCCCCC;
+}
+TR.memlist {
+	background-color: #f0f0f0; 
+}
+P.formulaDsp { 
+	text-align: center; 
+}
+IMG.formulaDsp {
+}
+IMG.formulaInl { 
+	vertical-align: middle; 
+}
+SPAN.keyword       { color: #008000 }
+SPAN.keywordtype   { color: #604020 }
+SPAN.keywordflow   { color: #e08000 }
+SPAN.comment       { color: #800000 }
+SPAN.preprocessor  { color: #806020 }
+SPAN.stringliteral { color: #002080 }
+SPAN.charliteral   { color: #008080 }
+SPAN.vhdldigit     { color: #ff00ff }
+SPAN.vhdlchar      { color: #000000 }
+SPAN.vhdlkeyword   { color: #700070 }
+SPAN.vhdllogic     { color: #ff0000 }
+
+.mdescLeft {
+	padding: 0px 8px 4px 8px;
+	font-size: 80%;
+	font-style: italic;
+	background-color: #FAFAFA;
+	border-top: 1px none #E0E0E0;
+	border-right: 1px none #E0E0E0;
+	border-bottom: 1px none #E0E0E0;
+	border-left: 1px none #E0E0E0;
+	margin: 0px;
+}
+.mdescRight {
+        padding: 0px 8px 4px 8px;
+	font-size: 80%;
+	font-style: italic;
+	background-color: #FAFAFA;
+	border-top: 1px none #E0E0E0;
+	border-right: 1px none #E0E0E0;
+	border-bottom: 1px none #E0E0E0;
+	border-left: 1px none #E0E0E0;
+	margin: 0px;
+}
+.memItemLeft {
+	padding: 1px 0px 0px 8px;
+	margin: 4px;
+	border-top-width: 1px;
+	border-right-width: 1px;
+	border-bottom-width: 1px;
+	border-left-width: 1px;
+	border-top-color: #E0E0E0;
+	border-right-color: #E0E0E0;
+	border-bottom-color: #E0E0E0;
+	border-left-color: #E0E0E0;
+	border-top-style: solid;
+	border-right-style: none;
+	border-bottom-style: none;
+	border-left-style: none;
+	background-color: #FAFAFA;
+	font-size: 80%;
+}
+.memItemRight {
+	padding: 1px 8px 0px 8px;
+	margin: 4px;
+	border-top-width: 1px;
+	border-right-width: 1px;
+	border-bottom-width: 1px;
+	border-left-width: 1px;
+	border-top-color: #E0E0E0;
+	border-right-color: #E0E0E0;
+	border-bottom-color: #E0E0E0;
+	border-left-color: #E0E0E0;
+	border-top-style: solid;
+	border-right-style: none;
+	border-bottom-style: none;
+	border-left-style: none;
+	background-color: #FAFAFA;
+	font-size: 80%;
+}
+.memTemplItemLeft {
+	padding: 1px 0px 0px 8px;
+	margin: 4px;
+	border-top-width: 1px;
+	border-right-width: 1px;
+	border-bottom-width: 1px;
+	border-left-width: 1px;
+	border-top-color: #E0E0E0;
+	border-right-color: #E0E0E0;
+	border-bottom-color: #E0E0E0;
+	border-left-color: #E0E0E0;
+	border-top-style: none;
+	border-right-style: none;
+	border-bottom-style: none;
+	border-left-style: none;
+	background-color: #FAFAFA;
+	font-size: 80%;
+}
+.memTemplItemRight {
+	padding: 1px 8px 0px 8px;
+	margin: 4px;
+	border-top-width: 1px;
+	border-right-width: 1px;
+	border-bottom-width: 1px;
+	border-left-width: 1px;
+	border-top-color: #E0E0E0;
+	border-right-color: #E0E0E0;
+	border-bottom-color: #E0E0E0;
+	border-left-color: #E0E0E0;
+	border-top-style: none;
+	border-right-style: none;
+	border-bottom-style: none;
+	border-left-style: none;
+	background-color: #FAFAFA;
+	font-size: 80%;
+}
+.memTemplParams {
+	padding: 1px 0px 0px 8px;
+	margin: 4px;
+	border-top-width: 1px;
+	border-right-width: 1px;
+	border-bottom-width: 1px;
+	border-left-width: 1px;
+	border-top-color: #E0E0E0;
+	border-right-color: #E0E0E0;
+	border-bottom-color: #E0E0E0;
+	border-left-color: #E0E0E0;
+	border-top-style: solid;
+	border-right-style: none;
+	border-bottom-style: none;
+	border-left-style: none;
+	color: #606060;
+	background-color: #FAFAFA;
+	font-size: 80%;
+}
+.search { 
+	color: #003399;
+	font-weight: bold;
+}
+FORM.search {
+	margin-bottom: 0px;
+	margin-top: 0px;
+}
+INPUT.search { 
+	font-size: 75%;
+	color: #000080;
+	font-weight: normal;
+	background-color: #e8eef2;
+}
+TD.tiny { 
+	font-size: 75%;
+}
+a {
+	color: #1A41A8;
+}
+a:visited {
+	color: #2A3798;
+}
+.dirtab { 
+	padding: 4px;
+	border-collapse: collapse;
+	border: 1px solid #84b0c7;
+}
+TH.dirtab { 
+	background: #e8eef2;
+	font-weight: bold;
+}
+HR { 
+	height: 1px;
+	border: none;
+	border-top: 1px solid black;
+}
+
+/* Style for detailed member documentation */
+.memtemplate {
+	font-size: 80%;
+	color: #606060;
+	font-weight: normal;
+	margin-left: 3px;
+} 
+.memnav { 
+	background-color: #e8eef2;
+	border: 1px solid #84b0c7;
+	text-align: center;
+	margin: 2px;
+	margin-right: 15px;
+	padding: 2px;
+}
+.memitem {
+	padding: 4px;
+	background-color: #eef3f5;
+	border-width: 1px;
+	border-style: solid;
+	border-color: #dedeee;
+	-moz-border-radius: 8px 8px 8px 8px;
+}
+.memname {
+	white-space: nowrap;
+	font-weight: bold;
+}
+.memdoc{
+	padding-left: 10px;
+}
+.memproto {
+	background-color: #d5e1e8;
+	width: 100%;
+	border-width: 1px;
+	border-style: solid;
+	border-color: #84b0c7;
+	font-weight: bold;
+	-moz-border-radius: 8px 8px 8px 8px;
+}
+.paramkey {
+	text-align: right;
+}
+.paramtype {
+	white-space: nowrap;
+}
+.paramname {
+	color: #602020;
+	font-style: italic;
+	white-space: nowrap;
+}
+/* End Styling for detailed member documentation */
+
+/* for the tree view */
+.ftvtree {
+	font-family: sans-serif;
+	margin:0.5em;
+}
+/* these are for tree view when used as main index */
+.directory { 
+	font-size: 9pt; 
+	font-weight: bold; 
+}
+.directory h3 { 
+	margin: 0px; 
+	margin-top: 1em; 
+	font-size: 11pt; 
+}
+
+/* The following two styles can be used to replace the root node title */
+/* with an image of your choice.  Simply uncomment the next two styles, */
+/* specify the name of your image and be sure to set 'height' to the */
+/* proper pixel height of your image. */
+
+/* .directory h3.swap { */
+/* 	height: 61px; */
+/* 	background-repeat: no-repeat; */
+/* 	background-image: url("yourimage.gif"); */
+/* } */
+/* .directory h3.swap span { */
+/* 	display: none; */
+/* } */
+
+.directory > h3 { 
+	margin-top: 0; 
+}
+.directory p { 
+	margin: 0px; 
+	white-space: nowrap; 
+}
+.directory div { 
+	display: none; 
+	margin: 0px; 
+}
+.directory img { 
+	vertical-align: -30%; 
+}
+/* these are for tree view when not used as main index */
+.directory-alt { 
+	font-size: 100%; 
+	font-weight: bold; 
+}
+.directory-alt h3 { 
+	margin: 0px; 
+	margin-top: 1em; 
+	font-size: 11pt; 
+}
+.directory-alt > h3 { 
+	margin-top: 0; 
+}
+.directory-alt p { 
+	margin: 0px; 
+	white-space: nowrap; 
+}
+.directory-alt div { 
+	display: none; 
+	margin: 0px; 
+}
+.directory-alt img { 
+	vertical-align: -30%; 
+}
+
diff -uNr libnl_kk/doc/Makefile.am libnl/doc/Makefile.am
--- libnl_kk/doc/Makefile.am	1970-01-01 08:00:00.000000000 +0800
+++ libnl/doc/Makefile.am	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,9 @@
+# -*- Makefile -*-
+
+.PHONY: gendoc
+
+gendoc:
+	doxygen Doxyfile;
+
+distclean-local:
+	rm -f html/*;
diff -uNr libnl_kk/etc/pktloc libnl/etc/pktloc
--- libnl_kk/etc/pktloc	1970-01-01 08:00:00.000000000 +0800
+++ libnl/etc/pktloc	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,44 @@
+#
+# Location definitions for packet matching
+#
+
+# name		alignment	offset		mask
+ip.version	u8		net+0		0xF0
+ip.hdrlen	u8		net+0		0x0F
+ip.diffserv	u8		net+1
+ip.length	u16		net+2
+ip.id		u16		net+4
+ip.df		u8		net+6		0x40
+ip.mf		u8		net+6		0x20
+ip.offset	u16		net+6		0x1FFF
+ip.ttl		u8		net+8
+ip.proto	u8		net+9
+ip.chksum	u16		net+10
+ip.src		u32		net+12
+ip.dst		u32		net+16
+
+
+#
+# Transmission Control Protocol (TCP)
+#
+# name		alignment	offset		mask
+tcp.sport	u16		tcp+0
+tcp.dport	u16		tcp+2
+tcp.seq		u32		tcp+4
+tcp.ack		u32		tcp+8
+tcp.off		u8		tcp+12		0xF0
+tcp.reserved	u8		tcp+12		0x0F
+# FLAGS
+tcp.win		u16		tcp+14
+tcp.csum	u16		tcp+16
+tcp.urg		u16		tcp+18
+tcp.opts	u32		tcp+20
+
+#
+# User Datagram Protocol (UDP)
+#
+# name		alignment	offset		mask
+udp.sport	u16		tcp+0
+udp.dport	u16		tcp+2
+udp.length	u16		tcp+4
+udp.csum	u16		tcp+6
diff -uNr libnl_kk/.gitignore libnl/.gitignore
--- libnl_kk/.gitignore	1970-01-01 08:00:00.000000000 +0800
+++ libnl/.gitignore	2015-09-10 13:39:33.055778085 +0800
@@ -0,0 +1,28 @@
+.deps
+.libs
+.dirstamp
+*.in
+*.la
+*.lo
+*.o
+*.swp
+Makefile
+/lib/stamp-h1
+
+/libnl-1.pc
+/doc/Doxyfile
+/lib/defs.h
+cscope.*
+
+/aclocal.m4
+/autom4te.cache
+/compile
+/config.*
+/configure
+/depcomp
+/libtool
+/ltmain.sh
+/install-sh
+/missing
+
+/*.pc
diff -uNr libnl_kk/include/linux/genetlink.h libnl/include/linux/genetlink.h
--- libnl_kk/include/linux/genetlink.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/linux/genetlink.h	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,82 @@
+#ifndef __LINUX_GENERIC_NETLINK_H
+#define __LINUX_GENERIC_NETLINK_H
+
+#include <linux/netlink.h>
+
+#define GENL_NAMSIZ	16	/* length of family name */
+
+#define GENL_MIN_ID	NLMSG_MIN_TYPE
+#define GENL_MAX_ID	1023
+
+struct genlmsghdr {
+	__u8	cmd;
+	__u8	version;
+	__u16	reserved;
+};
+
+#define GENL_HDRLEN	NLMSG_ALIGN(sizeof(struct genlmsghdr))
+
+#define GENL_ADMIN_PERM		0x01
+#define GENL_CMD_CAP_DO		0x02
+#define GENL_CMD_CAP_DUMP	0x04
+#define GENL_CMD_CAP_HASPOL	0x08
+
+/*
+ * List of reserved static generic netlink identifiers:
+ */
+#define GENL_ID_GENERATE	0
+#define GENL_ID_CTRL		NLMSG_MIN_TYPE
+
+/**************************************************************************
+ * Controller
+ **************************************************************************/
+
+enum {
+	CTRL_CMD_UNSPEC,
+	CTRL_CMD_NEWFAMILY,
+	CTRL_CMD_DELFAMILY,
+	CTRL_CMD_GETFAMILY,
+	CTRL_CMD_NEWOPS,
+	CTRL_CMD_DELOPS,
+	CTRL_CMD_GETOPS,
+	CTRL_CMD_NEWMCAST_GRP,
+	CTRL_CMD_DELMCAST_GRP,
+	CTRL_CMD_GETMCAST_GRP, /* unused */
+	__CTRL_CMD_MAX,
+};
+
+#define CTRL_CMD_MAX (__CTRL_CMD_MAX - 1)
+
+enum {
+	CTRL_ATTR_UNSPEC,
+	CTRL_ATTR_FAMILY_ID,
+	CTRL_ATTR_FAMILY_NAME,
+	CTRL_ATTR_VERSION,
+	CTRL_ATTR_HDRSIZE,
+	CTRL_ATTR_MAXATTR,
+	CTRL_ATTR_OPS,
+	CTRL_ATTR_MCAST_GROUPS,
+	__CTRL_ATTR_MAX,
+};
+
+#define CTRL_ATTR_MAX (__CTRL_ATTR_MAX - 1)
+
+enum {
+	CTRL_ATTR_OP_UNSPEC,
+	CTRL_ATTR_OP_ID,
+	CTRL_ATTR_OP_FLAGS,
+	__CTRL_ATTR_OP_MAX,
+};
+
+#define CTRL_ATTR_OP_MAX (__CTRL_ATTR_OP_MAX - 1)
+
+enum {
+	CTRL_ATTR_MCAST_GRP_UNSPEC,
+	CTRL_ATTR_MCAST_GRP_NAME,
+	CTRL_ATTR_MCAST_GRP_ID,
+	__CTRL_ATTR_MCAST_GRP_MAX,
+};
+
+#define CTRL_ATTR_MCAST_GRP_MAX (__CTRL_ATTR_MCAST_GRP_MAX - 1)
+
+#endif	/* __LINUX_GENERIC_NETLINK_H */
diff -uNr libnl_kk/include/linux/gen_stats.h libnl/include/linux/gen_stats.h
--- libnl_kk/include/linux/gen_stats.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/linux/gen_stats.h	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,60 @@
+#ifndef __LINUX_GEN_STATS_H
+#define __LINUX_GEN_STATS_H
+
+enum {
+	TCA_STATS_UNSPEC,
+	TCA_STATS_BASIC,
+	TCA_STATS_RATE_EST,
+	TCA_STATS_QUEUE,
+	TCA_STATS_APP,
+	__TCA_STATS_MAX,
+};
+#define TCA_STATS_MAX (__TCA_STATS_MAX - 1)
+
+/**
+ * @bytes: number of seen bytes
+ * @packets: number of seen packets
+ */
+struct gnet_stats_basic
+{
+	__u64	bytes;
+	__u32	packets;
+};
+
+/**
+ * @bps: current byte rate
+ * @pps: current packet rate
+ */
+struct gnet_stats_rate_est
+{
+	__u32	bps;
+	__u32	pps;
+};
+
+/**
+ * @qlen: queue length
+ * @backlog: backlog size of queue
+ * @drops: number of dropped packets
+ * @requeues: number of requeues
+ */
+struct gnet_stats_queue
+{
+	__u32	qlen;
+	__u32	backlog;
+	__u32	drops;
+	__u32	requeues;
+	__u32	overlimits;
+};
+
+/**
+ * @interval: sampling period
+ * @ewma_log: the log of measurement window weight
+ */
+struct gnet_estimator
+{
+	signed char	interval;
+	unsigned char	ewma_log;
+};
+
+
+#endif /* __LINUX_GEN_STATS_H */
diff -uNr libnl_kk/include/linux/if_addr.h libnl/include/linux/if_addr.h
--- libnl_kk/include/linux/if_addr.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/linux/if_addr.h	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,62 @@
+#ifndef __LINUX_IF_ADDR_H
+#define __LINUX_IF_ADDR_H
+
+#include <linux/netlink.h>
+
+struct ifaddrmsg
+{
+	__u8		ifa_family;
+	__u8		ifa_prefixlen;	/* The prefix length		*/
+	__u8		ifa_flags;	/* Flags			*/
+	__u8		ifa_scope;	/* Address scope		*/
+	__u32		ifa_index;	/* Link index			*/
+};
+
+/*
+ * Important comment:
+ * IFA_ADDRESS is prefix address, rather than local interface address.
+ * It makes no difference for normally configured broadcast interfaces,
+ * but for point-to-point IFA_ADDRESS is DESTINATION address,
+ * local address is supplied in IFA_LOCAL attribute.
+ */
+enum
+{
+	IFA_UNSPEC,
+	IFA_ADDRESS,
+	IFA_LOCAL,
+	IFA_LABEL,
+	IFA_BROADCAST,
+	IFA_ANYCAST,
+	IFA_CACHEINFO,
+	IFA_MULTICAST,
+	__IFA_MAX,
+};
+
+#define IFA_MAX (__IFA_MAX - 1)
+
+/* ifa_flags */
+#define IFA_F_SECONDARY		0x01
+#define IFA_F_TEMPORARY		IFA_F_SECONDARY
+
+#define	IFA_F_NODAD		0x02
+#define IFA_F_OPTIMISTIC	0x04
+#define	IFA_F_HOMEADDRESS	0x10
+#define IFA_F_DEPRECATED	0x20
+#define IFA_F_TENTATIVE		0x40
+#define IFA_F_PERMANENT		0x80
+
+struct ifa_cacheinfo
+{
+	__u32	ifa_prefered;
+	__u32	ifa_valid;
+	__u32	cstamp; /* created timestamp, hundredths of seconds */
+	__u32	tstamp; /* updated timestamp, hundredths of seconds */
+};
+
+/* backwards compatibility for userspace */
+#ifndef __KERNEL__
+#define IFA_RTA(r)  ((struct rtattr*)(((char*)(r)) + NLMSG_ALIGN(sizeof(struct ifaddrmsg))))
+#define IFA_PAYLOAD(n) NLMSG_PAYLOAD(n,sizeof(struct ifaddrmsg))
+#endif
+
+#endif
diff -uNr libnl_kk/include/linux/if_arp.h libnl/include/linux/if_arp.h
--- libnl_kk/include/linux/if_arp.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/linux/if_arp.h	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,149 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		Global definitions for the ARP (RFC 826) protocol.
+ *
+ * Version:	@(#)if_arp.h	1.0.1	04/16/93
+ *
+ * Authors:	Original taken from Berkeley UNIX 4.3, (c) UCB 1986-1988
+ *		Portions taken from the KA9Q/NOS (v2.00m PA0GRI) source.
+ *		Ross Biro
+ *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *		Florian La Roche,
+ *		Jonathan Layes <layes@loran.com>
+ *		Arnaldo Carvalho de Melo <acme@conectiva.com.br> ARPHRD_HWX25
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+#ifndef _LINUX_IF_ARP_H
+#define _LINUX_IF_ARP_H
+
+/* ARP protocol HARDWARE identifiers. */
+#define ARPHRD_NETROM	0		/* from KA9Q: NET/ROM pseudo	*/
+#define ARPHRD_ETHER 	1		/* Ethernet 10Mbps		*/
+#define	ARPHRD_EETHER	2		/* Experimental Ethernet	*/
+#define	ARPHRD_AX25	3		/* AX.25 Level 2		*/
+#define	ARPHRD_PRONET	4		/* PROnet token ring		*/
+#define	ARPHRD_CHAOS	5		/* Chaosnet			*/
+#define	ARPHRD_IEEE802	6		/* IEEE 802.2 Ethernet/TR/TB	*/
+#define	ARPHRD_ARCNET	7		/* ARCnet			*/
+#define	ARPHRD_APPLETLK	8		/* APPLEtalk			*/
+#define ARPHRD_DLCI	15		/* Frame Relay DLCI		*/
+#define ARPHRD_ATM	19		/* ATM 				*/
+#define ARPHRD_METRICOM	23		/* Metricom STRIP (new IANA id)	*/
+#define	ARPHRD_IEEE1394	24		/* IEEE 1394 IPv4 - RFC 2734	*/
+#define ARPHRD_EUI64	27		/* EUI-64                       */
+#define ARPHRD_INFINIBAND 32		/* InfiniBand			*/
+
+/* Dummy types for non ARP hardware */
+#define ARPHRD_SLIP	256
+#define ARPHRD_CSLIP	257
+#define ARPHRD_SLIP6	258
+#define ARPHRD_CSLIP6	259
+#define ARPHRD_RSRVD	260		/* Notional KISS type 		*/
+#define ARPHRD_ADAPT	264
+#define ARPHRD_ROSE	270
+#define ARPHRD_X25	271		/* CCITT X.25			*/
+#define ARPHRD_HWX25	272		/* Boards with X.25 in firmware	*/
+#define ARPHRD_PPP	512
+#define ARPHRD_CISCO	513		/* Cisco HDLC	 		*/
+#define ARPHRD_HDLC	ARPHRD_CISCO
+#define ARPHRD_LAPB	516		/* LAPB				*/
+#define ARPHRD_DDCMP    517		/* Digital's DDCMP protocol     */
+#define ARPHRD_RAWHDLC	518		/* Raw HDLC			*/
+
+#define ARPHRD_TUNNEL	768		/* IPIP tunnel			*/
+#define ARPHRD_TUNNEL6	769		/* IP6IP6 tunnel       		*/
+#define ARPHRD_FRAD	770             /* Frame Relay Access Device    */
+#define ARPHRD_SKIP	771		/* SKIP vif			*/
+#define ARPHRD_LOOPBACK	772		/* Loopback device		*/
+#define ARPHRD_LOCALTLK 773		/* Localtalk device		*/
+#define ARPHRD_FDDI	774		/* Fiber Distributed Data Interface */
+#define ARPHRD_BIF      775             /* AP1000 BIF                   */
+#define ARPHRD_SIT	776		/* sit0 device - IPv6-in-IPv4	*/
+#define ARPHRD_IPDDP	777		/* IP over DDP tunneller	*/
+#define ARPHRD_IPGRE	778		/* GRE over IP			*/
+#define ARPHRD_PIMREG	779		/* PIMSM register interface	*/
+#define ARPHRD_HIPPI	780		/* High Performance Parallel Interface */
+#define ARPHRD_ASH	781		/* Nexus 64Mbps Ash		*/
+#define ARPHRD_ECONET	782		/* Acorn Econet			*/
+#define ARPHRD_IRDA 	783		/* Linux-IrDA			*/
+/* ARP works differently on different FC media .. so  */
+#define ARPHRD_FCPP	784		/* Point to point fibrechannel	*/
+#define ARPHRD_FCAL	785		/* Fibrechannel arbitrated loop */
+#define ARPHRD_FCPL	786		/* Fibrechannel public loop	*/
+#define ARPHRD_FCFABRIC	787		/* Fibrechannel fabric		*/
+	/* 787->799 reserved for fibrechannel media types */
+#define ARPHRD_IEEE802_TR 800		/* Magic type ident for TR	*/
+#define ARPHRD_IEEE80211 801		/* IEEE 802.11			*/
+#define ARPHRD_IEEE80211_PRISM 802	/* IEEE 802.11 + Prism2 header  */
+#define ARPHRD_IEEE80211_RADIOTAP 803	/* IEEE 802.11 + radiotap header */
+
+#define ARPHRD_VOID	  0xFFFF	/* Void type, nothing is known */
+#define ARPHRD_NONE	  0xFFFE	/* zero header length */
+
+/* ARP protocol opcodes. */
+#define	ARPOP_REQUEST	1		/* ARP request			*/
+#define	ARPOP_REPLY	2		/* ARP reply			*/
+#define	ARPOP_RREQUEST	3		/* RARP request			*/
+#define	ARPOP_RREPLY	4		/* RARP reply			*/
+#define	ARPOP_InREQUEST	8		/* InARP request		*/
+#define	ARPOP_InREPLY	9		/* InARP reply			*/
+#define	ARPOP_NAK	10		/* (ATM)ARP NAK			*/
+
+
+/* ARP ioctl request. */
+struct arpreq {
+  struct sockaddr	arp_pa;		/* protocol address		*/
+  struct sockaddr	arp_ha;		/* hardware address		*/
+  int			arp_flags;	/* flags			*/
+  struct sockaddr       arp_netmask;    /* netmask (only for proxy arps) */
+  char			arp_dev[16];
+};
+
+struct arpreq_old {
+  struct sockaddr	arp_pa;		/* protocol address		*/
+  struct sockaddr	arp_ha;		/* hardware address		*/
+  int			arp_flags;	/* flags			*/
+  struct sockaddr       arp_netmask;    /* netmask (only for proxy arps) */
+};
+
+/* ARP Flag values. */
+#define ATF_COM		0x02		/* completed entry (ha valid)	*/
+#define	ATF_PERM	0x04		/* permanent entry		*/
+#define	ATF_PUBL	0x08		/* publish entry		*/
+#define	ATF_USETRAILERS	0x10		/* has requested trailers	*/
+#define ATF_NETMASK     0x20            /* want to use a netmask (only
+					   for proxy entries) */
+#define ATF_DONTPUB	0x40		/* don't answer this addresses	*/
+
+/*
+ *	This structure defines an ethernet arp header.
+ */
+
+struct arphdr
+{
+	unsigned short	ar_hrd;		/* format of hardware address	*/
+	unsigned short	ar_pro;		/* format of protocol address	*/
+	unsigned char	ar_hln;		/* length of hardware address	*/
+	unsigned char	ar_pln;		/* length of protocol address	*/
+	unsigned short	ar_op;		/* ARP opcode (command)		*/
+
+#if 0
+	 /*
+	  *	 Ethernet looks like this : This bit is variable sized however...
+	  */
+	unsigned char		ar_sha[ETH_ALEN];	/* sender hardware address	*/
+	unsigned char		ar_sip[4];		/* sender IP address		*/
+	unsigned char		ar_tha[ETH_ALEN];	/* target hardware address	*/
+	unsigned char		ar_tip[4];		/* target IP address		*/
+#endif
+
+};
+
+#endif	/* _LINUX_IF_ARP_H */
diff -uNr libnl_kk/include/linux/if_bad.h libnl/include/linux/if_bad.h
--- libnl_kk/include/linux/if_bad.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/linux/if_bad.h	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,131 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		Global definitions for the INET interface module.
+ *
+ * Version:	@(#)if.h	1.0.2	04/18/93
+ *
+ * Authors:	Original taken from Berkeley UNIX 4.3, (c) UCB 1982-1988
+ *		Ross Biro
+ *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+#ifndef _LINUX_IF_H
+#define _LINUX_IF_H
+
+#include <linux/types.h>		/* for "__kernel_caddr_t" et al	*/
+
+#define	IFNAMSIZ	16
+
+/* Standard interface flags (netdevice->flags). */
+#define	IFF_UP		0x1		/* interface is up		*/
+#define	IFF_BROADCAST	0x2		/* broadcast address valid	*/
+#define	IFF_DEBUG	0x4		/* turn on debugging		*/
+#define	IFF_LOOPBACK	0x8		/* is a loopback net		*/
+#define	IFF_POINTOPOINT	0x10		/* interface is has p-p link	*/
+#define	IFF_NOTRAILERS	0x20		/* avoid use of trailers	*/
+#define	IFF_RUNNING	0x40		/* interface RFC2863 OPER_UP	*/
+#define	IFF_NOARP	0x80		/* no ARP protocol		*/
+#define	IFF_PROMISC	0x100		/* receive all packets		*/
+#define	IFF_ALLMULTI	0x200		/* receive all multicast packets*/
+
+#define IFF_MASTER	0x400		/* master of a load balancer 	*/
+#define IFF_SLAVE	0x800		/* slave of a load balancer	*/
+
+#define IFF_MULTICAST	0x1000		/* Supports multicast		*/
+
+#define IFF_PORTSEL	0x2000          /* can set media type		*/
+#define IFF_AUTOMEDIA	0x4000		/* auto media select active	*/
+#define IFF_DYNAMIC	0x8000		/* dialup device with changing addresses*/
+
+#define IFF_LOWER_UP	0x10000		/* driver signals L1 up		*/
+#define IFF_DORMANT	0x20000		/* driver signals dormant	*/
+
+#define IFF_ECHO	0x40000		/* echo sent packets		*/
+
+#define IFF_VOLATILE	(IFF_LOOPBACK|IFF_POINTOPOINT|IFF_BROADCAST|IFF_ECHO|\
+		IFF_MASTER|IFF_SLAVE|IFF_RUNNING|IFF_LOWER_UP|IFF_DORMANT)
+
+/* Private (from user) interface flags (netdevice->priv_flags). */
+#define IFF_802_1Q_VLAN 0x1             /* 802.1Q VLAN device.          */
+#define IFF_EBRIDGE	0x2		/* Ethernet bridging device.	*/
+#define IFF_SLAVE_INACTIVE	0x4	/* bonding slave not the curr. active */
+#define IFF_MASTER_8023AD	0x8	/* bonding master, 802.3ad. 	*/
+#define IFF_MASTER_ALB	0x10		/* bonding master, balance-alb.	*/
+#define IFF_BONDING	0x20		/* bonding master or slave	*/
+#define IFF_SLAVE_NEEDARP 0x40		/* need ARPs for validation	*/
+#define IFF_ISATAP	0x80		/* ISATAP interface (RFC4214)	*/
+
+#define IF_GET_IFACE	0x0001		/* for querying only */
+#define IF_GET_PROTO	0x0002
+
+/* For definitions see hdlc.h */
+#define IF_IFACE_V35	0x1000		/* V.35 serial interface	*/
+#define IF_IFACE_V24	0x1001		/* V.24 serial interface	*/
+#define IF_IFACE_X21	0x1002		/* X.21 serial interface	*/
+#define IF_IFACE_T1	0x1003		/* T1 telco serial interface	*/
+#define IF_IFACE_E1	0x1004		/* E1 telco serial interface	*/
+#define IF_IFACE_SYNC_SERIAL 0x1005	/* can't be set by software	*/
+#define IF_IFACE_X21D   0x1006          /* X.21 Dual Clocking (FarSite) */
+
+/* For definitions see hdlc.h */
+#define IF_PROTO_HDLC	0x2000		/* raw HDLC protocol		*/
+#define IF_PROTO_PPP	0x2001		/* PPP protocol			*/
+#define IF_PROTO_CISCO	0x2002		/* Cisco HDLC protocol		*/
+#define IF_PROTO_FR	0x2003		/* Frame Relay protocol		*/
+#define IF_PROTO_FR_ADD_PVC 0x2004	/*    Create FR PVC		*/
+#define IF_PROTO_FR_DEL_PVC 0x2005	/*    Delete FR PVC		*/
+#define IF_PROTO_X25	0x2006		/* X.25				*/
+#define IF_PROTO_HDLC_ETH 0x2007	/* raw HDLC, Ethernet emulation	*/
+#define IF_PROTO_FR_ADD_ETH_PVC 0x2008	/*  Create FR Ethernet-bridged PVC */
+#define IF_PROTO_FR_DEL_ETH_PVC 0x2009	/*  Delete FR Ethernet-bridged PVC */
+#define IF_PROTO_FR_PVC	0x200A		/* for reading PVC status	*/
+#define IF_PROTO_FR_ETH_PVC 0x200B
+#define IF_PROTO_RAW    0x200C          /* RAW Socket                   */
+
+/* RFC 2863 operational status */
+enum {
+	IF_OPER_UNKNOWN,
+	IF_OPER_NOTPRESENT,
+	IF_OPER_DOWN,
+	IF_OPER_LOWERLAYERDOWN,
+	IF_OPER_TESTING,
+	IF_OPER_DORMANT,
+	IF_OPER_UP,
+};
+
+/* link modes */
+enum {
+	IF_LINK_MODE_DEFAULT,
+	IF_LINK_MODE_DORMANT,	/* limit upward transition to dormant */
+};
+
+/*
+ *	Device mapping structure. I'd just gone off and designed a
+ *	beautiful scheme using only loadable modules with arguments
+ *	for driver options and along come the PCMCIA people 8)
+ *
+ *	Ah well. The get() side of this is good for WDSETUP, and it'll
+ *	be handy for debugging things. The set side is fine for now and
+ *	being very small might be worth keeping for clean configuration.
+ */
+
+struct ifmap
+{
+	unsigned long mem_start;
+	unsigned long mem_end;
+	unsigned short base_addr;
+	unsigned char irq;
+	unsigned char dma;
+	unsigned char port;
+	/* 3 bytes spare */
+};
+
+
+#endif /* _LINUX_IF_H */
diff -uNr libnl_kk/include/linux/if_ether.h libnl/include/linux/if_ether.h
--- libnl_kk/include/linux/if_ether.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/linux/if_ether.h	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,106 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		Global definitions for the Ethernet IEEE 802.3 interface.
+ *
+ * Version:	@(#)if_ether.h	1.0.1a	02/08/94
+ *
+ * Author:	Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *		Donald Becker, <becker@super.org>
+ *		Alan Cox, <alan@redhat.com>
+ *		Steve Whitehouse, <gw7rrm@eeshack3.swan.ac.uk>
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+ 
+#ifndef _LINUX_IF_ETHER_H
+#define _LINUX_IF_ETHER_H
+
+/*
+ *	IEEE 802.3 Ethernet magic constants.  The frame sizes omit the preamble
+ *	and FCS/CRC (frame check sequence). 
+ */
+
+#define ETH_ALEN	6		/* Octets in one ethernet addr	 */
+#define ETH_HLEN	14		/* Total octets in header.	 */
+#define ETH_ZLEN	60		/* Min. octets in frame sans FCS */
+#define ETH_DATA_LEN	1500		/* Max. octets in payload	 */
+#define ETH_FRAME_LEN	1514		/* Max. octets in frame sans FCS */
+
+/*
+ *	These are the defined Ethernet Protocol ID's.
+ */
+
+#define ETH_P_LOOP	0x0060		/* Ethernet Loopback packet	*/
+#define ETH_P_PUP	0x0200		/* Xerox PUP packet		*/
+#define ETH_P_PUPAT	0x0201		/* Xerox PUP Addr Trans packet	*/
+#define ETH_P_IP	0x0800		/* Internet Protocol packet	*/
+#define ETH_P_X25	0x0805		/* CCITT X.25			*/
+#define ETH_P_ARP	0x0806		/* Address Resolution packet	*/
+#define	ETH_P_BPQ	0x08FF		/* G8BPQ AX.25 Ethernet Packet	[ NOT AN OFFICIALLY REGISTERED ID ] */
+#define ETH_P_IEEEPUP	0x0a00		/* Xerox IEEE802.3 PUP packet */
+#define ETH_P_IEEEPUPAT	0x0a01		/* Xerox IEEE802.3 PUP Addr Trans packet */
+#define ETH_P_DEC       0x6000          /* DEC Assigned proto           */
+#define ETH_P_DNA_DL    0x6001          /* DEC DNA Dump/Load            */
+#define ETH_P_DNA_RC    0x6002          /* DEC DNA Remote Console       */
+#define ETH_P_DNA_RT    0x6003          /* DEC DNA Routing              */
+#define ETH_P_LAT       0x6004          /* DEC LAT                      */
+#define ETH_P_DIAG      0x6005          /* DEC Diagnostics              */
+#define ETH_P_CUST      0x6006          /* DEC Customer use             */
+#define ETH_P_SCA       0x6007          /* DEC Systems Comms Arch       */
+#define ETH_P_RARP      0x8035		/* Reverse Addr Res packet	*/
+#define ETH_P_ATALK	0x809B		/* Appletalk DDP		*/
+#define ETH_P_AARP	0x80F3		/* Appletalk AARP		*/
+#define ETH_P_8021Q	0x8100          /* 802.1Q VLAN Extended Header  */
+#define ETH_P_IPX	0x8137		/* IPX over DIX			*/
+#define ETH_P_IPV6	0x86DD		/* IPv6 over bluebook		*/
+#define ETH_P_WCCP	0x883E		/* Web-cache coordination protocol
+					 * defined in draft-wilson-wrec-wccp-v2-00.txt */
+#define ETH_P_PPP_DISC	0x8863		/* PPPoE discovery messages     */
+#define ETH_P_PPP_SES	0x8864		/* PPPoE session messages	*/
+#define ETH_P_MPLS_UC	0x8847		/* MPLS Unicast traffic		*/
+#define ETH_P_MPLS_MC	0x8848		/* MPLS Multicast traffic	*/
+#define ETH_P_ATMMPOA	0x884c		/* MultiProtocol Over ATM	*/
+#define ETH_P_ATMFATE	0x8884		/* Frame-based ATM Transport
+					 * over Ethernet
+					 */
+#define ETH_P_AOE	0x88A2		/* ATA over Ethernet		*/
+
+/*
+ *	Non DIX types. Won't clash for 1500 types.
+ */
+ 
+#define ETH_P_802_3	0x0001		/* Dummy type for 802.3 frames  */
+#define ETH_P_AX25	0x0002		/* Dummy protocol id for AX.25  */
+#define ETH_P_ALL	0x0003		/* Every packet (be careful!!!) */
+#define ETH_P_802_2	0x0004		/* 802.2 frames 		*/
+#define ETH_P_SNAP	0x0005		/* Internal only		*/
+#define ETH_P_DDCMP     0x0006          /* DEC DDCMP: Internal only     */
+#define ETH_P_WAN_PPP   0x0007          /* Dummy type for WAN PPP frames*/
+#define ETH_P_PPP_MP    0x0008          /* Dummy type for PPP MP frames */
+#define ETH_P_LOCALTALK 0x0009		/* Localtalk pseudo type 	*/
+#define ETH_P_PPPTALK	0x0010		/* Dummy type for Atalk over PPP*/
+#define ETH_P_TR_802_2	0x0011		/* 802.2 frames 		*/
+#define ETH_P_MOBITEX	0x0015		/* Mobitex (kaz@cafe.net)	*/
+#define ETH_P_CONTROL	0x0016		/* Card specific control frames */
+#define ETH_P_IRDA	0x0017		/* Linux-IrDA			*/
+#define ETH_P_ECONET	0x0018		/* Acorn Econet			*/
+#define ETH_P_HDLC	0x0019		/* HDLC frames			*/
+#define ETH_P_ARCNET	0x001A		/* 1A for ArcNet :-)            */
+
+/*
+ *	This is an Ethernet frame header.
+ */
+ 
+struct ethhdr {
+	unsigned char	h_dest[ETH_ALEN];	/* destination eth addr	*/
+	unsigned char	h_source[ETH_ALEN];	/* source ether addr	*/
+	unsigned short	h_proto;		/* packet type ID field	*/
+} __attribute__((packed));
+
+#endif	/* _LINUX_IF_ETHER_H */
diff -uNr libnl_kk/include/linux/if_link.h libnl/include/linux/if_link.h
--- libnl_kk/include/linux/if_link.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/linux/if_link.h	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,191 @@
+#ifndef _LINUX_IF_LINK_H
+#define _LINUX_IF_LINK_H
+
+#include <linux/netlink.h>
+
+/* The struct should be in sync with struct net_device_stats */
+struct rtnl_link_stats
+{
+	__u32	rx_packets;		/* total packets received	*/
+	__u32	tx_packets;		/* total packets transmitted	*/
+	__u32	rx_bytes;		/* total bytes received 	*/
+	__u32	tx_bytes;		/* total bytes transmitted	*/
+	__u32	rx_errors;		/* bad packets received		*/
+	__u32	tx_errors;		/* packet transmit problems	*/
+	__u32	rx_dropped;		/* no space in linux buffers	*/
+	__u32	tx_dropped;		/* no space available in linux	*/
+	__u32	multicast;		/* multicast packets received	*/
+	__u32	collisions;
+
+	/* detailed rx_errors: */
+	__u32	rx_length_errors;
+	__u32	rx_over_errors;		/* receiver ring buff overflow	*/
+	__u32	rx_crc_errors;		/* recved pkt with crc error	*/
+	__u32	rx_frame_errors;	/* recv'd frame alignment error */
+	__u32	rx_fifo_errors;		/* recv'r fifo overrun		*/
+	__u32	rx_missed_errors;	/* receiver missed packet	*/
+
+	/* detailed tx_errors */
+	__u32	tx_aborted_errors;
+	__u32	tx_carrier_errors;
+	__u32	tx_fifo_errors;
+	__u32	tx_heartbeat_errors;
+	__u32	tx_window_errors;
+
+	/* for cslip etc */
+	__u32	rx_compressed;
+	__u32	tx_compressed;
+};
+
+/* The struct should be in sync with struct ifmap */
+struct rtnl_link_ifmap
+{
+	__u64	mem_start;
+	__u64	mem_end;
+	__u64	base_addr;
+	__u16	irq;
+	__u8	dma;
+	__u8	port;
+};
+
+enum
+{
+	IFLA_UNSPEC,
+	IFLA_ADDRESS,
+	IFLA_BROADCAST,
+	IFLA_IFNAME,
+	IFLA_MTU,
+	IFLA_LINK,
+	IFLA_QDISC,
+	IFLA_STATS,
+	IFLA_COST,
+#define IFLA_COST IFLA_COST
+	IFLA_PRIORITY,
+#define IFLA_PRIORITY IFLA_PRIORITY
+	IFLA_MASTER,
+#define IFLA_MASTER IFLA_MASTER
+	IFLA_WIRELESS,		/* Wireless Extension event - see wireless.h */
+#define IFLA_WIRELESS IFLA_WIRELESS
+	IFLA_PROTINFO,		/* Protocol specific information for a link */
+#define IFLA_PROTINFO IFLA_PROTINFO
+	IFLA_TXQLEN,
+#define IFLA_TXQLEN IFLA_TXQLEN
+	IFLA_MAP,
+#define IFLA_MAP IFLA_MAP
+	IFLA_WEIGHT,
+#define IFLA_WEIGHT IFLA_WEIGHT
+	IFLA_OPERSTATE,
+	IFLA_LINKMODE,
+	IFLA_LINKINFO,
+#define IFLA_LINKINFO IFLA_LINKINFO
+	IFLA_NET_NS_PID,
+	__IFLA_MAX
+};
+
+
+#define IFLA_MAX (__IFLA_MAX - 1)
+
+/* backwards compatibility for userspace */
+#ifndef __KERNEL__
+#define IFLA_RTA(r)  ((struct rtattr*)(((char*)(r)) + NLMSG_ALIGN(sizeof(struct ifinfomsg))))
+#define IFLA_PAYLOAD(n) NLMSG_PAYLOAD(n,sizeof(struct ifinfomsg))
+#endif
+
+/* ifi_flags.
+
+   IFF_* flags.
+
+   The only change is:
+   IFF_LOOPBACK, IFF_BROADCAST and IFF_POINTOPOINT are
+   more not changeable by user. They describe link media
+   characteristics and set by device driver.
+
+   Comments:
+   - Combination IFF_BROADCAST|IFF_POINTOPOINT is invalid
+   - If neither of these three flags are set;
+     the interface is NBMA.
+
+   - IFF_MULTICAST does not mean anything special:
+   multicasts can be used on all not-NBMA links.
+   IFF_MULTICAST means that this media uses special encapsulation
+   for multicast frames. Apparently, all IFF_POINTOPOINT and
+   IFF_BROADCAST devices are able to use multicasts too.
+ */
+
+/* IFLA_LINK.
+   For usual devices it is equal ifi_index.
+   If it is a "virtual interface" (f.e. tunnel), ifi_link
+   can point to real physical interface (f.e. for bandwidth calculations),
+   or maybe 0, what means, that real media is unknown (usual
+   for IPIP tunnels, when route to endpoint is allowed to change)
+ */
+
+/* Subtype attributes for IFLA_PROTINFO */
+enum
+{
+	IFLA_INET6_UNSPEC,
+	IFLA_INET6_FLAGS,	/* link flags			*/
+	IFLA_INET6_CONF,	/* sysctl parameters		*/
+	IFLA_INET6_STATS,	/* statistics			*/
+	IFLA_INET6_MCAST,	/* MC things. What of them?	*/
+	IFLA_INET6_CACHEINFO,	/* time values and max reasm size */
+	IFLA_INET6_ICMP6STATS,	/* statistics (icmpv6)		*/
+	__IFLA_INET6_MAX
+};
+
+#define IFLA_INET6_MAX	(__IFLA_INET6_MAX - 1)
+
+struct ifla_cacheinfo
+{
+	__u32	max_reasm_len;
+	__u32	tstamp;		/* ipv6InterfaceTable updated timestamp */
+	__u32	reachable_time;
+	__u32	retrans_time;
+};
+
+enum
+{
+	IFLA_INFO_UNSPEC,
+	IFLA_INFO_KIND,
+	IFLA_INFO_DATA,
+	IFLA_INFO_XSTATS,
+	__IFLA_INFO_MAX,
+};
+
+#define IFLA_INFO_MAX	(__IFLA_INFO_MAX - 1)
+
+/* VLAN section */
+
+enum
+{
+	IFLA_VLAN_UNSPEC,
+	IFLA_VLAN_ID,
+	IFLA_VLAN_FLAGS,
+	IFLA_VLAN_EGRESS_QOS,
+	IFLA_VLAN_INGRESS_QOS,
+	__IFLA_VLAN_MAX,
+};
+
+#define IFLA_VLAN_MAX	(__IFLA_VLAN_MAX - 1)
+
+struct ifla_vlan_flags {
+	__u32	flags;
+	__u32	mask;
+};
+
+enum
+{
+	IFLA_VLAN_QOS_UNSPEC,
+	IFLA_VLAN_QOS_MAPPING,
+	__IFLA_VLAN_QOS_MAX
+};
+
+#define IFLA_VLAN_QOS_MAX	(__IFLA_VLAN_QOS_MAX - 1)
+
+struct ifla_vlan_qos_mapping
+{
+	__u32 from;
+	__u32 to;
+};
+
+#endif /* _LINUX_IF_LINK_H */
diff -uNr libnl_kk/include/linux/if_vlan.h libnl/include/linux/if_vlan.h
--- libnl_kk/include/linux/if_vlan.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/linux/if_vlan.h	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,61 @@
+/*
+ * VLAN		An implementation of 802.1Q VLAN tagging.
+ *
+ * Authors:	Ben Greear <greearb@candelatech.com>
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef _LINUX_IF_VLAN_H_
+#define _LINUX_IF_VLAN_H_
+
+
+/* VLAN IOCTLs are found in sockios.h */
+
+/* Passed in vlan_ioctl_args structure to determine behaviour. */
+enum vlan_ioctl_cmds {
+	ADD_VLAN_CMD,
+	DEL_VLAN_CMD,
+	SET_VLAN_INGRESS_PRIORITY_CMD,
+	SET_VLAN_EGRESS_PRIORITY_CMD,
+	GET_VLAN_INGRESS_PRIORITY_CMD,
+	GET_VLAN_EGRESS_PRIORITY_CMD,
+	SET_VLAN_NAME_TYPE_CMD,
+	SET_VLAN_FLAG_CMD,
+	GET_VLAN_REALDEV_NAME_CMD, /* If this works, you know it's a VLAN device, btw */
+	GET_VLAN_VID_CMD /* Get the VID of this VLAN (specified by name) */
+};
+
+enum vlan_flags {
+	VLAN_FLAG_REORDER_HDR	= 0x1,
+};
+
+enum vlan_name_types {
+	VLAN_NAME_TYPE_PLUS_VID, /* Name will look like:  vlan0005 */
+	VLAN_NAME_TYPE_RAW_PLUS_VID, /* name will look like:  eth1.0005 */
+	VLAN_NAME_TYPE_PLUS_VID_NO_PAD, /* Name will look like:  vlan5 */
+	VLAN_NAME_TYPE_RAW_PLUS_VID_NO_PAD, /* Name will look like:  eth0.5 */
+	VLAN_NAME_TYPE_HIGHEST
+};
+
+struct vlan_ioctl_args {
+	int cmd; /* Should be one of the vlan_ioctl_cmds enum above. */
+	char device1[24];
+
+        union {
+		char device2[24];
+		int VID;
+		unsigned int skb_priority;
+		unsigned int name_type;
+		unsigned int bind_type;
+		unsigned int flag; /* Matches vlan_dev_info flags */
+        } u;
+
+	short vlan_qos;
+};
+
+#endif /* !(_LINUX_IF_VLAN_H_) */
diff -uNr libnl_kk/include/linux/ip_mp_alg.h libnl/include/linux/ip_mp_alg.h
--- libnl_kk/include/linux/ip_mp_alg.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/linux/ip_mp_alg.h	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,22 @@
+/* ip_mp_alg.h: IPV4 multipath algorithm support, user-visible values.
+ *
+ * Copyright (C) 2004, 2005 Einar Lueck <elueck@de.ibm.com>
+ * Copyright (C) 2005 David S. Miller <davem@davemloft.net>
+ */
+
+#ifndef _LINUX_IP_MP_ALG_H
+#define _LINUX_IP_MP_ALG_H
+
+enum ip_mp_alg {
+	IP_MP_ALG_NONE,
+	IP_MP_ALG_RR,
+	IP_MP_ALG_DRR,
+	IP_MP_ALG_RANDOM,
+	IP_MP_ALG_WRANDOM,
+	__IP_MP_ALG_MAX
+};
+
+#define IP_MP_ALG_MAX (__IP_MP_ALG_MAX - 1)
+
+#endif /* _LINUX_IP_MP_ALG_H */
+
diff -uNr libnl_kk/include/linux/neighbour.h libnl/include/linux/neighbour.h
--- libnl_kk/include/linux/neighbour.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/linux/neighbour.h	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,159 @@
+#ifndef __LINUX_NEIGHBOUR_H
+#define __LINUX_NEIGHBOUR_H
+
+#include <linux/netlink.h>
+
+struct ndmsg
+{
+	__u8		ndm_family;
+	__u8		ndm_pad1;
+	__u16		ndm_pad2;
+	__s32		ndm_ifindex;
+	__u16		ndm_state;
+	__u8		ndm_flags;
+	__u8		ndm_type;
+};
+
+enum
+{
+	NDA_UNSPEC,
+	NDA_DST,
+	NDA_LLADDR,
+	NDA_CACHEINFO,
+	NDA_PROBES,
+	__NDA_MAX
+};
+
+#define NDA_MAX (__NDA_MAX - 1)
+
+/*
+ *	Neighbor Cache Entry Flags
+ */
+
+#define NTF_PROXY	0x08	/* == ATF_PUBL */
+#define NTF_ROUTER	0x80
+
+/*
+ *	Neighbor Cache Entry States.
+ */
+
+#define NUD_INCOMPLETE	0x01
+#define NUD_REACHABLE	0x02
+#define NUD_STALE	0x04
+#define NUD_DELAY	0x08
+#define NUD_PROBE	0x10
+#define NUD_FAILED	0x20
+
+/* Dummy states */
+#define NUD_NOARP	0x40
+#define NUD_PERMANENT	0x80
+#define NUD_NONE	0x00
+
+/* NUD_NOARP & NUD_PERMANENT are pseudostates, they never change
+   and make no address resolution or NUD.
+   NUD_PERMANENT is also cannot be deleted by garbage collectors.
+ */
+
+struct nda_cacheinfo
+{
+	__u32		ndm_confirmed;
+	__u32		ndm_used;
+	__u32		ndm_updated;
+	__u32		ndm_refcnt;
+};
+
+/*****************************************************************
+ *		Neighbour tables specific messages.
+ *
+ * To retrieve the neighbour tables send RTM_GETNEIGHTBL with the
+ * NLM_F_DUMP flag set. Every neighbour table configuration is
+ * spread over multiple messages to avoid running into message
+ * size limits on systems with many interfaces. The first message
+ * in the sequence transports all not device specific data such as
+ * statistics, configuration, and the default parameter set.
+ * This message is followed by 0..n messages carrying device
+ * specific parameter sets.
+ * Although the ordering should be sufficient, NDTA_NAME can be
+ * used to identify sequences. The initial message can be identified
+ * by checking for NDTA_CONFIG. The device specific messages do
+ * not contain this TLV but have NDTPA_IFINDEX set to the
+ * corresponding interface index.
+ *
+ * To change neighbour table attributes, send RTM_SETNEIGHTBL
+ * with NDTA_NAME set. Changeable attribute include NDTA_THRESH[1-3],
+ * NDTA_GC_INTERVAL, and all TLVs in NDTA_PARMS unless marked
+ * otherwise. Device specific parameter sets can be changed by
+ * setting NDTPA_IFINDEX to the interface index of the corresponding
+ * device.
+ ****/
+
+struct ndt_stats
+{
+	__u64		ndts_allocs;
+	__u64		ndts_destroys;
+	__u64		ndts_hash_grows;
+	__u64		ndts_res_failed;
+	__u64		ndts_lookups;
+	__u64		ndts_hits;
+	__u64		ndts_rcv_probes_mcast;
+	__u64		ndts_rcv_probes_ucast;
+	__u64		ndts_periodic_gc_runs;
+	__u64		ndts_forced_gc_runs;
+};
+
+enum {
+	NDTPA_UNSPEC,
+	NDTPA_IFINDEX,			/* u32, unchangeable */
+	NDTPA_REFCNT,			/* u32, read-only */
+	NDTPA_REACHABLE_TIME,		/* u64, read-only, msecs */
+	NDTPA_BASE_REACHABLE_TIME,	/* u64, msecs */
+	NDTPA_RETRANS_TIME,		/* u64, msecs */
+	NDTPA_GC_STALETIME,		/* u64, msecs */
+	NDTPA_DELAY_PROBE_TIME,		/* u64, msecs */
+	NDTPA_QUEUE_LEN,		/* u32 */
+	NDTPA_APP_PROBES,		/* u32 */
+	NDTPA_UCAST_PROBES,		/* u32 */
+	NDTPA_MCAST_PROBES,		/* u32 */
+	NDTPA_ANYCAST_DELAY,		/* u64, msecs */
+	NDTPA_PROXY_DELAY,		/* u64, msecs */
+	NDTPA_PROXY_QLEN,		/* u32 */
+	NDTPA_LOCKTIME,			/* u64, msecs */
+	__NDTPA_MAX
+};
+#define NDTPA_MAX (__NDTPA_MAX - 1)
+
+struct ndtmsg
+{
+	__u8		ndtm_family;
+	__u8		ndtm_pad1;
+	__u16		ndtm_pad2;
+};
+
+struct ndt_config
+{
+	__u16		ndtc_key_len;
+	__u16		ndtc_entry_size;
+	__u32		ndtc_entries;
+	__u32		ndtc_last_flush;	/* delta to now in msecs */
+	__u32		ndtc_last_rand;		/* delta to now in msecs */
+	__u32		ndtc_hash_rnd;
+	__u32		ndtc_hash_mask;
+	__u32		ndtc_hash_chain_gc;
+	__u32		ndtc_proxy_qlen;
+};
+
+enum {
+	NDTA_UNSPEC,
+	NDTA_NAME,			/* char *, unchangeable */
+	NDTA_THRESH1,			/* u32 */
+	NDTA_THRESH2,			/* u32 */
+	NDTA_THRESH3,			/* u32 */
+	NDTA_CONFIG,			/* struct ndt_config, read-only */
+	NDTA_PARMS,			/* nested TLV NDTPA_* */
+	NDTA_STATS,			/* struct ndt_stats, read-only */
+	NDTA_GC_INTERVAL,		/* u64, msecs */
+	__NDTA_MAX
+};
+#define NDTA_MAX (__NDTA_MAX - 1)
+
+#endif
diff -uNr libnl_kk/include/linux/netfilter/nfnetlink_acct.h libnl/include/linux/netfilter/nfnetlink_acct.h
--- libnl_kk/include/linux/netfilter/nfnetlink_acct.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/linux/netfilter/nfnetlink_acct.h	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,27 @@
+#ifndef _UAPI_NFNL_ACCT_H_
+#define _UAPI_NFNL_ACCT_H_
+
+#ifndef NFACCT_NAME_MAX
+#define NFACCT_NAME_MAX		32
+#endif
+
+enum nfnl_acct_msg_types {
+	NFNL_MSG_ACCT_NEW,
+	NFNL_MSG_ACCT_GET,
+	NFNL_MSG_ACCT_GET_CTRZERO,
+	NFNL_MSG_ACCT_DEL,
+	NFNL_MSG_ACCT_MAX
+};
+
+enum nfnl_acct_type {
+	NFACCT_UNSPEC,
+	NFACCT_NAME,
+	NFACCT_PKTS,
+	NFACCT_BYTES,
+	NFACCT_USE,
+	NFACCT_QUOTA,
+	__NFACCT_MAX
+};
+#define NFACCT_MAX (__NFACCT_MAX - 1)
+
+#endif /* _UAPI_NFNL_ACCT_H_ */
diff -uNr libnl_kk/include/linux/netfilter/nfnetlink_conntrack.h libnl/include/linux/netfilter/nfnetlink_conntrack.h
--- libnl_kk/include/linux/netfilter/nfnetlink_conntrack.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/linux/netfilter/nfnetlink_conntrack.h	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,140 @@
+#ifndef _IPCONNTRACK_NETLINK_H
+#define _IPCONNTRACK_NETLINK_H
+#include <linux/netfilter/nfnetlink.h>
+
+enum cntl_msg_types {
+	IPCTNL_MSG_CT_NEW,
+	IPCTNL_MSG_CT_GET,
+	IPCTNL_MSG_CT_DELETE,
+	IPCTNL_MSG_CT_GET_CTRZERO,
+
+	IPCTNL_MSG_MAX
+};
+
+enum ctnl_exp_msg_types {
+	IPCTNL_MSG_EXP_NEW,
+	IPCTNL_MSG_EXP_GET,
+	IPCTNL_MSG_EXP_DELETE,
+
+	IPCTNL_MSG_EXP_MAX
+};
+
+
+enum ctattr_type {
+	CTA_UNSPEC,
+	CTA_TUPLE_ORIG,
+	CTA_TUPLE_REPLY,
+	CTA_STATUS,
+	CTA_PROTOINFO,
+	CTA_HELP,
+	CTA_NAT_SRC,
+#define CTA_NAT	CTA_NAT_SRC	/* backwards compatibility */
+	CTA_TIMEOUT,
+	CTA_MARK,
+	CTA_COUNTERS_ORIG,
+	CTA_COUNTERS_REPLY,
+	CTA_USE,
+	CTA_ID,
+	CTA_NAT_DST,
+	__CTA_MAX
+};
+#define CTA_MAX (__CTA_MAX - 1)
+
+enum ctattr_tuple {
+	CTA_TUPLE_UNSPEC,
+	CTA_TUPLE_IP,
+	CTA_TUPLE_PROTO,
+	__CTA_TUPLE_MAX
+};
+#define CTA_TUPLE_MAX (__CTA_TUPLE_MAX - 1)
+
+enum ctattr_ip {
+	CTA_IP_UNSPEC,
+	CTA_IP_V4_SRC,
+	CTA_IP_V4_DST,
+	CTA_IP_V6_SRC,
+	CTA_IP_V6_DST,
+	__CTA_IP_MAX
+};
+#define CTA_IP_MAX (__CTA_IP_MAX - 1)
+
+enum ctattr_l4proto {
+	CTA_PROTO_UNSPEC,
+	CTA_PROTO_NUM,
+	CTA_PROTO_SRC_PORT,
+	CTA_PROTO_DST_PORT,
+	CTA_PROTO_ICMP_ID,
+	CTA_PROTO_ICMP_TYPE,
+	CTA_PROTO_ICMP_CODE,
+	CTA_PROTO_ICMPV6_ID,
+	CTA_PROTO_ICMPV6_TYPE,
+	CTA_PROTO_ICMPV6_CODE,
+	__CTA_PROTO_MAX
+};
+#define CTA_PROTO_MAX (__CTA_PROTO_MAX - 1)
+
+enum ctattr_protoinfo {
+	CTA_PROTOINFO_UNSPEC,
+	CTA_PROTOINFO_TCP,
+	__CTA_PROTOINFO_MAX
+};
+#define CTA_PROTOINFO_MAX (__CTA_PROTOINFO_MAX - 1)
+
+enum ctattr_protoinfo_tcp {
+	CTA_PROTOINFO_TCP_UNSPEC,
+	CTA_PROTOINFO_TCP_STATE,
+	CTA_PROTOINFO_TCP_WSCALE_ORIGINAL,
+	CTA_PROTOINFO_TCP_WSCALE_REPLY,
+	CTA_PROTOINFO_TCP_FLAGS_ORIGINAL,
+	CTA_PROTOINFO_TCP_FLAGS_REPLY,
+	__CTA_PROTOINFO_TCP_MAX
+};
+#define CTA_PROTOINFO_TCP_MAX (__CTA_PROTOINFO_TCP_MAX - 1)
+
+enum ctattr_counters {
+	CTA_COUNTERS_UNSPEC,
+	CTA_COUNTERS_PACKETS,		/* old 64bit counters */
+	CTA_COUNTERS_BYTES,		/* old 64bit counters */
+	CTA_COUNTERS32_PACKETS,
+	CTA_COUNTERS32_BYTES,
+	__CTA_COUNTERS_MAX
+};
+#define CTA_COUNTERS_MAX (__CTA_COUNTERS_MAX - 1)
+
+enum ctattr_nat {
+	CTA_NAT_UNSPEC,
+	CTA_NAT_MINIP,
+	CTA_NAT_MAXIP,
+	CTA_NAT_PROTO,
+	__CTA_NAT_MAX
+};
+#define CTA_NAT_MAX (__CTA_NAT_MAX - 1)
+
+enum ctattr_protonat {
+	CTA_PROTONAT_UNSPEC,
+	CTA_PROTONAT_PORT_MIN,
+	CTA_PROTONAT_PORT_MAX,
+	__CTA_PROTONAT_MAX
+};
+#define CTA_PROTONAT_MAX (__CTA_PROTONAT_MAX - 1)
+
+enum ctattr_expect {
+	CTA_EXPECT_UNSPEC,
+	CTA_EXPECT_MASTER,
+	CTA_EXPECT_TUPLE,
+	CTA_EXPECT_MASK,
+	CTA_EXPECT_TIMEOUT,
+	CTA_EXPECT_ID,
+	CTA_EXPECT_HELP_NAME,
+	__CTA_EXPECT_MAX
+};
+#define CTA_EXPECT_MAX (__CTA_EXPECT_MAX - 1)
+
+enum ctattr_help {
+	CTA_HELP_UNSPEC,
+	CTA_HELP_NAME,
+	__CTA_HELP_MAX
+};
+#define CTA_HELP_MAX (__CTA_HELP_MAX - 1)
+
+#endif /* _IPCONNTRACK_NETLINK_H */
diff -uNr libnl_kk/include/linux/netfilter/nfnetlink.h libnl/include/linux/netfilter/nfnetlink.h
--- libnl_kk/include/linux/netfilter/nfnetlink.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/linux/netfilter/nfnetlink.h	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,66 @@
+#ifndef _NFNETLINK_H
+#define _NFNETLINK_H
+#include <linux/types.h>
+
+#ifndef __KERNEL__
+/* nfnetlink groups: Up to 32 maximum - backwards compatibility for userspace */
+#define NF_NETLINK_CONNTRACK_NEW 		0x00000001
+#define NF_NETLINK_CONNTRACK_UPDATE		0x00000002
+#define NF_NETLINK_CONNTRACK_DESTROY		0x00000004
+#define NF_NETLINK_CONNTRACK_EXP_NEW		0x00000008
+#define NF_NETLINK_CONNTRACK_EXP_UPDATE		0x00000010
+#define NF_NETLINK_CONNTRACK_EXP_DESTROY	0x00000020
+#define NF_NETLINK_ACCT_QUOTA			0x00000040
+#endif
+
+enum nfnetlink_groups {
+	NFNLGRP_NONE,
+#define NFNLGRP_NONE			NFNLGRP_NONE
+	NFNLGRP_CONNTRACK_NEW,
+#define NFNLGRP_CONNTRACK_NEW		NFNLGRP_CONNTRACK_NEW
+	NFNLGRP_CONNTRACK_UPDATE,
+#define NFNLGRP_CONNTRACK_UPDATE	NFNLGRP_CONNTRACK_UPDATE
+	NFNLGRP_CONNTRACK_DESTROY,
+#define NFNLGRP_CONNTRACK_DESTROY	NFNLGRP_CONNTRACK_DESTROY
+	NFNLGRP_CONNTRACK_EXP_NEW,
+#define	NFNLGRP_CONNTRACK_EXP_NEW	NFNLGRP_CONNTRACK_EXP_NEW
+	NFNLGRP_CONNTRACK_EXP_UPDATE,
+#define NFNLGRP_CONNTRACK_EXP_UPDATE	NFNLGRP_CONNTRACK_EXP_UPDATE
+	NFNLGRP_CONNTRACK_EXP_DESTROY,
+#define NFNLGRP_CONNTRACK_EXP_DESTROY	NFNLGRP_CONNTRACK_EXP_DESTROY
+	NFNLGRP_NFTABLES,
+#define NFNLGRP_NFTABLES		NFNLGRP_NFTABLES
+	NFNLGRP_ACCT_QUOTA,
+#define NFNLGRP_ACCT_QUOTA		NFNLGRP_ACCT_QUOTA
+	__NFNLGRP_MAX,
+};
+#define NFNLGRP_MAX	(__NFNLGRP_MAX - 1)
+
+/* General form of address family dependent message.
+ */
+struct nfgenmsg {
+	u_int8_t  nfgen_family;		/* AF_xxx */
+	u_int8_t  version;		/* nfnetlink version */
+	__be16    res_id;		/* resource id */
+};
+
+#define NFNETLINK_V0	0
+
+/* netfilter netlink message types are split in two pieces:
+ * 8 bit subsystem, 8bit operation.
+ */
+
+#define NFNL_SUBSYS_ID(x)	((x & 0xff00) >> 8)
+#define NFNL_MSG_TYPE(x)	(x & 0x00ff)
+
+/* No enum here, otherwise __stringify() trick of MODULE_ALIAS_NFNL_SUBSYS()
+ * won't work anymore */
+#define NFNL_SUBSYS_NONE 		0
+#define NFNL_SUBSYS_CTNETLINK		1
+#define NFNL_SUBSYS_CTNETLINK_EXP	2
+#define NFNL_SUBSYS_QUEUE		3
+#define NFNL_SUBSYS_ULOG		4
+#define NFNL_SUBSYS_COUNT		5
+#define NFNL_SUBSYS_ACCT		7
+
+#endif	/* _NFNETLINK_H */
diff -uNr libnl_kk/include/linux/netfilter/nfnetlink_log.h libnl/include/linux/netfilter/nfnetlink_log.h
--- libnl_kk/include/linux/netfilter/nfnetlink_log.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/linux/netfilter/nfnetlink_log.h	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,97 @@
+#ifndef _NFNETLINK_LOG_H
+#define _NFNETLINK_LOG_H
+
+/* This file describes the netlink messages (i.e. 'protocol packets'),
+ * and not any kind of function definitions.  It is shared between kernel and
+ * userspace.  Don't put kernel specific stuff in here */
+
+#ifndef aligned_be64
+#define aligned_be64 u_int64_t __attribute__((aligned(8)))
+#endif
+
+#include <linux/types.h>
+#include <linux/netfilter/nfnetlink.h>
+
+enum nfulnl_msg_types {
+	NFULNL_MSG_PACKET,		/* packet from kernel to userspace */
+	NFULNL_MSG_CONFIG,		/* connect to a particular queue */
+
+	NFULNL_MSG_MAX
+};
+
+struct nfulnl_msg_packet_hdr {
+	__be16		hw_protocol;	/* hw protocol (network order) */
+	u_int8_t	hook;		/* netfilter hook */
+	u_int8_t	_pad;
+};
+
+struct nfulnl_msg_packet_hw {
+	__be16		hw_addrlen;
+	u_int16_t	_pad;
+	u_int8_t	hw_addr[8];
+};
+
+struct nfulnl_msg_packet_timestamp {
+	aligned_be64	sec;
+	aligned_be64	usec;
+};
+
+enum nfulnl_attr_type {
+	NFULA_UNSPEC,
+	NFULA_PACKET_HDR,
+	NFULA_MARK,			/* u_int32_t nfmark */
+	NFULA_TIMESTAMP,		/* nfulnl_msg_packet_timestamp */
+	NFULA_IFINDEX_INDEV,		/* u_int32_t ifindex */
+	NFULA_IFINDEX_OUTDEV,		/* u_int32_t ifindex */
+	NFULA_IFINDEX_PHYSINDEV,	/* u_int32_t ifindex */
+	NFULA_IFINDEX_PHYSOUTDEV,	/* u_int32_t ifindex */
+	NFULA_HWADDR,			/* nfulnl_msg_packet_hw */
+	NFULA_PAYLOAD,			/* opaque data payload */
+	NFULA_PREFIX,			/* string prefix */
+	NFULA_UID,			/* user id of socket */
+	NFULA_SEQ,			/* instance-local sequence number */
+	NFULA_SEQ_GLOBAL,		/* global sequence number */
+	NFULA_GID,			/* group id of socket */
+
+	__NFULA_MAX
+};
+#define NFULA_MAX (__NFULA_MAX - 1)
+
+enum nfulnl_msg_config_cmds {
+	NFULNL_CFG_CMD_NONE,
+	NFULNL_CFG_CMD_BIND,
+	NFULNL_CFG_CMD_UNBIND,
+	NFULNL_CFG_CMD_PF_BIND,
+	NFULNL_CFG_CMD_PF_UNBIND,
+};
+
+struct nfulnl_msg_config_cmd {
+	u_int8_t	command;	/* nfulnl_msg_config_cmds */
+} __attribute__ ((packed));
+
+struct nfulnl_msg_config_mode {
+	__be32		copy_range;
+	u_int8_t	copy_mode;
+	u_int8_t	_pad;
+} __attribute__ ((packed));
+
+enum nfulnl_attr_config {
+	NFULA_CFG_UNSPEC,
+	NFULA_CFG_CMD,			/* nfulnl_msg_config_cmd */
+	NFULA_CFG_MODE,			/* nfulnl_msg_config_mode */
+	NFULA_CFG_NLBUFSIZ,		/* u_int32_t buffer size */
+	NFULA_CFG_TIMEOUT,		/* u_int32_t in 1/100 s */
+	NFULA_CFG_QTHRESH,		/* u_int32_t */
+	NFULA_CFG_FLAGS,		/* u_int16_t */
+	__NFULA_CFG_MAX
+};
+#define NFULA_CFG_MAX (__NFULA_CFG_MAX -1)
+
+#define NFULNL_COPY_NONE	0x00
+#define NFULNL_COPY_META	0x01
+#define NFULNL_COPY_PACKET	0x02
+
+#define NFULNL_CFG_F_SEQ	0x0001
+#define NFULNL_CFG_F_SEQ_GLOBAL	0x0002
+
+#endif /* _NFNETLINK_LOG_H */
diff -uNr libnl_kk/include/linux/netfilter/nfnetlink_queue.h libnl/include/linux/netfilter/nfnetlink_queue.h
--- libnl_kk/include/linux/netfilter/nfnetlink_queue.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/linux/netfilter/nfnetlink_queue.h	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,94 @@
+#ifndef _NFNETLINK_QUEUE_H
+#define _NFNETLINK_QUEUE_H
+
+#include <linux/types.h>
+#include <linux/netfilter/nfnetlink.h>
+
+#ifndef aligned_be64
+#define aligned_be64 u_int64_t __attribute__((aligned(8)))
+#endif
+
+enum nfqnl_msg_types {
+	NFQNL_MSG_PACKET,		/* packet from kernel to userspace */
+	NFQNL_MSG_VERDICT,		/* verdict from userspace to kernel */
+	NFQNL_MSG_CONFIG,		/* connect to a particular queue */
+
+	NFQNL_MSG_MAX
+};
+
+struct nfqnl_msg_packet_hdr {
+	__be32		packet_id;	/* unique ID of packet in queue */
+	__be16		hw_protocol;	/* hw protocol (network order) */
+	u_int8_t	hook;		/* netfilter hook */
+} __attribute__ ((packed));
+
+struct nfqnl_msg_packet_hw {
+	__be16		hw_addrlen;
+	u_int16_t	_pad;
+	u_int8_t	hw_addr[8];
+};
+
+struct nfqnl_msg_packet_timestamp {
+	aligned_be64	sec;
+	aligned_be64	usec;
+};
+
+enum nfqnl_attr_type {
+	NFQA_UNSPEC,
+	NFQA_PACKET_HDR,
+	NFQA_VERDICT_HDR,		/* nfqnl_msg_verdict_hrd */
+	NFQA_MARK,			/* u_int32_t nfmark */
+	NFQA_TIMESTAMP,			/* nfqnl_msg_packet_timestamp */
+	NFQA_IFINDEX_INDEV,		/* u_int32_t ifindex */
+	NFQA_IFINDEX_OUTDEV,		/* u_int32_t ifindex */
+	NFQA_IFINDEX_PHYSINDEV,		/* u_int32_t ifindex */
+	NFQA_IFINDEX_PHYSOUTDEV,	/* u_int32_t ifindex */
+	NFQA_HWADDR,			/* nfqnl_msg_packet_hw */
+	NFQA_PAYLOAD,			/* opaque data payload */
+
+	__NFQA_MAX
+};
+#define NFQA_MAX (__NFQA_MAX - 1)
+
+struct nfqnl_msg_verdict_hdr {
+	__be32 verdict;
+	__be32 id;
+};
+
+
+enum nfqnl_msg_config_cmds {
+	NFQNL_CFG_CMD_NONE,
+	NFQNL_CFG_CMD_BIND,
+	NFQNL_CFG_CMD_UNBIND,
+	NFQNL_CFG_CMD_PF_BIND,
+	NFQNL_CFG_CMD_PF_UNBIND,
+};
+
+struct nfqnl_msg_config_cmd {
+	u_int8_t	command;	/* nfqnl_msg_config_cmds */
+	u_int8_t	_pad;
+	__be16		pf;		/* AF_xxx for PF_[UN]BIND */
+};
+
+enum nfqnl_config_mode {
+	NFQNL_COPY_NONE,
+	NFQNL_COPY_META,
+	NFQNL_COPY_PACKET,
+};
+
+struct nfqnl_msg_config_params {
+	__be32		copy_range;
+	u_int8_t	copy_mode;	/* enum nfqnl_config_mode */
+} __attribute__ ((packed));
+
+
+enum nfqnl_attr_config {
+	NFQA_CFG_UNSPEC,
+	NFQA_CFG_CMD,			/* nfqnl_msg_config_cmd */
+	NFQA_CFG_PARAMS,		/* nfqnl_msg_config_params */
+	NFQA_CFG_QUEUE_MAXLEN,		/* u_int32_t */
+	__NFQA_CFG_MAX
+};
+#define NFQA_CFG_MAX (__NFQA_CFG_MAX-1)
+
+#endif /* _NFNETLINK_QUEUE_H */
diff -uNr libnl_kk/include/linux/netfilter.h libnl/include/linux/netfilter.h
--- libnl_kk/include/linux/netfilter.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/linux/netfilter.h	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,39 @@
+#ifndef __LINUX_NETFILTER_H
+#define __LINUX_NETFILTER_H
+
+
+/* Responses from hook functions. */
+#define NF_DROP 0
+#define NF_ACCEPT 1
+#define NF_STOLEN 2
+#define NF_QUEUE 3
+#define NF_REPEAT 4
+#define NF_STOP 5
+#define NF_MAX_VERDICT NF_STOP
+
+/* we overload the higher bits for encoding auxiliary data such as the queue
+ * number. Not nice, but better than additional function arguments. */
+#define NF_VERDICT_MASK 0x0000ffff
+#define NF_VERDICT_BITS 16
+
+#define NF_VERDICT_QMASK 0xffff0000
+#define NF_VERDICT_QBITS 16
+
+#define NF_QUEUE_NR(x) (((x << NF_VERDICT_QBITS) & NF_VERDICT_QMASK) | NF_QUEUE)
+
+/* only for userspace compatibility */
+/* Generic cache responses from hook functions.
+   <= 0x2000 is used for protocol-flags. */
+#define NFC_UNKNOWN 0x4000
+#define NFC_ALTERED 0x8000
+
+enum nf_inet_hooks {
+	NF_INET_PRE_ROUTING,
+	NF_INET_LOCAL_IN,
+	NF_INET_FORWARD,
+	NF_INET_LOCAL_OUT,
+	NF_INET_POST_ROUTING,
+	NF_INET_NUMHOOKS,
+};
+
+#endif /*__LINUX_NETFILTER_H*/
diff -uNr libnl_kk/include/linux/netlink.h libnl/include/linux/netlink.h
--- libnl_kk/include/linux/netlink.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/linux/netlink.h	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,150 @@
+#ifndef __LINUX_NETLINK_H
+#define __LINUX_NETLINK_H
+
+#include <linux/socket.h> /* for sa_family_t */
+#include <linux/types.h>
+
+#define NETLINK_ROUTE		0	/* Routing/device hook				*/
+#define NETLINK_UNUSED		1	/* Unused number				*/
+#define NETLINK_USERSOCK	2	/* Reserved for user mode socket protocols 	*/
+#define NETLINK_FIREWALL	3	/* Firewalling hook				*/
+#define NETLINK_INET_DIAG	4	/* INET socket monitoring			*/
+#define NETLINK_NFLOG		5	/* netfilter/iptables ULOG */
+#define NETLINK_XFRM		6	/* ipsec */
+#define NETLINK_SELINUX		7	/* SELinux event notifications */
+#define NETLINK_ISCSI		8	/* Open-iSCSI */
+#define NETLINK_AUDIT		9	/* auditing */
+#define NETLINK_FIB_LOOKUP	10	
+#define NETLINK_CONNECTOR	11
+#define NETLINK_NETFILTER	12	/* netfilter subsystem */
+#define NETLINK_IP6_FW		13
+#define NETLINK_DNRTMSG		14	/* DECnet routing messages */
+#define NETLINK_KOBJECT_UEVENT	15	/* Kernel messages to userspace */
+#define NETLINK_GENERIC		16
+/* leave room for NETLINK_DM (DM Events) */
+#define NETLINK_SCSITRANSPORT	18	/* SCSI Transports */
+#define NETLINK_ECRYPTFS	19
+
+#define MAX_LINKS 32		
+
+struct sockaddr_nl
+{
+	sa_family_t	nl_family;	/* AF_NETLINK	*/
+	unsigned short	nl_pad;		/* zero		*/
+	__u32		nl_pid;		/* port ID	*/
+       	__u32		nl_groups;	/* multicast groups mask */
+};
+
+struct nlmsghdr
+{
+	__u32		nlmsg_len;	/* Length of message including header */
+	__u16		nlmsg_type;	/* Message content */
+	__u16		nlmsg_flags;	/* Additional flags */
+	__u32		nlmsg_seq;	/* Sequence number */
+	__u32		nlmsg_pid;	/* Sending process port ID */
+};
+
+/* Flags values */
+
+#define NLM_F_REQUEST		1	/* It is request message. 	*/
+#define NLM_F_MULTI		2	/* Multipart message, terminated by NLMSG_DONE */
+#define NLM_F_ACK		4	/* Reply with ack, with zero or error code */
+#define NLM_F_ECHO		8	/* Echo this request 		*/
+
+/* Modifiers to GET request */
+#define NLM_F_ROOT	0x100	/* specify tree	root	*/
+#define NLM_F_MATCH	0x200	/* return all matching	*/
+#define NLM_F_ATOMIC	0x400	/* atomic GET		*/
+#define NLM_F_DUMP	(NLM_F_ROOT|NLM_F_MATCH)
+
+/* Modifiers to NEW request */
+#define NLM_F_REPLACE	0x100	/* Override existing		*/
+#define NLM_F_EXCL	0x200	/* Do not touch, if it exists	*/
+#define NLM_F_CREATE	0x400	/* Create, if it does not exist	*/
+#define NLM_F_APPEND	0x800	/* Add to end of list		*/
+
+/*
+   4.4BSD ADD		NLM_F_CREATE|NLM_F_EXCL
+   4.4BSD CHANGE	NLM_F_REPLACE
+
+   True CHANGE		NLM_F_CREATE|NLM_F_REPLACE
+   Append		NLM_F_CREATE
+   Check		NLM_F_EXCL
+ */
+
+#define NLMSG_ALIGNTO	4
+#define NLMSG_ALIGN(len) ( ((len)+NLMSG_ALIGNTO-1) & ~(NLMSG_ALIGNTO-1) )
+#define NLMSG_HDRLEN	 ((int) NLMSG_ALIGN(sizeof(struct nlmsghdr)))
+#define NLMSG_LENGTH(len) ((len)+NLMSG_ALIGN(NLMSG_HDRLEN))
+#define NLMSG_SPACE(len) NLMSG_ALIGN(NLMSG_LENGTH(len))
+#define NLMSG_DATA(nlh)  ((void*)(((char*)nlh) + NLMSG_LENGTH(0)))
+#define NLMSG_NEXT(nlh,len)	 ((len) -= NLMSG_ALIGN((nlh)->nlmsg_len), \
+				  (struct nlmsghdr*)(((char*)(nlh)) + NLMSG_ALIGN((nlh)->nlmsg_len)))
+#define NLMSG_OK(nlh,len) ((len) >= (int)sizeof(struct nlmsghdr) && \
+			   (nlh)->nlmsg_len >= sizeof(struct nlmsghdr) && \
+			   (nlh)->nlmsg_len <= (len))
+#define NLMSG_PAYLOAD(nlh,len) ((nlh)->nlmsg_len - NLMSG_SPACE((len)))
+
+#define NLMSG_NOOP		0x1	/* Nothing.		*/
+#define NLMSG_ERROR		0x2	/* Error		*/
+#define NLMSG_DONE		0x3	/* End of a dump	*/
+#define NLMSG_OVERRUN		0x4	/* Data lost		*/
+
+#define NLMSG_MIN_TYPE		0x10	/* < 0x10: reserved control messages */
+
+struct nlmsgerr
+{
+	int		error;
+	struct nlmsghdr msg;
+};
+
+#define NETLINK_ADD_MEMBERSHIP	1
+#define NETLINK_DROP_MEMBERSHIP	2
+#define NETLINK_PKTINFO		3
+
+struct nl_pktinfo
+{
+	__u32	group;
+};
+
+#define NET_MAJOR 36		/* Major 36 is reserved for networking 						*/
+
+enum {
+	NETLINK_UNCONNECTED = 0,
+	NETLINK_CONNECTED,
+};
+
+/*
+ *  <------- NLA_HDRLEN ------> <-- NLA_ALIGN(payload)-->
+ * +---------------------+- - -+- - - - - - - - - -+- - -+
+ * |        Header       | Pad |     Payload       | Pad |
+ * |   (struct nlattr)   | ing |                   | ing |
+ * +---------------------+- - -+- - - - - - - - - -+- - -+
+ *  <-------------- nlattr->nla_len -------------->
+ */
+
+struct nlattr
+{
+	__u16           nla_len;
+	__u16           nla_type;
+};
+
+/*
+ * nla_type (16 bits)
+ * +---+---+-------------------------------+
+ * | N | O | Attribute Type                |
+ * +---+---+-------------------------------+
+ * N := Carries nested attributes
+ * O := Payload stored in network byte order
+ *
+ * Note: The N and O flag are mutually exclusive.
+ */
+#define NLA_F_NESTED		(1 << 15)
+#define NLA_F_NET_BYTEORDER	(1 << 14)
+#define NLA_TYPE_MASK		~(NLA_F_NESTED | NLA_F_NET_BYTEORDER)
+
+#define NLA_ALIGNTO		4
+#define NLA_ALIGN(len)		(((len) + NLA_ALIGNTO - 1) & ~(NLA_ALIGNTO - 1))
+#define NLA_HDRLEN		((int) NLA_ALIGN(sizeof(struct nlattr)))
+
+#endif	/* __LINUX_NETLINK_H */
diff -uNr libnl_kk/include/linux/pkt_cls.h libnl/include/linux/pkt_cls.h
--- libnl_kk/include/linux/pkt_cls.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/linux/pkt_cls.h	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,494 @@
+#ifndef __LINUX_PKT_CLS_H
+#define __LINUX_PKT_CLS_H
+
+#include <linux/types.h>
+#include <linux/pkt_sched.h>
+
+/* I think i could have done better macros ; for now this is stolen from
+ * some arch/mips code - jhs
+*/
+#define _TC_MAKE32(x) ((x))
+
+#define _TC_MAKEMASK1(n) (_TC_MAKE32(1) << _TC_MAKE32(n))
+#define _TC_MAKEMASK(v,n) (_TC_MAKE32((_TC_MAKE32(1)<<(v))-1) << _TC_MAKE32(n))
+#define _TC_MAKEVALUE(v,n) (_TC_MAKE32(v) << _TC_MAKE32(n))
+#define _TC_GETVALUE(v,n,m) ((_TC_MAKE32(v) & _TC_MAKE32(m)) >> _TC_MAKE32(n))
+
+/* verdict bit breakdown 
+ *
+bit 0: when set -> this packet has been munged already
+
+bit 1: when set -> It is ok to munge this packet
+
+bit 2,3,4,5: Reclassify counter - sort of reverse TTL - if exceeded
+assume loop
+
+bit 6,7: Where this packet was last seen 
+0: Above the transmit example at the socket level
+1: on the Ingress
+2: on the Egress
+
+bit 8: when set --> Request not to classify on ingress. 
+
+bits 9,10,11: redirect counter -  redirect TTL. Loop avoidance
+
+ *
+ * */
+
+#define TC_MUNGED          _TC_MAKEMASK1(0)
+#define SET_TC_MUNGED(v)   ( TC_MUNGED | (v & ~TC_MUNGED))
+#define CLR_TC_MUNGED(v)   ( v & ~TC_MUNGED)
+
+#define TC_OK2MUNGE        _TC_MAKEMASK1(1)
+#define SET_TC_OK2MUNGE(v)   ( TC_OK2MUNGE | (v & ~TC_OK2MUNGE))
+#define CLR_TC_OK2MUNGE(v)   ( v & ~TC_OK2MUNGE)
+
+#define S_TC_VERD          _TC_MAKE32(2)
+#define M_TC_VERD          _TC_MAKEMASK(4,S_TC_VERD)
+#define G_TC_VERD(x)       _TC_GETVALUE(x,S_TC_VERD,M_TC_VERD)
+#define V_TC_VERD(x)       _TC_MAKEVALUE(x,S_TC_VERD)
+#define SET_TC_VERD(v,n)   ((V_TC_VERD(n)) | (v & ~M_TC_VERD))
+
+#define S_TC_FROM          _TC_MAKE32(6)
+#define M_TC_FROM          _TC_MAKEMASK(2,S_TC_FROM)
+#define G_TC_FROM(x)       _TC_GETVALUE(x,S_TC_FROM,M_TC_FROM)
+#define V_TC_FROM(x)       _TC_MAKEVALUE(x,S_TC_FROM)
+#define SET_TC_FROM(v,n)   ((V_TC_FROM(n)) | (v & ~M_TC_FROM))
+#define AT_STACK	0x0
+#define AT_INGRESS	0x1
+#define AT_EGRESS	0x2
+
+#define TC_NCLS          _TC_MAKEMASK1(8)
+#define SET_TC_NCLS(v)   ( TC_NCLS | (v & ~TC_NCLS))
+#define CLR_TC_NCLS(v)   ( v & ~TC_NCLS)
+
+#define S_TC_RTTL          _TC_MAKE32(9)
+#define M_TC_RTTL          _TC_MAKEMASK(3,S_TC_RTTL)
+#define G_TC_RTTL(x)       _TC_GETVALUE(x,S_TC_RTTL,M_TC_RTTL)
+#define V_TC_RTTL(x)       _TC_MAKEVALUE(x,S_TC_RTTL)
+#define SET_TC_RTTL(v,n)   ((V_TC_RTTL(n)) | (v & ~M_TC_RTTL))
+
+#define S_TC_AT          _TC_MAKE32(12)
+#define M_TC_AT          _TC_MAKEMASK(2,S_TC_AT)
+#define G_TC_AT(x)       _TC_GETVALUE(x,S_TC_AT,M_TC_AT)
+#define V_TC_AT(x)       _TC_MAKEVALUE(x,S_TC_AT)
+#define SET_TC_AT(v,n)   ((V_TC_AT(n)) | (v & ~M_TC_AT))
+
+/* Action attributes */
+enum
+{
+	TCA_ACT_UNSPEC,
+	TCA_ACT_KIND,
+	TCA_ACT_OPTIONS,
+	TCA_ACT_INDEX,
+	TCA_ACT_STATS,
+	__TCA_ACT_MAX
+};
+
+#define TCA_ACT_MAX __TCA_ACT_MAX
+#define TCA_OLD_COMPAT (TCA_ACT_MAX+1)
+#define TCA_ACT_MAX_PRIO 32
+#define TCA_ACT_BIND	1
+#define TCA_ACT_NOBIND	0
+#define TCA_ACT_UNBIND	1
+#define TCA_ACT_NOUNBIND	0
+#define TCA_ACT_REPLACE		1
+#define TCA_ACT_NOREPLACE	0
+#define MAX_REC_LOOP 4
+#define MAX_RED_LOOP 4
+
+#define TC_ACT_UNSPEC	(-1)
+#define TC_ACT_OK		0
+#define TC_ACT_RECLASSIFY	1
+#define TC_ACT_SHOT		2
+#define TC_ACT_PIPE		3
+#define TC_ACT_STOLEN		4
+#define TC_ACT_QUEUED		5
+#define TC_ACT_REPEAT		6
+#define TC_ACT_JUMP		0x10000000
+
+/* Action type identifiers*/
+enum
+{
+	TCA_ID_UNSPEC=0,
+	TCA_ID_POLICE=1,
+	/* other actions go here */
+	__TCA_ID_MAX=255
+};
+
+#define TCA_ID_MAX __TCA_ID_MAX
+
+struct tc_police
+{
+	__u32			index;
+	int			action;
+#define TC_POLICE_UNSPEC	TC_ACT_UNSPEC
+#define TC_POLICE_OK		TC_ACT_OK
+#define TC_POLICE_RECLASSIFY	TC_ACT_RECLASSIFY
+#define TC_POLICE_SHOT		TC_ACT_SHOT
+#define TC_POLICE_PIPE		TC_ACT_PIPE
+
+	__u32			limit;
+	__u32			burst;
+	__u32			mtu;
+	struct tc_ratespec	rate;
+	struct tc_ratespec	peakrate;
+	int 			refcnt;
+	int 			bindcnt;
+	__u32			capab;
+};
+
+struct tcf_t
+{
+	__u64   install;
+	__u64   lastuse;
+	__u64   expires;
+};
+
+struct tc_cnt
+{
+	int                   refcnt; 
+	int                   bindcnt;
+};
+
+#define tc_gen \
+	__u32                 index; \
+	__u32                 capab; \
+	int                   action; \
+	int                   refcnt; \
+	int                   bindcnt
+
+enum
+{
+	TCA_POLICE_UNSPEC,
+	TCA_POLICE_TBF,
+	TCA_POLICE_RATE,
+	TCA_POLICE_PEAKRATE,
+	TCA_POLICE_AVRATE,
+	TCA_POLICE_RESULT,
+	__TCA_POLICE_MAX
+#define TCA_POLICE_RESULT TCA_POLICE_RESULT
+};
+
+#define TCA_POLICE_MAX (__TCA_POLICE_MAX - 1)
+
+/* U32 filters */
+
+#define TC_U32_HTID(h) ((h)&0xFFF00000)
+#define TC_U32_USERHTID(h) (TC_U32_HTID(h)>>20)
+#define TC_U32_HASH(h) (((h)>>12)&0xFF)
+#define TC_U32_NODE(h) ((h)&0xFFF)
+#define TC_U32_KEY(h) ((h)&0xFFFFF)
+#define TC_U32_UNSPEC	0
+#define TC_U32_ROOT	(0xFFF00000)
+
+enum
+{
+	TCA_U32_UNSPEC,
+	TCA_U32_CLASSID,
+	TCA_U32_HASH,
+	TCA_U32_LINK,
+	TCA_U32_DIVISOR,
+	TCA_U32_SEL,
+	TCA_U32_POLICE,
+	TCA_U32_ACT,   
+	TCA_U32_INDEV,
+	TCA_U32_PCNT,
+	TCA_U32_MARK,
+	__TCA_U32_MAX
+};
+
+#define TCA_U32_MAX (__TCA_U32_MAX - 1)
+
+struct tc_u32_key
+{
+	__be32		mask;
+	__be32		val;
+	int		off;
+	int		offmask;
+};
+
+struct tc_u32_sel
+{
+	unsigned char		flags;
+	unsigned char		offshift;
+	unsigned char		nkeys;
+
+	__be16			offmask;
+	__u16			off;
+	short			offoff;
+
+	short			hoff;
+	__be32			hmask;
+	struct tc_u32_key	keys[0];
+};
+
+struct tc_u32_mark
+{
+	__u32		val;
+	__u32		mask;
+	__u32		success;
+};
+
+struct tc_u32_pcnt
+{
+	__u64 rcnt;
+	__u64 rhit;
+	__u64 kcnts[0];
+};
+
+/* Flags */
+
+#define TC_U32_TERMINAL		1
+#define TC_U32_OFFSET		2
+#define TC_U32_VAROFFSET	4
+#define TC_U32_EAT		8
+
+#define TC_U32_MAXDEPTH 8
+
+
+/* RSVP filter */
+
+enum
+{
+	TCA_RSVP_UNSPEC,
+	TCA_RSVP_CLASSID,
+	TCA_RSVP_DST,
+	TCA_RSVP_SRC,
+	TCA_RSVP_PINFO,
+	TCA_RSVP_POLICE,
+	TCA_RSVP_ACT,
+	__TCA_RSVP_MAX
+};
+
+#define TCA_RSVP_MAX (__TCA_RSVP_MAX - 1 )
+
+struct tc_rsvp_gpi
+{
+	__u32	key;
+	__u32	mask;
+	int	offset;
+};
+
+struct tc_rsvp_pinfo
+{
+	struct tc_rsvp_gpi dpi;
+	struct tc_rsvp_gpi spi;
+	__u8	protocol;
+	__u8	tunnelid;
+	__u8	tunnelhdr;
+	__u8	pad;
+};
+
+/* ROUTE filter */
+
+enum
+{
+	TCA_ROUTE4_UNSPEC,
+	TCA_ROUTE4_CLASSID,
+	TCA_ROUTE4_TO,
+	TCA_ROUTE4_FROM,
+	TCA_ROUTE4_IIF,
+	TCA_ROUTE4_POLICE,
+	TCA_ROUTE4_ACT,
+	__TCA_ROUTE4_MAX
+};
+
+#define TCA_ROUTE4_MAX (__TCA_ROUTE4_MAX - 1)
+
+
+/* FW filter */
+
+enum
+{
+	TCA_FW_UNSPEC,
+	TCA_FW_CLASSID,
+	TCA_FW_POLICE,
+	TCA_FW_INDEV, /*  used by CONFIG_NET_CLS_IND */
+	TCA_FW_ACT, /* used by CONFIG_NET_CLS_ACT */
+	TCA_FW_MASK,
+	__TCA_FW_MAX
+};
+
+#define TCA_FW_MAX (__TCA_FW_MAX - 1)
+
+/* TC index filter */
+
+enum
+{
+	TCA_TCINDEX_UNSPEC,
+	TCA_TCINDEX_HASH,
+	TCA_TCINDEX_MASK,
+	TCA_TCINDEX_SHIFT,
+	TCA_TCINDEX_FALL_THROUGH,
+	TCA_TCINDEX_CLASSID,
+	TCA_TCINDEX_POLICE,
+	TCA_TCINDEX_ACT,
+	__TCA_TCINDEX_MAX
+};
+
+#define TCA_TCINDEX_MAX     (__TCA_TCINDEX_MAX - 1)
+
+/* Flow filter */
+
+enum
+{
+	FLOW_KEY_SRC,
+	FLOW_KEY_DST,
+	FLOW_KEY_PROTO,
+	FLOW_KEY_PROTO_SRC,
+	FLOW_KEY_PROTO_DST,
+	FLOW_KEY_IIF,
+	FLOW_KEY_PRIORITY,
+	FLOW_KEY_MARK,
+	FLOW_KEY_NFCT,
+	FLOW_KEY_NFCT_SRC,
+	FLOW_KEY_NFCT_DST,
+	FLOW_KEY_NFCT_PROTO_SRC,
+	FLOW_KEY_NFCT_PROTO_DST,
+	FLOW_KEY_RTCLASSID,
+	FLOW_KEY_SKUID,
+	FLOW_KEY_SKGID,
+	FLOW_KEY_VLAN_TAG,
+	__FLOW_KEY_MAX,
+};
+
+#define FLOW_KEY_MAX	(__FLOW_KEY_MAX - 1)
+
+enum
+{
+	FLOW_MODE_MAP,
+	FLOW_MODE_HASH,
+};
+
+enum
+{
+	TCA_FLOW_UNSPEC,
+	TCA_FLOW_KEYS,
+	TCA_FLOW_MODE,
+	TCA_FLOW_BASECLASS,
+	TCA_FLOW_RSHIFT,
+	TCA_FLOW_ADDEND,
+	TCA_FLOW_MASK,
+	TCA_FLOW_XOR,
+	TCA_FLOW_DIVISOR,
+	TCA_FLOW_ACT,
+	TCA_FLOW_POLICE,
+	TCA_FLOW_EMATCHES,
+	TCA_FLOW_PERTURB,
+	__TCA_FLOW_MAX
+};
+
+#define TCA_FLOW_MAX	(__TCA_FLOW_MAX - 1)
+
+/* Basic filter */
+
+enum
+{
+	TCA_BASIC_UNSPEC,
+	TCA_BASIC_CLASSID,
+	TCA_BASIC_EMATCHES,
+	TCA_BASIC_ACT,
+	TCA_BASIC_POLICE,
+	__TCA_BASIC_MAX
+};
+
+#define TCA_BASIC_MAX (__TCA_BASIC_MAX - 1)
+
+
+/* Cgroup classifier */
+
+enum
+{
+	TCA_CGROUP_UNSPEC,
+	TCA_CGROUP_ACT,
+	TCA_CGROUP_POLICE,
+	TCA_CGROUP_EMATCHES,
+	__TCA_CGROUP_MAX,
+};
+
+#define TCA_CGROUP_MAX (__TCA_CGROUP_MAX - 1)
+
+/* Extended Matches */
+
+struct tcf_ematch_tree_hdr
+{
+	__u16		nmatches;
+	__u16		progid;
+};
+
+enum
+{
+	TCA_EMATCH_TREE_UNSPEC,
+	TCA_EMATCH_TREE_HDR,
+	TCA_EMATCH_TREE_LIST,
+	__TCA_EMATCH_TREE_MAX
+};
+#define TCA_EMATCH_TREE_MAX (__TCA_EMATCH_TREE_MAX - 1)
+
+struct tcf_ematch_hdr
+{
+	__u16		matchid;
+	__u16		kind;
+	__u16		flags;
+	__u16		pad; /* currently unused */
+};
+
+/*  0                   1
+ *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 
+ * +-----------------------+-+-+---+
+ * |         Unused        |S|I| R |
+ * +-----------------------+-+-+---+
+ *
+ * R(2) ::= relation to next ematch
+ *          where: 0 0 END (last ematch)
+ *                 0 1 AND
+ *                 1 0 OR
+ *                 1 1 Unused (invalid)
+ * I(1) ::= invert result
+ * S(1) ::= simple payload
+ */
+#define TCF_EM_REL_END	0
+#define TCF_EM_REL_AND	(1<<0)
+#define TCF_EM_REL_OR	(1<<1)
+#define TCF_EM_INVERT	(1<<2)
+#define TCF_EM_SIMPLE	(1<<3)
+
+#define TCF_EM_REL_MASK	3
+#define TCF_EM_REL_VALID(v) (((v) & TCF_EM_REL_MASK) != TCF_EM_REL_MASK)
+
+enum
+{
+	TCF_LAYER_LINK,
+	TCF_LAYER_NETWORK,
+	TCF_LAYER_TRANSPORT,
+	__TCF_LAYER_MAX
+};
+#define TCF_LAYER_MAX (__TCF_LAYER_MAX - 1)
+
+/* Ematch type assignments
+ *   1..32767		Reserved for ematches inside kernel tree
+ *   32768..65535	Free to use, not reliable
+ */
+#define	TCF_EM_CONTAINER	0
+#define	TCF_EM_CMP		1
+#define	TCF_EM_NBYTE		2
+#define	TCF_EM_U32		3
+#define	TCF_EM_META		4
+#define	TCF_EM_TEXT		5
+#define        TCF_EM_VLAN		6
+#define	TCF_EM_MAX		6
+
+enum
+{
+	TCF_EM_PROG_TC
+};
+
+enum
+{
+	TCF_EM_OPND_EQ,
+	TCF_EM_OPND_GT,
+	TCF_EM_OPND_LT
+};
+
+#endif
diff -uNr libnl_kk/include/linux/pkt_sched.h libnl/include/linux/pkt_sched.h
--- libnl_kk/include/linux/pkt_sched.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/linux/pkt_sched.h	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,478 @@
+#ifndef __LINUX_PKT_SCHED_H
+#define __LINUX_PKT_SCHED_H
+
+/* Logical priority bands not depending on specific packet scheduler.
+   Every scheduler will map them to real traffic classes, if it has
+   no more precise mechanism to classify packets.
+
+   These numbers have no special meaning, though their coincidence
+   with obsolete IPv6 values is not occasional :-). New IPv6 drafts
+   preferred full anarchy inspired by diffserv group.
+
+   Note: TC_PRIO_BESTEFFORT does not mean that it is the most unhappy
+   class, actually, as rule it will be handled with more care than
+   filler or even bulk.
+ */
+
+#define TC_PRIO_BESTEFFORT		0
+#define TC_PRIO_FILLER			1
+#define TC_PRIO_BULK			2
+#define TC_PRIO_INTERACTIVE_BULK	4
+#define TC_PRIO_INTERACTIVE		6
+#define TC_PRIO_CONTROL			7
+
+#define TC_PRIO_MAX			15
+
+/* Generic queue statistics, available for all the elements.
+   Particular schedulers may have also their private records.
+ */
+
+struct tc_stats
+{
+	__u64	bytes;			/* NUmber of enqueues bytes */
+	__u32	packets;		/* Number of enqueued packets	*/
+	__u32	drops;			/* Packets dropped because of lack of resources */
+	__u32	overlimits;		/* Number of throttle events when this
+					 * flow goes out of allocated bandwidth */
+	__u32	bps;			/* Current flow byte rate */
+	__u32	pps;			/* Current flow packet rate */
+	__u32	qlen;
+	__u32	backlog;
+};
+
+struct tc_estimator
+{
+	signed char	interval;
+	unsigned char	ewma_log;
+};
+
+/* "Handles"
+   ---------
+
+    All the traffic control objects have 32bit identifiers, or "handles".
+
+    They can be considered as opaque numbers from user API viewpoint,
+    but actually they always consist of two fields: major and
+    minor numbers, which are interpreted by kernel specially,
+    that may be used by applications, though not recommended.
+
+    F.e. qdisc handles always have minor number equal to zero,
+    classes (or flows) have major equal to parent qdisc major, and
+    minor uniquely identifying class inside qdisc.
+
+    Macros to manipulate handles:
+ */
+
+#define TC_H_MAJ_MASK (0xFFFF0000U)
+#define TC_H_MIN_MASK (0x0000FFFFU)
+#define TC_H_MAJ(h) ((h)&TC_H_MAJ_MASK)
+#define TC_H_MIN(h) ((h)&TC_H_MIN_MASK)
+#define TC_H_MAKE(maj,min) (((maj)&TC_H_MAJ_MASK)|((min)&TC_H_MIN_MASK))
+
+#define TC_H_UNSPEC	(0U)
+#define TC_H_ROOT	(0xFFFFFFFFU)
+#define TC_H_INGRESS    (0xFFFFFFF1U)
+
+struct tc_ratespec
+{
+	unsigned char	cell_log;
+	unsigned char	__reserved;
+	unsigned short	feature;
+	short		addend;
+	unsigned short	mpu;
+	__u32		rate;
+};
+
+/* FIFO section */
+
+struct tc_fifo_qopt
+{
+	__u32	limit;	/* Queue length: bytes for bfifo, packets for pfifo */
+};
+
+/* PRIO section */
+
+#define TCQ_PRIO_BANDS	16
+#define TCQ_MIN_PRIO_BANDS 2
+
+struct tc_prio_qopt
+{
+	int	bands;			/* Number of bands */
+	__u8	priomap[TC_PRIO_MAX+1];	/* Map: logical priority -> PRIO band */
+};
+
+enum
+{
+	TCA_PRIO_UNSPEC,
+	TCA_PRIO_MQ,
+	__TCA_PRIO_MAX
+};
+
+#define TCA_PRIO_MAX    (__TCA_PRIO_MAX - 1)
+
+/* TBF section */
+
+struct tc_tbf_qopt
+{
+	struct tc_ratespec rate;
+	struct tc_ratespec peakrate;
+	__u32		limit;
+	__u32		buffer;
+	__u32		mtu;
+};
+
+enum
+{
+	TCA_TBF_UNSPEC,
+	TCA_TBF_PARMS,
+	TCA_TBF_RTAB,
+	TCA_TBF_PTAB,
+	__TCA_TBF_MAX,
+};
+
+#define TCA_TBF_MAX (__TCA_TBF_MAX - 1)
+
+
+/* TEQL section */
+
+/* TEQL does not require any parameters */
+
+/* SFQ section */
+
+struct tc_sfq_qopt
+{
+	unsigned	quantum;	/* Bytes per round allocated to flow */
+	int		perturb_period;	/* Period of hash perturbation */
+	__u32		limit;		/* Maximal packets in queue */
+	unsigned	divisor;	/* Hash divisor  */
+	unsigned	flows;		/* Maximal number of flows  */
+};
+
+/*
+ *  NOTE: limit, divisor and flows are hardwired to code at the moment.
+ *
+ *	limit=flows=128, divisor=1024;
+ *
+ *	The only reason for this is efficiency, it is possible
+ *	to change these parameters in compile time.
+ */
+
+/* RED section */
+
+enum
+{
+	TCA_RED_UNSPEC,
+	TCA_RED_PARMS,
+	TCA_RED_STAB,
+	__TCA_RED_MAX,
+};
+
+#define TCA_RED_MAX (__TCA_RED_MAX - 1)
+
+struct tc_red_qopt
+{
+	__u32		limit;		/* HARD maximal queue length (bytes)	*/
+	__u32		qth_min;	/* Min average length threshold (bytes) */
+	__u32		qth_max;	/* Max average length threshold (bytes) */
+	unsigned char   Wlog;		/* log(W)		*/
+	unsigned char   Plog;		/* log(P_max/(qth_max-qth_min))	*/
+	unsigned char   Scell_log;	/* cell size for idle damping */
+	unsigned char	flags;
+#define TC_RED_ECN	1
+#define TC_RED_HARDDROP	2
+};
+
+struct tc_red_xstats
+{
+	__u32           early;          /* Early drops */
+	__u32           pdrop;          /* Drops due to queue limits */
+	__u32           other;          /* Drops due to drop() calls */
+	__u32           marked;         /* Marked packets */
+};
+
+/* GRED section */
+
+#define MAX_DPs 16
+
+enum
+{
+       TCA_GRED_UNSPEC,
+       TCA_GRED_PARMS,
+       TCA_GRED_STAB,
+       TCA_GRED_DPS,
+	   __TCA_GRED_MAX,
+};
+
+#define TCA_GRED_MAX (__TCA_GRED_MAX - 1)
+
+struct tc_gred_qopt
+{
+	__u32		limit;        /* HARD maximal queue length (bytes)    */
+	__u32		qth_min;      /* Min average length threshold (bytes) */
+	__u32		qth_max;      /* Max average length threshold (bytes) */
+	__u32		DP;           /* upto 2^32 DPs */
+	__u32		backlog;
+	__u32		qave;
+	__u32		forced;
+	__u32		early;
+	__u32		other;
+	__u32		pdrop;
+	__u8		Wlog;         /* log(W)               */
+	__u8		Plog;         /* log(P_max/(qth_max-qth_min)) */
+	__u8		Scell_log;    /* cell size for idle damping */
+	__u8		prio;         /* prio of this VQ */
+	__u32		packets;
+	__u32		bytesin;
+};
+
+/* gred setup */
+struct tc_gred_sopt
+{
+	__u32		DPs;
+	__u32		def_DP;
+	__u8		grio;
+	__u8		flags;
+	__u16		pad1;
+};
+
+/* HTB section */
+#define TC_HTB_NUMPRIO		8
+#define TC_HTB_MAXDEPTH		8
+#define TC_HTB_PROTOVER		3 /* the same as HTB and TC's major */
+
+struct tc_htb_opt
+{
+	struct tc_ratespec 	rate;
+	struct tc_ratespec 	ceil;
+	__u32	buffer;
+	__u32	cbuffer;
+	__u32	quantum;
+	__u32	level;		/* out only */
+	__u32	prio;
+};
+struct tc_htb_glob
+{
+	__u32 version;		/* to match HTB/TC */
+    	__u32 rate2quantum;	/* bps->quantum divisor */
+    	__u32 defcls;		/* default class number */
+	__u32 debug;		/* debug flags */
+
+	/* stats */
+	__u32 direct_pkts; /* count of non shapped packets */
+};
+enum
+{
+	TCA_HTB_UNSPEC,
+	TCA_HTB_PARMS,
+	TCA_HTB_INIT,
+	TCA_HTB_CTAB,
+	TCA_HTB_RTAB,
+	__TCA_HTB_MAX,
+};
+
+#define TCA_HTB_MAX (__TCA_HTB_MAX - 1)
+
+struct tc_htb_xstats
+{
+	__u32 lends;
+	__u32 borrows;
+	__u32 giants;	/* too big packets (rate will not be accurate) */
+	__u32 tokens;
+	__u32 ctokens;
+};
+
+/* HFSC section */
+
+struct tc_hfsc_qopt
+{
+	__u16	defcls;		/* default class */
+};
+
+struct tc_service_curve
+{
+	__u32	m1;		/* slope of the first segment in bps */
+	__u32	d;		/* x-projection of the first segment in us */
+	__u32	m2;		/* slope of the second segment in bps */
+};
+
+struct tc_hfsc_stats
+{
+	__u64	work;		/* total work done */
+	__u64	rtwork;		/* work done by real-time criteria */
+	__u32	period;		/* current period */
+	__u32	level;		/* class level in hierarchy */
+};
+
+enum
+{
+	TCA_HFSC_UNSPEC,
+	TCA_HFSC_RSC,
+	TCA_HFSC_FSC,
+	TCA_HFSC_USC,
+	__TCA_HFSC_MAX,
+};
+
+#define TCA_HFSC_MAX (__TCA_HFSC_MAX - 1)
+
+
+/* CBQ section */
+
+#define TC_CBQ_MAXPRIO		8
+#define TC_CBQ_MAXLEVEL		8
+#define TC_CBQ_DEF_EWMA		5
+
+struct tc_cbq_lssopt
+{
+	unsigned char	change;
+	unsigned char	flags;
+#define TCF_CBQ_LSS_BOUNDED	1
+#define TCF_CBQ_LSS_ISOLATED	2
+	unsigned char  	ewma_log;
+	unsigned char  	level;
+#define TCF_CBQ_LSS_FLAGS	1
+#define TCF_CBQ_LSS_EWMA	2
+#define TCF_CBQ_LSS_MAXIDLE	4
+#define TCF_CBQ_LSS_MINIDLE	8
+#define TCF_CBQ_LSS_OFFTIME	0x10
+#define TCF_CBQ_LSS_AVPKT	0x20
+	__u32		maxidle;
+	__u32		minidle;
+	__u32		offtime;
+	__u32		avpkt;
+};
+
+struct tc_cbq_wrropt
+{
+	unsigned char	flags;
+	unsigned char	priority;
+	unsigned char	cpriority;
+	unsigned char	__reserved;
+	__u32		allot;
+	__u32		weight;
+};
+
+struct tc_cbq_ovl
+{
+	unsigned char	strategy;
+#define	TC_CBQ_OVL_CLASSIC	0
+#define	TC_CBQ_OVL_DELAY	1
+#define	TC_CBQ_OVL_LOWPRIO	2
+#define	TC_CBQ_OVL_DROP		3
+#define	TC_CBQ_OVL_RCLASSIC	4
+	unsigned char	priority2;
+	__u16		pad;
+	__u32		penalty;
+};
+
+struct tc_cbq_police
+{
+	unsigned char	police;
+	unsigned char	__res1;
+	unsigned short	__res2;
+};
+
+struct tc_cbq_fopt
+{
+	__u32		split;
+	__u32		defmap;
+	__u32		defchange;
+};
+
+struct tc_cbq_xstats
+{
+	__u32		borrows;
+	__u32		overactions;
+	__s32		avgidle;
+	__s32		undertime;
+};
+
+enum
+{
+	TCA_CBQ_UNSPEC,
+	TCA_CBQ_LSSOPT,
+	TCA_CBQ_WRROPT,
+	TCA_CBQ_FOPT,
+	TCA_CBQ_OVL_STRATEGY,
+	TCA_CBQ_RATE,
+	TCA_CBQ_RTAB,
+	TCA_CBQ_POLICE,
+	__TCA_CBQ_MAX,
+};
+
+#define TCA_CBQ_MAX	(__TCA_CBQ_MAX - 1)
+
+/* dsmark section */
+
+enum {
+	TCA_DSMARK_UNSPEC,
+	TCA_DSMARK_INDICES,
+	TCA_DSMARK_DEFAULT_INDEX,
+	TCA_DSMARK_SET_TC_INDEX,
+	TCA_DSMARK_MASK,
+	TCA_DSMARK_VALUE,
+	__TCA_DSMARK_MAX,
+};
+
+#define TCA_DSMARK_MAX (__TCA_DSMARK_MAX - 1)
+
+/* ATM  section */
+
+enum {
+	TCA_ATM_UNSPEC,
+	TCA_ATM_FD,		/* file/socket descriptor */
+	TCA_ATM_PTR,		/* pointer to descriptor - later */
+	TCA_ATM_HDR,		/* LL header */
+	TCA_ATM_EXCESS,		/* excess traffic class (0 for CLP)  */
+	TCA_ATM_ADDR,		/* PVC address (for output only) */
+	TCA_ATM_STATE,		/* VC state (ATM_VS_*; for output only) */
+	__TCA_ATM_MAX,
+};
+
+#define TCA_ATM_MAX	(__TCA_ATM_MAX - 1)
+
+/* Network emulator */
+
+enum
+{
+	TCA_NETEM_UNSPEC,
+	TCA_NETEM_CORR,
+	TCA_NETEM_DELAY_DIST,
+	TCA_NETEM_REORDER,
+	TCA_NETEM_CORRUPT,
+	__TCA_NETEM_MAX,
+};
+
+#define TCA_NETEM_MAX (__TCA_NETEM_MAX - 1)
+
+struct tc_netem_qopt
+{
+	__u32	latency;	/* added delay (us) */
+	__u32   limit;		/* fifo limit (packets) */
+	__u32	loss;		/* random packet loss (0=none ~0=100%) */
+	__u32	gap;		/* re-ordering gap (0 for none) */
+	__u32   duplicate;	/* random packet dup  (0=none ~0=100%) */
+	__u32	jitter;		/* random jitter in latency (us) */
+};
+
+struct tc_netem_corr
+{
+	__u32	delay_corr;	/* delay correlation */
+	__u32	loss_corr;	/* packet loss correlation */
+	__u32	dup_corr;	/* duplicate correlation  */
+};
+
+struct tc_netem_reorder
+{
+	__u32	probability;
+	__u32	correlation;
+};
+
+struct tc_netem_corrupt
+{
+	__u32	probability;
+	__u32	correlation;
+};
+
+#define NETEM_DIST_SCALE	8192
+
+#endif
diff -uNr libnl_kk/include/linux/rtnetlink.h libnl/include/linux/rtnetlink.h
--- libnl_kk/include/linux/rtnetlink.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/linux/rtnetlink.h	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,602 @@
+#ifndef __LINUX_RTNETLINK_H
+#define __LINUX_RTNETLINK_H
+
+#include <linux/netlink.h>
+#include <linux/if_link.h>
+#include <linux/if_addr.h>
+#include <linux/neighbour.h>
+
+/****
+ *		Routing/neighbour discovery messages.
+ ****/
+
+/* Types of messages */
+
+enum {
+	RTM_BASE	= 16,
+#define RTM_BASE	RTM_BASE
+
+	RTM_NEWLINK	= 16,
+#define RTM_NEWLINK	RTM_NEWLINK
+	RTM_DELLINK,
+#define RTM_DELLINK	RTM_DELLINK
+	RTM_GETLINK,
+#define RTM_GETLINK	RTM_GETLINK
+	RTM_SETLINK,
+#define RTM_SETLINK	RTM_SETLINK
+
+	RTM_NEWADDR	= 20,
+#define RTM_NEWADDR	RTM_NEWADDR
+	RTM_DELADDR,
+#define RTM_DELADDR	RTM_DELADDR
+	RTM_GETADDR,
+#define RTM_GETADDR	RTM_GETADDR
+
+	RTM_NEWROUTE	= 24,
+#define RTM_NEWROUTE	RTM_NEWROUTE
+	RTM_DELROUTE,
+#define RTM_DELROUTE	RTM_DELROUTE
+	RTM_GETROUTE,
+#define RTM_GETROUTE	RTM_GETROUTE
+
+	RTM_NEWNEIGH	= 28,
+#define RTM_NEWNEIGH	RTM_NEWNEIGH
+	RTM_DELNEIGH,
+#define RTM_DELNEIGH	RTM_DELNEIGH
+	RTM_GETNEIGH,
+#define RTM_GETNEIGH	RTM_GETNEIGH
+
+	RTM_NEWRULE	= 32,
+#define RTM_NEWRULE	RTM_NEWRULE
+	RTM_DELRULE,
+#define RTM_DELRULE	RTM_DELRULE
+	RTM_GETRULE,
+#define RTM_GETRULE	RTM_GETRULE
+
+	RTM_NEWQDISC	= 36,
+#define RTM_NEWQDISC	RTM_NEWQDISC
+	RTM_DELQDISC,
+#define RTM_DELQDISC	RTM_DELQDISC
+	RTM_GETQDISC,
+#define RTM_GETQDISC	RTM_GETQDISC
+
+	RTM_NEWTCLASS	= 40,
+#define RTM_NEWTCLASS	RTM_NEWTCLASS
+	RTM_DELTCLASS,
+#define RTM_DELTCLASS	RTM_DELTCLASS
+	RTM_GETTCLASS,
+#define RTM_GETTCLASS	RTM_GETTCLASS
+
+	RTM_NEWTFILTER	= 44,
+#define RTM_NEWTFILTER	RTM_NEWTFILTER
+	RTM_DELTFILTER,
+#define RTM_DELTFILTER	RTM_DELTFILTER
+	RTM_GETTFILTER,
+#define RTM_GETTFILTER	RTM_GETTFILTER
+
+	RTM_NEWACTION	= 48,
+#define RTM_NEWACTION   RTM_NEWACTION
+	RTM_DELACTION,
+#define RTM_DELACTION   RTM_DELACTION
+	RTM_GETACTION,
+#define RTM_GETACTION   RTM_GETACTION
+
+	RTM_NEWPREFIX	= 52,
+#define RTM_NEWPREFIX	RTM_NEWPREFIX
+
+	RTM_GETMULTICAST = 58,
+#define RTM_GETMULTICAST RTM_GETMULTICAST
+
+	RTM_GETANYCAST	= 62,
+#define RTM_GETANYCAST	RTM_GETANYCAST
+
+	RTM_NEWNEIGHTBL	= 64,
+#define RTM_NEWNEIGHTBL	RTM_NEWNEIGHTBL
+	RTM_GETNEIGHTBL	= 66,
+#define RTM_GETNEIGHTBL	RTM_GETNEIGHTBL
+	RTM_SETNEIGHTBL,
+#define RTM_SETNEIGHTBL	RTM_SETNEIGHTBL
+
+	RTM_NEWNDUSEROPT = 68,
+#define RTM_NEWNDUSEROPT RTM_NEWNDUSEROPT
+
+	RTM_NEWADDRLABEL = 72,
+#define RTM_NEWADDRLABEL RTM_NEWADDRLABEL
+	RTM_DELADDRLABEL,
+#define RTM_NEWADDRLABEL RTM_NEWADDRLABEL
+	RTM_GETADDRLABEL,
+#define RTM_GETADDRLABEL RTM_GETADDRLABEL
+
+	__RTM_MAX,
+#define RTM_MAX		(((__RTM_MAX + 3) & ~3) - 1)
+};
+
+#define RTM_NR_MSGTYPES	(RTM_MAX + 1 - RTM_BASE)
+#define RTM_NR_FAMILIES	(RTM_NR_MSGTYPES >> 2)
+#define RTM_FAM(cmd)	(((cmd) - RTM_BASE) >> 2)
+
+/* 
+   Generic structure for encapsulation of optional route information.
+   It is reminiscent of sockaddr, but with sa_family replaced
+   with attribute type.
+ */
+
+struct rtattr
+{
+	unsigned short	rta_len;
+	unsigned short	rta_type;
+};
+
+/* Macros to handle rtattributes */
+
+#define RTA_ALIGNTO	4
+#define RTA_ALIGN(len) ( ((len)+RTA_ALIGNTO-1) & ~(RTA_ALIGNTO-1) )
+#define RTA_OK(rta,len) ((len) >= (int)sizeof(struct rtattr) && \
+			 (rta)->rta_len >= sizeof(struct rtattr) && \
+			 (rta)->rta_len <= (len))
+#define RTA_NEXT(rta,attrlen)	((attrlen) -= RTA_ALIGN((rta)->rta_len), \
+				 (struct rtattr*)(((char*)(rta)) + RTA_ALIGN((rta)->rta_len)))
+#define RTA_LENGTH(len)	(RTA_ALIGN(sizeof(struct rtattr)) + (len))
+#define RTA_SPACE(len)	RTA_ALIGN(RTA_LENGTH(len))
+#define RTA_DATA(rta)   ((void*)(((char*)(rta)) + RTA_LENGTH(0)))
+#define RTA_PAYLOAD(rta) ((int)((rta)->rta_len) - RTA_LENGTH(0))
+
+
+
+
+/******************************************************************************
+ *		Definitions used in routing table administration.
+ ****/
+
+struct rtmsg
+{
+	unsigned char		rtm_family;
+	unsigned char		rtm_dst_len;
+	unsigned char		rtm_src_len;
+	unsigned char		rtm_tos;
+
+	unsigned char		rtm_table;	/* Routing table id */
+	unsigned char		rtm_protocol;	/* Routing protocol; see below	*/
+	unsigned char		rtm_scope;	/* See below */	
+	unsigned char		rtm_type;	/* See below	*/
+
+	unsigned		rtm_flags;
+};
+
+/* rtm_type */
+
+enum
+{
+	RTN_UNSPEC,
+	RTN_UNICAST,		/* Gateway or direct route	*/
+	RTN_LOCAL,		/* Accept locally		*/
+	RTN_BROADCAST,		/* Accept locally as broadcast,
+				   send as broadcast */
+	RTN_ANYCAST,		/* Accept locally as broadcast,
+				   but send as unicast */
+	RTN_MULTICAST,		/* Multicast route		*/
+	RTN_BLACKHOLE,		/* Drop				*/
+	RTN_UNREACHABLE,	/* Destination is unreachable   */
+	RTN_PROHIBIT,		/* Administratively prohibited	*/
+	RTN_THROW,		/* Not in this table		*/
+	RTN_NAT,		/* Translate this address	*/
+	RTN_XRESOLVE,		/* Use external resolver	*/
+	__RTN_MAX
+};
+
+#define RTN_MAX (__RTN_MAX - 1)
+
+
+/* rtm_protocol */
+
+#define RTPROT_UNSPEC	0
+#define RTPROT_REDIRECT	1	/* Route installed by ICMP redirects;
+				   not used by current IPv4 */
+#define RTPROT_KERNEL	2	/* Route installed by kernel		*/
+#define RTPROT_BOOT	3	/* Route installed during boot		*/
+#define RTPROT_STATIC	4	/* Route installed by administrator	*/
+
+/* Values of protocol >= RTPROT_STATIC are not interpreted by kernel;
+   they are just passed from user and back as is.
+   It will be used by hypothetical multiple routing daemons.
+   Note that protocol values should be standardized in order to
+   avoid conflicts.
+ */
+
+#define RTPROT_GATED	8	/* Apparently, GateD */
+#define RTPROT_RA	9	/* RDISC/ND router advertisements */
+#define RTPROT_MRT	10	/* Merit MRT */
+#define RTPROT_ZEBRA	11	/* Zebra */
+#define RTPROT_BIRD	12	/* BIRD */
+#define RTPROT_DNROUTED	13	/* DECnet routing daemon */
+#define RTPROT_XORP	14	/* XORP */
+#define RTPROT_NTK	15	/* Netsukuku */
+
+/* rtm_scope
+
+   Really it is not scope, but sort of distance to the destination.
+   NOWHERE are reserved for not existing destinations, HOST is our
+   local addresses, LINK are destinations, located on directly attached
+   link and UNIVERSE is everywhere in the Universe.
+
+   Intermediate values are also possible f.e. interior routes
+   could be assigned a value between UNIVERSE and LINK.
+*/
+
+enum rt_scope_t
+{
+	RT_SCOPE_UNIVERSE=0,
+/* User defined values  */
+	RT_SCOPE_SITE=200,
+	RT_SCOPE_LINK=253,
+	RT_SCOPE_HOST=254,
+	RT_SCOPE_NOWHERE=255
+};
+
+/* rtm_flags */
+
+#define RTM_F_NOTIFY		0x100	/* Notify user of route change	*/
+#define RTM_F_CLONED		0x200	/* This route is cloned		*/
+#define RTM_F_EQUALIZE		0x400	/* Multipath equalizer: NI	*/
+#define RTM_F_PREFIX		0x800	/* Prefix addresses		*/
+
+/* Reserved table identifiers */
+
+enum rt_class_t
+{
+	RT_TABLE_UNSPEC=0,
+/* User defined values */
+	RT_TABLE_DEFAULT=253,
+	RT_TABLE_MAIN=254,
+	RT_TABLE_LOCAL=255,
+	RT_TABLE_MAX=0xFFFFFFFF
+};
+
+
+/* Routing message attributes */
+
+enum rtattr_type_t
+{
+	RTA_UNSPEC,
+	RTA_DST,
+	RTA_SRC,
+	RTA_IIF,
+	RTA_OIF,
+	RTA_GATEWAY,
+	RTA_PRIORITY,
+	RTA_PREFSRC,
+	RTA_METRICS,
+	RTA_MULTIPATH,
+	RTA_PROTOINFO, /* no longer used */
+	RTA_FLOW,
+	RTA_CACHEINFO,
+	RTA_SESSION, /* no longer used */
+	RTA_MP_ALGO, /* no longer used */
+	RTA_TABLE,
+	RTA_GENERATION,
+	__RTA_MAX
+};
+
+#define RTA_MAX (__RTA_MAX - 1)
+
+#define RTM_RTA(r)  ((struct rtattr*)(((char*)(r)) + NLMSG_ALIGN(sizeof(struct rtmsg))))
+#define RTM_PAYLOAD(n) NLMSG_PAYLOAD(n,sizeof(struct rtmsg))
+
+/* RTM_MULTIPATH --- array of struct rtnexthop.
+ *
+ * "struct rtnexthop" describes all necessary nexthop information,
+ * i.e. parameters of path to a destination via this nexthop.
+ *
+ * At the moment it is impossible to set different prefsrc, mtu, window
+ * and rtt for different paths from multipath.
+ */
+
+struct rtnexthop
+{
+	unsigned short		rtnh_len;
+	unsigned char		rtnh_flags;
+	unsigned char		rtnh_hops;
+	int			rtnh_ifindex;
+};
+
+/* rtnh_flags */
+
+#define RTNH_F_DEAD		1	/* Nexthop is dead (used by multipath)	*/
+#define RTNH_F_PERVASIVE	2	/* Do recursive gateway lookup	*/
+#define RTNH_F_ONLINK		4	/* Gateway is forced on link	*/
+
+/* Macros to handle hexthops */
+
+#define RTNH_ALIGNTO	4
+#define RTNH_ALIGN(len) ( ((len)+RTNH_ALIGNTO-1) & ~(RTNH_ALIGNTO-1) )
+#define RTNH_OK(rtnh,len) ((rtnh)->rtnh_len >= sizeof(struct rtnexthop) && \
+			   ((int)(rtnh)->rtnh_len) <= (len))
+#define RTNH_NEXT(rtnh)	((struct rtnexthop*)(((char*)(rtnh)) + RTNH_ALIGN((rtnh)->rtnh_len)))
+#define RTNH_LENGTH(len) (RTNH_ALIGN(sizeof(struct rtnexthop)) + (len))
+#define RTNH_SPACE(len)	RTNH_ALIGN(RTNH_LENGTH(len))
+#define RTNH_DATA(rtnh)   ((struct rtattr*)(((char*)(rtnh)) + RTNH_LENGTH(0)))
+
+/* RTM_CACHEINFO */
+
+struct rta_cacheinfo
+{
+	__u32	rta_clntref;
+	__u32	rta_lastuse;
+	__s32	rta_expires;
+	__u32	rta_error;
+	__u32	rta_used;
+
+#define RTNETLINK_HAVE_PEERINFO 1
+	__u32	rta_id;
+	__u32	rta_ts;
+	__u32	rta_tsage;
+};
+
+/* RTM_METRICS --- array of struct rtattr with types of RTAX_* */
+
+enum
+{
+	RTAX_UNSPEC,
+#define RTAX_UNSPEC RTAX_UNSPEC
+	RTAX_LOCK,
+#define RTAX_LOCK RTAX_LOCK
+	RTAX_MTU,
+#define RTAX_MTU RTAX_MTU
+	RTAX_WINDOW,
+#define RTAX_WINDOW RTAX_WINDOW
+	RTAX_RTT,
+#define RTAX_RTT RTAX_RTT
+	RTAX_RTTVAR,
+#define RTAX_RTTVAR RTAX_RTTVAR
+	RTAX_SSTHRESH,
+#define RTAX_SSTHRESH RTAX_SSTHRESH
+	RTAX_CWND,
+#define RTAX_CWND RTAX_CWND
+	RTAX_ADVMSS,
+#define RTAX_ADVMSS RTAX_ADVMSS
+	RTAX_REORDERING,
+#define RTAX_REORDERING RTAX_REORDERING
+	RTAX_HOPLIMIT,
+#define RTAX_HOPLIMIT RTAX_HOPLIMIT
+	RTAX_INITCWND,
+#define RTAX_INITCWND RTAX_INITCWND
+	RTAX_FEATURES,
+#define RTAX_FEATURES RTAX_FEATURES
+	RTAX_RTO_MIN,
+#define RTAX_RTO_MIN RTAX_RTO_MIN
+	__RTAX_MAX
+};
+
+#define RTAX_MAX (__RTAX_MAX - 1)
+
+#define RTAX_FEATURE_ECN	0x00000001
+#define RTAX_FEATURE_SACK	0x00000002
+#define RTAX_FEATURE_TIMESTAMP	0x00000004
+#define RTAX_FEATURE_ALLFRAG	0x00000008
+
+struct rta_session
+{
+	__u8	proto;
+	__u8	pad1;
+	__u16	pad2;
+
+	union {
+		struct {
+			__u16	sport;
+			__u16	dport;
+		} ports;
+
+		struct {
+			__u8	type;
+			__u8	code;
+			__u16	ident;
+		} icmpt;
+
+		__u32		spi;
+	} u;
+};
+
+/****
+ *		General form of address family dependent message.
+ ****/
+
+struct rtgenmsg
+{
+	unsigned char		rtgen_family;
+};
+
+/*****************************************************************
+ *		Link layer specific messages.
+ ****/
+
+/* struct ifinfomsg
+ * passes link level specific information, not dependent
+ * on network protocol.
+ */
+
+struct ifinfomsg
+{
+	unsigned char	ifi_family;
+	unsigned char	__ifi_pad;
+	unsigned short	ifi_type;		/* ARPHRD_* */
+	int		ifi_index;		/* Link index	*/
+	unsigned	ifi_flags;		/* IFF_* flags	*/
+	unsigned	ifi_change;		/* IFF_* change mask */
+};
+
+/********************************************************************
+ *		prefix information 
+ ****/
+
+struct prefixmsg
+{
+	unsigned char	prefix_family;
+	unsigned char	prefix_pad1;
+	unsigned short	prefix_pad2;
+	int		prefix_ifindex;
+	unsigned char	prefix_type;
+	unsigned char	prefix_len;
+	unsigned char	prefix_flags;
+	unsigned char	prefix_pad3;
+};
+
+enum 
+{
+	PREFIX_UNSPEC,
+	PREFIX_ADDRESS,
+	PREFIX_CACHEINFO,
+	__PREFIX_MAX
+};
+
+#define PREFIX_MAX	(__PREFIX_MAX - 1)
+
+struct prefix_cacheinfo
+{
+	__u32	preferred_time;
+	__u32	valid_time;
+};
+
+
+/*****************************************************************
+ *		Traffic control messages.
+ ****/
+
+struct tcmsg
+{
+	unsigned char	tcm_family;
+	unsigned char	tcm__pad1;
+	unsigned short	tcm__pad2;
+	int		tcm_ifindex;
+	__u32		tcm_handle;
+	__u32		tcm_parent;
+	__u32		tcm_info;
+};
+
+enum
+{
+	TCA_UNSPEC,
+	TCA_KIND,
+	TCA_OPTIONS,
+	TCA_STATS,
+	TCA_XSTATS,
+	TCA_RATE,
+	TCA_FCNT,
+	TCA_STATS2,
+	__TCA_MAX
+};
+
+#define TCA_MAX (__TCA_MAX - 1)
+
+#define TCA_RTA(r)  ((struct rtattr*)(((char*)(r)) + NLMSG_ALIGN(sizeof(struct tcmsg))))
+#define TCA_PAYLOAD(n) NLMSG_PAYLOAD(n,sizeof(struct tcmsg))
+
+/********************************************************************
+ *		Neighbor Discovery userland options
+ ****/
+
+struct nduseroptmsg
+{
+	unsigned char	nduseropt_family;
+	unsigned char	nduseropt_pad1;
+	unsigned short	nduseropt_opts_len;	/* Total length of options */
+	int		nduseropt_ifindex;
+	__u8		nduseropt_icmp_type;
+	__u8		nduseropt_icmp_code;
+	unsigned short	nduseropt_pad2;
+	unsigned int	nduseropt_pad3;
+	/* Followed by one or more ND options */
+};
+
+enum
+{
+	NDUSEROPT_UNSPEC,
+	NDUSEROPT_SRCADDR,
+	__NDUSEROPT_MAX
+};
+
+#define NDUSEROPT_MAX	(__NDUSEROPT_MAX - 1)
+
+#ifndef __KERNEL__
+/* RTnetlink multicast groups - backwards compatibility for userspace */
+#define RTMGRP_LINK		1
+#define RTMGRP_NOTIFY		2
+#define RTMGRP_NEIGH		4
+#define RTMGRP_TC		8
+
+#define RTMGRP_IPV4_IFADDR	0x10
+#define RTMGRP_IPV4_MROUTE	0x20
+#define RTMGRP_IPV4_ROUTE	0x40
+#define RTMGRP_IPV4_RULE	0x80
+
+#define RTMGRP_IPV6_IFADDR	0x100
+#define RTMGRP_IPV6_MROUTE	0x200
+#define RTMGRP_IPV6_ROUTE	0x400
+#define RTMGRP_IPV6_IFINFO	0x800
+
+#define RTMGRP_DECnet_IFADDR    0x1000
+#define RTMGRP_DECnet_ROUTE     0x4000
+
+#define RTMGRP_IPV6_PREFIX	0x20000
+#endif
+
+/* RTnetlink multicast groups */
+enum rtnetlink_groups {
+	RTNLGRP_NONE,
+#define RTNLGRP_NONE		RTNLGRP_NONE
+	RTNLGRP_LINK,
+#define RTNLGRP_LINK		RTNLGRP_LINK
+	RTNLGRP_NOTIFY,
+#define RTNLGRP_NOTIFY		RTNLGRP_NOTIFY
+	RTNLGRP_NEIGH,
+#define RTNLGRP_NEIGH		RTNLGRP_NEIGH
+	RTNLGRP_TC,
+#define RTNLGRP_TC		RTNLGRP_TC
+	RTNLGRP_IPV4_IFADDR,
+#define RTNLGRP_IPV4_IFADDR	RTNLGRP_IPV4_IFADDR
+	RTNLGRP_IPV4_MROUTE,
+#define	RTNLGRP_IPV4_MROUTE	RTNLGRP_IPV4_MROUTE
+	RTNLGRP_IPV4_ROUTE,
+#define RTNLGRP_IPV4_ROUTE	RTNLGRP_IPV4_ROUTE
+	RTNLGRP_IPV4_RULE,
+#define RTNLGRP_IPV4_RULE	RTNLGRP_IPV4_RULE
+	RTNLGRP_IPV6_IFADDR,
+#define RTNLGRP_IPV6_IFADDR	RTNLGRP_IPV6_IFADDR
+	RTNLGRP_IPV6_MROUTE,
+#define RTNLGRP_IPV6_MROUTE	RTNLGRP_IPV6_MROUTE
+	RTNLGRP_IPV6_ROUTE,
+#define RTNLGRP_IPV6_ROUTE	RTNLGRP_IPV6_ROUTE
+	RTNLGRP_IPV6_IFINFO,
+#define RTNLGRP_IPV6_IFINFO	RTNLGRP_IPV6_IFINFO
+	RTNLGRP_DECnet_IFADDR,
+#define RTNLGRP_DECnet_IFADDR	RTNLGRP_DECnet_IFADDR
+	RTNLGRP_NOP2,
+	RTNLGRP_DECnet_ROUTE,
+#define RTNLGRP_DECnet_ROUTE	RTNLGRP_DECnet_ROUTE
+	RTNLGRP_DECnet_RULE,
+#define RTNLGRP_DECnet_RULE	RTNLGRP_DECnet_RULE
+	RTNLGRP_NOP4,
+	RTNLGRP_IPV6_PREFIX,
+#define RTNLGRP_IPV6_PREFIX	RTNLGRP_IPV6_PREFIX
+	RTNLGRP_IPV6_RULE,
+#define RTNLGRP_IPV6_RULE	RTNLGRP_IPV6_RULE
+	RTNLGRP_ND_USEROPT,
+#define RTNLGRP_ND_USEROPT	RTNLGRP_ND_USEROPT
+	__RTNLGRP_MAX
+};
+#define RTNLGRP_MAX	(__RTNLGRP_MAX - 1)
+
+/* TC action piece */
+struct tcamsg
+{
+	unsigned char	tca_family;
+	unsigned char	tca__pad1;
+	unsigned short	tca__pad2;
+};
+#define TA_RTA(r)  ((struct rtattr*)(((char*)(r)) + NLMSG_ALIGN(sizeof(struct tcamsg))))
+#define TA_PAYLOAD(n) NLMSG_PAYLOAD(n,sizeof(struct tcamsg))
+#define TCA_ACT_TAB 1 /* attr type must be >=1 */	
+#define TCAA_MAX 1
+
+/* End of information exported to user level */
+
+#endif	/* __LINUX_RTNETLINK_H */
diff -uNr libnl_kk/include/Makefile.am libnl/include/Makefile.am
--- libnl_kk/include/Makefile.am	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/Makefile.am	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,63 @@
+# -*- Makefile -*-
+
+nobase_include_HEADERS = \
+	netlink/fib_lookup/lookup.h \
+	netlink/fib_lookup/request.h \
+	netlink/genl/ctrl.h \
+	netlink/genl/family.h \
+	netlink/genl/genl.h \
+	netlink/genl/mngt.h \
+	netlink/netfilter/ct.h \
+	netlink/netfilter/log.h \
+	netlink/netfilter/log_msg.h \
+	netlink/netfilter/netfilter.h \
+	netlink/netfilter/nfnl.h \
+	netlink/netfilter/queue.h \
+	netlink/netfilter/queue_msg.h \
+	netlink/addr.h \
+	netlink/attr.h \
+	netlink/cache-api.h \
+	netlink/cache.h \
+	netlink/data.h \
+	netlink/errno.h \
+	netlink/handlers.h \
+	netlink/list.h \
+	netlink/msg.h \
+	netlink/netlink-compat.h \
+	netlink/netlink-kernel.h \
+	netlink/netlink.h \
+	netlink/object-api.h \
+	netlink/object.h \
+	netlink/route/cls/fw.h \
+	netlink/route/cls/police.h \
+	netlink/route/cls/u32.h \
+	netlink/route/link/info-api.h \
+	netlink/route/link/vlan.h \
+	netlink/route/sch/cbq.h \
+	netlink/route/sch/dsmark.h \
+	netlink/route/sch/fifo.h \
+	netlink/route/sch/htb.h \
+	netlink/route/sch/netem.h \
+	netlink/route/sch/prio.h \
+	netlink/route/sch/red.h \
+	netlink/route/sch/sfq.h \
+	netlink/route/sch/tbf.h \
+	netlink/route/addr.h \
+	netlink/route/class-modules.h \
+	netlink/route/class.h \
+	netlink/route/classifier-modules.h \
+	netlink/route/classifier.h \
+	netlink/route/link.h \
+	netlink/route/neighbour.h \
+	netlink/route/neightbl.h \
+	netlink/route/nexthop.h \
+	netlink/route/qdisc-modules.h \
+	netlink/route/qdisc.h \
+	netlink/route/route.h \
+	netlink/route/rtnl.h \
+	netlink/route/rule.h \
+	netlink/route/tc.h \
+	netlink/socket.h \
+	netlink/types.h \
+	netlink/utils.h \
+	netlink/version.h
diff -uNr libnl_kk/include/netlink/addr.h libnl/include/netlink/addr.h
--- libnl_kk/include/netlink/addr.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/addr.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,69 @@
+/*
+ * netlink/addr.h		Abstract Address
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_ADDR_H_
+#define NETLINK_ADDR_H_
+
+#include <netlink/netlink.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct nl_addr;
+
+/* Creation */
+extern struct nl_addr *	nl_addr_alloc(size_t);
+extern struct nl_addr *	nl_addr_alloc_attr(struct nlattr *, int);
+extern struct nl_addr *	nl_addr_build(int, void *, size_t);
+extern int		nl_addr_parse(const char *, int, struct nl_addr **);
+extern struct nl_addr *	nl_addr_clone(struct nl_addr *);
+
+/* Destroyage */
+extern void		nl_addr_destroy(struct nl_addr *);
+
+/* Usage Management */
+extern struct nl_addr *	nl_addr_get(struct nl_addr *);
+extern void		nl_addr_put(struct nl_addr *);
+extern int		nl_addr_shared(struct nl_addr *);
+
+extern int		nl_addr_cmp(struct nl_addr *, struct nl_addr *);
+extern int		nl_addr_cmp_prefix(struct nl_addr *, struct nl_addr *);
+extern int		nl_addr_iszero(struct nl_addr *);
+extern int		nl_addr_valid(char *, int);
+extern int      	nl_addr_guess_family(struct nl_addr *);
+extern int		nl_addr_fill_sockaddr(struct nl_addr *,
+					      struct sockaddr *, socklen_t *);
+extern int		nl_addr_info(struct nl_addr *, struct addrinfo **);
+extern int		nl_addr_resolve(struct nl_addr *addr, char *host, size_t hostlen);
+
+/* Access Functions */
+extern void		nl_addr_set_family(struct nl_addr *, int);
+extern int		nl_addr_get_family(struct nl_addr *);
+extern int		nl_addr_set_binary_addr(struct nl_addr *, void *,
+						size_t);
+extern void *		nl_addr_get_binary_addr(struct nl_addr *);
+extern unsigned int	nl_addr_get_len(struct nl_addr *);
+extern void		nl_addr_set_prefixlen(struct nl_addr *, int);
+extern unsigned int	nl_addr_get_prefixlen(struct nl_addr *);
+
+/* Address Family Translations */
+extern char *		nl_af2str(int, char *, size_t);
+extern int		nl_str2af(const char *);
+
+/* Translations to Strings */
+extern char *		nl_addr2str(struct nl_addr *, char *, size_t);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/attr.h libnl/include/netlink/attr.h
--- libnl_kk/include/netlink/attr.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/attr.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,283 @@
+/*
+ * netlink/attr.h		Netlink Attributes
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_ATTR_H_
+#define NETLINK_ATTR_H_
+
+#include <netlink/netlink.h>
+#include <netlink/object.h>
+#include <netlink/addr.h>
+#include <netlink/data.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct nl_msg;
+
+/**
+ * @name Basic Attribute Data Types
+ * @{
+ */
+
+ /**
+  * @ingroup attr
+  * Basic attribute data types
+  *
+  * See \ref attr_datatypes for more details.
+  */
+enum {
+	NLA_UNSPEC,	/**< Unspecified type, binary data chunk */
+	NLA_U8,		/**< 8 bit integer */
+	NLA_U16,	/**< 16 bit integer */
+	NLA_U32,	/**< 32 bit integer */
+	NLA_U64,	/**< 64 bit integer */
+	NLA_STRING,	/**< NUL terminated character string */
+	NLA_FLAG,	/**< Flag */
+	NLA_MSECS,	/**< Micro seconds (64bit) */
+	NLA_NESTED,	/**< Nested attributes */
+	__NLA_TYPE_MAX,
+};
+
+#define NLA_TYPE_MAX (__NLA_TYPE_MAX - 1)
+
+/** @} */
+
+/**
+ * @ingroup attr
+ * Attribute validation policy.
+ *
+ * See \ref attr_datatypes for more details.
+ */
+struct nla_policy {
+	/** Type of attribute or NLA_UNSPEC */
+	uint16_t	type;
+
+	/** Minimal length of payload required */
+	uint16_t	minlen;
+
+	/** Maximal length of payload allowed */
+	uint16_t	maxlen;
+};
+
+/* Size calculations */
+extern int		nla_attr_size(int payload);
+extern int		nla_total_size(int payload);
+extern int		nla_padlen(int payload);
+
+/* Attribute parsing */
+extern int		nla_type(const struct nlattr *);
+extern void *		nla_data(const struct nlattr *);
+extern int		nla_len(const struct nlattr *);
+extern int		nla_ok(const struct nlattr *, int);
+extern struct nlattr *	nla_next(const struct nlattr *, int *);
+extern int		nla_parse(struct nlattr **, int, struct nlattr *,
+				  int, struct nla_policy *);
+extern int		nla_validate(struct nlattr *, int, int,
+				     struct nla_policy *);
+extern struct nlattr *	nla_find(struct nlattr *, int, int);
+
+/* Helper Functions */
+extern int		nla_memcpy(void *, struct nlattr *, int);
+extern size_t		nla_strlcpy(char *, const struct nlattr *, size_t);
+extern int		nla_memcmp(const struct nlattr *, const void *, size_t);
+extern int		nla_strcmp(const struct nlattr *, const char *);
+
+/* Unspecific attribute */
+extern struct nlattr *	nla_reserve(struct nl_msg *, int, int);
+extern int		nla_put(struct nl_msg *, int, int, const void *);
+extern int		nla_put_data(struct nl_msg *, int, struct nl_data *);
+extern int		nla_put_addr(struct nl_msg *, int, struct nl_addr *);
+
+/* Integer attribute */
+extern uint8_t		nla_get_u8(struct nlattr *);
+extern int		nla_put_u8(struct nl_msg *, int, uint8_t);
+extern uint16_t		nla_get_u16(struct nlattr *);
+extern int		nla_put_u16(struct nl_msg *, int, uint16_t);
+extern uint32_t		nla_get_u32(struct nlattr *);
+extern int		nla_put_u32(struct nl_msg *, int, uint32_t);
+extern uint64_t		nla_get_u64(struct nlattr *);
+extern int		nla_put_u64(struct nl_msg *, int, uint64_t);
+
+/* String attribute */
+extern char *		nla_get_string(struct nlattr *);
+extern char *		nla_strdup(struct nlattr *);
+extern int		nla_put_string(struct nl_msg *, int, const char *);
+
+/* Flag attribute */
+extern int		nla_get_flag(struct nlattr *);
+extern int		nla_put_flag(struct nl_msg *, int);
+
+/* Msec attribute */
+extern unsigned long	nla_get_msecs(struct nlattr *);
+extern int		nla_put_msecs(struct nl_msg *, int, unsigned long);
+
+/* Attribute nesting */
+extern int		nla_put_nested(struct nl_msg *, int, struct nl_msg *);
+extern struct nlattr *	nla_nest_start(struct nl_msg *, int);
+extern int		nla_nest_end(struct nl_msg *, struct nlattr *);
+extern int		nla_parse_nested(struct nlattr **, int, struct nlattr *,
+					 struct nla_policy *);
+
+/**
+ * @name Attribute Construction (Exception Based)
+ * @{
+ */
+
+/**
+ * @ingroup attr
+ * Add unspecific attribute to netlink message.
+ * @arg msg		Netlink message.
+ * @arg attrtype	Attribute type.
+ * @arg attrlen		Length of attribute payload.
+ * @arg data		Head of attribute payload.
+ */
+#define NLA_PUT(msg, attrtype, attrlen, data) \
+	do { \
+		if (nla_put(msg, attrtype, attrlen, data) < 0) \
+			goto nla_put_failure; \
+	} while(0)
+
+/**
+ * @ingroup attr
+ * Add atomic type attribute to netlink message.
+ * @arg msg		Netlink message.
+ * @arg type		Atomic type.
+ * @arg attrtype	Attribute type.
+ * @arg value		Head of attribute payload.
+ */
+#define NLA_PUT_TYPE(msg, type, attrtype, value) \
+	do { \
+		type __tmp = value; \
+		NLA_PUT(msg, attrtype, sizeof(type), &__tmp); \
+	} while(0)
+
+/**
+ * Add 8 bit integer attribute to netlink message.
+ * @arg msg		Netlink message.
+ * @arg attrtype	Attribute type.
+ * @arg value		Numeric value.
+ */
+#define NLA_PUT_U8(msg, attrtype, value) \
+	NLA_PUT_TYPE(msg, uint8_t, attrtype, value)
+
+/**
+ * Add 16 bit integer attribute to netlink message.
+ * @arg msg		Netlink message.
+ * @arg attrtype	Attribute type.
+ * @arg value		Numeric value.
+ */
+#define NLA_PUT_U16(msg, attrtype, value) \
+	NLA_PUT_TYPE(msg, uint16_t, attrtype, value)
+
+/**
+ * Add 32 bit integer attribute to netlink message.
+ * @arg msg		Netlink message.
+ * @arg attrtype	Attribute type.
+ * @arg value		Numeric value.
+ */
+#define NLA_PUT_U32(msg, attrtype, value) \
+	NLA_PUT_TYPE(msg, uint32_t, attrtype, value)
+
+/**
+ * Add 64 bit integer attribute to netlink message.
+ * @arg msg		Netlink message.
+ * @arg attrtype	Attribute type.
+ * @arg value		Numeric value.
+ */
+#define NLA_PUT_U64(msg, attrtype, value) \
+	NLA_PUT_TYPE(msg, uint64_t, attrtype, value)
+
+/**
+ * Add string attribute to netlink message.
+ * @arg msg		Netlink message.
+ * @arg attrtype	Attribute type.
+ * @arg value		NUL terminated character string.
+ */
+#define NLA_PUT_STRING(msg, attrtype, value) \
+	NLA_PUT(msg, attrtype, strlen(value) + 1, value)
+
+/**
+ * Add flag attribute to netlink message.
+ * @arg msg		Netlink message.
+ * @arg attrtype	Attribute type.
+ */
+#define NLA_PUT_FLAG(msg, attrtype) \
+	NLA_PUT(msg, attrtype, 0, NULL)
+
+/**
+ * Add msecs attribute to netlink message.
+ * @arg msg		Netlink message.
+ * @arg attrtype	Attribute type.
+ * @arg msecs		Numeric value in micro seconds.
+ */
+#define NLA_PUT_MSECS(msg, attrtype, msecs) \
+	NLA_PUT_U64(msg, attrtype, msecs)
+
+/**
+ * Add address attribute to netlink message.
+ * @arg msg		Netlink message.
+ * @arg attrtype	Attribute type.
+ * @arg addr		Abstract address object.
+ */
+#define NLA_PUT_ADDR(msg, attrtype, addr) \
+	NLA_PUT(msg, attrtype, nl_addr_get_len(addr), \
+		nl_addr_get_binary_addr(addr))
+
+/**
+ * Add abstract data attribute to netlink message.
+ * @arg msg		Netlink message.
+ * @arg attrtype	Attribute type.
+ * @arg data		Abstract data object.
+ */
+#define NLA_PUT_DATA(msg, attrtype, data) \
+	NLA_PUT(msg, attrtype, nl_data_get_size(data), \
+		nl_data_get(data))
+
+/** @} */
+
+/**
+ * @name Iterators
+ * @{
+ */
+
+/**
+ * @ingroup attr
+ * Iterate over a stream of attributes
+ * @arg pos	loop counter, set to current attribute
+ * @arg head	head of attribute stream
+ * @arg len	length of attribute stream
+ * @arg rem	initialized to len, holds bytes currently remaining in stream
+ */
+#define nla_for_each_attr(pos, head, len, rem) \
+	for (pos = head, rem = len; \
+	     nla_ok(pos, rem); \
+	     pos = nla_next(pos, &(rem)))
+
+/**
+ * @ingroup attr
+ * Iterate over a stream of nested attributes
+ * @arg pos	loop counter, set to current attribute
+ * @arg nla	attribute containing the nested attributes
+ * @arg rem	initialized to len, holds bytes currently remaining in stream
+ */
+#define nla_for_each_nested(pos, nla, rem) \
+	for (pos = nla_data(nla), rem = nla_len(nla); \
+	     nla_ok(pos, rem); \
+	     pos = nla_next(pos, &(rem)))
+
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/cache-api.h libnl/include/netlink/cache-api.h
--- libnl_kk/include/netlink/cache-api.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/cache-api.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,199 @@
+/*
+ * netlink/cache-api.h		Caching API
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2006 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_CACHE_API_H_
+#define NETLINK_CACHE_API_H_
+
+#include <netlink/netlink.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @ingroup cache
+ * @defgroup cache_api Cache Implementation
+ * @brief
+ *
+ * @par 1) Cache Definition
+ * @code
+ * struct nl_cache_ops my_cache_ops = {
+ * 	.co_name		= "route/link",
+ * 	.co_protocol		= NETLINK_ROUTE,
+ * 	.co_hdrsize		= sizeof(struct ifinfomsg),
+ * 	.co_obj_ops		= &my_obj_ops,
+ * };
+ * @endcode
+ *
+ * @par 2) 
+ * @code
+ * // The simplest way to fill a cache is by providing a request-update
+ * // function which must trigger a complete dump on the kernel-side of
+ * // whatever the cache covers.
+ * static int my_request_update(struct nl_cache *cache,
+ * 				struct nl_sock *socket)
+ * {
+ * 	// In this example, we request a full dump of the interface table
+ * 	return nl_rtgen_request(socket, RTM_GETLINK, AF_UNSPEC, NLM_F_DUMP);
+ * }
+ *
+ * // The resulting netlink messages sent back will be fed into a message
+ * // parser one at a time. The message parser has to extract all relevant
+ * // information from the message and create an object reflecting the
+ * // contents of the message and pass it on to the parser callback function
+ * // provide which will add the object to the cache.
+ * static int my_msg_parser(struct nl_cache_ops *ops, struct sockaddr_nl *who,
+ * 			    struct nlmsghdr *nlh, struct nl_parser_param *pp)
+ * {
+ * 	struct my_obj *obj;
+ *
+ * 	obj = my_obj_alloc();
+ * 	obj->ce_msgtype = nlh->nlmsg_type;
+ *
+ * 	// Parse the netlink message and continue creating the object.
+ *
+ * 	err = pp->pp_cb((struct nl_object *) obj, pp);
+ * 	if (err < 0)
+ * 		goto errout;
+ * }
+ *
+ * struct nl_cache_ops my_cache_ops = {
+ * 	...
+ * 	.co_request_update	= my_request_update,
+ * 	.co_msg_parser		= my_msg_parser,
+ * };
+ * @endcode
+ *
+ * @par 3) Notification based Updates
+ * @code
+ * // Caches can be kept up-to-date based on notifications if the kernel
+ * // sends out notifications whenever an object is added/removed/changed.
+ * //
+ * // It is trivial to support this, first a list of groups needs to be
+ * // defined which are required to join in order to receive all necessary
+ * // notifications. The groups are separated by address family to support
+ * // the common situation where a separate group is used for each address
+ * // family. If there is only one group, simply specify AF_UNSPEC.
+ * static struct nl_af_group addr_groups[] = {
+ * 	{ AF_INET,	RTNLGRP_IPV4_IFADDR },
+ * 	{ AF_INET6,	RTNLGRP_IPV6_IFADDR },
+ * 	{ END_OF_GROUP_LIST },
+ * };
+ *
+ * // In order for the caching system to know the meaning of each message
+ * // type it requires a table which maps each supported message type to
+ * // a cache action, e.g. RTM_NEWADDR means address has been added or
+ * // updated, RTM_DELADDR means address has been removed.
+ * static struct nl_cache_ops rtnl_addr_ops = {
+ * 	...
+ * 	.co_msgtypes		= {
+ * 					{ RTM_NEWADDR, NL_ACT_NEW, "new" },
+ * 					{ RTM_DELADDR, NL_ACT_DEL, "del" },
+ * 					{ RTM_GETADDR, NL_ACT_GET, "get" },
+ * 					END_OF_MSGTYPES_LIST,
+ * 				},
+ * 	.co_groups		= addr_groups,
+ * };
+ *
+ * // It is now possible to keep the cache up-to-date using the cache manager.
+ * @endcode
+ * @{
+ */
+
+enum {
+	NL_ACT_UNSPEC,
+	NL_ACT_NEW,
+	NL_ACT_DEL,
+	NL_ACT_GET,
+	NL_ACT_SET,
+	NL_ACT_CHANGE,
+	__NL_ACT_MAX,
+};
+
+#define NL_ACT_MAX (__NL_ACT_MAX - 1)
+
+#define END_OF_MSGTYPES_LIST	{ -1, -1, NULL }
+
+/**
+ * Message type to cache action association
+ */
+struct nl_msgtype
+{
+	/** Netlink message type */
+	int			mt_id;
+
+	/** Cache action to take */
+	int			mt_act;
+
+	/** Name of operation for human-readable printing */
+	char *			mt_name;
+};
+
+/**
+ * Address family to netlink group association
+ */
+struct nl_af_group
+{
+	/** Address family */
+	int			ag_family;
+
+	/** Netlink group identifier */
+	int			ag_group;
+};
+
+#define END_OF_GROUP_LIST AF_UNSPEC, 0
+
+struct nl_parser_param
+{
+	int             (*pp_cb)(struct nl_object *, struct nl_parser_param *);
+	void *            pp_arg;
+};
+
+/**
+ * Cache Operations
+ */
+struct nl_cache_ops
+{
+	char  *			co_name;
+
+	int			co_hdrsize;
+	int			co_protocol;
+	struct nl_af_group *	co_groups;
+	
+	/**
+	 * Called whenever an update of the cache is required. Must send
+	 * a request message to the kernel requesting a complete dump.
+	 */
+	int   (*co_request_update)(struct nl_cache *, struct nl_sock *);
+
+	/**
+	 * Called whenever a message was received that needs to be parsed.
+	 * Must parse the message and call the paser callback function
+	 * (nl_parser_param) provided via the argument.
+	 */
+	int   (*co_msg_parser)(struct nl_cache_ops *, struct sockaddr_nl *,
+			       struct nlmsghdr *, struct nl_parser_param *);
+
+	struct nl_object_ops *	co_obj_ops;
+
+	struct nl_cache_ops *co_next;
+	struct nl_cache *co_major_cache;
+	struct genl_ops *	co_genl;
+	struct nl_msgtype	co_msgtypes[];
+};
+
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/cache.h libnl/include/netlink/cache.h
--- libnl_kk/include/netlink/cache.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/cache.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,129 @@
+/*
+ * netlink/cache.h		Caching Module
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_CACHE_H_
+#define NETLINK_CACHE_H_
+
+#include <netlink/netlink.h>
+#include <netlink/msg.h>
+#include <netlink/utils.h>
+#include <netlink/object.h>
+#include <netlink/cache-api.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct nl_cache;
+
+typedef void (*change_func_t)(struct nl_cache *, struct nl_object *, int, void *);
+
+/* Access Functions */
+extern int			nl_cache_nitems(struct nl_cache *);
+extern int			nl_cache_nitems_filter(struct nl_cache *,
+						       struct nl_object *);
+extern struct nl_cache_ops *	nl_cache_get_ops(struct nl_cache *);
+extern struct nl_object *	nl_cache_get_first(struct nl_cache *);
+extern struct nl_object *	nl_cache_get_last(struct nl_cache *);
+extern struct nl_object *	nl_cache_get_next(struct nl_object *);
+extern struct nl_object *	nl_cache_get_prev(struct nl_object *);
+
+extern struct nl_cache *	nl_cache_alloc(struct nl_cache_ops *);
+extern int			nl_cache_alloc_and_fill(struct nl_cache_ops *,
+							struct nl_sock *,
+							struct nl_cache **);
+extern int			nl_cache_alloc_name(const char *,
+						    struct nl_cache **);
+extern struct nl_cache *	nl_cache_subset(struct nl_cache *,
+						struct nl_object *);
+extern void			nl_cache_clear(struct nl_cache *);
+extern void			nl_cache_free(struct nl_cache *);
+
+/* Cache modification */
+extern int			nl_cache_add(struct nl_cache *,
+					     struct nl_object *);
+extern int			nl_cache_parse_and_add(struct nl_cache *,
+						       struct nl_msg *);
+extern void			nl_cache_remove(struct nl_object *);
+extern int			nl_cache_refill(struct nl_sock *,
+						struct nl_cache *);
+extern int			nl_cache_pickup(struct nl_sock *,
+						struct nl_cache *);
+extern int			nl_cache_resync(struct nl_sock *,
+						struct nl_cache *,
+						change_func_t,
+						void *);
+extern int			nl_cache_include(struct nl_cache *,
+						 struct nl_object *,
+						 change_func_t,
+						 void *);
+
+/* General */
+extern int			nl_cache_is_empty(struct nl_cache *);
+extern void			nl_cache_mark_all(struct nl_cache *);
+
+/* Dumping */
+extern void			nl_cache_dump(struct nl_cache *,
+					      struct nl_dump_params *);
+extern void			nl_cache_dump_filter(struct nl_cache *,
+						     struct nl_dump_params *,
+						     struct nl_object *);
+
+/* Iterators */
+extern void			nl_cache_foreach(struct nl_cache *,
+						 void (*cb)(struct nl_object *,
+							    void *),
+						 void *arg);
+extern void			nl_cache_foreach_filter(struct nl_cache *,
+							struct nl_object *,
+							void (*cb)(struct
+								   nl_object *,
+								   void *),
+							void *arg);
+
+/* --- cache management --- */
+
+/* Cache type management */
+extern struct nl_cache_ops *	nl_cache_ops_lookup(const char *);
+extern struct nl_cache_ops *	nl_cache_ops_associate(int, int);
+extern struct nl_msgtype *	nl_msgtype_lookup(struct nl_cache_ops *, int);
+extern void			nl_cache_ops_foreach(void (*cb)(struct nl_cache_ops *, void *), void *);
+extern int			nl_cache_mngt_register(struct nl_cache_ops *);
+extern int			nl_cache_mngt_unregister(struct nl_cache_ops *);
+
+/* Global cache provisioning/requiring */
+extern void			nl_cache_mngt_provide(struct nl_cache *);
+extern void			nl_cache_mngt_unprovide(struct nl_cache *);
+extern struct nl_cache *	nl_cache_mngt_require(const char *);
+
+struct nl_cache_mngr;
+
+#define NL_AUTO_PROVIDE		1
+
+extern int			nl_cache_mngr_alloc(struct nl_sock *,
+						    int, int,
+						    struct nl_cache_mngr **);
+extern int			nl_cache_mngr_add(struct nl_cache_mngr *,
+						  const char *,
+						  change_func_t,
+						  void *,
+						  struct nl_cache **);
+extern int			nl_cache_mngr_get_fd(struct nl_cache_mngr *);
+extern int			nl_cache_mngr_poll(struct nl_cache_mngr *,
+						   int);
+extern int			nl_cache_mngr_data_ready(struct nl_cache_mngr *);
+extern void			nl_cache_mngr_free(struct nl_cache_mngr *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/cli/addr.h libnl/include/netlink/cli/addr.h
--- libnl_kk/include/netlink/cli/addr.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/cli/addr.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,32 @@
+/*
+ * netlink/cli/addr.h    CLI Address Helpers
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2008-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef __NETLINK_CLI_ADDR_H_
+#define __NETLINK_CLI_ADDR_H_
+
+#include <netlink/route/addr.h>
+
+#define nl_cli_addr_alloc_cache(sk) \
+		nl_cli_alloc_cache((sk), "address", rtnl_addr_alloc_cache)
+
+extern struct rtnl_addr *nl_cli_addr_alloc(void);
+
+extern void nl_cli_addr_parse_family(struct rtnl_addr *, char *);
+extern void nl_cli_addr_parse_local(struct rtnl_addr *, char *);
+extern void nl_cli_addr_parse_dev(struct rtnl_addr *, struct nl_cache *,char *);
+extern void nl_cli_addr_parse_label(struct rtnl_addr *, char *);
+extern void nl_cli_addr_parse_peer(struct rtnl_addr *, char *);
+extern void nl_cli_addr_parse_scope(struct rtnl_addr *, char *);
+extern void nl_cli_addr_parse_broadcast(struct rtnl_addr *, char *);
+extern void nl_cli_addr_parse_preferred(struct rtnl_addr *, char *);
+extern void nl_cli_addr_parse_valid(struct rtnl_addr *, char *);
+
+#endif
diff -uNr libnl_kk/include/netlink/cli/ct.h libnl/include/netlink/cli/ct.h
--- libnl_kk/include/netlink/cli/ct.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/cli/ct.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,34 @@
+/*
+ * netlink/cli/ct.h	CLI Conntrack Helper
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2008-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef __NETLINK_CLI_CT_H_
+#define __NETLINK_CLI_CT_H_
+
+#include <netlink/netfilter/ct.h>
+#include <linux/netfilter/nf_conntrack_common.h>
+
+extern struct nfnl_ct *nl_cli_ct_alloc(void);
+extern struct nl_cache *nl_cli_ct_alloc_cache(struct nl_sock *);
+
+extern void nl_cli_ct_parse_family(struct nfnl_ct *, char *);
+extern void nl_cli_ct_parse_protocol(struct nfnl_ct *, char *);
+extern void nl_cli_ct_parse_mark(struct nfnl_ct *, char *);
+extern void nl_cli_ct_parse_timeout(struct nfnl_ct *, char *);
+extern void nl_cli_ct_parse_id(struct nfnl_ct *, char *);
+extern void nl_cli_ct_parse_use(struct nfnl_ct *, char *);
+extern void nl_cli_ct_parse_src(struct nfnl_ct *, int, char *);
+extern void nl_cli_ct_parse_dst(struct nfnl_ct *, int, char *);
+extern void nl_cli_ct_parse_src_port(struct nfnl_ct *, int, char *);
+extern void nl_cli_ct_parse_dst_port(struct nfnl_ct *, int, char *);
+extern void nl_cli_ct_parse_tcp_state(struct nfnl_ct *, char *);
+extern void nl_cli_ct_parse_status(struct nfnl_ct *, char *);
+
+#endif
diff -uNr libnl_kk/include/netlink/cli/link.h libnl/include/netlink/cli/link.h
--- libnl_kk/include/netlink/cli/link.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/cli/link.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,30 @@
+/*
+ * netlink/cli/link.h     CLI Link Helpers
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2008-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef __NETLINK_CLI_LINK_H_
+#define __NETLINK_CLI_LINK_H_
+
+#include <netlink/route/link.h>
+#include <netlink/cli/utils.h>
+
+#define nl_cli_link_alloc_cache(sk) \
+		nl_cli_alloc_cache((sk), "link", rtnl_link_alloc_cache)
+
+extern struct rtnl_link *nl_cli_link_alloc(void);
+
+extern void nl_cli_link_parse_family(struct rtnl_link *, char *);
+extern void nl_cli_link_parse_name(struct rtnl_link *, char *);
+extern void nl_cli_link_parse_mtu(struct rtnl_link *, char *);
+extern void nl_cli_link_parse_ifindex(struct rtnl_link *, char *);
+extern void nl_cli_link_parse_txqlen(struct rtnl_link *, char *);
+extern void nl_cli_link_parse_weight(struct rtnl_link *, char *);
+
+#endif
diff -uNr libnl_kk/include/netlink/cli/neigh.h libnl/include/netlink/cli/neigh.h
--- libnl_kk/include/netlink/cli/neigh.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/cli/neigh.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,27 @@
+/*
+ * netlink/cli/neighbour.h     CLI Neighbour Helpers
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2008-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef __NETLINK_CLI_NEIGH_H_
+#define __NETLINK_CLI_NEIGH_H_
+
+#include <netlink/route/neighbour.h>
+
+#define nl_cli_neigh_alloc_cache(sk) \
+		nl_cli_alloc_cache((sk), "neighbour", rtnl_neigh_alloc_cache)
+
+extern struct rtnl_neigh *nl_cli_neigh_alloc(void);
+extern void nl_cli_neigh_parse_dst(struct rtnl_neigh *, char *);
+extern void nl_cli_neigh_parse_lladdr(struct rtnl_neigh *, char *);
+extern void nl_cli_neigh_parse_dev(struct rtnl_neigh *, struct nl_cache *, char *);
+extern void nl_cli_neigh_parse_family(struct rtnl_neigh *, char *);
+extern void nl_cli_neigh_parse_state(struct rtnl_neigh *, char *);
+
+#endif
diff -uNr libnl_kk/include/netlink/cli/qdisc.h libnl/include/netlink/cli/qdisc.h
--- libnl_kk/include/netlink/cli/qdisc.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/cli/qdisc.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,28 @@
+/*
+ * netlink/cli/qdisc.h     CLI QDisc Helpers
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2008-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef __NETLINK_CLI_QDISC_H_
+#define __NETLINK_CLI_QDISC_H_
+
+#include <netlink/route/qdisc.h>
+
+#define nl_cli_qdisc_alloc_cache(sk) \
+		nl_cli_alloc_cache((sk), "queueing disciplines", \
+				   rtnl_qdisc_alloc_cache)
+
+extern struct rtnl_qdisc *nl_cli_qdisc_alloc(void);
+
+extern void nl_cli_qdisc_parse_dev(struct rtnl_qdisc *, struct nl_cache *, char *);
+extern void nl_cli_qdisc_parse_parent(struct rtnl_qdisc *, char *);
+extern void nl_cli_qdisc_parse_handle(struct rtnl_qdisc *, char *);
+extern void nl_cli_qdisc_parse_kind(struct rtnl_qdisc *, char *);
+
+#endif
diff -uNr libnl_kk/include/netlink/cli/route.h libnl/include/netlink/cli/route.h
--- libnl_kk/include/netlink/cli/route.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/cli/route.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,34 @@
+/*
+ * netlink/cli//route.h     CLI Route Helpers
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2008-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef __NETLINK_CLI_ROUTE_H_
+#define __NETLINK_CLI_ROUTE_H_
+
+#include <netlink/route/route.h>
+
+extern struct rtnl_route *nl_cli_route_alloc(void);
+
+extern struct nl_cache *nl_cli_route_alloc_cache(struct nl_sock *, int);
+
+extern void	nl_cli_route_parse_family(struct rtnl_route *, char *);
+extern void	nl_cli_route_parse_dst(struct rtnl_route *, char *);
+extern void	nl_cli_route_parse_src(struct rtnl_route *, char *);
+extern void	nl_cli_route_parse_pref_src(struct rtnl_route *, char *);
+extern void	nl_cli_route_parse_metric(struct rtnl_route *, char *);
+extern void	nl_cli_route_parse_nexthop(struct rtnl_route *, char *, struct nl_cache *);
+extern void	nl_cli_route_parse_table(struct rtnl_route *, char *);
+extern void	nl_cli_route_parse_prio(struct rtnl_route *, char *);
+extern void	nl_cli_route_parse_scope(struct rtnl_route *, char *);
+extern void	nl_cli_route_parse_protocol(struct rtnl_route *, char *);
+extern void	nl_cli_route_parse_type(struct rtnl_route *, char *);
+extern void	nl_cli_route_parse_iif(struct rtnl_route *, char *, struct nl_cache *);
+
+#endif
diff -uNr libnl_kk/include/netlink/cli/rule.h libnl/include/netlink/cli/rule.h
--- libnl_kk/include/netlink/cli/rule.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/cli/rule.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,21 @@
+/*
+ * netlink/cli/rule.h     CLI Routing Rule Helpers
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2008-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef __NETLINK_CLI_RULE_H_
+#define __NETLINK_CLI_RULE_H_
+
+#include <netlink/route/rule.h>
+
+extern struct rtnl_rule *nl_cli_rule_alloc(void);
+extern struct nl_cache *nl_cli_rule_alloc_cache(struct nl_sock *);
+extern void nl_cli_rule_parse_family(struct rtnl_rule *, char *);
+
+#endif
diff -uNr libnl_kk/include/netlink/cli/utils.h libnl/include/netlink/cli/utils.h
--- libnl_kk/include/netlink/cli/utils.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/cli/utils.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,80 @@
+/*
+ * src/utils.h		Utilities
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef __NETLINK_CLI_UTILS_H_
+#define __NETLINK_CLI_UTILS_H_
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <limits.h>
+#include <inttypes.h>
+#include <errno.h>
+#include <stdint.h>
+#include <ctype.h>
+#include <getopt.h>
+#include <dlfcn.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+
+#include <netlink/netlink.h>
+#include <netlink/utils.h>
+#include <netlink/addr.h>
+#include <netlink/list.h>
+#include <netlink/route/rtnl.h>
+#include <netlink/route/link.h>
+#include <netlink/route/addr.h>
+#include <netlink/route/neighbour.h>
+#include <netlink/route/neightbl.h>
+#include <netlink/route/route.h>
+#include <netlink/route/rule.h>
+#include <netlink/route/qdisc.h>
+#include <netlink/route/class.h>
+#include <netlink/route/classifier.h>
+#include <netlink/route/cls/ematch.h>
+#include <netlink/fib_lookup/lookup.h>
+#include <netlink/fib_lookup/request.h>
+#include <netlink/genl/genl.h>
+#include <netlink/genl/ctrl.h>
+#include <netlink/genl/mngt.h>
+#include <netlink/netfilter/ct.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef __init
+#define __init __attribute__((constructor))
+#endif
+
+#ifndef __exit
+#define __exit __attribute__((destructor))
+#endif
+
+extern uint32_t		nl_cli_parse_u32(const char *);
+extern void		nl_cli_print_version(void);
+extern void		nl_cli_fatal(int, const char *, ...);
+extern struct nl_addr *	nl_cli_addr_parse(const char *, int);
+extern int		nl_cli_connect(struct nl_sock *, int);
+extern struct nl_sock *	nl_cli_alloc_socket(void);
+extern int		nl_cli_parse_dumptype(const char *);
+extern int		nl_cli_confirm(struct nl_object *,
+				       struct nl_dump_params *, int);
+
+extern struct nl_cache *nl_cli_alloc_cache(struct nl_sock *, const char *,
+			     int (*ac)(struct nl_sock *, struct nl_cache **));
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/data.h libnl/include/netlink/data.h
--- libnl_kk/include/netlink/data.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/data.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,41 @@
+/*
+ * netlink/data.h	Abstract Data
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_DATA_H_
+#define NETLINK_DATA_H_
+
+#include <netlink/netlink.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct nl_data;
+
+/* General */
+extern struct nl_data *	nl_data_alloc(void *, size_t);
+extern struct nl_data * nl_data_alloc_attr(struct nlattr *);
+extern struct nl_data *	nl_data_clone(struct nl_data *);
+extern int		nl_data_append(struct nl_data *, void *, size_t);
+extern void		nl_data_free(struct nl_data *);
+
+/* Access Functions */
+extern void *		nl_data_get(struct nl_data *);
+extern size_t		nl_data_get_size(struct nl_data *);
+
+/* Misc */
+extern int		nl_data_cmp(struct nl_data *, struct nl_data *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/errno.h libnl/include/netlink/errno.h
--- libnl_kk/include/netlink/errno.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/errno.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,60 @@
+/*
+ * netlink/errno.h		Error Numbers
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_ERRNO_H_
+#define NETLINK_ERRNO_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define NLE_SUCCESS		0
+#define NLE_FAILURE		1
+#define NLE_INTR		2
+#define NLE_BAD_SOCK		3
+#define NLE_AGAIN		4
+#define NLE_NOMEM		5
+#define NLE_EXIST		6
+#define NLE_INVAL		7
+#define NLE_RANGE		8
+#define NLE_MSGSIZE		9
+#define NLE_OPNOTSUPP		10
+#define NLE_AF_NOSUPPORT	11
+#define NLE_OBJ_NOTFOUND	12
+#define NLE_NOATTR		13
+#define NLE_MISSING_ATTR	14
+#define NLE_AF_MISMATCH		15
+#define NLE_SEQ_MISMATCH	16
+#define NLE_MSG_OVERFLOW	17
+#define NLE_MSG_TRUNC		18
+#define NLE_NOADDR		19
+#define NLE_SRCRT_NOSUPPORT	20
+#define NLE_MSG_TOOSHORT	21
+#define NLE_MSGTYPE_NOSUPPORT	22
+#define NLE_OBJ_MISMATCH	23
+#define NLE_NOCACHE		24
+#define NLE_BUSY		25
+#define NLE_PROTO_MISMATCH	26
+#define NLE_NOACCESS		27
+#define NLE_PERM		28
+#define NLE_PKTLOC_FILE		29
+
+#define NLE_MAX			NLE_PKTLOC_FILE
+
+extern const char *	nl_geterror(int);
+extern void		nl_perror(int, const char *);
+extern int		nl_syserr2nlerr(int);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/fib_lookup/lookup.h libnl/include/netlink/fib_lookup/lookup.h
--- libnl_kk/include/netlink/fib_lookup/lookup.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/fib_lookup/lookup.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,42 @@
+/*
+ * netlink/fib_lookup/fib_lookup.h	FIB Lookup
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_FIB_LOOKUP_H_
+#define NETLINK_FIB_LOOKUP_H_
+
+#include <netlink/netlink.h>
+#include <netlink/cache.h>
+#include <netlink/addr.h>
+#include <netlink/fib_lookup/request.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct flnl_result;
+
+extern struct flnl_result *	flnl_result_alloc(void);
+extern void			flnl_result_put(struct flnl_result *);
+
+extern struct nl_cache *	flnl_result_alloc_cache(void);
+
+extern int			flnl_lookup_build_request(struct flnl_request *,
+							  int,
+							  struct nl_msg **);
+extern int			flnl_lookup(struct nl_sock *,
+					    struct flnl_request *,
+					    struct nl_cache *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/fib_lookup/request.h libnl/include/netlink/fib_lookup/request.h
--- libnl_kk/include/netlink/fib_lookup/request.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/fib_lookup/request.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,51 @@
+/*
+ * netlink/fib_lookup/request.h		FIB Lookup Request	
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2006 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_FIB_LOOKUP_REQUEST_H_
+#define NETLINK_FIB_LOOKUP_REQUEST_H_
+
+#include <netlink/netlink.h>
+#include <netlink/addr.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct flnl_request;
+
+#define REQUEST_CAST(ptr)	((struct flnl_request *) (ptr))
+
+extern struct flnl_request *	flnl_request_alloc(void);
+
+extern void			flnl_request_set_fwmark(struct flnl_request *,
+							uint64_t);
+extern uint64_t			flnl_request_get_fwmark(struct flnl_request *);
+extern void			flnl_request_set_tos(struct flnl_request *,
+						     int);
+extern int			flnl_request_get_tos(struct flnl_request *);
+extern void			flnl_request_set_scope(struct flnl_request *,
+						       int);
+extern int			flnl_request_get_scope(struct flnl_request *);
+extern void			flnl_request_set_table(struct flnl_request *,
+						       int);
+extern int			flnl_request_get_table(struct flnl_request *);
+extern int			flnl_request_set_addr(struct flnl_request *,
+						      struct nl_addr *);
+extern struct nl_addr *		flnl_request_get_addr(struct flnl_request *);
+
+extern int			flnl_request_cmp(struct flnl_request *,
+						 struct flnl_request *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/genl/ctrl.h libnl/include/netlink/genl/ctrl.h
--- libnl_kk/include/netlink/genl/ctrl.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/genl/ctrl.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,37 @@
+/*
+ * netlink/genl/ctrl.h		Generic Netlink Controller
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_GENL_CTRL_H_
+#define NETLINK_GENL_CTRL_H_
+
+#include <netlink/netlink.h>
+#include <netlink/cache.h>
+#include <netlink/addr.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct genl_family;
+
+extern int			genl_ctrl_alloc_cache(struct nl_sock *,
+						      struct nl_cache **);
+extern struct genl_family *	genl_ctrl_search(struct nl_cache *, int);
+extern struct genl_family *	genl_ctrl_search_by_name(struct nl_cache *,
+							 const char *);
+extern int			genl_ctrl_resolve(struct nl_sock *,
+						  const char *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/genl/family.h libnl/include/netlink/genl/family.h
--- libnl_kk/include/netlink/genl/family.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/genl/family.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,50 @@
+/*
+ * netlink/genl/family.h	Generic Netlink Family
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2006 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_GENL_FAMILY_H_
+#define NETLINK_GENL_FAMILY_H_
+
+#include <netlink/netlink.h>
+#include <netlink/cache.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct genl_family;
+
+extern struct genl_family *	genl_family_alloc(void);
+extern void			genl_family_put(struct genl_family *);
+
+extern unsigned int		genl_family_get_id(struct genl_family *);
+extern void			genl_family_set_id(struct genl_family *,
+						   unsigned int);
+extern char *			genl_family_get_name(struct genl_family *);
+extern void			genl_family_set_name(struct genl_family *,
+						     const char *name);
+extern uint8_t			genl_family_get_version(struct genl_family *);
+extern void			genl_family_set_version(struct genl_family *,
+							uint8_t);
+extern uint32_t			genl_family_get_hdrsize(struct genl_family *);
+extern void			genl_family_set_hdrsize(struct genl_family *,
+							uint32_t);
+extern uint32_t			genl_family_get_maxattr(struct genl_family *);
+extern void			genl_family_set_maxattr(struct genl_family *,
+							uint32_t);
+
+extern int			genl_family_add_op(struct genl_family *,
+						   int, int);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/genl/genl.h libnl/include/netlink/genl/genl.h
--- libnl_kk/include/netlink/genl/genl.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/genl/genl.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,47 @@
+/*
+ * netlink/genl/genl.h		Generic Netlink
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_GENL_H_
+#define NETLINK_GENL_H_
+
+#include <netlink/netlink.h>
+#include <netlink/msg.h>
+#include <netlink/attr.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern int		genl_connect(struct nl_sock *);
+
+extern int		genl_send_simple(struct nl_sock *, int, int,
+					 int, int);
+
+extern void *		genlmsg_put(struct nl_msg *, uint32_t, uint32_t,
+				    int, int, int, uint8_t, uint8_t);
+
+extern int		genlmsg_valid_hdr(struct nlmsghdr *, int);
+extern int		genlmsg_validate(struct nlmsghdr *, int, int,
+					 struct nla_policy *);
+extern int		genlmsg_parse(struct nlmsghdr *, int, struct nlattr **,
+				      int, struct nla_policy *);
+extern void *		genlmsg_data(const struct genlmsghdr *);
+extern int		genlmsg_len(const struct genlmsghdr *);
+extern struct nlattr *	genlmsg_attrdata(const struct genlmsghdr *, int);
+extern int		genlmsg_attrlen(const struct genlmsghdr *, int);
+
+extern char *		genl_op2name(int, int, char *, size_t);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/genl/mngt.h libnl/include/netlink/genl/mngt.h
--- libnl_kk/include/netlink/genl/mngt.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/genl/mngt.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,87 @@
+/*
+ * netlink/genl/mngt.h		Generic Netlink Management
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2006 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_GENL_MNGT_H_
+#define NETLINK_GENL_MNGT_H_
+
+#include <netlink/netlink.h>
+#include <netlink/attr.h>
+#include <netlink/list.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct nl_cache_ops;
+
+struct genl_info
+{
+	struct sockaddr_nl *    who;
+	struct nlmsghdr *       nlh;
+	struct genlmsghdr *     genlhdr;
+	void *                  userhdr;
+	struct nlattr **        attrs;
+};
+
+/**
+ * @ingroup genl_mngt
+ * Generic Netlink Command
+ */
+struct genl_cmd
+{
+	/** Unique command identifier */
+	int			c_id;
+
+	/** Name/description of command */
+	char *			c_name;
+
+	/**
+	 * Maximum attribute identifier, must be provided if
+	 * a message parser is available.
+	 */
+	int			c_maxattr;
+
+	int		      (*c_msg_parser)(struct nl_cache_ops *,
+					      struct genl_cmd *,
+					      struct genl_info *, void *);
+
+	/**
+	 * Attribute validation policy (optional)
+	 */
+	struct nla_policy *	c_attr_policy;
+};
+
+/**
+ * @ingroup genl_mngt
+ * Generic Netlink Operations
+ */
+struct genl_ops
+{
+	int			o_family;
+	int			o_id;
+	char *			o_name;
+	struct nl_cache_ops *	o_cache_ops;
+	struct genl_cmd	*	o_cmds;
+	int			o_ncmds;
+
+	/* linked list of all genl cache operations */
+	struct nl_list_head	o_list;
+};
+
+
+extern int		genl_register(struct nl_cache_ops *);
+extern void		genl_unregister(struct nl_cache_ops *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/.gitignore libnl/include/netlink/.gitignore
--- libnl_kk/include/netlink/.gitignore	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/.gitignore	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1 @@
+version.h
diff -uNr libnl_kk/include/netlink/handlers.h libnl/include/netlink/handlers.h
--- libnl_kk/include/netlink/handlers.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/handlers.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,144 @@
+/*
+ * netlink/handlers.c	default netlink message handlers
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2006 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_HANDLERS_H_
+#define NETLINK_HANDLERS_H_
+
+#include <stdio.h>
+#include <stdint.h>
+#include <sys/types.h>
+#include <netlink/netlink-compat.h>
+#include <netlink/netlink-kernel.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct nl_cb;
+struct nl_sock;
+struct nl_msg;
+struct ucred;
+
+/**
+ * @name Callback Typedefs
+ * @{
+ */
+
+/**
+ * nl_recvmsgs() callback for message processing customization
+ * @ingroup cb
+ * @arg msg		netlink message being processed
+ * @arg arg		argument passwd on through caller
+ */
+typedef int (*nl_recvmsg_msg_cb_t)(struct nl_msg *msg, void *arg);
+
+/**
+ * nl_recvmsgs() callback for error message processing customization
+ * @ingroup cb
+ * @arg nla		netlink address of the peer
+ * @arg nlerr		netlink error message being processed
+ * @arg arg		argument passed on through caller
+ */
+typedef int (*nl_recvmsg_err_cb_t)(struct sockaddr_nl *nla,
+				   struct nlmsgerr *nlerr, void *arg);
+
+/** @} */
+
+/**
+ * Callback actions
+ * @ingroup cb
+ */
+enum nl_cb_action {
+	/** Proceed with wathever would come next */
+	NL_OK,
+	/** Skip this message */
+	NL_SKIP,
+	/** Stop parsing altogether and discard remaining messages */
+	NL_STOP,
+};
+
+/**
+ * Callback kinds
+ * @ingroup cb
+ */
+enum nl_cb_kind {
+	/** Default handlers (quiet) */
+	NL_CB_DEFAULT,
+	/** Verbose default handlers (error messages printed) */
+	NL_CB_VERBOSE,
+	/** Debug handlers for debugging */
+	NL_CB_DEBUG,
+	/** Customized handler specified by the user */
+	NL_CB_CUSTOM,
+	__NL_CB_KIND_MAX,
+};
+
+#define NL_CB_KIND_MAX (__NL_CB_KIND_MAX - 1)
+
+/**
+ * Callback types
+ * @ingroup cb
+ */
+enum nl_cb_type {
+	/** Message is valid */
+	NL_CB_VALID,
+	/** Last message in a series of multi part messages received */
+	NL_CB_FINISH,
+	/** Report received that data was lost */
+	NL_CB_OVERRUN,
+	/** Message wants to be skipped */
+	NL_CB_SKIPPED,
+	/** Message is an acknowledge */
+	NL_CB_ACK,
+	/** Called for every message received */
+	NL_CB_MSG_IN,
+	/** Called for every message sent out except for nl_sendto() */
+	NL_CB_MSG_OUT,
+	/** Message is malformed and invalid */
+	NL_CB_INVALID,
+	/** Called instead of internal sequence number checking */
+	NL_CB_SEQ_CHECK,
+	/** Sending of an acknowledge message has been requested */
+	NL_CB_SEND_ACK,
+	__NL_CB_TYPE_MAX,
+};
+
+#define NL_CB_TYPE_MAX (__NL_CB_TYPE_MAX - 1)
+
+extern struct nl_cb *	nl_cb_alloc(enum nl_cb_kind);
+extern struct nl_cb *	nl_cb_clone(struct nl_cb *);
+extern struct nl_cb *	nl_cb_get(struct nl_cb *);
+extern void		nl_cb_put(struct nl_cb *);
+
+extern int  nl_cb_set(struct nl_cb *, enum nl_cb_type, enum nl_cb_kind,
+		      nl_recvmsg_msg_cb_t, void *);
+extern int  nl_cb_set_all(struct nl_cb *, enum nl_cb_kind,
+			  nl_recvmsg_msg_cb_t, void *);
+extern int  nl_cb_err(struct nl_cb *, enum nl_cb_kind, nl_recvmsg_err_cb_t,
+		      void *);
+
+extern void nl_cb_overwrite_recvmsgs(struct nl_cb *,
+				     int (*func)(struct nl_sock *,
+						 struct nl_cb *));
+extern void nl_cb_overwrite_recv(struct nl_cb *,
+				 int (*func)(struct nl_sock *,
+					     struct sockaddr_nl *,
+					     unsigned char **,
+					     struct ucred **));
+extern void nl_cb_overwrite_send(struct nl_cb *,
+				 int (*func)(struct nl_sock *,
+					     struct nl_msg *));
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/list.h libnl/include/netlink/list.h
--- libnl_kk/include/netlink/list.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/list.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,93 @@
+/*
+ * netlink/list.h	Netlink List Utilities
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2006 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_LIST_H_
+#define NETLINK_LIST_H_
+
+struct nl_list_head
+{
+	struct nl_list_head *	next;
+	struct nl_list_head *	prev;
+};
+
+static inline void NL_INIT_LIST_HEAD(struct nl_list_head *list)
+{
+	list->next = list;
+	list->prev = list;
+}
+
+static inline void __nl_list_add(struct nl_list_head *obj,
+				 struct nl_list_head *prev,
+				 struct nl_list_head *next)
+{
+	prev->next = obj;
+	obj->prev = prev;
+	next->prev = obj;
+	obj->next = next;
+}
+
+static inline void nl_list_add_tail(struct nl_list_head *obj,
+				    struct nl_list_head *head)
+{
+	__nl_list_add(obj, head->prev, head);
+}
+
+static inline void nl_list_add_head(struct nl_list_head *obj,
+				    struct nl_list_head *head)
+{
+	__nl_list_add(obj, head, head->next);
+}
+
+static inline void nl_list_del(struct nl_list_head *obj)
+{
+	obj->next->prev = obj->prev;
+	obj->prev->next = obj->next;
+}
+
+static inline int nl_list_empty(struct nl_list_head *head)
+{
+	return head->next == head;
+}
+
+#define nl_container_of(ptr, type, member) ({			\
+        const typeof( ((type *)0)->member ) *__mptr = (ptr);	\
+        (type *)( (char *)__mptr - ((size_t) &((type *)0)->member));})
+
+#define nl_list_entry(ptr, type, member) \
+	nl_container_of(ptr, type, member)
+
+#define nl_list_at_tail(pos, head, member) \
+	((pos)->member.next == (head))
+
+#define nl_list_at_head(pos, head, member) \
+	((pos)->member.prev == (head))
+
+#define NL_LIST_HEAD(name) \
+	struct nl_list_head name = { &(name), &(name) }
+
+#define nl_list_first_entry(head, type, member)			\
+	nl_list_entry((head)->next, type, member)
+
+#define nl_list_for_each_entry(pos, head, member)				\
+	for (pos = nl_list_entry((head)->next, typeof(*pos), member);	\
+	     &(pos)->member != (head); 	\
+	     (pos) = nl_list_entry((pos)->member.next, typeof(*(pos)), member))
+
+#define nl_list_for_each_entry_safe(pos, n, head, member)			\
+	for (pos = nl_list_entry((head)->next, typeof(*pos), member),	\
+		n = nl_list_entry(pos->member.next, typeof(*pos), member);	\
+	     &(pos)->member != (head); 					\
+	     pos = n, n = nl_list_entry(n->member.next, typeof(*n), member))
+
+#define nl_init_list_head(head) \
+	do { (head)->next = (head); (head)->prev = (head); } while (0)
+
+#endif
diff -uNr libnl_kk/include/netlink/msg.h libnl/include/netlink/msg.h
--- libnl_kk/include/netlink/msg.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/msg.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,144 @@
+/*
+ * netlink/msg.c		Netlink Messages Interface
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2006 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_MSG_H_
+#define NETLINK_MSG_H_
+
+#include <netlink/netlink.h>
+#include <netlink/object.h>
+#include <netlink/attr.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define NL_DONTPAD	0
+
+/**
+ * @ingroup msg
+ * @brief
+ * Will cause the netlink pid to be set to the pid assigned to
+ * the netlink handle (socket) just before sending the message off.
+ * @note Requires the use of nl_send_auto_complete()!
+ */
+#define NL_AUTO_PID	0
+
+/**
+ * @ingroup msg
+ * @brief
+ * May be used to refer to a sequence number which should be
+ * automatically set just before sending the message off.
+ * @note Requires the use of nl_send_auto_complete()!
+ */
+#define NL_AUTO_SEQ	0
+
+struct nl_msg;
+struct nl_tree;
+struct ucred;
+
+/* size calculations */
+extern int		  nlmsg_msg_size(int);
+extern int		  nlmsg_total_size(int);
+extern int		  nlmsg_padlen(int);
+
+/* payload access */
+extern void *		  nlmsg_data(const struct nlmsghdr *);
+extern int		  nlmsg_len(const struct nlmsghdr *);
+extern void *		  nlmsg_tail(const struct nlmsghdr *);
+
+/* attribute access */
+extern struct nlattr *	  nlmsg_attrdata(const struct nlmsghdr *, int);
+extern int		  nlmsg_attrlen(const struct nlmsghdr *, int);
+
+/* message parsing */
+extern int		  nlmsg_valid_hdr(const struct nlmsghdr *, int);
+extern int		  nlmsg_ok(const struct nlmsghdr *, int);
+extern struct nlmsghdr *  nlmsg_next(struct nlmsghdr *, int *);
+extern int		  nlmsg_parse(struct nlmsghdr *, int, struct nlattr **,
+				      int, struct nla_policy *);
+extern struct nlattr *	  nlmsg_find_attr(struct nlmsghdr *, int, int);
+extern int		  nlmsg_validate(struct nlmsghdr *, int, int,
+					 struct nla_policy *);
+
+extern struct nl_msg *	  nlmsg_alloc(void);
+extern struct nl_msg *	  nlmsg_alloc_size(size_t);
+extern struct nl_msg *	  nlmsg_alloc_simple(int, int);
+extern void		  nlmsg_set_default_size(size_t);
+extern struct nl_msg *	  nlmsg_inherit(struct nlmsghdr *);
+extern struct nl_msg *	  nlmsg_convert(struct nlmsghdr *);
+extern void *		  nlmsg_reserve(struct nl_msg *, size_t, int);
+extern int		  nlmsg_append(struct nl_msg *, void *, size_t, int);
+extern int		  nlmsg_expand(struct nl_msg *, size_t);
+
+extern struct nlmsghdr *  nlmsg_put(struct nl_msg *, uint32_t, uint32_t,
+				    int, int, int);
+extern struct nlmsghdr *  nlmsg_hdr(struct nl_msg *);
+extern void		  nlmsg_get(struct nl_msg *);
+extern void		  nlmsg_free(struct nl_msg *);
+
+/* attribute modification */
+extern void		  nlmsg_set_proto(struct nl_msg *, int);
+extern int		  nlmsg_get_proto(struct nl_msg *);
+extern size_t		  nlmsg_get_max_size(struct nl_msg *);
+extern void		  nlmsg_set_src(struct nl_msg *, struct sockaddr_nl *);
+extern struct sockaddr_nl *nlmsg_get_src(struct nl_msg *);
+extern void		  nlmsg_set_dst(struct nl_msg *, struct sockaddr_nl *);
+extern struct sockaddr_nl *nlmsg_get_dst(struct nl_msg *);
+extern void		  nlmsg_set_creds(struct nl_msg *, struct ucred *);
+extern struct ucred *	  nlmsg_get_creds(struct nl_msg *);
+
+extern char *		  nl_nlmsgtype2str(int, char *, size_t);
+extern int		  nl_str2nlmsgtype(const char *);
+
+extern char *		  nl_nlmsg_flags2str(int, char *, size_t);
+
+extern int		  nl_msg_parse(struct nl_msg *,
+				       void (*cb)(struct nl_object *, void *),
+				       void *);
+
+extern void		nl_msg_dump(struct nl_msg *, FILE *);
+
+/**
+ * @name Iterators
+ * @{
+ */
+
+/**
+ * @ingroup msg
+ * Iterate over a stream of attributes in a message
+ * @arg pos	loop counter, set to current attribute
+ * @arg nlh	netlink message header
+ * @arg hdrlen	length of family header
+ * @arg rem	initialized to len, holds bytes currently remaining in stream
+ */
+#define nlmsg_for_each_attr(pos, nlh, hdrlen, rem) \
+	nla_for_each_attr(pos, nlmsg_attrdata(nlh, hdrlen), \
+			  nlmsg_attrlen(nlh, hdrlen), rem)
+
+/**
+ * Iterate over a stream of messages
+ * @arg pos	loop counter, set to current message
+ * @arg head	head of message stream
+ * @arg len	length of message stream
+ * @arg rem	initialized to len, holds bytes currently remaining in stream
+ */
+#define nlmsg_for_each_msg(pos, head, len, rem) \
+	for (pos = head, rem = len; \
+	     nlmsg_ok(pos, rem); \
+	     pos = nlmsg_next(pos, &(rem)))
+
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/netfilter/ct.h libnl/include/netlink/netfilter/ct.h
--- libnl_kk/include/netlink/netfilter/ct.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/netfilter/ct.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,126 @@
+/*
+ * netlink/netfilter/ct.h	Conntrack
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ * Copyright (c) 2007 Philip Craig <philipc@snapgear.com>
+ * Copyright (c) 2007 Secure Computing Corporation
+ */
+
+#ifndef NETLINK_CT_H_
+#define NETLINK_CT_H_
+
+#include <netlink/netlink.h>
+#include <netlink/addr.h>
+#include <netlink/cache.h>
+#include <netlink/msg.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct nfnl_ct;
+
+extern struct nl_object_ops ct_obj_ops;
+
+extern struct nfnl_ct *	nfnl_ct_alloc(void);
+extern int	nfnl_ct_alloc_cache(struct nl_sock *, struct nl_cache **);
+
+extern int	nfnlmsg_ct_group(struct nlmsghdr *);
+extern int	nfnlmsg_ct_parse(struct nlmsghdr *, struct nfnl_ct **);
+
+extern void	nfnl_ct_get(struct nfnl_ct *);
+extern void	nfnl_ct_put(struct nfnl_ct *);
+
+extern int	nfnl_ct_dump_request(struct nl_sock *);
+
+extern int	nfnl_ct_build_add_request(const struct nfnl_ct *, int,
+					  struct nl_msg **);
+extern int	nfnl_ct_add(struct nl_sock *, const struct nfnl_ct *, int);
+
+extern int	nfnl_ct_build_delete_request(const struct nfnl_ct *, int,
+					     struct nl_msg **);
+extern int	nfnl_ct_delete(struct nl_sock *, const struct nfnl_ct *, int);
+
+extern int	nfnl_ct_build_query_request(const struct nfnl_ct *, int,
+					    struct nl_msg **);
+extern int	nfnl_ct_query(struct nl_sock *, const struct nfnl_ct *, int);
+
+extern void	nfnl_ct_set_family(struct nfnl_ct *, uint8_t);
+extern uint8_t	nfnl_ct_get_family(const struct nfnl_ct *);
+
+extern void	nfnl_ct_set_proto(struct nfnl_ct *, uint8_t);
+extern int	nfnl_ct_test_proto(const struct nfnl_ct *);
+extern uint8_t	nfnl_ct_get_proto(const struct nfnl_ct *);
+
+extern void	nfnl_ct_set_tcp_state(struct nfnl_ct *, uint8_t);
+extern int	nfnl_ct_test_tcp_state(const struct nfnl_ct *);
+extern uint8_t	nfnl_ct_get_tcp_state(const struct nfnl_ct *);
+extern char *	nfnl_ct_tcp_state2str(uint8_t, char *, size_t);
+extern int	nfnl_ct_str2tcp_state(const char *name);
+
+extern void	nfnl_ct_set_status(struct nfnl_ct *, uint32_t);
+extern void	nfnl_ct_unset_status(struct nfnl_ct *, uint32_t);
+extern uint32_t	nfnl_ct_get_status(const struct nfnl_ct *);
+extern char *	nfnl_ct_status2str(int, char *, size_t);
+extern int	nfnl_ct_str2status(const char *);
+
+extern void	nfnl_ct_set_timeout(struct nfnl_ct *, uint32_t);
+extern int	nfnl_ct_test_timeout(const struct nfnl_ct *);
+extern uint32_t	nfnl_ct_get_timeout(const struct nfnl_ct *);
+
+extern void	nfnl_ct_set_mark(struct nfnl_ct *, uint32_t);
+extern int	nfnl_ct_test_mark(const struct nfnl_ct *);
+extern uint32_t	nfnl_ct_get_mark(const struct nfnl_ct *);
+
+extern void	nfnl_ct_set_use(struct nfnl_ct *, uint32_t);
+extern int	nfnl_ct_test_use(const struct nfnl_ct *);
+extern uint32_t	nfnl_ct_get_use(const struct nfnl_ct *);
+
+extern void	nfnl_ct_set_id(struct nfnl_ct *, uint32_t);
+extern int	nfnl_ct_test_id(const struct nfnl_ct *);
+extern uint32_t	nfnl_ct_get_id(const struct nfnl_ct *);
+
+extern int	nfnl_ct_set_src(struct nfnl_ct *, int, struct nl_addr *);
+extern struct nl_addr *	nfnl_ct_get_src(const struct nfnl_ct *, int);
+
+extern int	nfnl_ct_set_dst(struct nfnl_ct *, int, struct nl_addr *);
+extern struct nl_addr *	nfnl_ct_get_dst(const struct nfnl_ct *, int);
+
+extern void	nfnl_ct_set_src_port(struct nfnl_ct *, int, uint16_t);
+extern int	nfnl_ct_test_src_port(const struct nfnl_ct *, int);
+extern uint16_t	nfnl_ct_get_src_port(const struct nfnl_ct *, int);
+
+extern void	nfnl_ct_set_dst_port(struct nfnl_ct *, int, uint16_t);
+extern int	nfnl_ct_test_dst_port(const struct nfnl_ct *, int);
+extern uint16_t	nfnl_ct_get_dst_port(const struct nfnl_ct *, int);
+
+extern void	nfnl_ct_set_icmp_id(struct nfnl_ct *, int, uint16_t);
+extern int	nfnl_ct_test_icmp_id(const struct nfnl_ct *, int);
+extern uint16_t	nfnl_ct_get_icmp_id(const struct nfnl_ct *, int);
+
+extern void	nfnl_ct_set_icmp_type(struct nfnl_ct *, int, uint8_t);
+extern int	nfnl_ct_test_icmp_type(const struct nfnl_ct *, int);
+extern uint8_t	nfnl_ct_get_icmp_type(const struct nfnl_ct *, int);
+
+extern void	nfnl_ct_set_icmp_code(struct nfnl_ct *, int, uint8_t);
+extern int	nfnl_ct_test_icmp_code(const struct nfnl_ct *, int);
+extern uint8_t	nfnl_ct_get_icmp_code(const struct nfnl_ct *, int);
+
+extern void	nfnl_ct_set_packets(struct nfnl_ct *, int, uint64_t);
+extern int	nfnl_ct_test_packets(const struct nfnl_ct *, int);
+extern uint64_t	nfnl_ct_get_packets(const struct nfnl_ct *,int);
+
+extern void	nfnl_ct_set_bytes(struct nfnl_ct *, int, uint64_t);
+extern int	nfnl_ct_test_bytes(const struct nfnl_ct *, int);
+extern uint64_t	nfnl_ct_get_bytes(const struct nfnl_ct *, int);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/netfilter/log.h libnl/include/netlink/netfilter/log.h
--- libnl_kk/include/netlink/netfilter/log.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/netfilter/log.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,109 @@
+/*
+ * netlink/netfilter/log.h	Netfilter Log
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2006 Thomas Graf <tgraf@suug.ch>
+ * Copyright (c) 2007 Philip Craig <philipc@snapgear.com>
+ * Copyright (c) 2007 Secure Computing Corporation
+ * Copyright (c) 2008 Patrick McHardy <kaber@trash.net>
+ */
+
+#ifndef NETLINK_LOG_H_
+#define NETLINK_LOG_H_
+
+#include <netlink/netlink.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct nl_sock;
+struct nlmsghdr;
+struct nfnl_log;
+
+extern struct nl_object_ops log_obj_ops;
+
+enum nfnl_log_copy_mode {
+	NFNL_LOG_COPY_NONE,
+	NFNL_LOG_COPY_META,
+	NFNL_LOG_COPY_PACKET,
+};
+
+enum nfnl_log_flags {
+	NFNL_LOG_FLAG_SEQ		= 0x1,
+	NFNL_LOG_FLAG_SEQ_GLOBAL	= 0x2,
+};
+
+/* General */
+extern struct nfnl_log *	nfnl_log_alloc(void);
+extern int			nfnlmsg_log_parse(struct nlmsghdr *,
+						  struct nfnl_log **);
+
+extern void			nfnl_log_get(struct nfnl_log *);
+extern void			nfnl_log_put(struct nfnl_log *);
+
+/* Attributes */
+extern void			nfnl_log_set_group(struct nfnl_log *, uint16_t);
+extern int			nfnl_log_test_group(const struct nfnl_log *);
+extern uint16_t			nfnl_log_get_group(const struct nfnl_log *);
+
+extern void			nfnl_log_set_copy_mode(struct nfnl_log *,
+						       enum nfnl_log_copy_mode);
+extern int			nfnl_log_test_copy_mode(const struct nfnl_log *);
+extern enum nfnl_log_copy_mode	nfnl_log_get_copy_mode(const struct nfnl_log *);
+
+extern char *			nfnl_log_copy_mode2str(enum nfnl_log_copy_mode,
+						       char *, size_t);
+extern enum nfnl_log_copy_mode	nfnl_log_str2copy_mode(const char *);
+
+extern void			nfnl_log_set_copy_range(struct nfnl_log *, uint32_t);
+extern int			nfnl_log_test_copy_range(const struct nfnl_log *);
+extern uint32_t			nfnl_log_get_copy_range(const struct nfnl_log *);
+
+extern void			nfnl_log_set_flush_timeout(struct nfnl_log *, uint32_t);
+extern int			nfnl_log_test_flush_timeout(const struct nfnl_log *);
+extern uint32_t			nfnl_log_get_flush_timeout(const struct nfnl_log *);
+
+extern void			nfnl_log_set_alloc_size(struct nfnl_log *, uint32_t);
+extern int			nfnl_log_test_alloc_size(const struct nfnl_log *);
+extern uint32_t			nfnl_log_get_alloc_size(const struct nfnl_log *);
+
+extern void			nfnl_log_set_queue_threshold(struct nfnl_log *, uint32_t);
+extern int			nfnl_log_test_queue_threshold(const struct nfnl_log *);
+extern uint32_t			nfnl_log_get_queue_threshold(const struct nfnl_log *);
+
+extern void			nfnl_log_set_flags(struct nfnl_log *, unsigned int);
+extern void			nfnl_log_unset_flags(struct nfnl_log *, unsigned int);
+extern unsigned int		nfnl_log_get_flags(const struct nfnl_log *);
+
+extern char *			nfnl_log_flags2str(unsigned int, char *, size_t);
+extern unsigned int		nfnl_log_str2flags(const char *);
+
+extern int	nfnl_log_build_pf_bind(uint8_t, struct nl_msg **);
+extern int	nfnl_log_pf_bind(struct nl_sock *, uint8_t);
+
+extern int	nfnl_log_build_pf_unbind(uint8_t, struct nl_msg **);
+extern int	nfnl_log_pf_unbind(struct nl_sock *, uint8_t);
+
+extern int	nfnl_log_build_create_request(const struct nfnl_log *,
+					      struct nl_msg **);
+extern int	nfnl_log_create(struct nl_sock *, const struct nfnl_log *);
+
+extern int	nfnl_log_build_change_request(const struct nfnl_log *,
+					      struct nl_msg **);
+extern int	nfnl_log_change(struct nl_sock *, const struct nfnl_log *);
+
+extern int	nfnl_log_build_delete_request(const struct nfnl_log *,
+					      struct nl_msg **);
+extern int	nfnl_log_delete(struct nl_sock *, const struct nfnl_log *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff -uNr libnl_kk/include/netlink/netfilter/log_msg.h libnl/include/netlink/netfilter/log_msg.h
--- libnl_kk/include/netlink/netfilter/log_msg.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/netfilter/log_msg.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,98 @@
+/*
+ * netlink/netfilter/log_msg.h	Netfilter Log Message
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ * Copyright (c) 2007 Philip Craig <philipc@snapgear.com>
+ * Copyright (c) 2007 Secure Computing Corporation
+ * Copyright (c) 2008 Patrick McHardy <kaber@trash.net>
+ */
+
+#ifndef NETLINK_LOG_MSG_H_
+#define NETLINK_LOG_MSG_H_
+
+#include <netlink/netlink.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct nlmsghdr;
+struct nfnl_log_msg;
+
+extern struct nl_object_ops log_msg_obj_ops;
+
+/* General */
+extern struct nfnl_log_msg *nfnl_log_msg_alloc(void);
+extern int		nfnlmsg_log_msg_parse(struct nlmsghdr *,
+					      struct nfnl_log_msg **);
+
+extern void		nfnl_log_msg_get(struct nfnl_log_msg *);
+extern void		nfnl_log_msg_put(struct nfnl_log_msg *);
+
+extern void		nfnl_log_msg_set_family(struct nfnl_log_msg *, uint8_t);
+extern uint8_t		nfnl_log_msg_get_family(const struct nfnl_log_msg *);
+
+extern void		nfnl_log_msg_set_hwproto(struct nfnl_log_msg *, uint16_t);
+extern int		nfnl_log_msg_test_hwproto(const struct nfnl_log_msg *);
+extern uint16_t		nfnl_log_msg_get_hwproto(const struct nfnl_log_msg *);
+
+extern void		nfnl_log_msg_set_hook(struct nfnl_log_msg *, uint8_t);
+extern int		nfnl_log_msg_test_hook(const struct nfnl_log_msg *);
+extern uint8_t		nfnl_log_msg_get_hook(const struct nfnl_log_msg *);
+
+extern void		nfnl_log_msg_set_mark(struct nfnl_log_msg *, uint32_t);
+extern int		nfnl_log_msg_test_mark(const struct nfnl_log_msg *);
+extern uint32_t		nfnl_log_msg_get_mark(const struct nfnl_log_msg *);
+
+extern void		nfnl_log_msg_set_timestamp(struct nfnl_log_msg *,
+					       struct timeval *);
+extern const struct timeval *nfnl_log_msg_get_timestamp(const struct nfnl_log_msg *);
+
+extern void		nfnl_log_msg_set_indev(struct nfnl_log_msg *, uint32_t);
+extern uint32_t		nfnl_log_msg_get_indev(const struct nfnl_log_msg *);
+
+extern void		nfnl_log_msg_set_outdev(struct nfnl_log_msg *, uint32_t);
+extern uint32_t		nfnl_log_msg_get_outdev(const struct nfnl_log_msg *);
+
+extern void		nfnl_log_msg_set_physindev(struct nfnl_log_msg *, uint32_t);
+extern uint32_t		nfnl_log_msg_get_physindev(const struct nfnl_log_msg *);
+
+extern void		nfnl_log_msg_set_physoutdev(struct nfnl_log_msg *, uint32_t);
+extern uint32_t		nfnl_log_msg_get_physoutdev(const struct nfnl_log_msg *);
+
+extern void		nfnl_log_msg_set_hwaddr(struct nfnl_log_msg *, uint8_t *, int);
+extern const uint8_t *	nfnl_log_msg_get_hwaddr(const struct nfnl_log_msg *, int *);
+
+extern int		nfnl_log_msg_set_payload(struct nfnl_log_msg *, uint8_t *, int);
+extern const void *	nfnl_log_msg_get_payload(const struct nfnl_log_msg *, int *);
+
+extern int		nfnl_log_msg_set_prefix(struct nfnl_log_msg *, void *);
+extern const char *	nfnl_log_msg_get_prefix(const struct nfnl_log_msg *);
+
+extern void		nfnl_log_msg_set_uid(struct nfnl_log_msg *, uint32_t);
+extern int		nfnl_log_msg_test_uid(const struct nfnl_log_msg *);
+extern uint32_t		nfnl_log_msg_get_uid(const struct nfnl_log_msg *);
+
+extern void		nfnl_log_msg_set_gid(struct nfnl_log_msg *, uint32_t);
+extern int		nfnl_log_msg_test_gid(const struct nfnl_log_msg *);
+extern uint32_t		nfnl_log_msg_get_gid(const struct nfnl_log_msg *);
+
+extern void		nfnl_log_msg_set_seq(struct nfnl_log_msg *, uint32_t);
+extern int		nfnl_log_msg_test_seq(const struct nfnl_log_msg *);
+extern uint32_t		nfnl_log_msg_get_seq(const struct nfnl_log_msg *);
+
+extern void		nfnl_log_msg_set_seq_global(struct nfnl_log_msg *, uint32_t);
+extern int		nfnl_log_msg_test_seq_global(const struct nfnl_log_msg *);
+extern uint32_t		nfnl_log_msg_get_seq_global(const struct nfnl_log_msg *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff -uNr libnl_kk/include/netlink/netfilter/netfilter.h libnl/include/netlink/netfilter/netfilter.h
--- libnl_kk/include/netlink/netfilter/netfilter.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/netfilter/netfilter.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,31 @@
+/*
+ * netlink/netfilter/netfilter.h	Netfilter generic functions
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2008 Patrick McHardy <kaber@trash.net>
+ */
+
+#ifndef NETLINK_NETFILTER_H_
+#define NETLINK_NETFILTER_H_
+
+#include <netlink/netlink.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern char *			nfnl_verdict2str(unsigned int, char *, size_t);
+extern unsigned int		nfnl_str2verdict(const char *);
+
+extern char *			nfnl_inet_hook2str(unsigned int, char *, size_t);
+extern unsigned int		nfnl_str2inet_hook(const char *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/netfilter/nfnl.h libnl/include/netlink/netfilter/nfnl.h
--- libnl_kk/include/netlink/netfilter/nfnl.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/netfilter/nfnl.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,44 @@
+/*
+ * netlink/nfnl/nfnl.h		Netfilter Netlink
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ * Copyright (c) 2007 Philip Craig <philipc@snapgear.com>
+ * Copyright (c) 2007 Secure Computing Corporation
+ */
+
+#ifndef NETLINK_NFNL_H_
+#define NETLINK_NFNL_H_
+
+#include <netlink/netlink.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define NFNL_HDRLEN NLMSG_ALIGN(sizeof(struct nfgenmsg))
+#define NFNLMSG_TYPE(subsys, subtype) (((subsys) << 8) | (subtype))
+
+extern int		nfnl_connect(struct nl_sock *);
+
+extern uint8_t		nfnlmsg_subsys(struct nlmsghdr *);
+extern uint8_t		nfnlmsg_subtype(struct nlmsghdr *);
+extern uint8_t		nfnlmsg_family(struct nlmsghdr *);
+extern uint16_t		nfnlmsg_res_id(struct nlmsghdr *);
+
+extern int		nfnl_send_simple(struct nl_sock *, uint8_t, uint8_t,
+					 int, uint8_t, uint16_t);
+extern struct nl_msg *	nfnlmsg_alloc_simple(uint8_t, uint8_t, int,
+					     uint8_t, uint16_t);
+extern int		nfnlmsg_put(struct nl_msg *, uint32_t, uint32_t,
+				    uint8_t, uint8_t, int, uint8_t, uint16_t);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/netfilter/queue.h libnl/include/netlink/netfilter/queue.h
--- libnl_kk/include/netlink/netfilter/queue.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/netfilter/queue.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,90 @@
+/*
+ * netlink/netfilter/queue.h	Netfilter Queue
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2007, 2008 Patrick McHardy <kaber@trash.net>
+ */
+
+#ifndef NETLINK_QUEUE_H_
+#define NETLINK_QUEUE_H_
+
+#include <netlink/netlink.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct nl_sock;
+struct nlmsghdr;
+struct nfnl_queue;
+
+extern struct nl_object_ops queue_obj_ops;
+
+enum nfnl_queue_copy_mode {
+	NFNL_QUEUE_COPY_NONE,
+	NFNL_QUEUE_COPY_META,
+	NFNL_QUEUE_COPY_PACKET,
+};
+
+/* General */
+extern struct nl_sock *		nfnl_queue_socket_alloc(void);
+
+extern struct nfnl_queue *	nfnl_queue_alloc(void);
+
+extern void			nfnl_queue_get(struct nfnl_queue *);
+extern void			nfnl_queue_put(struct nfnl_queue *);
+
+/* Attributes */
+extern void			nfnl_queue_set_group(struct nfnl_queue *, uint16_t);
+extern int			nfnl_queue_test_group(const struct nfnl_queue *);
+extern uint16_t			nfnl_queue_get_group(const struct nfnl_queue *);
+
+extern void			nfnl_queue_set_maxlen(struct nfnl_queue *, uint32_t);
+extern int			nfnl_queue_test_maxlen(const struct nfnl_queue *);
+extern uint32_t			nfnl_queue_get_maxlen(const struct nfnl_queue *);
+
+extern void			nfnl_queue_set_copy_mode(struct nfnl_queue *,
+							 enum nfnl_queue_copy_mode);
+extern int			nfnl_queue_test_copy_mode(const struct nfnl_queue *);
+extern enum nfnl_queue_copy_mode nfnl_queue_get_copy_mode(const struct nfnl_queue *);
+
+extern char *			nfnl_queue_copy_mode2str(enum nfnl_queue_copy_mode,
+							 char *, size_t);
+extern enum nfnl_queue_copy_mode nfnl_queue_str2copy_mode(const char *);
+
+extern void			nfnl_queue_set_copy_range(struct nfnl_queue *,
+							  uint32_t);
+extern int			nfnl_queue_test_copy_range(const struct nfnl_queue *);
+extern uint32_t			nfnl_queue_get_copy_range(const struct nfnl_queue *);
+
+extern int	nfnl_queue_build_pf_bind(uint8_t, struct nl_msg **);
+extern int	nfnl_queue_pf_bind(struct nl_sock *, uint8_t);
+
+extern int	nfnl_queue_build_pf_unbind(uint8_t, struct nl_msg **);
+extern int	nfnl_queue_pf_unbind(struct nl_sock *, uint8_t);
+
+extern int	nfnl_queue_build_create_request(const struct nfnl_queue *,
+						struct nl_msg **);
+extern int	nfnl_queue_create(struct nl_sock *,
+				  const struct nfnl_queue *);
+
+extern int	nfnl_queue_build_change_request(const struct nfnl_queue *,
+						struct nl_msg **);
+extern int	nfnl_queue_change(struct nl_sock *,
+				  const struct nfnl_queue *);
+
+extern int	nfnl_queue_build_delete_request(const struct nfnl_queue *,
+						struct nl_msg **);
+extern int	nfnl_queue_delete(struct nl_sock *,
+				  const struct nfnl_queue *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff -uNr libnl_kk/include/netlink/netfilter/queue_msg.h libnl/include/netlink/netfilter/queue_msg.h
--- libnl_kk/include/netlink/netfilter/queue_msg.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/netfilter/queue_msg.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,104 @@
+/*
+ * netlink/netfilter/queue_msg.h	Netfilter Queue Messages
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2007, 2008 Patrick McHardy <kaber@trash.net>
+ */
+
+#ifndef NETLINK_QUEUE_MSG_H_
+#define NETLINK_QUEUE_MSG_H_
+
+#include <netlink/netlink.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct nl_sock;
+struct nlmsghdr;
+struct nfnl_queue_msg;
+
+extern struct nl_object_ops queue_msg_obj_ops;
+
+/* General */
+extern struct nfnl_queue_msg *	nfnl_queue_msg_alloc(void);
+extern int			nfnlmsg_queue_msg_parse(struct nlmsghdr *,
+						struct nfnl_queue_msg **);
+
+extern void			nfnl_queue_msg_get(struct nfnl_queue_msg *);
+extern void			nfnl_queue_msg_put(struct nfnl_queue_msg *);
+
+extern void			nfnl_queue_msg_set_group(struct nfnl_queue_msg *, uint16_t);
+extern int			nfnl_queue_msg_test_group(const struct nfnl_queue_msg *);
+extern uint16_t			nfnl_queue_msg_get_group(const struct nfnl_queue_msg *);
+
+extern void			nfnl_queue_msg_set_family(struct nfnl_queue_msg *, uint8_t);
+extern int			nfnl_queue_msg_test_family(const struct nfnl_queue_msg *);
+extern uint8_t			nfnl_queue_msg_get_family(const struct nfnl_queue_msg *);
+
+extern void			nfnl_queue_msg_set_packetid(struct nfnl_queue_msg *, uint32_t);
+extern int			nfnl_queue_msg_test_packetid(const struct nfnl_queue_msg *);
+extern uint32_t			nfnl_queue_msg_get_packetid(const struct nfnl_queue_msg *);
+
+extern void			nfnl_queue_msg_set_hwproto(struct nfnl_queue_msg *, uint16_t);
+extern int			nfnl_queue_msg_test_hwproto(const struct nfnl_queue_msg *);
+extern uint16_t			nfnl_queue_msg_get_hwproto(const struct nfnl_queue_msg *);
+
+extern void			nfnl_queue_msg_set_hook(struct nfnl_queue_msg *, uint8_t);
+extern int			nfnl_queue_msg_test_hook(const struct nfnl_queue_msg *);
+extern uint8_t			nfnl_queue_msg_get_hook(const struct nfnl_queue_msg *);
+
+extern void			nfnl_queue_msg_set_mark(struct nfnl_queue_msg *, uint32_t);
+extern int			nfnl_queue_msg_test_mark(const struct nfnl_queue_msg *);
+extern uint32_t			nfnl_queue_msg_get_mark(const struct nfnl_queue_msg *);
+
+extern void			nfnl_queue_msg_set_timestamp(struct nfnl_queue_msg *,
+							      struct timeval *);
+extern int			nfnl_queue_msg_test_timestamp(const struct nfnl_queue_msg *);
+extern const struct timeval *	nfnl_queue_msg_get_timestamp(const struct nfnl_queue_msg *);
+
+extern void			nfnl_queue_msg_set_indev(struct nfnl_queue_msg *, uint32_t);
+extern int			nfnl_queue_msg_test_indev(const struct nfnl_queue_msg *);
+extern uint32_t			nfnl_queue_msg_get_indev(const struct nfnl_queue_msg *);
+
+extern void			nfnl_queue_msg_set_outdev(struct nfnl_queue_msg *, uint32_t);
+extern int			nfnl_queue_msg_test_outdev(const struct nfnl_queue_msg *);
+extern uint32_t			nfnl_queue_msg_get_outdev(const struct nfnl_queue_msg *);
+
+extern void			nfnl_queue_msg_set_physindev(struct nfnl_queue_msg *, uint32_t);
+extern int			nfnl_queue_msg_test_physindev(const struct nfnl_queue_msg *);
+extern uint32_t			nfnl_queue_msg_get_physindev(const struct nfnl_queue_msg *);
+
+extern void			nfnl_queue_msg_set_physoutdev(struct nfnl_queue_msg *, uint32_t);
+extern int			nfnl_queue_msg_test_physoutdev(const struct nfnl_queue_msg *);
+extern uint32_t			nfnl_queue_msg_get_physoutdev(const struct nfnl_queue_msg *);
+
+extern void			nfnl_queue_msg_set_hwaddr(struct nfnl_queue_msg *, uint8_t *, int);
+extern int			nfnl_queue_msg_test_hwaddr(const struct nfnl_queue_msg *);
+extern const uint8_t *		nfnl_queue_msg_get_hwaddr(const struct nfnl_queue_msg *, int *);
+
+extern int			nfnl_queue_msg_set_payload(struct nfnl_queue_msg *, uint8_t *, int);
+extern int			nfnl_queue_msg_test_payload(const struct nfnl_queue_msg *);
+extern const void *		nfnl_queue_msg_get_payload(const struct nfnl_queue_msg *, int *);
+
+extern void			nfnl_queue_msg_set_verdict(struct nfnl_queue_msg *,
+							   unsigned int);
+extern int			nfnl_queue_msg_test_verdict(const struct nfnl_queue_msg *);
+extern unsigned int		nfnl_queue_msg_get_verdict(const struct nfnl_queue_msg *);
+
+extern struct nl_msg *		nfnl_queue_msg_build_verdict(const struct nfnl_queue_msg *);
+extern int			nfnl_queue_msg_send_verdict(struct nl_sock *,
+							    const struct nfnl_queue_msg *);
+extern int			nfnl_queue_msg_send_verdict_payload(struct nl_sock *,
+						const struct nfnl_queue_msg *,
+						const void *, unsigned );
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff -uNr libnl_kk/include/netlink/netlink-compat.h libnl/include/netlink/netlink-compat.h
--- libnl_kk/include/netlink/netlink-compat.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/netlink-compat.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,50 @@
+/*
+ * netlink/netlink-compat.h	Netlink Compatability
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2006 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_COMPAT_H_
+#define NETLINK_COMPAT_H_
+
+#if !defined _LINUX_SOCKET_H && !defined _BITS_SOCKADDR_H
+typedef unsigned short  sa_family_t;
+#endif
+
+#ifndef IFNAMSIZ 
+/** Maximum length of a interface name */
+#define IFNAMSIZ 16
+#endif
+
+/* patch 2.4.x if_arp */
+#ifndef ARPHRD_INFINIBAND
+#define ARPHRD_INFINIBAND 32
+#endif
+
+/* patch 2.4.x eth header file */
+#ifndef ETH_P_MPLS_UC
+#define ETH_P_MPLS_UC  0x8847 
+#endif
+
+#ifndef ETH_P_MPLS_MC
+#define ETH_P_MPLS_MC   0x8848
+#endif
+
+#ifndef  ETH_P_EDP2
+#define ETH_P_EDP2      0x88A2
+#endif
+
+#ifndef ETH_P_HDLC
+#define ETH_P_HDLC      0x0019 
+#endif
+
+#ifndef AF_LLC
+#define AF_LLC		26
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/netlink.h libnl/include/netlink/netlink.h
--- libnl_kk/include/netlink/netlink.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/netlink.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,81 @@
+/*
+ * netlink/netlink.h		Netlink Interface
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2006 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_NETLINK_H_
+#define NETLINK_NETLINK_H_
+
+#include <stdio.h>
+#include <stdint.h>
+#include <string.h>
+#include <stdlib.h>
+#include <sys/poll.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <sys/time.h>
+#include <netdb.h>
+#include <netlink/netlink-compat.h>
+#include <linux/netlink.h>
+#include <linux/rtnetlink.h>
+#include <linux/genetlink.h>
+#include <linux/netfilter/nfnetlink.h>
+#include <netlink/version.h>
+#include <netlink/errno.h>
+#include <netlink/types.h>
+#include <netlink/handlers.h>
+#include <netlink/socket.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct ucred;
+
+extern int nl_debug;
+extern struct nl_dump_params nl_debug_dp;
+
+/* Connection Management */
+extern int			nl_connect(struct nl_sock *, int);
+extern void			nl_close(struct nl_sock *);
+
+/* Send */
+extern int			nl_sendto(struct nl_sock *, void *, size_t);
+extern int			nl_sendmsg(struct nl_sock *, struct nl_msg *,
+					   struct msghdr *);
+extern int			nl_send(struct nl_sock *, struct nl_msg *);
+extern int			nl_send_iovec(struct nl_sock *, struct nl_msg *,
+					      struct iovec *, unsigned);
+extern void			nl_auto_complete(struct nl_sock *,
+						      struct nl_msg *);
+extern int			nl_send_auto_complete(struct nl_sock *,
+						      struct nl_msg *);
+extern int			nl_send_simple(struct nl_sock *, int, int,
+					       void *, size_t);
+
+/* Receive */
+extern int			nl_recv(struct nl_sock *,
+					struct sockaddr_nl *, unsigned char **,
+					struct ucred **);
+
+extern int			nl_recvmsgs(struct nl_sock *, struct nl_cb *);
+
+extern int			nl_recvmsgs_default(struct nl_sock *);
+
+extern int			nl_wait_for_ack(struct nl_sock *);
+
+/* Netlink Family Translations */
+extern char *			nl_nlfamily2str(int, char *, size_t);
+extern int			nl_str2nlfamily(const char *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/netlink-kernel.h libnl/include/netlink/netlink-kernel.h
--- libnl_kk/include/netlink/netlink-kernel.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/netlink-kernel.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,196 @@
+#ifndef __LINUX_NETLINK_H
+#define __LINUX_NETLINK_H
+
+/**
+ * Netlink socket address
+ * @ingroup nl
+ */
+struct sockaddr_nl
+{
+	/** socket family (AF_NETLINK) */
+	sa_family_t     nl_family;
+
+	/** Padding (unused) */
+	unsigned short  nl_pad;
+
+	/** Unique process ID  */
+	uint32_t        nl_pid;
+
+	/** Multicast group subscriptions */
+	uint32_t        nl_groups;
+};
+
+/**
+ * Netlink message header
+ * @ingroup msg
+ */
+struct nlmsghdr
+{
+	/**
+	 * Length of message including header.
+	 */
+	uint32_t	nlmsg_len;
+
+	/**
+	 * Message type (content type)
+	 */
+	uint16_t	nlmsg_type;
+
+	/**
+	 * Message flags
+	 */
+	uint16_t	nlmsg_flags;
+
+	/**
+	 * Sequence number
+	 */
+	uint32_t	nlmsg_seq;
+
+	/**
+	 * Netlink PID of the proccess sending the message.
+	 */
+	uint32_t	nlmsg_pid;
+};
+
+/**
+ * @name Standard message flags
+ * @{
+ */
+
+/**
+ * Must be set on all request messages (typically from user space to
+ * kernel space).
+ * @ingroup msg
+ */
+#define NLM_F_REQUEST		1
+
+/**
+ * Indicates the message is part of a multipart message terminated
+ * by NLMSG_DONE.
+ */
+#define NLM_F_MULTI		2
+
+/**
+ * Request for an acknowledgment on success.
+ */
+#define NLM_F_ACK		4
+
+/**
+ * Echo this request
+ */
+#define NLM_F_ECHO		8
+
+/** @} */
+
+/**
+ * @name Additional message flags for GET requests
+ * @{
+ */
+
+/**
+ * Return the complete table instead of a single entry.
+ * @ingroup msg
+ */
+#define NLM_F_ROOT	0x100
+
+/**
+ * Return all entries matching criteria passed in message content.
+ */
+#define NLM_F_MATCH	0x200
+
+/**
+ * Return an atomic snapshot of the table being referenced. This
+ * may require special privileges because it has the potential to
+ * interrupt service in the FE for a longer time.
+ */
+#define NLM_F_ATOMIC	0x400
+
+/**
+ * Dump all entries
+ */
+#define NLM_F_DUMP	(NLM_F_ROOT|NLM_F_MATCH)
+
+/** @} */
+
+/**
+ * @name Additional messsage flags for NEW requests
+ * @{
+ */
+
+/**
+ * Replace existing matching config object with this request.
+ * @ingroup msg
+ */
+#define NLM_F_REPLACE	0x100
+
+/**
+ * Don't replace the config object if it already exists.
+ */
+#define NLM_F_EXCL	0x200
+
+/**
+ * Create config object if it doesn't already exist.
+ */
+#define NLM_F_CREATE	0x400
+
+/**
+ * Add to the end of the object list.
+ */
+#define NLM_F_APPEND	0x800
+
+/** @} */
+
+/**
+ * @name Standard Message types
+ * @{
+ */
+
+/**
+ * No operation, message must be ignored
+ * @ingroup msg
+ */
+#define NLMSG_NOOP		0x1
+
+/**
+ * The message signals an error and the payload contains a nlmsgerr
+ * structure. This can be looked at as a NACK and typically it is
+ * from FEC to CPC.
+ */
+#define NLMSG_ERROR		0x2
+
+/**
+ * Message terminates a multipart message.
+ */
+#define NLMSG_DONE		0x3
+
+/**
+ * The message signals that data got lost
+ */
+#define NLMSG_OVERRUN		0x4
+
+/**
+ * Lower limit of reserved message types
+ */
+#define NLMSG_MIN_TYPE		0x10
+
+/** @} */
+
+/**
+ * Netlink error message
+ * @ingroup msg
+ */
+struct nlmsgerr
+{
+	/** Error code (errno number) */
+	int		error;
+
+	/** Original netlink message causing the error */
+	struct nlmsghdr	msg;
+};
+
+struct nl_pktinfo
+{
+	__u32	group;
+};
+
+#endif	/* __LINUX_NETLINK_H */
diff -uNr libnl_kk/include/netlink/object-api.h libnl/include/netlink/object-api.h
--- libnl_kk/include/netlink/object-api.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/object-api.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,342 @@
+/*
+ * netlink/object-api.c		Object API
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2007 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_OBJECT_API_H_
+#define NETLINK_OBJECT_API_H_
+
+#include <netlink/netlink.h>
+#include <netlink/utils.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @ingroup object
+ * @defgroup object_api Object API
+ * @brief
+ *
+ * @par 1) Object Definition
+ * @code
+ * // Define your object starting with the common object header
+ * struct my_obj {
+ * 	NLHDR_COMMON
+ * 	int		my_data;
+ * };
+ *
+ * // Fill out the object operations structure
+ * struct nl_object_ops my_ops = {
+ * 	.oo_name	= "my_obj",
+ * 	.oo_size	= sizeof(struct my_obj),
+ * };
+ *
+ * // At this point the object can be allocated, you may want to provide a
+ * // separate _alloc() function to ease allocting objects of this kind.
+ * struct nl_object *obj = nl_object_alloc(&my_ops);
+ *
+ * // And release it again...
+ * nl_object_put(obj);
+ * @endcode
+ *
+ * @par 2) Allocating additional data
+ * @code
+ * // You may require to allocate additional data and store it inside
+ * // object, f.e. assuming there is a field `ptr'.
+ * struct my_obj {
+ * 	NLHDR_COMMON
+ * 	void *		ptr;
+ * };
+ *
+ * // And at some point you may assign allocated data to this field:
+ * my_obj->ptr = calloc(1, ...);
+ *
+ * // In order to not introduce any memory leaks you have to release
+ * // this data again when the last reference is given back.
+ * static void my_obj_free_data(struct nl_object *obj)
+ * {
+ * 	struct my_obj *my_obj = nl_object_priv(obj);
+ *
+ * 	free(my_obj->ptr);
+ * }
+ *
+ * // Also when the object is cloned, you must ensure for your pointer
+ * // stay valid even if one of the clones is freed by either making
+ * // a clone as well or increase the reference count.
+ * static int my_obj_clone(struct nl_object *src, struct nl_object *dst)
+ * {
+ * 	struct my_obj *my_src = nl_object_priv(src);
+ * 	struct my_obj *my_dst = nl_object_priv(dst);
+ *
+ * 	if (src->ptr) {
+ * 		dst->ptr = calloc(1, ...);
+ * 		memcpy(dst->ptr, src->ptr, ...);
+ * 	}
+ * }
+ *
+ * struct nl_object_ops my_ops = {
+ * 	...
+ * 	.oo_free_data	= my_obj_free_data,
+ * 	.oo_clone	= my_obj_clone,
+ * };
+ * @endcode
+ *
+ * @par 3) Object Dumping
+ * @code
+ * static int my_obj_dump_detailed(struct nl_object *obj,
+ * 				   struct nl_dump_params *params)
+ * {
+ * 	struct my_obj *my_obj = nl_object_priv(obj);
+ *
+ * 	// It is absolutely essential to use nl_dump() when printing
+ *	// any text to make sure the dumping parameters are respected.
+ * 	nl_dump(params, "Obj Integer: %d\n", my_obj->my_int);
+ *
+ * 	// Before we can dump the next line, make sure to prefix
+ *	// this line correctly.
+ * 	nl_new_line(params);
+ *
+ * 	// You may also split a line into multiple nl_dump() calls.
+ * 	nl_dump(params, "String: %s ", my_obj->my_string);
+ * 	nl_dump(params, "String-2: %s\n", my_obj->another_string);
+ * }
+ *
+ * struct nl_object_ops my_ops = {
+ * 	...
+ * 	.oo_dump[NL_DUMP_FULL]	= my_obj_dump_detailed,
+ * };
+ * @endcode
+ *
+ * @par 4) Object Attributes
+ * @code
+ * // The concept of object attributes is optional but can ease the typical
+ * // case of objects that have optional attributes, e.g. a route may have a
+ * // nexthop assigned but it is not required to.
+ *
+ * // The first step to define your object specific bitmask listing all
+ * // attributes
+ * #define MY_ATTR_FOO		(1<<0)
+ * #define MY_ATTR_BAR		(1<<1)
+ *
+ * // When assigning an optional attribute to the object, make sure
+ * // to mark its availability.
+ * my_obj->foo = 123123;
+ * my_obj->ce_mask |= MY_ATTR_FOO;
+ *
+ * // At any time you may use this mask to check for the availability
+ * // of the attribute, e.g. while dumping
+ * if (my_obj->ce_mask & MY_ATTR_FOO)
+ * 	nl_dump(params, "foo %d ", my_obj->foo);
+ *
+ * // One of the big advantages of this concept is that it allows for
+ * // standardized comparisons which make it trivial for caches to
+ * // identify unique objects by use of unified comparison functions.
+ * // In order for it to work, your object implementation must provide
+ * // a comparison function and define a list of attributes which
+ * // combined together make an object unique.
+ *
+ * static int my_obj_compare(struct nl_object *_a, struct nl_object *_b,
+ * 			     uint32_t attrs, int flags)
+ * {
+ * 	struct my_obj *a = nl_object_priv(_a):
+ * 	struct my_obj *b = nl_object_priv(_b):
+ * 	int diff = 0;
+ *
+ * 	// We help ourselves in defining our own DIFF macro which will
+ *	// call ATTR_DIFF() on both objects which will make sure to only
+ *	// compare the attributes if required.
+ * 	#define MY_DIFF(ATTR, EXPR) ATTR_DIFF(attrs, MY_ATTR_##ATTR, a, b, EXPR)
+ *
+ * 	// Call our own diff macro for each attribute to build a bitmask
+ *	// representing the attributes which mismatch.
+ * 	diff |= MY_DIFF(FOO, a->foo != b->foo)
+ * 	diff |= MY_DIFF(BAR, strcmp(a->bar, b->bar))
+ *
+ * 	return diff;
+ * }
+ *
+ * // In order to identify identical objects with differing attributes
+ * // you must specify the attributes required to uniquely identify
+ * // your object. Make sure to not include too many attributes, this
+ * // list is used when caches look for an old version of an object.
+ * struct nl_object_ops my_ops = {
+ * 	...
+ * 	.oo_id_attrs		= MY_ATTR_FOO,
+ * 	.oo_compare		= my_obj_compare,
+ * };
+ * @endcode
+ * @{
+ */
+
+/**
+ * Common Object Header
+ *
+ * This macro must be included as first member in every object
+ * definition to allow objects to be cached.
+ */
+#define NLHDR_COMMON				\
+	int			ce_refcnt;	\
+	struct nl_object_ops *	ce_ops;		\
+	struct nl_cache *	ce_cache;	\
+	struct nl_list_head	ce_list;	\
+	int			ce_msgtype;	\
+	int			ce_flags;	\
+	uint32_t		ce_mask;
+
+/**
+ * Return true if attribute is available in both objects
+ * @arg A		an object
+ * @arg B		another object
+ * @arg ATTR		attribute bit
+ *
+ * @return True if the attribute is available, otherwise false is returned.
+ */
+#define AVAILABLE(A, B, ATTR)		(((A)->ce_mask & (B)->ce_mask) & (ATTR))
+
+/**
+ * Return true if attribute is available in only one of both objects
+ * @arg A		an object
+ * @arg B		another object
+ * @arg ATTR		attribute bit
+ *
+ * @return True if the attribute is available in only one of both objects,
+ * otherwise false is returned.
+ */
+#define AVAILABLE_MISMATCH(A, B, ATTR)	(((A)->ce_mask ^ (B)->ce_mask) & (ATTR))
+
+/**
+ * Return true if attributes mismatch
+ * @arg A		an object
+ * @arg B		another object
+ * @arg ATTR		attribute bit
+ * @arg EXPR		Comparison expression
+ *
+ * This function will check if the attribute in question is available
+ * in both objects, if not this will count as a mismatch.
+ *
+ * If available the function will execute the expression which must
+ * return true if the attributes mismatch.
+ *
+ * @return True if the attribute mismatch, or false if they match.
+ */
+#define ATTR_MISMATCH(A, B, ATTR, EXPR)	(AVAILABLE_MISMATCH(A, B, ATTR) || \
+					 (AVAILABLE(A, B, ATTR) && (EXPR)))
+
+/**
+ * Return attribute bit if attribute does not match
+ * @arg LIST		list of attributes to be compared
+ * @arg ATTR		attribute bit
+ * @arg A		an object
+ * @arg B		another object
+ * @arg EXPR		Comparison expression
+ *
+ * This function will check if the attribute in question is available
+ * in both objects, if not this will count as a mismatch.
+ *
+ * If available the function will execute the expression which must
+ * return true if the attributes mismatch.
+ *
+ * In case the attributes mismatch, the attribute is returned, otherwise
+ * 0 is returned.
+ *
+ * @code
+ * diff |= ATTR_DIFF(attrs, MY_ATTR_FOO, a, b, a->foo != b->foo);
+ * @endcode
+ */
+#define ATTR_DIFF(LIST, ATTR, A, B, EXPR) \
+({	int diff = 0; \
+	if (((LIST) & (ATTR)) && ATTR_MISMATCH(A, B, ATTR, EXPR)) \
+		diff = ATTR; \
+	diff; })
+
+/**
+ * Object Operations
+ */
+struct nl_object_ops
+{
+	/**
+	 * Unique name of object type
+	 *
+	 * Must be in the form family/name, e.g. "route/addr"
+	 */
+	char *		oo_name;
+
+	/** Size of object including its header */
+	size_t		oo_size;
+
+	/* List of attributes needed to uniquely identify the object */
+	uint32_t	oo_id_attrs;
+
+	/**
+	 * Constructor function
+	 *
+	 * Will be called when a new object of this type is allocated.
+	 * Can be used to initialize members such as lists etc.
+	 */
+	void  (*oo_constructor)(struct nl_object *);
+
+	/**
+	 * Destructor function
+	 *
+	 * Will be called when an object is freed. Must free all
+	 * resources which may have been allocated as part of this
+	 * object.
+	 */
+	void  (*oo_free_data)(struct nl_object *);
+
+	/**
+	 * Cloning function
+	 *
+	 * Will be called when an object needs to be cloned. Please
+	 * note that the generic object code will make an exact
+	 * copy of the object first, therefore you only need to take
+	 * care of members which require reference counting etc.
+	 *
+	 * May return a negative error code to abort cloning.
+	 */
+	int  (*oo_clone)(struct nl_object *, struct nl_object *);
+
+	/**
+	 * Dumping functions
+	 *
+	 * Will be called when an object is dumped. The implementations
+	 * have to use nl_dump(), nl_dump_line(), and nl_new_line() to
+	 * dump objects.
+	 *
+	 * The functions must return the number of lines printed.
+	 */
+	void (*oo_dump[NL_DUMP_MAX+1])(struct nl_object *,
+				       struct nl_dump_params *);
+
+	/**
+	 * Comparison function
+	 *
+	 * Will be called when two objects of the same type are
+	 * compared. It takes the two objects in question, an object
+	 * specific bitmask defining which attributes should be
+	 * compared and flags to control the behaviour.
+	 *
+	 * The function must return a bitmask with the relevant bit
+	 * set for each attribute that mismatches.
+	 */
+	int   (*oo_compare)(struct nl_object *, struct nl_object *,
+			    uint32_t, int);
+
+
+	char *(*oo_attrs2str)(int, char *, size_t);
+};
+
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/object.h libnl/include/netlink/object.h
--- libnl_kk/include/netlink/object.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/object.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,69 @@
+/*
+ * netlink/object.c	Generic Cacheable Object
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_OBJECT_H_
+#define NETLINK_OBJECT_H_
+
+#include <netlink/netlink.h>
+#include <netlink/utils.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct nl_cache;
+struct nl_object;
+struct nl_object_ops;
+
+#define OBJ_CAST(ptr)		((struct nl_object *) (ptr))
+
+/* General */
+extern struct nl_object *	nl_object_alloc(struct nl_object_ops *);
+extern int			nl_object_alloc_name(const char *,
+						     struct nl_object **);
+extern void			nl_object_free(struct nl_object *);
+extern struct nl_object *	nl_object_clone(struct nl_object *obj);
+extern void			nl_object_get(struct nl_object *);
+extern void			nl_object_put(struct nl_object *);
+extern int			nl_object_shared(struct nl_object *);
+extern void			nl_object_dump(struct nl_object *,
+					       struct nl_dump_params *);
+extern int			nl_object_identical(struct nl_object *,
+						    struct nl_object *);
+extern uint32_t			nl_object_diff(struct nl_object *,
+					       struct nl_object *);
+extern int			nl_object_match_filter(struct nl_object *,
+						       struct nl_object *);
+extern char *			nl_object_attrs2str(struct nl_object *,
+						    uint32_t attrs, char *buf,
+						    size_t);
+extern char *			nl_object_attr_list(struct nl_object *,
+						    char *, size_t);
+
+/* Marks */
+extern void			nl_object_mark(struct nl_object *);
+extern void			nl_object_unmark(struct nl_object *);
+extern int			nl_object_is_marked(struct nl_object *);
+
+/* Access Functions */
+extern int			nl_object_get_refcnt(struct nl_object *);
+extern struct nl_cache *	nl_object_get_cache(struct nl_object *);
+static inline void *		nl_object_priv(struct nl_object *obj)
+{
+	return obj;
+}
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/route/addr.h libnl/include/netlink/route/addr.h
--- libnl_kk/include/netlink/route/addr.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/route/addr.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,91 @@
+/*
+ * netlink/route/addr.c		rtnetlink addr layer
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ * Copyright (c) 2003-2006 Baruch Even <baruch@ev-en.org>,
+ *                         Mediatrix Telecom, inc. <ericb@mediatrix.com>
+ */
+
+#ifndef NETADDR_ADDR_H_
+#define NETADDR_ADDR_H_
+
+#include <netlink/netlink.h>
+#include <netlink/cache.h>
+#include <netlink/addr.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct rtnl_addr;
+
+/* General */
+extern struct rtnl_addr *rtnl_addr_alloc(void);
+extern void	rtnl_addr_put(struct rtnl_addr *);
+
+extern int	rtnl_addr_alloc_cache(struct nl_sock *, struct nl_cache **);
+
+extern int	rtnl_addr_build_add_request(struct rtnl_addr *, int,
+					    struct nl_msg **);
+extern int	rtnl_addr_add(struct nl_sock *, struct rtnl_addr *, int);
+
+extern int	rtnl_addr_build_delete_request(struct rtnl_addr *, int,
+					       struct nl_msg **);
+extern int	rtnl_addr_delete(struct nl_sock *,
+				 struct rtnl_addr *, int);
+
+extern char *	rtnl_addr_flags2str(int, char *, size_t);
+extern int	rtnl_addr_str2flags(const char *);
+
+extern int	rtnl_addr_set_label(struct rtnl_addr *, const char *);
+extern char *	rtnl_addr_get_label(struct rtnl_addr *);
+
+extern void	rtnl_addr_set_ifindex(struct rtnl_addr *, int);
+extern int	rtnl_addr_get_ifindex(struct rtnl_addr *);
+
+extern void	rtnl_addr_set_family(struct rtnl_addr *, int);
+extern int	rtnl_addr_get_family(struct rtnl_addr *);
+
+extern void	rtnl_addr_set_prefixlen(struct rtnl_addr *, int);
+extern int	rtnl_addr_get_prefixlen(struct rtnl_addr *);
+
+extern void	rtnl_addr_set_scope(struct rtnl_addr *, int);
+extern int	rtnl_addr_get_scope(struct rtnl_addr *);
+
+extern void	rtnl_addr_set_flags(struct rtnl_addr *, unsigned int);
+extern void	rtnl_addr_unset_flags(struct rtnl_addr *, unsigned int);
+extern unsigned int rtnl_addr_get_flags(struct rtnl_addr *);
+
+extern int	rtnl_addr_set_local(struct rtnl_addr *,
+					    struct nl_addr *);
+extern struct nl_addr *rtnl_addr_get_local(struct rtnl_addr *);
+
+extern int	rtnl_addr_set_peer(struct rtnl_addr *, struct nl_addr *);
+extern struct nl_addr *rtnl_addr_get_peer(struct rtnl_addr *);
+
+extern int	rtnl_addr_set_broadcast(struct rtnl_addr *, struct nl_addr *);
+extern struct nl_addr *rtnl_addr_get_broadcast(struct rtnl_addr *);
+
+extern int	rtnl_addr_set_multicast(struct rtnl_addr *, struct nl_addr *);
+extern struct nl_addr *rtnl_addr_get_multicast(struct rtnl_addr *);
+
+extern int	rtnl_addr_set_anycast(struct rtnl_addr *, struct nl_addr *);
+extern struct nl_addr *rtnl_addr_get_anycast(struct rtnl_addr *);
+
+extern uint32_t rtnl_addr_get_valid_lifetime(struct rtnl_addr *);
+extern void	rtnl_addr_set_valid_lifetime(struct rtnl_addr *, uint32_t);
+extern uint32_t rtnl_addr_get_preferred_lifetime(struct rtnl_addr *);
+extern void	rtnl_addr_set_preferred_lifetime(struct rtnl_addr *, uint32_t);
+extern uint32_t rtnl_addr_get_create_time(struct rtnl_addr *);
+extern uint32_t rtnl_addr_get_last_update_time(struct rtnl_addr *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/route/class.h libnl/include/netlink/route/class.h
--- libnl_kk/include/netlink/route/class.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/route/class.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,73 @@
+/*
+ * netlink/route/class.h       Classes
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_CLASS_H_
+#define NETLINK_CLASS_H_
+
+#include <netlink/netlink.h>
+#include <netlink/route/tc.h>
+#include <netlink/route/qdisc.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct rtnl_class;
+
+extern struct nl_object_ops class_obj_ops;
+
+extern struct rtnl_class *	rtnl_class_alloc(void);
+extern void		rtnl_class_put(struct rtnl_class *);
+extern int		rtnl_class_alloc_cache(struct nl_sock *, int,
+					       struct nl_cache **);
+extern struct rtnl_class *rtnl_class_get(struct nl_cache *, int, uint32_t);
+
+/* leaf qdisc access */
+extern struct rtnl_qdisc *	rtnl_class_leaf_qdisc(struct rtnl_class *,
+						      struct nl_cache *);
+
+extern int		rtnl_class_build_add_request(struct rtnl_class *, int,
+						     struct nl_msg **);
+extern int		rtnl_class_add(struct nl_sock *, struct rtnl_class *,
+				       int);
+
+extern int	rtnl_class_build_delete_request(struct rtnl_class *,
+											struct nl_msg **);
+extern int	rtnl_class_delete(struct nl_sock *, struct rtnl_class *);
+
+extern void		rtnl_class_set_ifindex(struct rtnl_class *, int);
+extern int		rtnl_class_get_ifindex(struct rtnl_class *);
+extern void		rtnl_class_set_handle(struct rtnl_class *, uint32_t);
+extern uint32_t		rtnl_class_get_handle(struct rtnl_class *);
+extern void		rtnl_class_set_parent(struct rtnl_class *, uint32_t);
+extern uint32_t		rtnl_class_get_parent(struct rtnl_class *);
+extern void		rtnl_class_set_kind(struct rtnl_class *, const char *);
+extern char *		rtnl_class_get_kind(struct rtnl_class *);
+extern uint64_t		rtnl_class_get_stat(struct rtnl_class *,
+					    enum rtnl_tc_stats_id);
+
+/* iterators */
+extern void		rtnl_class_foreach_child(struct rtnl_class *,
+						 struct nl_cache *,
+						 void (*cb)(struct nl_object *,
+						 	    void *),
+						 void *);
+extern void		rtnl_class_foreach_cls(struct rtnl_class *,
+					       struct nl_cache *,
+					       void (*cb)(struct nl_object *,
+							  void *),
+					       void *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/route/classifier.h libnl/include/netlink/route/classifier.h
--- libnl_kk/include/netlink/route/classifier.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/route/classifier.h	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,62 @@
+/*
+ * netlink/route/classifier.h       Classifiers
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_CLASSIFIER_H_
+#define NETLINK_CLASSIFIER_H_
+
+#include <netlink/netlink.h>
+#include <netlink/cache.h>
+#include <netlink/route/tc.h>
+#include <netlink/utils.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern struct nl_object_ops cls_obj_ops;
+
+extern struct rtnl_cls *rtnl_cls_alloc(void);
+extern void	rtnl_cls_put(struct rtnl_cls *);
+
+extern int	rtnl_cls_alloc_cache(struct nl_sock *, int, uint32_t,
+				     struct nl_cache **);
+
+extern int	rtnl_cls_build_add_request(struct rtnl_cls *, int,
+					   struct nl_msg **);
+extern int	rtnl_cls_add(struct nl_sock *, struct rtnl_cls *, int);
+
+extern int	rtnl_cls_build_change_request(struct rtnl_cls *, int,
+					      struct nl_msg **);
+extern int	rtnl_cls_build_delete_request(struct rtnl_cls *, int,
+					      struct nl_msg **);
+extern int	rtnl_cls_delete(struct nl_sock *, struct rtnl_cls *, int);
+
+extern void rtnl_cls_set_ifindex(struct rtnl_cls *, int);
+extern int rtnl_cls_get_ifindex(struct rtnl_cls *);
+extern void rtnl_cls_set_handle(struct rtnl_cls *, uint32_t);
+extern void rtnl_cls_set_parent(struct rtnl_cls *, uint32_t);
+extern uint32_t rtnl_cls_get_parent(struct rtnl_cls *);
+extern int rtnl_cls_set_kind(struct rtnl_cls *, const char *);
+extern struct rtnl_cls_ops *rtnl_cls_get_ops(struct rtnl_cls *);
+
+extern void rtnl_cls_set_prio(struct rtnl_cls *, uint16_t);
+extern uint16_t rtnl_cls_get_prio(struct rtnl_cls *);
+
+extern void rtnl_cls_set_protocol(struct rtnl_cls *, uint16_t);
+extern uint16_t rtnl_cls_get_protocol(struct rtnl_cls *);
+
+extern void *rtnl_cls_data(struct rtnl_cls *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/route/classifier-modules.h libnl/include/netlink/route/classifier-modules.h
--- libnl_kk/include/netlink/route/classifier-modules.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/route/classifier-modules.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,78 @@
+/*
+ * netlink/route/classifier-modules.h   Classifier Module API
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_CLASS_MODULES_H_
+#define NETLINK_CLASS_MODULES_H_
+
+#include <netlink/netlink.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * Classifier operations
+ * @ingroup cls_api
+ */
+struct rtnl_cls_ops
+{
+	/**
+	 * Name of classifier module
+	 */
+	char co_kind[32];
+
+
+	/**
+	 * Size of private classifier data
+	 */
+	size_t co_size;
+
+	/**
+	 * Dump callbacks
+	 */
+	void (*co_dump[NL_DUMP_MAX+1])(struct rtnl_cls *,
+				       struct nl_dump_params *);
+	/**
+	 * Must return the contents supposed to be in TCA_OPTIONS
+	 */
+	int (*co_get_opts)(struct rtnl_cls *, struct nl_msg *);
+
+	/**
+	 * TCA_OPTIONS message parser
+	 */
+	int (*co_msg_parser)(struct rtnl_cls *);
+
+	/**
+	 * Called before a class object gets destroyed
+	 */
+	void (*co_free_data)(struct rtnl_cls *);
+
+	/**
+	 * Called whenever a classifier object needs to be cloned
+	 */
+	int (*co_clone)(struct rtnl_cls *, struct rtnl_cls *);
+
+	/**
+	 * INTERNAL (Do not use)
+	 */
+	struct rtnl_cls_ops *co_next;
+};
+
+extern int 			rtnl_cls_register(struct rtnl_cls_ops *);
+extern int 			rtnl_cls_unregister(struct rtnl_cls_ops *);
+extern struct rtnl_cls_ops *	rtnl_cls_lookup_ops(struct rtnl_cls *);
+extern struct rtnl_cls_ops *	__rtnl_cls_lookup_ops(const char *kind);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/route/class-modules.h libnl/include/netlink/route/class-modules.h
--- libnl_kk/include/netlink/route/class-modules.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/route/class-modules.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,73 @@
+/*
+ * netlink/route/class-modules.h       Class Module API
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2006 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_CLASS_MODULES_H_
+#define NETLINK_CLASS_MODULES_H_
+
+#include <netlink/netlink.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * Class operations
+ * @ingroup class_api
+ */
+struct rtnl_class_ops
+{
+	/**
+	 * Kind/Name of class
+	 */
+	char co_kind[32];
+
+	/**
+	 * Dump callbacks
+	 */
+	void (*co_dump[NL_DUMP_MAX+1])(struct rtnl_class *,
+				       struct nl_dump_params *);
+
+	/**
+	 * Must return the contents supposed to be in TCA_OPTIONS
+	 */
+	struct nl_msg *(*co_get_opts)(struct rtnl_class *);
+
+	/**
+	 * TCA_OPTIONS message parser
+	 */
+	int  (*co_msg_parser)(struct rtnl_class *);
+
+	/**
+	 * Called before a class object gets destroyed
+	 */
+	void (*co_free_data)(struct rtnl_class *);
+
+	/**
+	 * Called whenever a class object needs to be cloned
+	 */
+	int (*co_clone)(struct rtnl_class *, struct rtnl_class *);
+
+	/**
+	 * INTERNAL (Do not use)
+	 */
+	struct rtnl_class_ops *co_next;
+};
+
+extern int			rtnl_class_register(struct rtnl_class_ops *);
+extern int			rtnl_class_unregister(struct rtnl_class_ops *);
+extern struct rtnl_class_ops *	rtnl_class_lookup_ops(struct rtnl_class *);
+extern struct rtnl_class_ops *	__rtnl_class_lookup_ops(const char *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/route/cls/basic.h libnl/include/netlink/route/cls/basic.h
--- libnl_kk/include/netlink/route/cls/basic.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/route/cls/basic.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,33 @@
+/*
+ * netlink/route/cls/basic.h	Basic Classifier
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2008-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_BASIC_H_
+#define NETLINK_BASIC_H_
+
+#include <netlink/netlink.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern struct rtnl_cls_ops *rtnl_basic_get_ops(void);
+extern int	rtnl_basic_set_classid(struct rtnl_cls *, uint32_t);
+extern uint32_t	rtnl_basic_get_classid(struct rtnl_cls *);
+extern int	rtnl_basic_set_ematch(struct rtnl_cls *,
+				      struct rtnl_ematch_tree *);
+extern struct rtnl_ematch_tree *
+		rtnl_basic_get_ematch(struct rtnl_cls *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/route/cls/cgroup.h libnl/include/netlink/route/cls/cgroup.h
--- libnl_kk/include/netlink/route/cls/cgroup.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/route/cls/cgroup.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,31 @@
+/*
+ * netlink/route/cls/cgroup.h	Control Groups Classifier
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_CLS_CGROUP_H_
+#define NETLINK_CLS_CGROUP_H_
+
+#include <netlink/netlink.h>
+#include <netlink/cache.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern int	rtnl_cgroup_set_ematch(struct rtnl_cls *,
+				       struct rtnl_ematch_tree *);
+extern struct rtnl_ematch_tree *
+		rtnl_cgroup_get_ematch(struct rtnl_cls *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/route/cls/ematch/cmp.h libnl/include/netlink/route/cls/ematch/cmp.h
--- libnl_kk/include/netlink/route/cls/ematch/cmp.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/route/cls/ematch/cmp.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,31 @@
+/*
+ * netlink/route/cls/ematch/cmp.h	Simple Comparison
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_CLS_EMATCH_CMP_H_
+#define NETLINK_CLS_EMATCH_CMP_H_
+
+#include <netlink/netlink.h>
+#include <netlink/route/cls/ematch.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern void	rtnl_ematch_cmp_set(struct rtnl_ematch *,
+				    struct tcf_em_cmp *);
+extern struct tcf_em_cmp *
+		rtnl_ematch_cmp_get(struct rtnl_ematch *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/route/cls/ematch.h libnl/include/netlink/route/cls/ematch.h
--- libnl_kk/include/netlink/route/cls/ematch.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/route/cls/ematch.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,73 @@
+/*
+ * netlink/route/cls/ematch.h		Extended Matches
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_CLS_EMATCH_H_
+#define NETLINK_CLS_EMATCH_H_
+
+#include <netlink/netlink.h>
+#include <netlink/route/classifier.h>
+#include <linux/pkt_cls.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct rtnl_ematch;
+struct rtnl_ematch_tree;
+
+struct rtnl_ematch_ops
+{
+	int				eo_kind;
+	const char *			eo_name;
+	size_t				eo_datalen;
+
+	int			      (*eo_parse)(struct rtnl_ematch *,
+						  void *, size_t);
+	void			      (*eo_dump)(struct rtnl_ematch *,
+						 struct nl_dump_params *);
+	struct nl_list_head		eo_list;
+};
+
+extern int	rtnl_ematch_register(struct rtnl_ematch_ops *);
+extern int	rtnl_ematch_unregister(struct rtnl_ematch_ops *);
+
+extern struct rtnl_ematch_ops *
+		rtnl_ematch_lookup_ops(int);
+extern struct rtnl_ematch_ops *
+		rtnl_ematch_lookup_ops_name(const char *);
+
+extern struct rtnl_ematch *
+		rtnl_ematch_alloc(struct rtnl_ematch_ops *);
+extern void	rtnl_ematch_add_child(struct rtnl_ematch *,
+				      struct rtnl_ematch *);
+extern void	rtnl_ematch_unlink(struct rtnl_ematch *);
+extern void	rtnl_ematch_free(struct rtnl_ematch *);
+
+extern void *	rtnl_ematch_data(struct rtnl_ematch *);
+extern void	rtnl_ematch_set_flags(struct rtnl_ematch *, uint16_t);
+extern void	rtnl_ematch_unset_flags(struct rtnl_ematch *, uint16_t);
+extern uint16_t	rtnl_ematch_get_flags(struct rtnl_ematch *);
+
+extern struct rtnl_ematch_tree *
+		rtnl_ematch_tree_alloc(uint16_t);
+extern void	rtnl_ematch_tree_free(struct rtnl_ematch_tree *);
+
+extern int	rtnl_ematch_parse(struct nlattr *, struct rtnl_ematch_tree **);
+extern void	rtnl_ematch_tree_add_tail(struct rtnl_ematch_tree *,
+					  struct rtnl_ematch *);
+extern void	rtnl_ematch_tree_dump(struct rtnl_ematch_tree *,
+				      struct nl_dump_params *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/route/cls/fw.h libnl/include/netlink/route/cls/fw.h
--- libnl_kk/include/netlink/route/cls/fw.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/route/cls/fw.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,29 @@
+/*
+ * netlink/route/cls/fw.h	fw classifier
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2006 Thomas Graf <tgraf@suug.ch>
+ * Copyright (c) 2006 Petr Gotthard <petr.gotthard@siemens.com>
+ * Copyright (c) 2006 Siemens AG Oesterreich
+ */
+
+#ifndef NETLINK_FW_H_
+#define NETLINK_FW_H_
+
+#include <netlink/netlink.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern int	rtnl_fw_set_classid(struct rtnl_cls *, uint32_t);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/route/cls/police.h libnl/include/netlink/route/cls/police.h
--- libnl_kk/include/netlink/route/cls/police.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/route/cls/police.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,29 @@
+/*
+ * netlink/route/cls/police.h	Policer
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2006 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_CLS_POLICE_H_
+#define NETLINK_CLS_POLICE_H_
+
+#include <netlink/netlink.h>
+#include <netlink/cache.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern char *	nl_police2str(int, char *, size_t);
+extern int	nl_str2police(const char *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/route/cls/u32.h libnl/include/netlink/route/cls/u32.h
--- libnl_kk/include/netlink/route/cls/u32.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/route/cls/u32.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,43 @@
+/*
+ * netlink/route/cls/u32.h	u32 classifier
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2006 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_U32_H_
+#define NETLINK_U32_H_
+
+#include <netlink/netlink.h>
+#include <netlink/cache.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern void	rtnl_u32_set_handle(struct rtnl_cls *, int, int, int);
+extern int	rtnl_u32_set_classid(struct rtnl_cls *, uint32_t);
+
+extern int	rtnl_u32_set_flags(struct rtnl_cls *, int);
+extern int	rtnl_u32_add_key(struct rtnl_cls *, uint32_t, uint32_t,
+				 int, int);
+extern int	rtnl_u32_add_key_uint8(struct rtnl_cls *, uint8_t, uint8_t,
+				       int, int);
+extern int	rtnl_u32_add_key_uint16(struct rtnl_cls *, uint16_t, uint16_t,
+					int, int);
+extern int	rtnl_u32_add_key_uint32(struct rtnl_cls *, uint32_t, uint32_t,
+					int, int);
+extern int	rtnl_u32_add_key_in_addr(struct rtnl_cls *, struct in_addr *,
+					 uint8_t, int, int);
+extern int	rtnl_u32_add_key_in6_addr(struct rtnl_cls *, struct in6_addr *,
+					  uint8_t, int, int);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/route/link/info-api.h libnl/include/netlink/route/link/info-api.h
--- libnl_kk/include/netlink/route/link/info-api.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/route/link/info-api.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,71 @@
+/*
+ * netlink/route/link/info-api.h	Link Info API
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_LINK_INFO_API_H_
+#define NETLINK_LINK_INFO_API_H_
+
+#include <netlink/netlink.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @ingroup link_info
+ *
+ * Link info operations
+ */
+struct rtnl_link_info_ops
+{
+	/** Name of operations, must match name on kernel side */
+	char *		io_name;
+
+	/** Reference count (internal, do not use) */
+	int		io_refcnt;
+
+	/** Called to assign an info type to a link.
+	 * Has to allocate enough resources to hold attributes. Can
+	 * use link->l_info to store a pointer. */
+	int	      (*io_alloc)(struct rtnl_link *);
+
+	/** Called to parse the link info attribute.
+	 * Must parse the attribute and assign all values to the link.
+	 */
+	int	      (*io_parse)(struct rtnl_link *,
+				  struct nlattr *,
+				  struct nlattr *);
+
+	/** Called when the link object is dumped.
+	 * Must dump the info type specific attributes. */
+	void	      (*io_dump[NL_DUMP_MAX+1])(struct rtnl_link *,
+						struct nl_dump_params *);
+
+	/** Called when a link object is cloned.
+	 * Must clone all info type specific attributes. */
+	int	      (*io_clone)(struct rtnl_link *, struct rtnl_link *);
+
+	/** Called when construction a link netlink message.
+	 * Must append all info type specific attributes to the message. */
+	int	      (*io_put_attrs)(struct nl_msg *, struct rtnl_link *);
+
+	/** Called to release all resources previously allocated
+	 * in either io_alloc() or io_parse(). */
+	void	      (*io_free)(struct rtnl_link *);
+
+	struct rtnl_link_info_ops *	io_next;
+};
+
+extern struct rtnl_link_info_ops *rtnl_link_info_ops_lookup(const char *);
+
+extern int			rtnl_link_register_info(struct rtnl_link_info_ops *);
+extern int			rtnl_link_unregister_info(struct rtnl_link_info_ops *);
+
+#endif
diff -uNr libnl_kk/include/netlink/route/link/vlan.h libnl/include/netlink/route/link/vlan.h
--- libnl_kk/include/netlink/route/link/vlan.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/route/link/vlan.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,55 @@
+/*
+ * netlink/route/link/vlan.h		VLAN interface
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_LINK_VLAN_H_
+#define NETLINK_LINK_VLAN_H_
+
+#include <netlink/netlink.h>
+#include <netlink/route/link.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct vlan_map
+{
+	uint32_t		vm_from;
+	uint32_t		vm_to;
+};
+
+#define VLAN_PRIO_MAX 7
+
+extern char *		rtnl_link_vlan_flags2str(int, char *, size_t);
+extern int		rtnl_link_vlan_str2flags(const char *);
+
+extern int		rtnl_link_vlan_set_id(struct rtnl_link *, int);
+extern int		rtnl_link_vlan_get_id(struct rtnl_link *);
+
+extern int		rtnl_link_vlan_set_flags(struct rtnl_link *,
+						 unsigned int);
+extern int		rtnl_link_vlan_unset_flags(struct rtnl_link *,
+						   unsigned int);
+extern unsigned int	rtnl_link_vlan_get_flags(struct rtnl_link *);
+
+extern int		rtnl_link_vlan_set_ingress_map(struct rtnl_link *,
+						       int, uint32_t);
+extern uint32_t *	rtnl_link_vlan_get_ingress_map(struct rtnl_link *);
+
+extern int		rtnl_link_vlan_set_egress_map(struct rtnl_link *,
+						      uint32_t, int);
+extern struct vlan_map *rtnl_link_vlan_get_egress_map(struct rtnl_link *,
+						      int *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/route/link.h libnl/include/netlink/route/link.h
--- libnl_kk/include/netlink/route/link.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/route/link.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,145 @@
+/*
+ * netlink/route/link.h		Links (Interfaces)
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_LINK_H_
+#define NETLINK_LINK_H_
+
+#include <netlink/netlink.h>
+#include <netlink/cache.h>
+#include <netlink/addr.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct rtnl_link;
+
+enum rtnl_link_st {
+	RTNL_LINK_RX_PACKETS,
+	RTNL_LINK_TX_PACKETS,
+	RTNL_LINK_RX_BYTES,
+	RTNL_LINK_TX_BYTES,
+	RTNL_LINK_RX_ERRORS,
+	RTNL_LINK_TX_ERRORS,
+	RTNL_LINK_RX_DROPPED,
+	RTNL_LINK_TX_DROPPED,
+	RTNL_LINK_RX_COMPRESSED,
+	RTNL_LINK_TX_COMPRESSED,
+	RTNL_LINK_RX_FIFO_ERR,
+	RTNL_LINK_TX_FIFO_ERR,
+	RTNL_LINK_RX_LEN_ERR,
+	RTNL_LINK_RX_OVER_ERR,
+	RTNL_LINK_RX_CRC_ERR,
+	RTNL_LINK_RX_FRAME_ERR,
+	RTNL_LINK_RX_MISSED_ERR,
+	RTNL_LINK_TX_ABORT_ERR,
+	RTNL_LINK_TX_CARRIER_ERR,
+	RTNL_LINK_TX_HBEAT_ERR,
+	RTNL_LINK_TX_WIN_ERR,
+	RTNL_LINK_TX_COLLISIONS,
+	RTNL_LINK_MULTICAST,
+	__RTNL_LINK_STATS_MAX,
+};
+
+#define RTNL_LINK_STATS_MAX (__RTNL_LINK_STATS_MAX - 1)
+
+/* link object allocation/freeage */
+extern struct rtnl_link *rtnl_link_alloc(void);
+extern void	rtnl_link_put(struct rtnl_link *);
+extern void	rtnl_link_free(struct rtnl_link *);
+
+/* link cache management */
+extern int	rtnl_link_alloc_cache(struct nl_sock *, struct nl_cache **);
+extern struct rtnl_link *rtnl_link_get(struct nl_cache *, int);
+extern struct rtnl_link *rtnl_link_get_by_name(struct nl_cache *, const char *);
+
+
+extern int	rtnl_link_build_change_request(struct rtnl_link *,
+					       struct rtnl_link *, int,
+					       struct nl_msg **);
+extern int	rtnl_link_change(struct nl_sock *, struct rtnl_link *,
+				 struct rtnl_link *, int);
+
+/* Name <-> Index Translations */
+extern char * 	rtnl_link_i2name(struct nl_cache *, int, char *, size_t);
+extern int	rtnl_link_name2i(struct nl_cache *, const char *);
+
+/* Name <-> Statistic Translations */
+extern char *	rtnl_link_stat2str(int, char *, size_t);
+extern int	rtnl_link_str2stat(const char *);
+
+/* Link Flags Translations */
+extern char *	rtnl_link_flags2str(int, char *, size_t);
+extern int	rtnl_link_str2flags(const char *);
+
+extern char *	rtnl_link_operstate2str(int, char *, size_t);
+extern int	rtnl_link_str2operstate(const char *);
+
+extern char *	rtnl_link_mode2str(int, char *, size_t);
+extern int	rtnl_link_str2mode(const char *);
+
+/* Access Functions */
+extern void	rtnl_link_set_qdisc(struct rtnl_link *, const char *);
+extern char *	rtnl_link_get_qdisc(struct rtnl_link *);
+
+extern void	rtnl_link_set_name(struct rtnl_link *, const char *);
+extern char *	rtnl_link_get_name(struct rtnl_link *);
+
+extern void	rtnl_link_set_flags(struct rtnl_link *, unsigned int);
+extern void	rtnl_link_unset_flags(struct rtnl_link *, unsigned int);
+extern unsigned int rtnl_link_get_flags(struct rtnl_link *);
+
+extern void	rtnl_link_set_mtu(struct rtnl_link *, unsigned int);
+extern unsigned int rtnl_link_get_mtu(struct rtnl_link *);
+
+extern void	rtnl_link_set_txqlen(struct rtnl_link *, unsigned int);
+extern unsigned int rtnl_link_get_txqlen(struct rtnl_link *);
+
+extern void	rtnl_link_set_weight(struct rtnl_link *, unsigned int);
+extern unsigned int rtnl_link_get_weight(struct rtnl_link *);
+
+extern void	rtnl_link_set_ifindex(struct rtnl_link *, int);
+extern int	rtnl_link_get_ifindex(struct rtnl_link *);
+
+extern void	rtnl_link_set_family(struct rtnl_link *, int);
+extern int	rtnl_link_get_family(struct rtnl_link *);
+
+extern void	rtnl_link_set_arptype(struct rtnl_link *, unsigned int);
+extern unsigned int rtnl_link_get_arptype(struct rtnl_link *);
+
+extern void	rtnl_link_set_addr(struct rtnl_link *, struct nl_addr *);
+extern struct nl_addr *rtnl_link_get_addr(struct rtnl_link *);
+
+extern void	rtnl_link_set_broadcast(struct rtnl_link *, struct nl_addr *);
+extern struct nl_addr *rtnl_link_get_broadcast(struct rtnl_link *);
+
+extern void	rtnl_link_set_link(struct rtnl_link *, int);
+extern int	rtnl_link_get_link(struct rtnl_link *);
+
+extern void	rtnl_link_set_master(struct rtnl_link *, int);
+extern int	rtnl_link_get_master(struct rtnl_link *);
+
+extern void	rtnl_link_set_operstate(struct rtnl_link *, uint8_t);
+extern uint8_t	rtnl_link_get_operstate(struct rtnl_link *);
+
+extern void	rtnl_link_set_linkmode(struct rtnl_link *, uint8_t);
+extern uint8_t	rtnl_link_get_linkmode(struct rtnl_link *);
+
+extern uint64_t rtnl_link_get_stat(struct rtnl_link *, int);
+
+extern int	rtnl_link_set_info_type(struct rtnl_link *, const char *);
+extern char *	rtnl_link_get_info_type(struct rtnl_link *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/route/neighbour.h libnl/include/netlink/route/neighbour.h
--- libnl_kk/include/netlink/route/neighbour.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/route/neighbour.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,79 @@
+/*
+ * netlink/route/neighbour.h	Neighbours
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_NEIGHBOUR_H_
+#define NETLINK_NEIGHBOUR_H_
+
+#include <netlink/netlink.h>
+#include <netlink/cache.h>
+#include <netlink/addr.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct rtnl_neigh;
+
+extern struct rtnl_neigh *rtnl_neigh_alloc(void);
+extern void	rtnl_neigh_put(struct rtnl_neigh *);
+
+extern int	rtnl_neigh_alloc_cache(struct nl_sock *, struct nl_cache **);
+extern struct rtnl_neigh *rtnl_neigh_get(struct nl_cache *, int,
+					       struct nl_addr *);
+
+extern char *	rtnl_neigh_state2str(int, char *, size_t);
+extern int	rtnl_neigh_str2state(const char *);
+
+extern char *	rtnl_neigh_flags2str(int, char *, size_t);
+extern int	rtnl_neigh_str2flag(const char *);
+
+extern int	rtnl_neigh_add(struct nl_sock *, struct rtnl_neigh *, int);
+extern int	rtnl_neigh_build_add_request(struct rtnl_neigh *, int,
+					     struct nl_msg **);
+
+extern int	rtnl_neigh_delete(struct nl_sock *, struct rtnl_neigh *, int);
+extern int	rtnl_neigh_build_delete_request(struct rtnl_neigh *, int,
+						struct nl_msg **);
+
+extern void			rtnl_neigh_set_state(struct rtnl_neigh *, int);
+extern int			rtnl_neigh_get_state(struct rtnl_neigh *);
+extern void			rtnl_neigh_unset_state(struct rtnl_neigh *,
+						       int);
+
+extern void			rtnl_neigh_set_flags(struct rtnl_neigh *,
+						     unsigned int);
+extern void			rtnl_neigh_unset_flags(struct rtnl_neigh *,
+						       unsigned int);
+extern unsigned int		rtnl_neigh_get_flags(struct rtnl_neigh *);
+
+extern void			rtnl_neigh_set_ifindex(struct rtnl_neigh *,
+						       int);
+extern int			rtnl_neigh_get_ifindex(struct rtnl_neigh *);
+
+extern void			rtnl_neigh_set_lladdr(struct rtnl_neigh *,
+						      struct nl_addr *);
+extern struct nl_addr *		rtnl_neigh_get_lladdr(struct rtnl_neigh *);
+
+extern int			rtnl_neigh_set_dst(struct rtnl_neigh *,
+						   struct nl_addr *);
+extern struct nl_addr *		rtnl_neigh_get_dst(struct rtnl_neigh *);
+
+extern void			rtnl_neigh_set_type(struct rtnl_neigh *, int);
+extern int			rtnl_neigh_get_type(struct rtnl_neigh *);
+
+extern void			rtnl_neigh_set_family(struct rtnl_neigh *, int);
+extern int			rtnl_neigh_get_family(struct rtnl_neigh *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/route/neightbl.h libnl/include/netlink/route/neightbl.h
--- libnl_kk/include/netlink/route/neightbl.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/route/neightbl.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,65 @@
+/*
+ * netlink/route/neightbl.h	Neighbour Tables
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_NEIGHTBL_H_
+#define NETLINK_NEIGHTBL_H_
+
+#include <netlink/netlink.h>
+#include <netlink/cache.h>
+#include <netlink/addr.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct rtnl_neightbl;
+
+extern struct rtnl_neightbl *rtnl_neightbl_alloc(void);
+extern void rtnl_neightbl_put(struct rtnl_neightbl *);
+extern void rtnl_neightbl_free(struct rtnl_neightbl *);
+extern int rtnl_neightbl_alloc_cache(struct nl_sock *, struct nl_cache **);
+extern struct rtnl_neightbl *rtnl_neightbl_get(struct nl_cache *,
+					       const char *, int);
+extern void rtnl_neightbl_dump(struct rtnl_neightbl *, FILE *,
+			       struct nl_dump_params *);
+
+extern int rtnl_neightbl_build_change_request(struct rtnl_neightbl *,
+					      struct rtnl_neightbl *,
+					      struct nl_msg **);
+extern int rtnl_neightbl_change(struct nl_sock *, struct rtnl_neightbl *,
+				struct rtnl_neightbl *);
+
+extern void rtnl_neightbl_set_family(struct rtnl_neightbl *, int);
+extern void rtnl_neightbl_set_gc_tresh1(struct rtnl_neightbl *, int);
+extern void rtnl_neightbl_set_gc_tresh2(struct rtnl_neightbl *, int);
+extern void rtnl_neightbl_set_gc_tresh3(struct rtnl_neightbl *, int);
+extern void rtnl_neightbl_set_name(struct rtnl_neightbl *, const char *);
+extern void rtnl_neightbl_set_dev(struct rtnl_neightbl *, int);
+extern void rtnl_neightbl_set_queue_len(struct rtnl_neightbl *, int);
+extern void rtnl_neightbl_set_proxy_queue_len(struct rtnl_neightbl *, int);
+extern void rtnl_neightbl_set_app_probes(struct rtnl_neightbl *, int);
+extern void rtnl_neightbl_set_ucast_probes(struct rtnl_neightbl *, int);
+extern void rtnl_neightbl_set_mcast_probes(struct rtnl_neightbl *, int);
+extern void rtnl_neightbl_set_base_reachable_time(struct rtnl_neightbl *,
+						  uint64_t);
+extern void rtnl_neightbl_set_retrans_time(struct rtnl_neightbl *, uint64_t);
+extern void rtnl_neightbl_set_gc_stale_time(struct rtnl_neightbl *, uint64_t);
+extern void rtnl_neightbl_set_delay_probe_time(struct rtnl_neightbl *,
+					       uint64_t);
+extern void rtnl_neightbl_set_anycast_delay(struct rtnl_neightbl *, uint64_t);
+extern void rtnl_neightbl_set_proxy_delay(struct rtnl_neightbl *, uint64_t);
+extern void rtnl_neightbl_set_locktime(struct rtnl_neightbl *, uint64_t);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/route/nexthop.h libnl/include/netlink/route/nexthop.h
--- libnl_kk/include/netlink/route/nexthop.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/route/nexthop.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,65 @@
+/*
+ * netlink/route/nexthop.h	Routing Nexthop
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_ROUTE_NEXTHOP_H_
+#define NETLINK_ROUTE_NEXTHOP_H_
+
+#include <netlink/netlink.h>
+#include <netlink/addr.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct rtnl_nexthop;
+
+enum {
+	NH_DUMP_FROM_ONELINE = -2,
+	NH_DUMP_FROM_DETAILS = -1,
+	NH_DUMP_FROM_ENV = 0,
+	/* > 0 reserved for nexthop index */
+};
+
+extern struct rtnl_nexthop * rtnl_route_nh_alloc(void);
+extern struct rtnl_nexthop * rtnl_route_nh_clone(struct rtnl_nexthop *);
+extern void		rtnl_route_nh_free(struct rtnl_nexthop *);
+
+extern int		rtnl_route_nh_compare(struct rtnl_nexthop *,
+					      struct rtnl_nexthop *,
+					      uint32_t, int);
+
+extern void		rtnl_route_nh_dump(struct rtnl_nexthop *,
+					   struct nl_dump_params *);
+
+extern void		rtnl_route_nh_set_weight(struct rtnl_nexthop *, uint8_t);
+extern uint8_t		rtnl_route_nh_get_weight(struct rtnl_nexthop *);
+extern void		rtnl_route_nh_set_ifindex(struct rtnl_nexthop *, int);
+extern int		rtnl_route_nh_get_ifindex(struct rtnl_nexthop *);
+extern void		rtnl_route_nh_set_gateway(struct rtnl_nexthop *,
+						  struct nl_addr *);
+extern struct nl_addr *	rtnl_route_nh_get_gateway(struct rtnl_nexthop *);
+extern void		rtnl_route_nh_set_flags(struct rtnl_nexthop *,
+						unsigned int);
+extern void		rtnl_route_nh_unset_flags(struct rtnl_nexthop *,
+						  unsigned int);
+extern unsigned int	rtnl_route_nh_get_flags(struct rtnl_nexthop *);
+extern void		rtnl_route_nh_set_realms(struct rtnl_nexthop *,
+						 uint32_t);
+extern uint32_t		rtnl_route_nh_get_realms(struct rtnl_nexthop *);
+
+extern char *		rtnl_route_nh_flags2str(int, char *, size_t);
+extern int		rtnl_route_nh_str2flags(const char *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/route/pktloc.h libnl/include/netlink/route/pktloc.h
--- libnl_kk/include/netlink/route/pktloc.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/route/pktloc.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,44 @@
+/*
+ * netlink/route/pktloc.h         Packet Location Aliasing
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2010 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_PKTLOC_H_
+#define NETLINK_PKTLOC_H_
+
+#include <netlink/netlink.h>
+#include <netlink/cache.h>
+#include <netlink/route/tc.h>
+
+#include <linux/tc_ematch/tc_em_cmp.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct rtnl_pktloc
+{
+	char *			name;
+	uint8_t			align:4;
+	uint8_t			layer:4;
+	uint8_t			flags;
+	uint16_t		offset;
+	uint32_t		mask;
+
+	struct nl_list_head	list;
+};
+
+extern int rtnl_pktloc_lookup(const char *, struct rtnl_pktloc **);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/route/qdisc.h libnl/include/netlink/route/qdisc.h
--- libnl_kk/include/netlink/route/qdisc.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/route/qdisc.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,73 @@
+/*
+ * netlink/route/qdisc.h         Queueing Disciplines
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_QDISC_H_
+#define NETLINK_QDISC_H_
+
+#include <netlink/netlink.h>
+#include <netlink/cache.h>
+#include <netlink/route/tc.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct rtnl_qdisc;
+
+extern struct nl_object_ops qdisc_obj_ops;
+
+extern struct rtnl_qdisc *rtnl_qdisc_alloc(void);
+extern void	rtnl_qdisc_put(struct rtnl_qdisc *);
+
+extern int	rtnl_qdisc_alloc_cache(struct nl_sock *, struct nl_cache **);
+extern struct rtnl_qdisc *rtnl_qdisc_get(struct nl_cache *, int, uint32_t);
+extern struct rtnl_qdisc *rtnl_qdisc_get_by_parent(struct nl_cache *,
+						   int, uint32_t);
+
+extern int	rtnl_qdisc_build_add_request(struct rtnl_qdisc *, int,
+					     struct nl_msg **);
+extern int	rtnl_qdisc_add(struct nl_sock *, struct rtnl_qdisc *, int);
+
+extern int	rtnl_qdisc_build_change_request(struct rtnl_qdisc *,
+						struct rtnl_qdisc *,
+						struct nl_msg **);
+extern int	rtnl_qdisc_change(struct nl_sock *, struct rtnl_qdisc *,
+				  struct rtnl_qdisc *);
+
+extern int	rtnl_qdisc_build_delete_request(struct rtnl_qdisc *,
+						struct nl_msg **);
+extern int	rtnl_qdisc_delete(struct nl_sock *, struct rtnl_qdisc *);
+
+extern void	rtnl_qdisc_set_ifindex(struct rtnl_qdisc *, int);
+extern int	rtnl_qdisc_get_ifindex(struct rtnl_qdisc *);
+extern void	rtnl_qdisc_set_handle(struct rtnl_qdisc *, uint32_t);
+extern uint32_t	rtnl_qdisc_get_handle(struct rtnl_qdisc *);
+extern void	rtnl_qdisc_set_parent(struct rtnl_qdisc *, uint32_t);
+extern uint32_t	rtnl_qdisc_get_parent(struct rtnl_qdisc *);
+extern void	rtnl_qdisc_set_kind(struct rtnl_qdisc *, const char *);
+extern char *	rtnl_qdisc_get_kind(struct rtnl_qdisc *);
+extern uint64_t	rtnl_qdisc_get_stat(struct rtnl_qdisc *, enum rtnl_tc_stats_id);
+
+extern void	rtnl_qdisc_foreach_child(struct rtnl_qdisc *, struct nl_cache *,
+					 void (*cb)(struct nl_object *, void *),
+					 void *);
+
+extern void	rtnl_qdisc_foreach_cls(struct rtnl_qdisc *, struct nl_cache *,
+				       void (*cb)(struct nl_object *, void *),
+				       void *);
+
+extern struct nl_msg *	rtnl_qdisc_get_opts(struct rtnl_qdisc *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/route/qdisc-modules.h libnl/include/netlink/route/qdisc-modules.h
--- libnl_kk/include/netlink/route/qdisc-modules.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/route/qdisc-modules.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,75 @@
+/*
+ * netlink/route/qdisc-modules.h       Qdisc Module API
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2006 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_QDISC_MODULES_H_
+#define NETLINK_QDISC_MODULES_H_
+
+#include <netlink/netlink.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * Qdisc Operations
+ * @ingroup qdisc
+ */
+struct rtnl_qdisc_ops
+{
+	/**
+	 * Kind/Name of Qdisc
+	 */
+	char qo_kind[32];
+
+	/**
+	 * Dump callbacks
+	 */
+	void  (*qo_dump[NL_DUMP_MAX+1])(struct rtnl_qdisc *,
+					struct nl_dump_params *);
+
+	/**
+	 * Must return the contents supposed to be in TCA_OPTIONS
+	 */
+	struct nl_msg *(*qo_get_opts)(struct rtnl_qdisc *);
+
+	int (*qo_build_msg)(struct rtnl_qdisc *, struct nl_msg *);
+
+	/**
+	 * TCA_OPTIONS message parser
+	 */
+	int  (*qo_msg_parser)(struct rtnl_qdisc *);
+
+	/**
+	 * Called before a Qdisc object gets destroyed
+	 */
+	void (*qo_free_data)(struct rtnl_qdisc *);
+
+	/**
+	 * Called whenever a qdisc object needs to be cloned
+	 */
+	int  (*qo_clone)(struct rtnl_qdisc *, struct rtnl_qdisc *);
+
+	/**
+	 * INTERNAL (Do not use)
+	 */
+	struct rtnl_qdisc_ops *qo_next;
+};
+
+extern int			rtnl_qdisc_register(struct rtnl_qdisc_ops *);
+extern int			rtnl_qdisc_unregister(struct rtnl_qdisc_ops *);
+extern struct rtnl_qdisc_ops *	rtnl_qdisc_lookup_ops(struct rtnl_qdisc *);
+extern struct rtnl_qdisc_ops *	__rtnl_qdisc_lookup_ops(const char *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/route/route.h libnl/include/netlink/route/route.h
--- libnl_kk/include/netlink/route/route.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/route/route.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,124 @@
+/*
+ * netlink/route/route.h	Routes
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_ROUTE_H_
+#define NETLINK_ROUTE_H_
+
+#include <netlink/netlink.h>
+#include <netlink/cache.h>
+#include <netlink/addr.h>
+#include <netlink/data.h>
+#include <netlink/route/nexthop.h>
+#include <netlink/route/rtnl.h>
+#include <linux/in_route.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* flags */
+#define ROUTE_CACHE_CONTENT	1
+
+struct rtnl_route;
+
+struct rtnl_rtcacheinfo
+{
+	uint32_t	rtci_clntref;
+	uint32_t	rtci_last_use;
+	uint32_t	rtci_expires;
+	int32_t		rtci_error;
+	uint32_t	rtci_used;
+	uint32_t	rtci_id;
+	uint32_t	rtci_ts;
+	uint32_t	rtci_tsage;
+};
+
+extern struct nl_object_ops route_obj_ops;
+
+extern struct rtnl_route *	rtnl_route_alloc(void);
+extern void	rtnl_route_put(struct rtnl_route *);
+extern int	rtnl_route_alloc_cache(struct nl_sock *, int, int,
+				       struct nl_cache **);
+
+extern void	rtnl_route_get(struct rtnl_route *);
+extern void	rtnl_route_put(struct rtnl_route *);
+
+extern int	rtnl_route_parse(struct nlmsghdr *, struct rtnl_route **);
+extern int	rtnl_route_build_msg(struct nl_msg *, struct rtnl_route *);
+
+extern int	rtnl_route_build_add_request(struct rtnl_route *, int,
+					     struct nl_msg **);
+extern int	rtnl_route_add(struct nl_sock *, struct rtnl_route *, int);
+extern int	rtnl_route_build_del_request(struct rtnl_route *, int,
+					     struct nl_msg **);
+extern int	rtnl_route_delete(struct nl_sock *, struct rtnl_route *, int);
+
+extern void	rtnl_route_set_table(struct rtnl_route *, uint32_t);
+extern uint32_t	rtnl_route_get_table(struct rtnl_route *);
+extern void	rtnl_route_set_scope(struct rtnl_route *, uint8_t);
+extern uint8_t	rtnl_route_get_scope(struct rtnl_route *);
+extern void	rtnl_route_set_tos(struct rtnl_route *, uint8_t);
+extern uint8_t	rtnl_route_get_tos(struct rtnl_route *);
+extern void	rtnl_route_set_protocol(struct rtnl_route *, uint8_t);
+extern uint8_t	rtnl_route_get_protocol(struct rtnl_route *);
+extern void	rtnl_route_set_priority(struct rtnl_route *, uint32_t);
+extern uint32_t	rtnl_route_get_priority(struct rtnl_route *);
+extern int	rtnl_route_set_family(struct rtnl_route *, uint8_t);
+extern uint8_t	rtnl_route_get_family(struct rtnl_route *);
+extern int	rtnl_route_set_type(struct rtnl_route *, uint8_t);
+extern uint8_t	rtnl_route_get_type(struct rtnl_route *);
+extern void	rtnl_route_set_flags(struct rtnl_route *, uint32_t);
+extern void	rtnl_route_unset_flags(struct rtnl_route *, uint32_t);
+extern uint32_t	rtnl_route_get_flags(struct rtnl_route *);
+extern int	rtnl_route_set_metric(struct rtnl_route *, int, unsigned int);
+extern int	rtnl_route_unset_metric(struct rtnl_route *, int);
+extern int	rtnl_route_get_metric(struct rtnl_route *, int, uint32_t *);
+extern int	rtnl_route_set_dst(struct rtnl_route *, struct nl_addr *);
+extern struct nl_addr *rtnl_route_get_dst(struct rtnl_route *);
+extern int	rtnl_route_set_src(struct rtnl_route *, struct nl_addr *);
+extern struct nl_addr *rtnl_route_get_src(struct rtnl_route *);
+extern int	rtnl_route_set_pref_src(struct rtnl_route *, struct nl_addr *);
+extern struct nl_addr *rtnl_route_get_pref_src(struct rtnl_route *);
+extern void	rtnl_route_set_iif(struct rtnl_route *, int);
+extern int	rtnl_route_get_iif(struct rtnl_route *);
+extern int	rtnl_route_get_src_len(struct rtnl_route *);
+
+extern void	rtnl_route_add_nexthop(struct rtnl_route *,
+				       struct rtnl_nexthop *);
+extern void	rtnl_route_remove_nexthop(struct rtnl_route *,
+					  struct rtnl_nexthop *);
+extern struct nl_list_head *rtnl_route_get_nexthops(struct rtnl_route *);
+extern int	rtnl_route_get_nnexthops(struct rtnl_route *);
+
+extern void	rtnl_route_foreach_nexthop(struct rtnl_route *r,
+                                 void (*cb)(struct rtnl_nexthop *, void *),
+                                 void *arg);
+
+extern struct rtnl_nexthop * rtnl_route_nexthop_n(struct rtnl_route *r, int n);
+
+extern int	rtnl_route_guess_scope(struct rtnl_route *);
+
+extern char *	rtnl_route_table2str(int, char *, size_t);
+extern int	rtnl_route_str2table(const char *);
+extern int	rtnl_route_read_table_names(const char *);
+
+extern char *	rtnl_route_proto2str(int, char *, size_t);
+extern int	rtnl_route_str2proto(const char *);
+extern int	rtnl_route_read_protocol_names(const char *);
+
+extern char *	rtnl_route_metric2str(int, char *, size_t);
+extern int	rtnl_route_str2metric(const char *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/route/rtnl.h libnl/include/netlink/route/rtnl.h
--- libnl_kk/include/netlink/route/rtnl.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/route/rtnl.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,69 @@
+/*
+ * netlink/route/rtnl.h		Routing Netlink
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_RTNL_H_
+#define NETLINK_RTNL_H_
+
+#include <netlink/netlink.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @name Realms
+ * @{
+ */
+
+/**
+ * Mask specying the size of each realm part
+ * @ingroup rtnl
+ */
+#define RTNL_REALM_MASK (0xFFFF)
+
+/**
+ * Extract FROM realm from a realms field
+ */
+#define RTNL_REALM_FROM(realm) ((realm) >> 16)
+
+/**
+ * Extract TO realm from a realms field
+ */
+#define RTNL_REALM_TO(realm) ((realm) & RTNL_REALM_MASK)
+
+/**
+ * Build a realms field
+ */
+#define RTNL_MAKE_REALM(from, to) \
+	((RTNL_REALM_TO(from) << 16) & RTNL_REALM_TO(to))
+
+/** @} */
+
+
+/* General */
+extern int		nl_rtgen_request(struct nl_sock *, int, int, int);
+
+/* Routing Type Translations */
+extern char *		nl_rtntype2str(int, char *, size_t);
+extern int		nl_str2rtntype(const char *);
+
+/* Scope Translations */
+extern char *		rtnl_scope2str(int, char *, size_t);
+extern int		rtnl_str2scope(const char *);
+
+/* Realms Translations */
+extern char *		rtnl_realms2str(uint32_t, char *, size_t);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/route/rule.h libnl/include/netlink/route/rule.h
--- libnl_kk/include/netlink/route/rule.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/route/rule.h	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,78 @@
+/*
+ * netlink/route/rule.h		Rules
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_RULE_H_
+#define NETLINK_RULE_H_
+
+#include <netlink/netlink.h>
+#include <netlink/cache.h>
+#include <netlink/addr.h>
+#include <netlink/route/route.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct rtnl_rule;
+
+/* General */
+extern struct rtnl_rule *	rtnl_rule_alloc(void);
+extern void			rtnl_rule_put(struct rtnl_rule *);
+
+extern int	rtnl_rule_alloc_cache(struct nl_sock *, int,
+				      struct nl_cache **);
+extern void rtnl_rule_dump(struct rtnl_rule *, FILE *, struct nl_dump_params *);
+
+extern int	rtnl_rule_build_add_request(struct rtnl_rule *, int,
+					    struct nl_msg **);
+extern int rtnl_rule_add(struct nl_sock *, struct rtnl_rule *, int);
+extern int	rtnl_rule_build_delete_request(struct rtnl_rule *, int,
+					       struct nl_msg **);
+extern int rtnl_rule_delete(struct nl_sock *, struct rtnl_rule *, int);
+
+
+/* attribute modification */
+extern void		rtnl_rule_set_family(struct rtnl_rule *, int);
+extern int		rtnl_rule_get_family(struct rtnl_rule *);
+extern void		rtnl_rule_set_prio(struct rtnl_rule *, int);
+extern int		rtnl_rule_get_prio(struct rtnl_rule *);
+extern void		rtnl_rule_set_mark(struct rtnl_rule *, uint64_t);
+extern uint64_t		rtnl_rule_get_mark(struct rtnl_rule *);
+extern void		rtnl_rule_set_table(struct rtnl_rule *, int);
+extern int		rtnl_rule_get_table(struct rtnl_rule *);
+extern void		rtnl_rule_set_dsfield(struct rtnl_rule *, int);
+extern int		rtnl_rule_get_dsfield(struct rtnl_rule *);
+extern int		rtnl_rule_set_src(struct rtnl_rule *, struct nl_addr *);
+extern struct nl_addr *	rtnl_rule_get_src(struct rtnl_rule *);
+extern int		rtnl_rule_set_dst(struct rtnl_rule *, struct nl_addr *);
+extern struct nl_addr *	rtnl_rule_get_dst(struct rtnl_rule *);
+extern void		rtnl_rule_set_src_len(struct rtnl_rule *, int);
+extern int		rtnl_rule_get_src_len(struct rtnl_rule *);
+extern void		rtnl_rule_set_dst_len(struct rtnl_rule *, int);
+extern int		rtnl_rule_get_dst_len(struct rtnl_rule *);
+
+extern void		rtnl_rule_set_action(struct rtnl_rule *, int);
+extern int		rtnl_rule_get_action(struct rtnl_rule *);
+
+extern int		rtnl_rule_set_iif(struct rtnl_rule *, const char *);
+extern char *		rtnl_rule_get_iif(struct rtnl_rule *);
+
+extern void		rtnl_rule_set_classid(struct rtnl_rule *, uint32_t);
+extern uint32_t		rtnl_rule_get_classid(struct rtnl_rule *);
+
+extern void		rtnl_rule_set_realms(struct rtnl_rule *, uint32_t);
+extern uint32_t		rtnl_rule_get_realms(struct rtnl_rule *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/route/sch/cbq.h libnl/include/netlink/route/sch/cbq.h
--- libnl_kk/include/netlink/route/sch/cbq.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/route/sch/cbq.h	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,30 @@
+/*
+ * netlink/route/sch/cbq.h	Class Based Queueing
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2006 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_CBQ_H_
+#define NETLINK_CBQ_H_
+
+#include <netlink/netlink.h>
+#include <netlink/cache.h>
+#include <netlink/route/qdisc.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern char * nl_ovl_strategy2str(int, char *, size_t);
+extern int    nl_str2ovl_strategy(const char *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/route/sch/dsmark.h libnl/include/netlink/route/sch/dsmark.h
--- libnl_kk/include/netlink/route/sch/dsmark.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/route/sch/dsmark.h	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,41 @@
+/*
+ * netlink/route/sch/dsmark.h	DSMARK
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2006 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_DSMARK_H_
+#define NETLINK_DSMARK_H_
+
+#include <netlink/netlink.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern int	rtnl_class_dsmark_set_bmask(struct rtnl_class *, uint8_t);
+extern int	rtnl_class_dsmark_get_bmask(struct rtnl_class *);
+
+extern int	rtnl_class_dsmark_set_value(struct rtnl_class *, uint8_t);
+extern int	rtnl_class_dsmark_get_value(struct rtnl_class *);
+
+extern int	rtnl_qdisc_dsmark_set_indices(struct rtnl_qdisc *, uint16_t);
+extern int	rtnl_qdisc_dsmark_get_indices(struct rtnl_qdisc *);
+
+extern int	rtnl_qdisc_dsmark_set_default_index(struct rtnl_qdisc *,
+						    uint16_t);
+extern int	rtnl_qdisc_dsmark_get_default_index(struct rtnl_qdisc *);
+
+extern int	rtnl_qdisc_dsmark_set_set_tc_index(struct rtnl_qdisc *, int);
+extern int	rtnl_qdisc_dsmark_get_set_tc_index(struct rtnl_qdisc *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/route/sch/fifo.h libnl/include/netlink/route/sch/fifo.h
--- libnl_kk/include/netlink/route/sch/fifo.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/route/sch/fifo.h	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,28 @@
+/*
+ * netlink/route/sch/fifo.c	FIFO Qdisc
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2006 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_FIFO_H_
+#define NETLINK_FIFO_H_
+
+#include <netlink/netlink.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern int	rtnl_qdisc_fifo_set_limit(struct rtnl_qdisc *, int);
+extern int	rtnl_qdisc_fifo_get_limit(struct rtnl_qdisc *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/route/sch/htb.h libnl/include/netlink/route/sch/htb.h
--- libnl_kk/include/netlink/route/sch/htb.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/route/sch/htb.h	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,41 @@
+/*
+ * netlink/route/sch/htb.h	HTB Qdisc
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2006 Thomas Graf <tgraf@suug.ch>
+ * Copyright (c) 2005 Petr Gotthard <petr.gotthard@siemens.com>
+ * Copyright (c) 2005 Siemens AG Oesterreich
+ */
+
+#ifndef NETLINK_HTB_H_
+#define NETLINK_HTB_H_
+
+#include <netlink/netlink.h>
+#include <netlink/route/tc.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern void rtnl_htb_set_rate2quantum(struct rtnl_qdisc *, uint32_t);
+extern void rtnl_htb_set_defcls(struct rtnl_qdisc *, uint32_t);
+
+extern void rtnl_htb_set_prio(struct rtnl_class *, uint32_t);
+extern void rtnl_htb_set_mtu(struct rtnl_class *, uint32_t);
+extern void rtnl_htb_set_rate(struct rtnl_class *, uint32_t);
+extern void rtnl_htb_set_ceil(struct rtnl_class *, uint32_t);
+extern void rtnl_htb_set_rbuffer(struct rtnl_class *, uint32_t);
+extern void rtnl_htb_set_cbuffer(struct rtnl_class *, uint32_t);
+extern void rtnl_htb_set_quantum(struct rtnl_class *, uint32_t quantum);
+extern void rtnl_htb_set_overhead(struct rtnl_class *, uint8_t overhead);
+extern void rtnl_htb_set_mpu(struct rtnl_class *, uint8_t mpu);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/route/sch/netem.h libnl/include/netlink/route/sch/netem.h
--- libnl_kk/include/netlink/route/sch/netem.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/route/sch/netem.h	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,75 @@
+/*
+ * netlink/route/sch/netem.h		Network Emulator Qdisc
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2006 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_NETEM_H_
+#define NETLINK_NETEM_H_
+
+#include <netlink/netlink.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern int rtnl_netem_set_limit(struct rtnl_qdisc *, int);
+extern int rtnl_netem_get_limit(struct rtnl_qdisc *);
+
+/* Packet Re-ordering */
+extern int rtnl_netem_set_gap(struct rtnl_qdisc *, int);
+extern int rtnl_netem_get_gap(struct rtnl_qdisc *);
+
+extern int rtnl_netem_set_reorder_probability(struct rtnl_qdisc *, int);
+extern int rtnl_netem_get_reorder_probability(struct rtnl_qdisc *);
+
+extern int rtnl_netem_set_reorder_correlation(struct rtnl_qdisc *, int);
+extern int rtnl_netem_get_reorder_correlation(struct rtnl_qdisc *);
+
+/* Corruption */
+extern int rtnl_netem_set_corruption_probability(struct rtnl_qdisc *, int);
+extern int rtnl_netem_get_corruption_probability(struct rtnl_qdisc *);
+
+extern int rtnl_netem_set_corruption_correlation(struct rtnl_qdisc *, int);
+extern int rtnl_netem_get_corruption_correlation(struct rtnl_qdisc *);
+
+/* Packet Loss */
+extern int rtnl_netem_set_loss(struct rtnl_qdisc *, int);
+extern int rtnl_netem_get_loss(struct rtnl_qdisc *);
+
+extern int rtnl_netem_set_loss_correlation(struct rtnl_qdisc *, int);
+extern int rtnl_netem_get_loss_correlation(struct rtnl_qdisc *);
+
+/* Packet Duplication */
+extern int rtnl_netem_set_duplicate(struct rtnl_qdisc *, int);
+extern int rtnl_netem_get_duplicate(struct rtnl_qdisc *);
+
+extern int rtnl_netem_set_duplicate_correlation(struct rtnl_qdisc *, int);
+extern int rtnl_netem_get_duplicate_correlation(struct rtnl_qdisc *);
+
+/* Packet Delay */
+extern int rtnl_netem_set_delay(struct rtnl_qdisc *, int);
+extern int rtnl_netem_get_delay(struct rtnl_qdisc *);
+
+extern int rtnl_netem_set_jitter(struct rtnl_qdisc *, int);
+extern int rtnl_netem_get_jitter(struct rtnl_qdisc *);
+
+extern int rtnl_netem_set_delay_correlation(struct rtnl_qdisc *, int);
+extern int rtnl_netem_get_delay_correlation(struct rtnl_qdisc *);
+
+/* Delay Distribution */
+#define MAXDIST 65536
+extern int rtnl_netem_set_delay_distribution(struct rtnl_qdisc *, const char *);
+extern int rtnl_netem_get_delay_distribution_size(struct rtnl_qdisc *);
+extern int rtnl_netem_get_delay_distribution(struct rtnl_qdisc *, int16_t **);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/route/sch/prio.h libnl/include/netlink/route/sch/prio.h
--- libnl_kk/include/netlink/route/sch/prio.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/route/sch/prio.h	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,53 @@
+/*
+ * netlink/route/sch/prio.c	PRIO Qdisc
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2006 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_PRIO_H_
+#define NETLINK_PRIO_H_
+
+#include <netlink/netlink.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @name Default Values
+ * @{
+ */
+
+/**
+ * Default number of bands.
+ * @ingroup prio
+ */
+#define QDISC_PRIO_DEFAULT_BANDS 3
+
+/**
+ * Default priority mapping.
+ * @ingroup prio
+ */
+#define QDISC_PRIO_DEFAULT_PRIOMAP \
+		{ 1, 2, 2, 2, 1, 2, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1 }
+
+/** @} */
+
+extern int  rtnl_qdisc_prio_set_bands(struct rtnl_qdisc *, int);
+extern int  rtnl_qdisc_prio_get_bands(struct rtnl_qdisc *);
+extern int  rtnl_qdisc_prio_set_priomap(struct rtnl_qdisc *, uint8_t[], int);
+extern uint8_t *rtnl_qdisc_prio_get_priomap(struct rtnl_qdisc *);
+
+extern char *	rtnl_prio2str(int, char *, size_t);
+extern int	rtnl_str2prio(const char *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/route/sch/red.h libnl/include/netlink/route/sch/red.h
--- libnl_kk/include/netlink/route/sch/red.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/route/sch/red.h	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,17 @@
+/*
+ * netlink/route/sch/red.h	RED Qdisc
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2006 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_RED_H_
+#define NETLINK_RED_H_
+
+#include <netlink/netlink.h>
+
+#endif
diff -uNr libnl_kk/include/netlink/route/sch/sfq.h libnl/include/netlink/route/sch/sfq.h
--- libnl_kk/include/netlink/route/sch/sfq.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/route/sch/sfq.h	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,36 @@
+/*
+ * netlink/route/sch/sfq.c	SFQ Qdisc
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2006 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_SFQ_H_
+#define NETLINK_SFQ_H_
+
+#include <netlink/netlink.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern int	rtnl_sfq_set_quantum(struct rtnl_qdisc *, int);
+extern int	rtnl_sfq_get_quantum(struct rtnl_qdisc *);
+
+extern int	rtnl_sfq_set_limit(struct rtnl_qdisc *, int);
+extern int	rtnl_sfq_get_limit(struct rtnl_qdisc *);
+
+extern int	rtnl_sfq_set_perturb(struct rtnl_qdisc *, int);
+extern int	rtnl_sfq_get_perturb(struct rtnl_qdisc *);
+
+extern int	rtnl_sfq_get_divisor(struct rtnl_qdisc *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/route/sch/tbf.h libnl/include/netlink/route/sch/tbf.h
--- libnl_kk/include/netlink/route/sch/tbf.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/route/sch/tbf.h	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,43 @@
+/*
+ * netlink/route/sch/tbf.h	TBF Qdisc
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2006 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_TBF_H_
+#define NETLINK_TBF_H_
+
+#include <netlink/netlink.h>
+#include <netlink/route/tc.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern int rtnl_qdisc_tbf_set_limit(struct rtnl_qdisc *, int);
+extern int rtnl_qdisc_tbf_set_limit_by_latency(struct rtnl_qdisc *, int);
+extern int rtnl_qdisc_tbf_get_limit(struct rtnl_qdisc *);
+
+extern int rtnl_qdisc_tbf_set_mpu(struct rtnl_qdisc *, int);
+extern int rtnl_qdisc_tbf_get_mpu(struct rtnl_qdisc *);
+
+extern int rtnl_qdisc_tbf_set_rate(struct rtnl_qdisc *, int, int, int);
+extern int rtnl_qdisc_tbf_get_rate(struct rtnl_qdisc *);
+extern int rtnl_qdisc_tbf_get_rate_bucket(struct rtnl_qdisc *);
+extern int rtnl_qdisc_tbf_get_rate_cell(struct rtnl_qdisc *);
+
+extern int rtnl_qdisc_tbf_set_peakrate(struct rtnl_qdisc *, int, int, int);
+extern int rtnl_qdisc_tbf_get_peakrate(struct rtnl_qdisc *);
+extern int rtnl_qdisc_tbf_get_peakrate_bucket(struct rtnl_qdisc *);
+extern int rtnl_qdisc_tbf_get_peakrate_cell(struct rtnl_qdisc *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/route/tc.h libnl/include/netlink/route/tc.h
--- libnl_kk/include/netlink/route/tc.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/route/tc.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,63 @@
+/*
+ * netlink/route/tc.h		Traffic Control
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2006 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_TC_H_
+#define NETLINK_TC_H_
+
+#include <netlink/netlink.h>
+#include <netlink/cache.h>
+#include <netlink/data.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * TC statistics identifiers
+ * @ingroup tc
+ */
+enum rtnl_tc_stats_id {
+	RTNL_TC_PACKETS,	/**< Packets seen */
+	RTNL_TC_BYTES,		/**< Bytes seen */
+	RTNL_TC_RATE_BPS,	/**< Current bits/s (rate estimator) */
+	RTNL_TC_RATE_PPS,	/**< Current packet/s (rate estimator) */
+	RTNL_TC_QLEN,		/**< Queue length */
+	RTNL_TC_BACKLOG,	/**< Backlog length */
+	RTNL_TC_DROPS,		/**< Packets dropped */
+	RTNL_TC_REQUEUES,	/**< Number of requeues */
+	RTNL_TC_OVERLIMITS,	/**< Number of overlimits */
+	__RTNL_TC_STATS_MAX,
+};
+
+#define RTNL_TC_STATS_MAX (__RTNL_TC_STATS_MAX - 1)
+
+extern int rtnl_tc_calc_txtime(int, int);
+extern int rtnl_tc_calc_bufsize(int, int);
+extern int rtnl_tc_calc_cell_log(int);
+
+/**
+ * Number of entries in a transmission time lookup table
+ * @ingroup tc
+ */
+#define RTNL_TC_RTABLE_SIZE	256
+
+extern int rtnl_tc_build_rate_table(uint32_t *, uint8_t, uint8_t, int, int);
+
+
+/* TC Handle Translations */
+extern char *		rtnl_tc_handle2str(uint32_t, char *, size_t);
+extern int		rtnl_tc_str2handle(const char *, uint32_t *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/socket.h libnl/include/netlink/socket.h
--- libnl_kk/include/netlink/socket.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/socket.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,66 @@
+/*
+ * netlink/socket.h		Netlink Socket
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_SOCKET_H_
+#define NETLINK_SOCKET_H_
+
+#include <netlink/types.h>
+#include <netlink/handlers.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern struct nl_sock *	nl_socket_alloc(void);
+extern struct nl_sock *	nl_socket_alloc_cb(struct nl_cb *);
+extern void		nl_socket_free(struct nl_sock *);
+
+extern uint32_t		nl_socket_get_local_port(struct nl_sock *);
+extern void		nl_socket_set_local_port(struct nl_sock *, uint32_t);
+
+extern int		nl_socket_add_memberships(struct nl_sock *, int, ...);
+extern int		nl_socket_add_membership(struct nl_sock *, int);
+extern int		nl_socket_drop_memberships(struct nl_sock *, int, ...);
+extern int		nl_socket_drop_membership(struct nl_sock *,
+							  int);
+extern void		nl_join_groups(struct nl_sock *, int);
+
+
+extern uint32_t		nl_socket_get_peer_port(struct nl_sock *);
+extern void		nl_socket_set_peer_port(struct nl_sock *,
+							uint32_t);
+
+extern struct nl_cb *	nl_socket_get_cb(struct nl_sock *);
+extern void		nl_socket_set_cb(struct nl_sock *,
+						 struct nl_cb *);
+extern int		nl_socket_modify_cb(struct nl_sock *, enum nl_cb_type,
+					    enum nl_cb_kind,
+					    nl_recvmsg_msg_cb_t, void *);
+
+extern int		nl_socket_set_buffer_size(struct nl_sock *, int, int);
+extern int		nl_socket_set_passcred(struct nl_sock *, int);
+extern int		nl_socket_recv_pktinfo(struct nl_sock *, int);
+
+extern void		nl_socket_disable_seq_check(struct nl_sock *);
+extern unsigned int	nl_socket_use_seq(struct nl_sock *);
+extern void		nl_socket_disable_auto_ack(struct nl_sock *);
+extern void		nl_socket_enable_auto_ack(struct nl_sock *);
+
+extern int		nl_socket_get_fd(struct nl_sock *);
+extern int		nl_socket_set_nonblocking(struct nl_sock *);
+extern void		nl_socket_enable_msg_peek(struct nl_sock *);
+extern void		nl_socket_disable_msg_peek(struct nl_sock *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/types.h libnl/include/netlink/types.h
--- libnl_kk/include/netlink/types.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/types.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,111 @@
+/*
+ * netlink/netlink-types.h	Netlink Types
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2006 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef __NETLINK_TYPES_H_
+#define __NETLINK_TYPES_H_
+
+#include <stdio.h>
+
+/**
+ * Dumping types (dp_type)
+ * @ingroup utils
+ */
+enum nl_dump_type {
+	NL_DUMP_LINE,		/**< Dump object briefly on one line */
+	NL_DUMP_DETAILS,	/**< Dump all attributes but no statistics */
+	NL_DUMP_STATS,		/**< Dump all attributes including statistics */
+	NL_DUMP_ENV,		/**< Dump all attribtues as env variables */
+	__NL_DUMP_MAX,
+};
+#define NL_DUMP_MAX (__NL_DUMP_MAX - 1)
+
+/**
+ * Dumping parameters
+ * @ingroup utils
+ */
+struct nl_dump_params
+{
+	/**
+	 * Specifies the type of dump that is requested.
+	 */
+	enum nl_dump_type	dp_type;
+
+	/**
+	 * Specifies the number of whitespaces to be put in front
+	 * of every new line (indentation).
+	 */
+	int			dp_prefix;
+
+	/**
+	 * Causes the cache index to be printed for each element.
+	 */
+	int			dp_print_index;
+
+	/**
+	 * Causes each element to be prefixed with the message type.
+	 */
+	int			dp_dump_msgtype;
+
+	/**
+	 * A callback invoked for output
+	 *
+	 * Passed arguments are:
+	 *  - dumping parameters
+	 *  - string to append to the output
+	 */
+	void			(*dp_cb)(struct nl_dump_params *, char *);
+
+	/**
+	 * A callback invoked for every new line, can be used to
+	 * customize the indentation.
+	 *
+	 * Passed arguments are:
+	 *  - dumping parameters
+	 *  - line number starting from 0
+	 */
+	void			(*dp_nl_cb)(struct nl_dump_params *, int);
+
+	/**
+	 * User data pointer, can be used to pass data to callbacks.
+	 */
+	void			*dp_data;
+
+	/**
+	 * File descriptor the dumping output should go to
+	 */
+	FILE *			dp_fd;
+
+	/**
+	 * Alternatively the output may be redirected into a buffer
+	 */
+	char *			dp_buf;
+
+	/**
+	 * Length of the buffer dp_buf
+	 */
+	size_t			dp_buflen;
+
+	/**
+	 * PRIVATE
+	 * Set if a dump was performed prior to the actual dump handler.
+	 */
+	int			dp_pre_dump;
+
+	/**
+	 * PRIVATE
+	 * Owned by the current caller
+	 */
+	int			dp_ivar;
+
+	unsigned int		dp_line;
+};
+
+#endif
diff -uNr libnl_kk/include/netlink/utils.h libnl/include/netlink/utils.h
--- libnl_kk/include/netlink/utils.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/utils.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,78 @@
+/*
+ * netlink/utils.h		Utility Functions
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_UTILS_H_
+#define NETLINK_UTILS_H_
+
+#include <netlink/netlink.h>
+#include <netlink/list.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @name Probability Constants
+ * @{
+ */
+
+/**
+ * Lower probability limit
+ * @ingroup utils
+ */
+#define NL_PROB_MIN 0x0
+
+/**
+ * Upper probability limit
+ * @ingroup utils
+ */
+#define NL_PROB_MAX 0xffffffff
+
+/** @} */
+
+/* unit pretty-printing */
+extern double	nl_cancel_down_bytes(unsigned long long, char **);
+extern double	nl_cancel_down_bits(unsigned long long, char **);
+extern double	nl_cancel_down_us(uint32_t, char **);
+
+/* generic unit translations */
+extern long	nl_size2int(const char *);
+extern long	nl_prob2int(const char *);
+
+/* time translations */
+extern int	nl_get_hz(void);
+extern uint32_t	nl_us2ticks(uint32_t);
+extern uint32_t	nl_ticks2us(uint32_t);
+extern int	nl_str2msec(const char *, uint64_t *);
+extern char *	nl_msec2str(uint64_t, char *, size_t);
+
+/* link layer protocol translations */
+extern char *	nl_llproto2str(int, char *, size_t);
+extern int	nl_str2llproto(const char *);
+
+/* ethernet protocol translations */
+extern char *	nl_ether_proto2str(int, char *, size_t);
+extern int	nl_str2ether_proto(const char *);
+
+/* IP protocol translations */
+extern char *	nl_ip_proto2str(int, char *, size_t);
+extern int	nl_str2ip_proto(const char *);
+
+/* Dumping helpers */
+extern void	nl_new_line(struct nl_dump_params *);
+extern void	nl_dump(struct nl_dump_params *, const char *, ...);
+extern void	nl_dump_line(struct nl_dump_params *, const char *, ...);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink/version.h libnl/include/netlink/version.h
--- libnl_kk/include/netlink/version.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/version.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,18 @@
+/*
+ * netlink/version.h	Compile Time Versioning Information
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_VERSION_H_
+#define NETLINK_VERSION_H_
+
+#define LIBNL_STRING "libnl 2.0"
+#define LIBNL_VERSION "2.0"
+
+#endif
diff -uNr libnl_kk/include/netlink/version.h.in libnl/include/netlink/version.h.in
--- libnl_kk/include/netlink/version.h.in	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink/version.h.in	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,18 @@
+/*
+ * netlink/version.h	Compile Time Versioning Information
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_VERSION_H_
+#define NETLINK_VERSION_H_
+
+#define LIBNL_STRING "@PACKAGE_STRING@"
+#define LIBNL_VERSION "@PACKAGE_VERSION@"
+
+#endif
diff -uNr libnl_kk/include/netlink-generic.h libnl/include/netlink-generic.h
--- libnl_kk/include/netlink-generic.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink-generic.h	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,20 @@
+/*
+ * netlink-generic.h	Local Generic Netlink Interface
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2006 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_GENL_PRIV_H_
+#define NETLINK_GENL_PRIV_H_
+
+#include <netlink-local.h>
+#include <netlink/netlink.h>
+
+#define GENL_HDRSIZE(hdrlen) (GENL_HDRLEN + (hdrlen))
+
+#endif
diff -uNr libnl_kk/include/netlink-local.h libnl/include/netlink-local.h
--- libnl_kk/include/netlink-local.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink-local.h	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,183 @@
+/*
+ * netlink-local.h		Local Netlink Interface
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_LOCAL_H_
+#define NETLINK_LOCAL_H_
+
+#include <stdio.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <math.h>
+#include <time.h>
+#include <stdarg.h>
+#include <ctype.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/socket.h>
+#include <inttypes.h>
+#include <assert.h>
+#include <limits.h>
+
+#include <arpa/inet.h>
+#include <netdb.h>
+
+#ifndef SOL_NETLINK
+#define SOL_NETLINK 270
+#endif
+
+#include <linux/types.h>
+
+/* local header copies */
+#include <linux/if.h>
+#include <linux/if_arp.h>
+#include <linux/if_ether.h>
+#include <linux/pkt_sched.h>
+#include <linux/pkt_cls.h>
+#include <linux/gen_stats.h>
+#include <linux/ip_mp_alg.h>
+
+#include <netlink/netlink.h>
+#include <netlink/handlers.h>
+#include <netlink/cache.h>
+#include <netlink/route/tc.h>
+#include <netlink/object-api.h>
+#include <netlink/cache-api.h>
+#include <netlink-types.h>
+
+struct trans_tbl {
+	int i;
+	const char *a;
+};
+
+#define __ADD(id, name) { .i = id, .a = #name },
+
+struct trans_list {
+	int i;
+	char *a;
+	struct nl_list_head list;
+};
+
+#define NL_DEBUG	1
+
+#define NL_DBG(LVL,FMT,ARG...) \
+	do {	\
+		if (LVL <= nl_debug) \
+			fprintf(stderr, "DBG<" #LVL ">: " FMT, ##ARG); \
+	} while (0)
+
+#define BUG()                            \
+	do {                                 \
+		fprintf(stderr, "BUG: %s:%d\n",  \
+			__FILE__, __LINE__);         \
+		assert(0);	\
+	} while (0)
+
+extern int __nl_read_num_str_file(const char *path,
+				  int (*cb)(long, const char *));
+
+extern int __trans_list_add(int, const char *, struct nl_list_head *);
+extern void __trans_list_clear(struct nl_list_head *);
+
+extern char *__type2str(int, char *, size_t, struct trans_tbl *, size_t);
+extern int __str2type(const char *, struct trans_tbl *, size_t);
+
+extern char *__list_type2str(int, char *, size_t, struct nl_list_head *);
+extern int __list_str2type(const char *, struct nl_list_head *);
+
+extern char *__flags2str(int, char *, size_t, struct trans_tbl *, size_t);
+extern int __str2flags(const char *, struct trans_tbl *, size_t);
+
+extern void dump_from_ops(struct nl_object *, struct nl_dump_params *);
+
+static inline struct nl_cache *dp_cache(struct nl_object *obj)
+{
+	if (obj->ce_cache == NULL)
+		return nl_cache_mngt_require(obj->ce_ops->oo_name);
+
+	return obj->ce_cache;
+}
+
+static inline int nl_cb_call(struct nl_cb *cb, int type, struct nl_msg *msg)
+{
+	return cb->cb_set[type](msg, cb->cb_args[type]);
+}
+
+#define ARRAY_SIZE(X) (sizeof(X) / sizeof((X)[0]))
+
+#define __init __attribute__ ((constructor))
+#define __exit __attribute__ ((destructor))
+#undef __deprecated
+#define __deprecated __attribute__ ((deprecated))
+
+#define min(x,y) ({ \
+	typeof(x) _x = (x);	\
+	typeof(y) _y = (y);	\
+	(void) (&_x == &_y);		\
+	_x < _y ? _x : _y; })
+
+#define max(x,y) ({ \
+	typeof(x) _x = (x);	\
+	typeof(y) _y = (y);	\
+	(void) (&_x == &_y);		\
+	_x > _y ? _x : _y; })
+
+#define min_t(type,x,y) \
+	({ type __x = (x); type __y = (y); __x < __y ? __x: __y; })
+#define max_t(type,x,y) \
+	({ type __x = (x); type __y = (y); __x > __y ? __x: __y; })
+
+extern int nl_cache_parse(struct nl_cache_ops *, struct sockaddr_nl *,
+			  struct nlmsghdr *, struct nl_parser_param *);
+
+
+static inline void rtnl_copy_ratespec(struct rtnl_ratespec *dst,
+				      struct tc_ratespec *src)
+{
+	dst->rs_cell_log = src->cell_log;
+	dst->rs_feature = src->feature;
+	dst->rs_addend = src->addend;
+	dst->rs_mpu = src->mpu;
+	dst->rs_rate = src->rate;
+}
+
+static inline void rtnl_rcopy_ratespec(struct tc_ratespec *dst,
+				       struct rtnl_ratespec *src)
+{
+	dst->cell_log = src->rs_cell_log;
+	dst->feature = src->rs_feature;
+	dst->addend = src->rs_addend;
+	dst->mpu = src->rs_mpu;
+	dst->rate = src->rs_rate;
+}
+
+static inline char *nl_cache_name(struct nl_cache *cache)
+{
+	return cache->c_ops ? cache->c_ops->co_name : "unknown";
+}
+
+#define GENL_FAMILY(id, name) \
+	{ \
+		{ id, NL_ACT_UNSPEC, name }, \
+		END_OF_MSGTYPES_LIST, \
+	}
+
+static inline int wait_for_ack(struct nl_sock *sk)
+{
+	if (sk->s_flags & NL_NO_AUTO_ACK)
+		return 0;
+	else
+		return nl_wait_for_ack(sk);
+}
+
+#endif
diff -uNr libnl_kk/include/netlink-tc.h libnl/include/netlink-tc.h
--- libnl_kk/include/netlink-tc.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink-tc.h	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,69 @@
+/*
+ * netlink-tc.h		Local Traffic Control Interface
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_TC_PRIV_H_
+#define NETLINK_TC_PRIV_H_
+
+#include <netlink-local.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define TCA_ATTR_HANDLE    0x001
+#define TCA_ATTR_PARENT    0x002
+#define TCA_ATTR_IFINDEX   0x004
+#define TCA_ATTR_KIND      0x008
+#define TCA_ATTR_FAMILY    0x010
+#define TCA_ATTR_INFO      0x020
+#define TCA_ATTR_OPTS      0x040
+#define TCA_ATTR_STATS     0x080
+#define TCA_ATTR_XSTATS    0x100
+#define TCA_ATTR_MAX	  TCA_ATTR_XSTATS
+
+extern int tca_parse(struct nlattr **, int, struct rtnl_tca *,
+		     struct nla_policy *);
+extern int  tca_msg_parser(struct nlmsghdr *, struct rtnl_tca *);
+extern void tca_free_data(struct rtnl_tca *);
+extern int  tca_clone(struct rtnl_tca *, struct rtnl_tca *);
+extern void tca_dump_line(struct rtnl_tca *, const char *,
+			  struct nl_dump_params *);
+extern void tca_dump_details(struct rtnl_tca *, struct nl_dump_params *);
+extern void tca_dump_stats(struct rtnl_tca *, struct nl_dump_params *);
+extern int  tca_compare(struct nl_object *, struct nl_object *, uint32_t, int);
+
+extern void tca_set_ifindex(struct rtnl_tca *, int);
+extern int  tca_get_ifindex(struct rtnl_tca *);
+extern void tca_set_handle(struct rtnl_tca *, uint32_t);
+extern uint32_t tca_get_handle(struct rtnl_tca *);
+extern void tca_set_parent(struct rtnl_tca *, uint32_t);
+extern uint32_t tca_get_parent(struct rtnl_tca *);
+extern void tca_set_kind(struct rtnl_tca *, const char *);
+extern char *tca_get_kind(struct rtnl_tca *);
+extern uint64_t tca_get_stat(struct rtnl_tca *, int );
+
+extern int tca_build_msg(struct rtnl_tca *, int, int, struct nl_msg **);
+
+static inline void *tca_priv(struct rtnl_tca *tca)
+{
+	return tca->tc_subdata;
+}
+
+static inline void *tca_xstats(struct rtnl_tca *tca)
+{
+	return tca->tc_xstats->d_data;
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr libnl_kk/include/netlink-types.h libnl/include/netlink-types.h
--- libnl_kk/include/netlink-types.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/include/netlink-types.h	2015-09-10 13:39:33.035778085 +0800
@@ -0,0 +1,829 @@
+/*
+ * netlink-types.h	Netlink Types (Private)
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_LOCAL_TYPES_H_
+#define NETLINK_LOCAL_TYPES_H_
+
+#include <netlink/list.h>
+#include <netlink/route/link.h>
+#include <netlink/route/qdisc.h>
+#include <netlink/route/rtnl.h>
+#include <netlink/route/route.h>
+
+#define NL_SOCK_BUFSIZE_SET	(1<<0)
+#define NL_SOCK_PASSCRED	(1<<1)
+#define NL_OWN_PORT		(1<<2)
+#define NL_MSG_PEEK		(1<<3)
+#define NL_NO_AUTO_ACK		(1<<4)
+
+#define NL_MSG_CRED_PRESENT 1
+
+struct nl_cache_ops;
+struct nl_sock;
+struct nl_object;
+
+struct nl_cb
+{
+	nl_recvmsg_msg_cb_t	cb_set[NL_CB_TYPE_MAX+1];
+	void *			cb_args[NL_CB_TYPE_MAX+1];
+	
+	nl_recvmsg_err_cb_t	cb_err;
+	void *			cb_err_arg;
+
+	/** May be used to replace nl_recvmsgs with your own implementation
+	 * in all internal calls to nl_recvmsgs. */
+	int			(*cb_recvmsgs_ow)(struct nl_sock *,
+						  struct nl_cb *);
+
+	/** Overwrite internal calls to nl_recv, must return the number of
+	 * octets read and allocate a buffer for the received data. */
+	int			(*cb_recv_ow)(struct nl_sock *,
+					      struct sockaddr_nl *,
+					      unsigned char **,
+					      struct ucred **);
+
+	/** Overwrites internal calls to nl_send, must send the netlink
+	 * message. */
+	int			(*cb_send_ow)(struct nl_sock *,
+					      struct nl_msg *);
+
+	int			cb_refcnt;
+};
+
+struct nl_sock
+{
+	struct sockaddr_nl	s_local;
+	struct sockaddr_nl	s_peer;
+	int			s_fd;
+	int			s_proto;
+	unsigned int		s_seq_next;
+	unsigned int		s_seq_expect;
+	int			s_flags;
+	struct nl_cb *		s_cb;
+};
+
+struct nl_cache
+{
+	struct nl_list_head	c_items;
+	int			c_nitems;
+	int                     c_iarg1;
+	int                     c_iarg2;
+	struct nl_cache_ops *   c_ops;
+};
+
+struct nl_cache_assoc
+{
+	struct nl_cache *	ca_cache;
+	change_func_t		ca_change;
+	void *			ca_change_data;
+};
+
+struct nl_cache_mngr
+{
+	int			cm_protocol;
+	int			cm_flags;
+	int			cm_nassocs;
+	struct nl_sock *	cm_handle;
+	struct nl_cache_assoc *	cm_assocs;
+};
+
+struct nl_parser_param;
+
+#define LOOSE_COMPARISON	1
+
+#define NL_OBJ_MARK		1
+
+struct nl_object
+{
+	NLHDR_COMMON
+};
+
+struct nl_data
+{
+	size_t			d_size;
+	void *			d_data;
+};
+
+struct nl_addr
+{
+	int			a_family;
+	unsigned int		a_maxsize;
+	unsigned int		a_len;
+	int			a_prefixlen;
+	int			a_refcnt;
+	char			a_addr[0];
+};
+
+struct nl_msg
+{
+	int			nm_protocol;
+	int			nm_flags;
+	struct sockaddr_nl	nm_src;
+	struct sockaddr_nl	nm_dst;
+	struct ucred		nm_creds;
+	struct nlmsghdr *	nm_nlh;
+	size_t			nm_size;
+	int			nm_refcnt;
+};
+
+struct rtnl_link_map
+{
+	uint64_t lm_mem_start;
+	uint64_t lm_mem_end;
+	uint64_t lm_base_addr;
+	uint16_t lm_irq;
+	uint8_t  lm_dma;
+	uint8_t  lm_port;
+};
+
+#define IFQDISCSIZ	32
+
+struct rtnl_link
+{
+	NLHDR_COMMON
+
+	char		l_name[IFNAMSIZ];
+
+	uint32_t	l_family;
+	uint32_t	l_arptype;
+	uint32_t	l_index;
+	uint32_t	l_flags;
+	uint32_t	l_change;
+	uint32_t 	l_mtu;
+	uint32_t	l_link;
+	uint32_t	l_txqlen;
+	uint32_t	l_weight;
+	uint32_t	l_master;
+	struct nl_addr *l_addr;	
+	struct nl_addr *l_bcast;
+	char		l_qdisc[IFQDISCSIZ];
+	struct rtnl_link_map l_map;
+	uint64_t	l_stats[RTNL_LINK_STATS_MAX+1];
+	uint32_t	l_flag_mask;
+	uint8_t		l_operstate;
+	uint8_t		l_linkmode;
+	/* 2 byte hole */
+	struct rtnl_link_info_ops *l_info_ops;
+	void *		l_info;
+};
+
+struct rtnl_ncacheinfo
+{
+	uint32_t nci_confirmed;	/**< Time since neighbour validty was last confirmed */
+	uint32_t nci_used;	/**< Time since neighbour entry was last ued */
+	uint32_t nci_updated;	/**< Time since last update */
+	uint32_t nci_refcnt;	/**< Reference counter */
+};
+
+
+struct rtnl_neigh
+{
+	NLHDR_COMMON
+	uint32_t	n_family;
+	uint32_t	n_ifindex;
+	uint16_t	n_state;
+	uint8_t		n_flags;
+	uint8_t		n_type;	
+	struct nl_addr *n_lladdr;
+	struct nl_addr *n_dst;	
+	uint32_t	n_probes;
+	struct rtnl_ncacheinfo n_cacheinfo;
+	uint32_t                n_state_mask;
+	uint32_t                n_flag_mask;
+};
+
+
+struct rtnl_addr_cacheinfo
+{
+	/* Preferred lifetime in seconds */
+	uint32_t aci_prefered;
+
+	/* Valid lifetime in seconds */
+	uint32_t aci_valid;
+
+	/* Timestamp of creation in 1/100s seince boottime */
+	uint32_t aci_cstamp;
+
+	/* Timestamp of last update in 1/100s since boottime */
+	uint32_t aci_tstamp;
+};
+
+struct rtnl_addr
+{
+	NLHDR_COMMON
+
+	uint8_t		a_family;
+	uint8_t		a_prefixlen;
+	uint8_t		a_flags;
+	uint8_t		a_scope;
+	uint32_t	a_ifindex;
+
+	struct nl_addr *a_peer;	
+	struct nl_addr *a_local;
+	struct nl_addr *a_bcast;
+	struct nl_addr *a_anycast;
+	struct nl_addr *a_multicast;
+
+	struct rtnl_addr_cacheinfo a_cacheinfo;
+	
+	char a_label[IFNAMSIZ];
+	uint32_t a_flag_mask;
+};
+
+struct rtnl_nexthop
+{
+	uint8_t			rtnh_flags;
+	uint8_t			rtnh_flag_mask;
+	uint8_t			rtnh_weight;
+	/* 1 byte spare */
+	uint32_t		rtnh_ifindex;
+	struct nl_addr *	rtnh_gateway;
+	uint32_t		ce_mask; /* HACK to support attr macros */
+	struct nl_list_head	rtnh_list;
+	uint32_t		rtnh_realms;
+};
+
+struct rtnl_route
+{
+	NLHDR_COMMON
+
+	uint8_t			rt_family;
+	uint8_t			rt_dst_len;
+	uint8_t			rt_src_len;
+	uint8_t			rt_tos;
+	uint8_t			rt_protocol;
+	uint8_t			rt_scope;
+	uint8_t			rt_type;
+	uint8_t			rt_nmetrics;
+	uint32_t		rt_flags;
+	struct nl_addr *	rt_dst;
+	struct nl_addr *	rt_src;
+	uint32_t		rt_table;
+	uint32_t		rt_iif;
+	uint32_t		rt_prio;
+	uint32_t		rt_metrics[RTAX_MAX];
+	uint32_t		rt_metrics_mask;
+	uint32_t		rt_nr_nh;
+	struct nl_addr *	rt_pref_src;
+	struct nl_list_head	rt_nexthops;
+	struct rtnl_rtcacheinfo	rt_cacheinfo;
+	uint32_t		rt_flag_mask;
+};
+
+struct rtnl_rule
+{
+	NLHDR_COMMON
+
+	uint64_t	r_mark;
+	uint32_t	r_prio;
+	uint32_t	r_realms;
+	uint32_t	r_table;
+	uint8_t		r_dsfield;
+	uint8_t		r_type;
+	uint8_t		r_family;
+	uint8_t		r_src_len;
+	uint8_t		r_dst_len;
+	char		r_iif[IFNAMSIZ];
+	struct nl_addr *r_src;
+	struct nl_addr *r_dst;
+	struct nl_addr *r_srcmap;
+};
+
+struct rtnl_neightbl_parms
+{
+	/**
+	 * Interface index of the device this parameter set is assigned
+	 * to or 0 for the default set.
+	 */
+	uint32_t		ntp_ifindex;
+
+	/**
+	 * Number of references to this parameter set.
+	 */
+	uint32_t		ntp_refcnt;
+
+	/**
+	 * Queue length for pending arp requests, i.e. the number of
+	 * packets which are accepted from other layers while the
+	 * neighbour address is still being resolved
+	 */
+	uint32_t		ntp_queue_len;
+
+	/**
+	 * Number of requests to send to the user level ARP daemon.
+	 * Specify 0 to disable.
+	 */
+	uint32_t		ntp_app_probes;
+
+	/**
+	 * Maximum number of retries for unicast solicitation.
+	 */
+	uint32_t		ntp_ucast_probes;
+
+	/**
+	 * Maximum number of retries for multicast solicitation.
+	 */
+	uint32_t		ntp_mcast_probes;
+
+	/**
+	 * Base value in milliseconds to ompute reachable time, see RFC2461.
+	 */
+	uint64_t		ntp_base_reachable_time;
+
+	/**
+	 * Actual reachable time (read-only)
+	 */
+	uint64_t		ntp_reachable_time;	/* secs */
+
+	/**
+	 * The time in milliseconds between retransmitted Neighbor
+	 * Solicitation messages.
+	 */
+	uint64_t		ntp_retrans_time;
+
+	/**
+	 * Interval in milliseconds to check for stale neighbour
+	 * entries.
+	 */
+	uint64_t		ntp_gc_stale_time;	/* secs */
+
+	/**
+	 * Delay in milliseconds for the first time probe if
+	 * the neighbour is reachable.
+	 */
+	uint64_t		ntp_probe_delay;	/* secs */
+
+	/**
+	 * Maximum delay in milliseconds of an answer to a neighbour
+	 * solicitation message.
+	 */
+	uint64_t		ntp_anycast_delay;
+
+	/**
+	 * Minimum age in milliseconds before a neighbour entry
+	 * may be replaced.
+	 */
+	uint64_t		ntp_locktime;
+
+	/**
+	 * Delay in milliseconds before answering to an ARP request
+	 * for which a proxy ARP entry exists.
+	 */
+	uint64_t		ntp_proxy_delay;
+
+	/**
+	 * Queue length for the delayed proxy arp requests.
+	 */
+	uint32_t		ntp_proxy_qlen;
+	
+	/**
+	 * Mask of available parameter attributes
+	 */
+	uint32_t		ntp_mask;
+};
+
+#define NTBLNAMSIZ	32
+
+/**
+ * Neighbour table
+ * @ingroup neightbl
+ */
+struct rtnl_neightbl
+{
+	NLHDR_COMMON
+
+	char			nt_name[NTBLNAMSIZ];
+	uint32_t		nt_family;
+	uint32_t		nt_gc_thresh1;
+	uint32_t		nt_gc_thresh2;
+	uint32_t		nt_gc_thresh3;
+	uint64_t		nt_gc_interval;
+	struct ndt_config	nt_config;
+	struct rtnl_neightbl_parms nt_parms;
+	struct ndt_stats	nt_stats;
+};
+
+struct rtnl_ratespec
+{
+	uint8_t			rs_cell_log;
+	uint16_t		rs_feature;
+	uint16_t		rs_addend;
+	uint16_t		rs_mpu;
+	uint32_t		rs_rate;
+};
+
+struct rtnl_tstats
+{
+	struct {
+		uint64_t            bytes;
+		uint64_t            packets;
+	} tcs_basic;
+
+	struct {
+		uint32_t            bps;
+		uint32_t            pps;
+	} tcs_rate_est;
+
+	struct {
+		uint32_t            qlen;
+		uint32_t            backlog;
+		uint32_t            drops;
+		uint32_t            requeues;
+		uint32_t            overlimits;
+	} tcs_queue;
+};
+
+#define TCKINDSIZ	32
+
+#define NL_TCA_GENERIC(pre)				\
+	NLHDR_COMMON					\
+	uint32_t		pre ##_family;		\
+	uint32_t		pre ##_ifindex;		\
+	uint32_t		pre ##_handle;		\
+	uint32_t		pre ##_parent;		\
+	uint32_t		pre ##_info;		\
+	char			pre ##_kind[TCKINDSIZ];	\
+	struct nl_data *	pre ##_opts;		\
+	uint64_t		pre ##_stats[RTNL_TC_STATS_MAX+1]; \
+	struct nl_data *	pre ##_xstats;		\
+	struct nl_data *	pre ##_subdata;		\
+
+
+struct rtnl_tca
+{
+	NL_TCA_GENERIC(tc);
+};
+
+struct rtnl_qdisc
+{
+	NL_TCA_GENERIC(q);
+	struct rtnl_qdisc_ops	*q_ops;
+};
+
+struct rtnl_class
+{
+	NL_TCA_GENERIC(c);
+	struct rtnl_class_ops	*c_ops;
+};
+
+struct rtnl_cls
+{
+	NL_TCA_GENERIC(c);
+	uint16_t		c_prio;
+	uint16_t		c_protocol;
+	struct rtnl_cls_ops	*c_ops;
+};
+
+struct rtnl_u32
+{
+	uint32_t		cu_divisor;
+	uint32_t		cu_hash;
+	uint32_t		cu_classid;
+	uint32_t		cu_link;
+	struct nl_data *	cu_pcnt;
+	struct nl_data *	cu_selector;
+	struct nl_data *	cu_act;
+	struct nl_data *	cu_police;
+	char			cu_indev[IFNAMSIZ];
+	int			cu_mask;
+};
+
+struct rtnl_cgroup
+{
+	struct rtnl_ematch_tree *cg_ematch;
+	int			cg_mask;
+};
+
+struct rtnl_fw
+{
+	uint32_t		cf_classid;
+	struct nl_data *	cf_act;
+	struct nl_data *	cf_police;
+	char			cf_indev[IFNAMSIZ];
+	int			cf_mask;
+};
+
+struct rtnl_ematch
+{
+	uint16_t		e_id;
+	uint16_t		e_kind;
+	uint16_t		e_flags;
+
+	struct nl_list_head	e_childs;
+	struct nl_list_head	e_list;
+	struct rtnl_ematch_ops *e_ops;
+
+	char			e_data[0];
+};
+
+struct rtnl_ematch_tree
+{
+	uint16_t		et_progid;
+	struct nl_list_head	et_list;
+
+};
+
+struct rtnl_dsmark_qdisc
+{
+	uint16_t	qdm_indices;
+	uint16_t	qdm_default_index;
+	uint32_t	qdm_set_tc_index;
+	uint32_t	qdm_mask;
+};
+
+struct rtnl_dsmark_class
+{
+	uint8_t		cdm_bmask;
+	uint8_t		cdm_value;
+	uint32_t	cdm_mask;
+};
+
+struct rtnl_fifo
+{
+	uint32_t	qf_limit;
+	uint32_t	qf_mask;
+};
+
+struct rtnl_prio
+{
+	uint32_t	qp_bands;
+	uint8_t		qp_priomap[TC_PRIO_MAX+1];
+	uint32_t	qp_mask;
+};
+
+struct rtnl_tbf
+{
+	uint32_t		qt_limit;
+	uint32_t		qt_mpu;
+	struct rtnl_ratespec	qt_rate;
+	uint32_t		qt_rate_bucket;
+	uint32_t		qt_rate_txtime;
+	struct rtnl_ratespec	qt_peakrate;
+	uint32_t		qt_peakrate_bucket;
+	uint32_t		qt_peakrate_txtime;
+	uint32_t		qt_mask;
+};
+
+struct rtnl_sfq
+{
+	uint32_t	qs_quantum;
+	uint32_t	qs_perturb;
+	uint32_t	qs_limit;
+	uint32_t	qs_divisor;
+	uint32_t	qs_flows;
+	uint32_t	qs_mask;
+};
+
+struct rtnl_netem_corr
+{
+	uint32_t	nmc_delay;
+	uint32_t	nmc_loss;
+	uint32_t	nmc_duplicate;
+};
+
+struct rtnl_netem_reo
+{
+	uint32_t	nmro_probability;
+	uint32_t	nmro_correlation;
+};
+
+struct rtnl_netem_crpt
+{
+	uint32_t	nmcr_probability;
+	uint32_t	nmcr_correlation;
+};
+
+struct rtnl_netem_dist
+{
+	int16_t	*	dist_data;
+	size_t		dist_size;
+};
+
+struct rtnl_netem
+{
+	uint32_t		qnm_latency;
+	uint32_t		qnm_limit;
+	uint32_t		qnm_loss;
+	uint32_t		qnm_gap;
+	uint32_t		qnm_duplicate;
+	uint32_t		qnm_jitter;
+	uint32_t		qnm_mask;
+	struct rtnl_netem_corr	qnm_corr;
+	struct rtnl_netem_reo	qnm_ro;
+	struct rtnl_netem_crpt	qnm_crpt;
+	struct rtnl_netem_dist  qnm_dist;
+};
+
+struct rtnl_htb_qdisc
+{
+	uint32_t		qh_rate2quantum;
+	uint32_t		qh_defcls;
+	uint32_t		qh_mask;
+};
+
+struct rtnl_htb_class
+{
+	uint32_t		ch_prio;
+	uint32_t		ch_mtu;
+	struct rtnl_ratespec	ch_rate;
+	struct rtnl_ratespec	ch_ceil;
+	uint32_t		ch_rbuffer;
+	uint32_t		ch_cbuffer;
+	uint32_t		ch_quantum;
+	uint8_t			ch_overhead;
+	uint8_t			ch_mpu;
+	uint32_t		ch_mask;
+};
+
+struct rtnl_cbq
+{
+	struct tc_cbq_lssopt    cbq_lss;
+	struct tc_ratespec      cbq_rate;
+	struct tc_cbq_wrropt    cbq_wrr;
+	struct tc_cbq_ovl       cbq_ovl;
+	struct tc_cbq_fopt      cbq_fopt;
+	struct tc_cbq_police    cbq_police;
+};
+
+struct rtnl_red
+{
+	uint32_t	qr_limit;
+	uint32_t	qr_qth_min;
+	uint32_t	qr_qth_max;
+	uint8_t		qr_flags;
+	uint8_t		qr_wlog;
+	uint8_t		qr_plog;
+	uint8_t		qr_scell_log;
+	uint32_t	qr_mask;
+};
+
+struct flnl_request
+{
+	NLHDR_COMMON
+
+	struct nl_addr *	lr_addr;
+	uint32_t		lr_fwmark;
+	uint8_t			lr_tos;
+	uint8_t			lr_scope;
+	uint8_t			lr_table;
+};
+
+
+struct flnl_result
+{
+	NLHDR_COMMON
+
+	struct flnl_request *	fr_req;
+	uint8_t			fr_table_id;
+	uint8_t			fr_prefixlen;
+	uint8_t			fr_nh_sel;
+	uint8_t			fr_type;
+	uint8_t			fr_scope;
+	uint32_t		fr_error;
+};
+
+#define GENL_OP_HAS_POLICY	1
+#define GENL_OP_HAS_DOIT	2
+#define GENL_OP_HAS_DUMPIT	4
+
+struct genl_family_op
+{
+	uint32_t		o_id;
+	uint32_t		o_flags;
+
+	struct nl_list_head	o_list;
+};
+
+struct genl_family
+{
+	NLHDR_COMMON
+
+	uint16_t		gf_id;
+	char 			gf_name[GENL_NAMSIZ];
+	uint32_t		gf_version;
+	uint32_t		gf_hdrsize;
+	uint32_t		gf_maxattr;
+
+	struct nl_list_head	gf_ops;
+};
+
+union nfnl_ct_proto
+{
+	struct {
+		uint16_t	src;
+		uint16_t	dst;
+	} port;
+	struct {
+		uint16_t	id;
+		uint8_t		type;
+		uint8_t		code;
+	} icmp;
+};
+
+struct nfnl_ct_dir {
+	struct nl_addr *	src;
+	struct nl_addr *	dst;
+	union nfnl_ct_proto	proto;
+	uint64_t		packets;
+	uint64_t		bytes;
+};
+
+union nfnl_ct_protoinfo {
+	struct {
+		uint8_t		state;
+	} tcp;
+};
+
+struct nfnl_ct {
+	NLHDR_COMMON
+
+	uint8_t			ct_family;
+	uint8_t			ct_proto;
+	union nfnl_ct_protoinfo	ct_protoinfo;
+
+	uint32_t		ct_status;
+	uint32_t		ct_status_mask;
+	uint32_t		ct_timeout;
+	uint32_t		ct_mark;
+	uint32_t		ct_use;
+	uint32_t		ct_id;
+
+	struct nfnl_ct_dir	ct_orig;
+	struct nfnl_ct_dir	ct_repl;
+};
+
+struct nfnl_log {
+	NLHDR_COMMON
+
+	uint16_t		log_group;
+	uint8_t			log_copy_mode;
+	uint32_t		log_copy_range;
+	uint32_t		log_flush_timeout;
+	uint32_t		log_alloc_size;
+	uint32_t		log_queue_threshold;
+	uint32_t		log_flags;
+	uint32_t		log_flag_mask;
+};
+
+struct nfnl_log_msg {
+	NLHDR_COMMON
+
+	uint8_t			log_msg_family;
+	uint8_t			log_msg_hook;
+	uint16_t		log_msg_hwproto;
+	uint32_t		log_msg_mark;
+	struct timeval		log_msg_timestamp;
+	uint32_t		log_msg_indev;
+	uint32_t		log_msg_outdev;
+	uint32_t		log_msg_physindev;
+	uint32_t		log_msg_physoutdev;
+	uint8_t			log_msg_hwaddr[8];
+	int			log_msg_hwaddr_len;
+	void *			log_msg_payload;
+	int			log_msg_payload_len;
+	char *			log_msg_prefix;
+	uint32_t		log_msg_uid;
+	uint32_t		log_msg_gid;
+	uint32_t		log_msg_seq;
+	uint32_t		log_msg_seq_global;
+};
+
+struct nfnl_queue {
+	NLHDR_COMMON
+
+	uint16_t		queue_group;
+	uint32_t		queue_maxlen;
+	uint32_t		queue_copy_range;
+	uint8_t			queue_copy_mode;
+};
+
+struct nfnl_queue_msg {
+	NLHDR_COMMON
+
+	uint16_t		queue_msg_group;
+	uint8_t			queue_msg_family;
+	uint8_t			queue_msg_hook;
+	uint16_t		queue_msg_hwproto;
+	uint32_t		queue_msg_packetid;
+	uint32_t		queue_msg_mark;
+	struct timeval		queue_msg_timestamp;
+	uint32_t		queue_msg_indev;
+	uint32_t		queue_msg_outdev;
+	uint32_t		queue_msg_physindev;
+	uint32_t		queue_msg_physoutdev;
+	uint8_t			queue_msg_hwaddr[8];
+	int			queue_msg_hwaddr_len;
+	void *			queue_msg_payload;
+	int			queue_msg_payload_len;
+	uint32_t		queue_msg_verdict;
+};
+
+#endif
diff -uNr libnl_kk/lib/addr.c libnl/lib/addr.c
--- libnl_kk/lib/addr.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/addr.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,929 @@
+/*
+ * lib/addr.c		Abstract Address
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup core
+ * @defgroup addr Abstract Address
+ *
+ * @par 1) Transform character string to abstract address
+ * @code
+ * struct nl_addr *a = nl_addr_parse("::1", AF_UNSPEC);
+ * printf("Address family: %s\n", nl_af2str(nl_addr_get_family(a)));
+ * nl_addr_put(a);
+ * a = nl_addr_parse("11:22:33:44:55:66", AF_UNSPEC);
+ * printf("Address family: %s\n", nl_af2str(nl_addr_get_family(a)));
+ * nl_addr_put(a);
+ * @endcode
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink/netlink.h>
+#include <netlink/utils.h>
+#include <netlink/addr.h>
+#include <linux/socket.h>
+
+/* All this DECnet stuff is stolen from iproute2, thanks to whoever wrote
+ * this, probably Alexey. */
+static inline uint16_t dn_ntohs(uint16_t addr)
+{
+	union {
+		uint8_t byte[2];
+		uint16_t word;
+	} u = {
+		.word = addr,
+	};
+
+	return ((uint16_t) u.byte[0]) | (((uint16_t) u.byte[1]) << 8);
+}
+
+static inline int do_digit(char *str, uint16_t *addr, uint16_t scale,
+			   size_t *pos, size_t len, int *started)
+{
+	uint16_t tmp = *addr / scale;
+
+	if (*pos == len)
+		return 1;
+
+	if (((tmp) > 0) || *started || (scale == 1)) {
+		*str = tmp + '0';
+		*started = 1;
+		(*pos)++;
+		*addr -= (tmp * scale);
+	}
+
+	return 0;
+}
+
+static const char *dnet_ntop(char *addrbuf, size_t addrlen, char *str,
+			     size_t len)
+{
+	uint16_t addr = dn_ntohs(*(uint16_t *)addrbuf);
+	uint16_t area = addr >> 10;
+	size_t pos = 0;
+	int started = 0;
+
+	if (addrlen != 2)
+		return NULL;
+
+	addr &= 0x03ff;
+
+	if (len == 0)
+		return str;
+
+	if (do_digit(str + pos, &area, 10, &pos, len, &started))
+		return str;
+
+	if (do_digit(str + pos, &area, 1, &pos, len, &started))
+		return str;
+
+	if (pos == len)
+		return str;
+
+	*(str + pos) = '.';
+	pos++;
+	started = 0;
+
+	if (do_digit(str + pos, &addr, 1000, &pos, len, &started))
+		return str;
+
+	if (do_digit(str + pos, &addr, 100, &pos, len, &started))
+		return str;
+
+	if (do_digit(str + pos, &addr, 10, &pos, len, &started))
+		return str;
+
+	if (do_digit(str + pos, &addr, 1, &pos, len, &started))
+		return str;
+
+	if (pos == len)
+		return str;
+
+	*(str + pos) = 0;
+
+	return str;
+}
+
+static int dnet_num(const char *src, uint16_t * dst)
+{
+	int rv = 0;
+	int tmp;
+	*dst = 0;
+
+	while ((tmp = *src++) != 0) {
+		tmp -= '0';
+		if ((tmp < 0) || (tmp > 9))
+			return rv;
+
+		rv++;
+		(*dst) *= 10;
+		(*dst) += tmp;
+	}
+
+	return rv;
+}
+
+static inline int dnet_pton(const char *src, char *addrbuf)
+{
+	uint16_t area = 0;
+	uint16_t node = 0;
+	int pos;
+
+	pos = dnet_num(src, &area);
+	if ((pos == 0) || (area > 63) ||
+	    ((*(src + pos) != '.') && (*(src + pos) != ',')))
+		return -NLE_INVAL;
+
+	pos = dnet_num(src + pos + 1, &node);
+	if ((pos == 0) || (node > 1023))
+		return -NLE_INVAL;
+
+	*(uint16_t *)addrbuf = dn_ntohs((area << 10) | node);
+
+	return 1;
+}
+
+/**
+ * @name Creating Abstract Addresses
+ * @{
+ */
+
+/**
+ * Allocate new abstract address object.
+ * @arg maxsize		Maximum size of the binary address.
+ * @return Newly allocated address object or NULL
+ */
+struct nl_addr *nl_addr_alloc(size_t maxsize)
+{
+	struct nl_addr *addr;
+	
+	addr = calloc(1, sizeof(*addr) + maxsize);
+	if (!addr)
+		return NULL;
+
+	addr->a_refcnt = 1;
+	addr->a_maxsize = maxsize;
+
+	return addr;
+}
+
+/**
+ * Allocate new abstract address object based on a binary address.
+ * @arg family		Address family.
+ * @arg buf		Buffer containing the binary address.
+ * @arg size		Length of binary address buffer.
+ * @return Newly allocated address handle or NULL
+ */
+struct nl_addr *nl_addr_build(int family, void *buf, size_t size)
+{
+	struct nl_addr *addr;
+
+	addr = nl_addr_alloc(size);
+	if (!addr)
+		return NULL;
+
+	addr->a_family = family;
+	addr->a_len = size;
+	addr->a_prefixlen = size*8;
+
+	if (size)
+		memcpy(addr->a_addr, buf, size);
+
+	return addr;
+}
+
+/**
+ * Allocate abstract address based on netlink attribute.
+ * @arg nla		Netlink attribute of unspecific type.
+ * @arg family		Address family.
+ *
+ * Considers the netlink attribute payload a address of the specified
+ * family and allocates a new abstract address based on it.
+ *
+ * @return Newly allocated address handle or NULL.
+ */
+struct nl_addr *nl_addr_alloc_attr(struct nlattr *nla, int family)
+{
+	return nl_addr_build(family, nla_data(nla), nla_len(nla));
+}
+
+/**
+ * Allocate abstract address object based on a character string
+ * @arg addrstr		Address represented as character string.
+ * @arg hint		Address family hint or AF_UNSPEC.
+ * @arg result		Pointer to store resulting address.
+ *
+ * Regognizes the following address formats:
+ *@code
+ *  Format                      Len                Family
+ *  ----------------------------------------------------------------
+ *  IPv6 address format         16                 AF_INET6
+ *  ddd.ddd.ddd.ddd             4                  AF_INET
+ *  HH:HH:HH:HH:HH:HH           6                  AF_LLC
+ *  AA{.|,}NNNN                 2                  AF_DECnet
+ *  HH:HH:HH:...                variable           AF_UNSPEC
+ * @endcode
+ *
+ *  Special values:
+ *    - none: All bits and length set to 0.
+ *    - {default|all|any}: All bits set to 0, length based on hint or
+ *                         AF_INET if no hint is given.
+ *
+ * The prefix length may be appened at the end prefixed with a
+ * slash, e.g. 10.0.0.0/8.
+ *
+ * @return 0 on success or a negative error code.
+ */
+int nl_addr_parse(const char *addrstr, int hint, struct nl_addr **result)
+{
+	int err, copy = 0, len = 0, family = AF_UNSPEC;
+	char *str, *prefix, buf[32];
+	struct nl_addr *addr = NULL; /* gcc ain't that smart */
+
+	str = strdup(addrstr);
+	if (!str) {
+		err = -NLE_NOMEM;
+		goto errout;
+	}
+
+	prefix = strchr(str, '/');
+	if (prefix)
+		*prefix = '\0';
+
+	if (!strcasecmp(str, "none")) {
+		family = hint;
+		goto prefix;
+	}
+
+	if (!strcasecmp(str, "default") ||
+	    !strcasecmp(str, "all") ||
+	    !strcasecmp(str, "any")) {
+			
+		switch (hint) {
+			case AF_INET:
+			case AF_UNSPEC:
+				/* Kind of a hack, we assume that if there is
+				 * no hint given the user wants to have a IPv4
+				 * address given back. */
+				family = AF_INET;
+				len = 4;
+				goto prefix;
+
+			case AF_INET6:
+				family = AF_INET6;
+				len = 16;
+				goto prefix;
+
+			case AF_LLC:
+				family = AF_LLC;
+				len = 6;
+				goto prefix;
+
+			default:
+				err = -NLE_AF_NOSUPPORT;
+				goto errout;
+		}
+	}
+
+	copy = 1;
+
+	if (hint == AF_INET || hint == AF_UNSPEC) {
+		if (inet_pton(AF_INET, str, buf) > 0) {
+			family = AF_INET;
+			len = 4;
+			goto prefix;
+		}
+		if (hint == AF_INET) {
+			err = -NLE_NOADDR;
+			goto errout;
+		}
+	}
+
+	if (hint == AF_INET6 || hint == AF_UNSPEC) {
+		if (inet_pton(AF_INET6, str, buf) > 0) {
+			family = AF_INET6;
+			len = 16;
+			goto prefix;
+		}
+		if (hint == AF_INET6) {
+			err = -NLE_NOADDR;
+			goto errout;
+		}
+	}
+
+	if ((hint == AF_LLC || hint == AF_UNSPEC) && strchr(str, ':')) {
+		unsigned int a, b, c, d, e, f;
+
+		if (sscanf(str, "%02x:%02x:%02x:%02x:%02x:%02x",
+		    &a, &b, &c, &d, &e, &f) == 6) {
+			family = AF_LLC;
+			len = 6;
+			buf[0] = (unsigned char) a;
+			buf[1] = (unsigned char) b;
+			buf[2] = (unsigned char) c;
+			buf[3] = (unsigned char) d;
+			buf[4] = (unsigned char) e;
+			buf[5] = (unsigned char) f;
+			goto prefix;
+		}
+
+		if (hint == AF_LLC) {
+			err = -NLE_NOADDR;
+			goto errout;
+		}
+	}
+
+	if ((hint == AF_DECnet || hint == AF_UNSPEC) &&
+	    (strchr(str, '.') || strchr(str, ','))) {
+		if (dnet_pton(str, buf) > 0) {
+			family = AF_DECnet;
+			len = 2;
+			goto prefix;
+		}
+		if (hint == AF_DECnet) {
+			err = -NLE_NOADDR;
+			goto errout;
+		}
+	}
+
+	if (hint == AF_UNSPEC && strchr(str, ':')) {
+		int i = 0;
+		char *s = str, *p;
+		for (;;) {
+			long l = strtol(s, &p, 16);
+
+			if (s == p || l > 0xff || i >= sizeof(buf)) {
+				err = -NLE_INVAL;
+				goto errout;
+			}
+
+			buf[i++] = (unsigned char) l;
+			if (*p == '\0')
+				break;
+			s = ++p;
+		}
+
+		len = i;
+		family = AF_UNSPEC;
+		goto prefix;
+	}
+
+	err = -NLE_NOADDR;
+	goto errout;
+
+prefix:
+	addr = nl_addr_alloc(len);
+	if (!addr) {
+		err = -NLE_NOMEM;
+		goto errout;
+	}
+
+	nl_addr_set_family(addr, family);
+
+	if (copy)
+		nl_addr_set_binary_addr(addr, buf, len);
+
+	if (prefix) {
+		char *p;
+		long pl = strtol(++prefix, &p, 0);
+		if (p == prefix) {
+			nl_addr_destroy(addr);
+			err = -NLE_INVAL;
+			goto errout;
+		}
+		nl_addr_set_prefixlen(addr, pl);
+	} else
+		nl_addr_set_prefixlen(addr, len * 8);
+
+	*result = addr;
+	err = 0;
+errout:
+	free(str);
+
+	return err;
+}
+
+/**
+ * Clone existing abstract address object.
+ * @arg addr		Abstract address object.
+ * @return Newly allocated abstract address object being a duplicate of the
+ *         specified address object or NULL if a failure occured.
+ */
+struct nl_addr *nl_addr_clone(struct nl_addr *addr)
+{
+	struct nl_addr *new;
+
+	new = nl_addr_build(addr->a_family, addr->a_addr, addr->a_len);
+	if (new)
+		new->a_prefixlen = addr->a_prefixlen;
+
+	return new;
+}
+
+/** @} */
+
+/**
+ * @name Destroying Abstract Addresses
+ * @{
+ */
+
+/**
+ * Destroy abstract address object.
+ * @arg addr		Abstract address object.
+ */
+void nl_addr_destroy(struct nl_addr *addr)
+{
+	if (!addr)
+		return;
+
+	if (addr->a_refcnt != 1)
+		BUG();
+
+	free(addr);
+}
+
+/** @} */
+
+/**
+ * @name Managing Usage References
+ * @{
+ */
+
+struct nl_addr *nl_addr_get(struct nl_addr *addr)
+{
+	addr->a_refcnt++;
+
+	return addr;
+}
+
+void nl_addr_put(struct nl_addr *addr)
+{
+	if (!addr)
+		return;
+
+	if (addr->a_refcnt == 1)
+		nl_addr_destroy(addr);
+	else
+		addr->a_refcnt--;
+}
+
+/**
+ * Check whether an abstract address object is shared.
+ * @arg addr		Abstract address object.
+ * @return Non-zero if the abstract address object is shared, otherwise 0.
+ */
+int nl_addr_shared(struct nl_addr *addr)
+{
+	return addr->a_refcnt > 1;
+}
+
+/** @} */
+
+/**
+ * @name Miscellaneous
+ * @{
+ */
+
+/**
+ * Compares two abstract address objects.
+ * @arg a		A abstract address object.
+ * @arg b		Another abstract address object.
+ *
+ * @return Integer less than, equal to or greather than zero if \c is found,
+ *         respectively to be less than, to, or be greater than \c b.
+ */
+int nl_addr_cmp(struct nl_addr *a, struct nl_addr *b)
+{
+	int d = a->a_family - b->a_family;
+
+	if (d == 0) {
+		d = a->a_len - b->a_len;
+
+		if (a->a_len && d == 0)
+			return memcmp(a->a_addr, b->a_addr, a->a_len);
+	}
+
+	return d;
+}
+
+/**
+ * Compares the prefix of two abstract address objects.
+ * @arg a		A abstract address object.
+ * @arg b		Another abstract address object.
+ *
+ * @return Integer less than, equal to or greather than zero if \c is found,
+ *         respectively to be less than, to, or be greater than \c b.
+ */
+int nl_addr_cmp_prefix(struct nl_addr *a, struct nl_addr *b)
+{
+	int d = a->a_family - b->a_family;
+
+	if (d == 0) {
+		int len = min(a->a_prefixlen, b->a_prefixlen);
+		int bytes = len / 8;
+
+		d = memcmp(a->a_addr, b->a_addr, bytes);
+		if (d == 0) {
+			int mask = (1UL << (len % 8)) - 1UL;
+
+			d = (a->a_addr[bytes] & mask) -
+			    (b->a_addr[bytes] & mask);
+		}
+	}
+
+	return d;
+}
+
+/**
+ * Returns true if the address consists of all zeros
+ * @arg addr		Address to look at.
+ */
+int nl_addr_iszero(struct nl_addr *addr)
+{
+	int i;
+
+	for (i = 0; i < addr->a_len; i++)
+		if (addr->a_addr[i])
+			return 0;
+
+	return 1;
+}
+
+/**
+ * Check if an address matches a certain family.
+ * @arg addr		Address represented as character string.
+ * @arg family		Desired address family.
+ *
+ * @return 1 if the address is of the desired address family,
+ *         otherwise 0 is returned.
+ */
+int nl_addr_valid(char *addr, int family)
+{
+	int ret;
+	char buf[32];
+
+	switch (family) {
+	case AF_INET:
+	case AF_INET6:
+		ret = inet_pton(family, addr, buf);
+		if (ret <= 0)
+			return 0;
+		break;
+
+	case AF_DECnet:
+		ret = dnet_pton(addr, buf);
+		if (ret <= 0)
+			return 0;
+		break;
+
+	case AF_LLC:
+		if (sscanf(addr, "%*02x:%*02x:%*02x:%*02x:%*02x:%*02x") != 6)
+			return 0;
+		break;
+	}
+
+	return 1;
+}
+
+/**
+ * Guess address family of an abstract address object based on address size.
+ * @arg addr		Abstract address object.
+ * @return Address family or AF_UNSPEC if guessing wasn't successful.
+ */
+int nl_addr_guess_family(struct nl_addr *addr)
+{
+	switch (addr->a_len) {
+		case 4:
+			return AF_INET;
+		case 6:
+			return AF_LLC;
+		case 16:
+			return AF_INET6;
+		default:
+			return AF_UNSPEC;
+	}
+}
+
+/**
+ * Fill out sockaddr structure with values from abstract address object.
+ * @arg addr		Abstract address object.
+ * @arg sa		Destination sockaddr structure buffer.
+ * @arg salen		Length of sockaddr structure buffer.
+ *
+ * Fills out the specified sockaddr structure with the data found in the
+ * specified abstract address. The salen argument needs to be set to the
+ * size of sa but will be modified to the actual size used during before
+ * the function exits.
+ *
+ * @return 0 on success or a negative error code
+ */
+int nl_addr_fill_sockaddr(struct nl_addr *addr, struct sockaddr *sa,
+			  socklen_t *salen)
+{
+	switch (addr->a_family) {
+	case AF_INET: {
+		struct sockaddr_in *sai = (struct sockaddr_in *) sa;
+
+		if (*salen < sizeof(*sai))
+			return -NLE_INVAL;
+
+		sai->sin_family = addr->a_family;
+		memcpy(&sai->sin_addr, addr->a_addr, 4);
+		*salen = sizeof(*sai);
+	}
+		break;
+
+	case AF_INET6: {
+		struct sockaddr_in6 *sa6 = (struct sockaddr_in6 *) sa;
+
+		if (*salen < sizeof(*sa6))
+			return -NLE_INVAL;
+
+		sa6->sin6_family = addr->a_family;
+		memcpy(&sa6->sin6_addr, addr->a_addr, 16);
+		*salen = sizeof(*sa6);
+	}
+		break;
+
+	default:
+		return -NLE_INVAL;
+	}
+
+	return 0;
+}
+
+
+/** @} */
+
+/**
+ * @name Getting Information About Addresses
+ * @{
+ */
+
+/**
+ * Call getaddrinfo() for an abstract address object.
+ * @arg addr		Abstract address object.
+ * @arg result		Pointer to store resulting address list.
+ * 
+ * Calls getaddrinfo() for the specified abstract address in AI_NUMERICHOST
+ * mode.
+ *
+ * @note The caller is responsible for freeing the linked list using the
+ *       interface provided by getaddrinfo(3).
+ *
+ * @return 0 on success or a negative error code.
+ */
+int nl_addr_info(struct nl_addr *addr, struct addrinfo **result)
+{
+	int err;
+	char buf[INET6_ADDRSTRLEN+5];
+	struct addrinfo hint = {
+		.ai_flags = AI_NUMERICHOST,
+		.ai_family = addr->a_family,
+	};
+
+	nl_addr2str(addr, buf, sizeof(buf));
+
+	err = getaddrinfo(buf, NULL, &hint, result);
+	if (err != 0) {
+		switch (err) {
+		case EAI_ADDRFAMILY: return -NLE_AF_NOSUPPORT;
+		case EAI_AGAIN: return -NLE_AGAIN;
+		case EAI_BADFLAGS: return -NLE_INVAL;
+		case EAI_FAIL: return -NLE_NOADDR;
+		case EAI_FAMILY: return -NLE_AF_NOSUPPORT;
+		case EAI_MEMORY: return -NLE_NOMEM;
+		case EAI_NODATA: return -NLE_NOADDR;
+		case EAI_NONAME: return -NLE_OBJ_NOTFOUND;
+		case EAI_SERVICE: return -NLE_OPNOTSUPP;
+		case EAI_SOCKTYPE: return -NLE_BAD_SOCK;
+		default: return -NLE_FAILURE;
+		}
+	}
+
+	return 0;
+}
+
+/**
+ * Resolve abstract address object to a name using getnameinfo().
+ * @arg addr		Abstract address object.
+ * @arg host		Destination buffer for host name.
+ * @arg hostlen		Length of destination buffer.
+ *
+ * Resolves the abstract address to a name and writes the looked up result
+ * into the host buffer. getnameinfo() is used to perform the lookup and
+ * is put into NI_NAMEREQD mode so the function will fail if the lookup
+ * couldn't be performed.
+ *
+ * @return 0 on success or a negative error code.
+ */
+int nl_addr_resolve(struct nl_addr *addr, char *host, size_t hostlen)
+{
+	int err;
+	struct sockaddr_in6 buf;
+	socklen_t salen = sizeof(buf);
+
+	err = nl_addr_fill_sockaddr(addr, (struct sockaddr *) &buf, &salen);
+	if (err < 0)
+		return err;
+
+	err = getnameinfo((struct sockaddr *) &buf, salen, host, hostlen,
+			  NULL, 0, NI_NAMEREQD);
+	if (err < 0)
+		return nl_syserr2nlerr(err);
+
+	return 0;
+}
+
+/** @} */
+
+/**
+ * @name Attributes
+ * @{
+ */
+
+void nl_addr_set_family(struct nl_addr *addr, int family)
+{
+	addr->a_family = family;
+}
+
+int nl_addr_get_family(struct nl_addr *addr)
+{
+	return addr->a_family;
+}
+
+/**
+ * Set binary address of abstract address object.
+ * @arg addr		Abstract address object.
+ * @arg buf		Buffer containing binary address.
+ * @arg len		Length of buffer containing binary address.
+ */
+int nl_addr_set_binary_addr(struct nl_addr *addr, void *buf, size_t len)
+{
+	if (len > addr->a_maxsize)
+		return -NLE_RANGE;
+
+	addr->a_len = len;
+	memcpy(addr->a_addr, buf, len);
+
+	return 0;
+}
+
+/**
+ * Get binary address of abstract address object.
+ * @arg addr		Abstract address object.
+ */
+void *nl_addr_get_binary_addr(struct nl_addr *addr)
+{
+	return addr->a_addr;
+}
+
+/**
+ * Get length of binary address of abstract address object.
+ * @arg addr		Abstract address object.
+ */
+unsigned int nl_addr_get_len(struct nl_addr *addr)
+{
+	return addr->a_len;
+}
+
+void nl_addr_set_prefixlen(struct nl_addr *addr, int prefixlen)
+{
+	addr->a_prefixlen = prefixlen;
+}
+
+/**
+ * Get prefix length of abstract address object.
+ * @arg addr		Abstract address object.
+ */
+unsigned int nl_addr_get_prefixlen(struct nl_addr *addr)
+{
+	return addr->a_prefixlen;
+}
+
+/** @} */
+
+/**
+ * @name Translations to Strings
+ * @{
+ */
+
+/**
+ * Convert abstract address object to character string.
+ * @arg addr		Abstract address object.
+ * @arg buf		Destination buffer.
+ * @arg size		Size of destination buffer.
+ *
+ * Converts an abstract address to a character string and stores
+ * the result in the specified destination buffer.
+ *
+ * @return Address represented in ASCII stored in destination buffer.
+ */
+char *nl_addr2str(struct nl_addr *addr, char *buf, size_t size)
+{
+	int i;
+	char tmp[16];
+
+	if (!addr || !addr->a_len) {
+		snprintf(buf, size, "none");
+		if (addr)
+			goto prefix;
+		else
+			return buf;
+	}
+
+	switch (addr->a_family) {
+		case AF_INET:
+			inet_ntop(AF_INET, addr->a_addr, buf, size);
+			break;
+
+		case AF_INET6:
+			inet_ntop(AF_INET6, addr->a_addr, buf, size);
+			break;
+
+		case AF_DECnet:
+			dnet_ntop(addr->a_addr, addr->a_len, buf, size);
+			break;
+
+		case AF_LLC:
+		default:
+			snprintf(buf, size, "%02x",
+				 (unsigned char) addr->a_addr[0]);
+			for (i = 1; i < addr->a_len; i++) {
+				snprintf(tmp, sizeof(tmp), ":%02x",
+					 (unsigned char) addr->a_addr[i]);
+				strncat(buf, tmp, size - strlen(buf) - 1);
+			}
+			break;
+	}
+
+prefix:
+	if (addr->a_prefixlen != (8 * addr->a_len)) {
+		snprintf(tmp, sizeof(tmp), "/%u", addr->a_prefixlen);
+		strncat(buf, tmp, size - strlen(buf) - 1);
+	}
+
+	return buf;
+}
+
+/** @} */
+
+/**
+ * @name Address Family Transformations
+ * @{
+ */
+
+static struct trans_tbl afs[] = {
+	__ADD(AF_UNSPEC,unspec)
+	__ADD(AF_UNIX,unix)
+	__ADD(AF_LOCAL,local)
+	__ADD(AF_INET,inet)
+	__ADD(AF_AX25,ax25)
+	__ADD(AF_IPX,ipx)
+	__ADD(AF_APPLETALK,appletalk)
+	__ADD(AF_NETROM,netrom)
+	__ADD(AF_BRIDGE,bridge)
+	__ADD(AF_ATMPVC,atmpvc)
+	__ADD(AF_X25,x25)
+	__ADD(AF_INET6,inet6)
+	__ADD(AF_ROSE,rose)
+	__ADD(AF_DECnet,decnet)
+	__ADD(AF_NETBEUI,netbeui)
+	__ADD(AF_SECURITY,security)
+	__ADD(AF_KEY,key)
+	__ADD(AF_NETLINK,netlink)
+	__ADD(AF_ROUTE,route)
+	__ADD(AF_PACKET,packet)
+	__ADD(AF_ASH,ash)
+	__ADD(AF_ECONET,econet)
+	__ADD(AF_ATMSVC,atmsvc)
+	__ADD(AF_SNA,sna)
+	__ADD(AF_IRDA,irda)
+	__ADD(AF_PPPOX,pppox)
+	__ADD(AF_WANPIPE,wanpipe)
+	__ADD(AF_LLC,llc)
+	__ADD(AF_BLUETOOTH,bluetooth)
+};
+
+char *nl_af2str(int family, char *buf, size_t size)
+{
+	return __type2str(family, buf, size, afs, ARRAY_SIZE(afs));
+}
+
+int nl_str2af(const char *name)
+{
+	int fam = __str2type(name, afs, ARRAY_SIZE(afs));
+	return fam >= 0 ? fam : AF_UNSPEC;
+}
+
+/** @} */
+
+/** @} */
diff -uNr libnl_kk/lib/attr.c libnl/lib/attr.c
--- libnl_kk/lib/attr.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/attr.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,1169 @@
+/*
+ * lib/attr.c		Netlink Attributes
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+#include <netlink-local.h>
+#include <netlink/netlink.h>
+#include <netlink/utils.h>
+#include <netlink/addr.h>
+#include <netlink/attr.h>
+#include <netlink/msg.h>
+#include <linux/socket.h>
+
+/**
+ * @ingroup msg
+ * @defgroup attr Attributes
+ * Netlink Attributes Construction/Parsing Interface
+ *
+ * \section attr_sec Netlink Attributes
+ * Netlink attributes allow for data chunks of arbitary length to be
+ * attached to a netlink message. Each attribute is encoded with a
+ * type and length field, both 16 bits, stored in the attribute header
+ * preceding the attribute data. The main advantage of using attributes
+ * over packing everything into the family header is that the interface
+ * stays extendable as new attributes can supersede old attributes while
+ * remaining backwards compatible. Also attributes can be defined optional
+ * thus avoiding the transmission of unnecessary empty data blocks.
+ * Special nested attributes allow for more complex data structures to
+ * be transmitted, e.g. trees, lists, etc.
+ *
+ * While not required, netlink attributes typically follow the family
+ * header of a netlink message and must be properly aligned to NLA_ALIGNTO:
+ * @code
+ *   +----------------+- - -+---------------+- - -+------------+- - -+
+ *   | Netlink Header | Pad | Family Header | Pad | Attributes | Pad |
+ *   +----------------+- - -+---------------+- - -+------------+- - -+
+ * @endcode
+ *
+ * The actual attributes are chained together each separately aligned to
+ * NLA_ALIGNTO. The position of an attribute is defined based on the
+ * length field of the preceding attributes:
+ * @code
+ *   +-------------+- - -+-------------+- - -+------
+ *   | Attribute 1 | Pad | Attribute 2 | Pad | ...
+ *   +-------------+- - -+-------------+- - -+------
+ *   nla_next(attr1)------^
+ * @endcode
+ *
+ * The attribute itself consists of the attribute header followed by
+ * the actual payload also aligned to NLA_ALIGNTO. The function nla_data()
+ * returns a pointer to the start of the payload while nla_len() returns
+ * the length of the payload in bytes.
+ *
+ * \b Note: Be aware, NLA_ALIGNTO equals to 4 bytes, therefore it is not
+ * safe to dereference any 64 bit data types directly.
+ *
+ * @code
+ *    <----------- nla_total_size(payload) ----------->
+ *    <-------- nla_attr_size(payload) --------->
+ *   +------------------+- - -+- - - - - - - - - +- - -+
+ *   | Attribute Header | Pad |     Payload      | Pad |
+ *   +------------------+- - -+- - - - - - - - - +- - -+
+ *   nla_data(nla)-------------^
+ *                             <- nla_len(nla) ->
+ * @endcode
+ *
+ * @subsection attr_datatypes Attribute Data Types
+ * A number of basic data types are supported to simplify access and
+ * validation of netlink attributes. This data type information is
+ * not encoded in the attribute, both the kernel and userspace part
+ * are required to share this information on their own.
+ *
+ * One of the major advantages of these basic types is the automatic
+ * validation of each attribute based on an attribute policy. The
+ * validation covers most of the checks required to safely use
+ * attributes and thus keeps the individual sanity check to a minimum.
+ *
+ * Never access attribute payload without ensuring basic validation
+ * first, attributes may:
+ * - not be present even though required
+ * - contain less actual payload than expected
+ * - fake a attribute length which exceeds the end of the message
+ * - contain unterminated character strings
+ *
+ * Policies are defined as array of the struct nla_policy. The array is
+ * indexed with the attribute type, therefore the array must be sized
+ * accordingly.
+ * @code
+ * static struct nla_policy my_policy[ATTR_MAX+1] = {
+ * 	[ATTR_FOO] = { .type = ..., .minlen = ..., .maxlen = ... },
+ * };
+ *
+ * err = nla_validate(attrs, attrlen, ATTR_MAX, &my_policy);
+ * @endcode
+ *
+ * Some basic validations are performed on every attribute, regardless of type.
+ * - If the attribute type exceeds the maximum attribute type specified or
+ *   the attribute type is lesser-or-equal than zero, the attribute will
+ *   be silently ignored.
+ * - If the payload length falls below the \a minlen value the attribute
+ *   will be rejected.
+ * - If \a maxlen is non-zero and the payload length exceeds the \a maxlen
+ *   value the attribute will be rejected.
+ *
+ *
+ * @par Unspecific Attribute (NLA_UNSPEC)
+ * This is the standard type if no type is specified. It is used for
+ * binary data of arbitary length. Typically this attribute carries
+ * a binary structure or a stream of bytes.
+ * @par
+ * @code
+ * // In this example, we will assume a binary structure requires to
+ * // be transmitted. The definition of the structure will typically
+ * // go into a header file available to both the kernel and userspace
+ * // side.
+ * //
+ * // Note: Be careful when putting 64 bit data types into a structure.
+ * // The attribute payload is only aligned to 4 bytes, dereferencing
+ * // the member may fail.
+ * struct my_struct {
+ *     int a;
+ *     int b;
+ * };
+ *
+ * // The validation function will not enforce an exact length match to
+ * // allow structures to grow as required. Note: While it is allowed
+ * // to add members to the end of the structure, changing the order or
+ * // inserting members in the middle of the structure will break your
+ * // binary interface.
+ * static struct nla_policy my_policy[ATTR_MAX+1] = {
+ *     [ATTR_MY_STRICT] = { .type = NLA_UNSPEC,
+ *                          .minlen = sizeof(struct my_struct) },
+ *
+ * // The binary structure is appened to the message using nla_put()
+ * struct my_struct foo = { .a = 1, .b = 2 };
+ * nla_put(msg, ATTR_MY_STRUCT, sizeof(foo), &foo);
+ *
+ * // On the receiving side, a pointer to the structure pointing inside
+ * // the message payload is returned by nla_get().
+ * if (attrs[ATTR_MY_STRUCT])
+ *     struct my_struct *foo = nla_get(attrs[ATTR_MY_STRUCT]);
+ * @endcode
+ *
+ * @par Integers (NLA_U8, NLA_U16, NLA_U32, NLA_U64)
+ * Integers come in different sizes from 8 bit to 64 bit. However, since the
+ * payload length is aligned to 4 bytes, integers smaller than 32 bit are
+ * only useful to enforce the maximum range of values.
+ * @par
+ * \b Note: There is no difference made between signed and unsigned integers.
+ * The validation only enforces the minimal payload length required to store
+ * an integer of specified type.
+ * @par
+ * @code
+ * // Even though possible, it does not make sense to specify .minlen or
+ * // .maxlen for integer types. The data types implies the corresponding
+ * // minimal payload length.
+ * static struct nla_policy my_policy[ATTR_MAX+1] = {
+ *     [ATTR_FOO] = { .type = NLA_U32 },
+ *
+ * // Numeric values can be appended directly using the respective
+ * // nla_put_uxxx() function
+ * nla_put_u32(msg, ATTR_FOO, 123);
+ *
+ * // Same for the receiving side.
+ * if (attrs[ATTR_FOO])
+ *     uint32_t foo = nla_get_u32(attrs[ATTR_FOO]);
+ * @endcode
+ *
+ * @par Character string (NLA_STRING)
+ * This data type represents a NUL terminated character string of variable
+ * length. For binary data streams the type NLA_UNSPEC is recommended.
+ * @par
+ * @code
+ * // Enforce a NUL terminated character string of at most 4 characters
+ * // including the NUL termination.
+ * static struct nla_policy my_policy[ATTR_MAX+1] = {
+ *     [ATTR_BAR] = { .type = NLA_STRING, maxlen = 4 },
+ *
+ * // nla_put_string() creates a string attribute of the necessary length
+ * // and appends it to the message including the NUL termination.
+ * nla_put_string(msg, ATTR_BAR, "some text");
+ *
+ * // It is safe to use the returned character string directly if the
+ * // attribute has been validated as the validation enforces the proper
+ * // termination of the string.
+ * if (attrs[ATTR_BAR])
+ *     char *text = nla_get_string(attrs[ATTR_BAR]);
+ * @endcode
+ *
+ * @par Flag (NLA_FLAG)
+ * This attribute type may be used to indicate the presence of a flag. The
+ * attribute is only valid if the payload length is zero. The presence of
+ * the attribute header indicates the presence of the flag.
+ * @par
+ * @code
+ * // This attribute type is special as .minlen and .maxlen have no effect.
+ * static struct nla_policy my_policy[ATTR_MAX+1] = {
+ *     [ATTR_FLAG] = { .type = NLA_FLAG },
+ *
+ * // nla_put_flag() appends a zero sized attribute to the message.
+ * nla_put_flag(msg, ATTR_FLAG);
+ *
+ * // There is no need for a receival function, the presence is the value.
+ * if (attrs[ATTR_FLAG])
+ *     // flag is present
+ * @endcode
+ *
+ * @par Micro Seconds (NLA_MSECS)
+ *
+ * @par Nested Attribute (NLA_NESTED)
+ * Attributes can be nested and put into a container to create groups, lists
+ * or to construct trees of attributes. Nested attributes are often used to
+ * pass attributes to a subsystem where the top layer has no knowledge of the
+ * configuration possibilities of each subsystem.
+ * @par
+ * \b Note: When validating the attributes using nlmsg_validate() or
+ * nlmsg_parse() it will only affect the top level attributes. Each
+ * level of nested attributes must be validated seperately using
+ * nla_parse_nested() or nla_validate().
+ * @par
+ * @code
+ * // The minimal length policy may be used to enforce the presence of at
+ * // least one attribute.
+ * static struct nla_policy my_policy[ATTR_MAX+1] = {
+ *     [ATTR_OPTS] = { .type = NLA_NESTED, minlen = NLA_HDRLEN },
+ *
+ * // Nested attributes are constructed by enclosing the attributes
+ * // to be nested with calls to nla_nest_start() respetively nla_nest_end().
+ * struct nlattr *opts = nla_nest_start(msg, ATTR_OPTS);
+ * nla_put_u32(msg, ATTR_FOO, 123);
+ * nla_put_string(msg, ATTR_BAR, "some text");
+ * nla_nest_end(msg, opts);
+ *
+ * // Various methods exist to parse nested attributes, the easiest being
+ * // nla_parse_nested() which also allows validation in the same step.
+ * if (attrs[ATTR_OPTS]) {
+ *     struct nlattr *nested[ATTR_MAX+1];
+ *
+ *     nla_parse_nested(nested, ATTR_MAX, attrs[ATTR_OPTS], &policy);
+ *
+ *     if (nested[ATTR_FOO])
+ *         uint32_t foo = nla_get_u32(nested[ATTR_FOO]);
+ * }
+ * @endcode
+ *
+ * @subsection attr_exceptions Exception Based Attribute Construction
+ * Often a large number of attributes are added to a message in a single
+ * function. In order to simplify error handling, a second set of
+ * construction functions exist which jump to a error label when they
+ * fail instead of returning an error code. This second set consists
+ * of macros which are named after their error code based counterpart
+ * except that the name is written all uppercase.
+ *
+ * All of the macros jump to the target \c nla_put_failure if they fail.
+ * @code
+ * void my_func(struct nl_msg *msg)
+ * {
+ *     NLA_PUT_U32(msg, ATTR_FOO, 10);
+ *     NLA_PUT_STRING(msg, ATTR_BAR, "bar");
+ *
+ *     return 0;
+ *
+ * nla_put_failure:
+ *     return -NLE_NOMEM;
+ * }
+ * @endcode
+ *
+ * @subsection attr_examples Examples
+ * @par Example 1.1 Constructing a netlink message with attributes.
+ * @code
+ * struct nl_msg *build_msg(int ifindex, struct nl_addr *lladdr, int mtu)
+ * {
+ *     struct nl_msg *msg;
+ *     struct nlattr *info, *vlan;
+ *     struct ifinfomsg ifi = {
+ *         .ifi_family = AF_INET,
+ *         .ifi_index = ifindex,
+ *     };
+ *
+ *     // Allocate a new netlink message, type=RTM_SETLINK, flags=NLM_F_ECHO
+ *     if (!(msg = nlmsg_alloc_simple(RTM_SETLINK, NLM_F_ECHO)))
+ *         return NULL;
+ *
+ *     // Append the family specific header (struct ifinfomsg)
+ *     if (nlmsg_append(msg, &ifi, sizeof(ifi), NLMSG_ALIGNTO) < 0)
+ *         goto nla_put_failure
+ *
+ *     // Append a 32 bit integer attribute to carry the MTU
+ *     NLA_PUT_U32(msg, IFLA_MTU, mtu);
+ *
+ *     // Append a unspecific attribute to carry the link layer address
+ *     NLA_PUT_ADDR(msg, IFLA_ADDRESS, lladdr);
+ *
+ *     // Append a container for nested attributes to carry link information
+ *     if (!(info = nla_nest_start(msg, IFLA_LINKINFO)))
+ *         goto nla_put_failure;
+ *
+ *     // Put a string attribute into the container
+ *     NLA_PUT_STRING(msg, IFLA_INFO_KIND, "vlan");
+ *
+ *     // Append another container inside the open container to carry
+ *     // vlan specific attributes
+ *     if (!(vlan = nla_nest_start(msg, IFLA_INFO_DATA)))
+ *         goto nla_put_failure;
+ *
+ *     // add vlan specific info attributes here...
+ *
+ *     // Finish nesting the vlan attributes and close the second container.
+ *     nla_nest_end(msg, vlan);
+ *
+ *     // Finish nesting the link info attribute and close the first container.
+ *     nla_nest_end(msg, info);
+ *
+ *     return msg;
+ *
+ * // If any of the construction macros fails, we end up here.
+ * nla_put_failure:
+ *     nlmsg_free(msg);
+ *     return NULL;
+ * }
+ * @endcode
+ *
+ * @par Example 2.1 Parsing a netlink message with attributes.
+ * @code
+ * int parse_message(struct nl_msg *msg)
+ * {
+ *     // The policy defines two attributes: a 32 bit integer and a container
+ *     // for nested attributes.
+ *     struct nla_policy attr_policy[ATTR_MAX+1] = {
+ *         [ATTR_FOO] = { .type = NLA_U32 },
+ *         [ATTR_BAR] = { .type = NLA_NESTED },
+ *     };
+ *     struct nlattr *attrs[ATTR_MAX+1];
+ *     int err;
+ *
+ *     // The nlmsg_parse() function will make sure that the message contains
+ *     // enough payload to hold the header (struct my_hdr), validates any
+ *     // attributes attached to the messages and stores a pointer to each
+ *     // attribute in the attrs[] array accessable by attribute type.
+ *     if ((err = nlmsg_parse(nlmsg_hdr(msg), sizeof(struct my_hdr), attrs,
+ *                            ATTR_MAX, attr_policy)) < 0)
+ *         goto errout;
+ *
+ *     if (attrs[ATTR_FOO]) {
+ *         // It is safe to directly access the attribute payload without
+ *         // any further checks since nlmsg_parse() enforced the policy.
+ *         uint32_t foo = nla_get_u32(attrs[ATTR_FOO]);
+ *     }
+ *
+ *     if (attrs[ATTR_BAR]) {
+ *         struct nlattr *nested[NESTED_MAX+1];
+ *
+ *         // Attributes nested in a container can be parsed the same way
+ *         // as top level attributes.
+ *         if ((err = nla_parse_nested(nested, NESTED_MAX, attrs[ATTR_BAR],
+ *                                     nested_policy)) < 0)
+ *             goto errout;
+ *
+ *         // Process nested attributes here.
+ *     }
+ *
+ *     err = 0;
+ * errout:
+ *     return err;
+ * }
+ * @endcode
+ *
+ * @{
+ */
+
+/**
+ * @name Attribute Size Calculation
+ * @{
+ */
+
+/**
+ * Return size of attribute whithout padding.
+ * @arg payload		Payload length of attribute.
+ *
+ * @code
+ *    <-------- nla_attr_size(payload) --------->
+ *   +------------------+- - -+- - - - - - - - - +- - -+
+ *   | Attribute Header | Pad |     Payload      | Pad |
+ *   +------------------+- - -+- - - - - - - - - +- - -+
+ * @endcode
+ *
+ * @return Size of attribute in bytes without padding.
+ */
+int nla_attr_size(int payload)
+{
+	return NLA_HDRLEN + payload;
+}
+
+/**
+ * Return size of attribute including padding.
+ * @arg payload		Payload length of attribute.
+ *
+ * @code
+ *    <----------- nla_total_size(payload) ----------->
+ *   +------------------+- - -+- - - - - - - - - +- - -+
+ *   | Attribute Header | Pad |     Payload      | Pad |
+ *   +------------------+- - -+- - - - - - - - - +- - -+
+ * @endcode
+ *
+ * @return Size of attribute in bytes.
+ */
+int nla_total_size(int payload)
+{
+	return NLA_ALIGN(nla_attr_size(payload));
+}
+
+/**
+ * Return length of padding at the tail of the attribute.
+ * @arg payload		Payload length of attribute.
+ *
+ * @code
+ *   +------------------+- - -+- - - - - - - - - +- - -+
+ *   | Attribute Header | Pad |     Payload      | Pad |
+ *   +------------------+- - -+- - - - - - - - - +- - -+
+ *                                                <--->  
+ * @endcode
+ *
+ * @return Length of padding in bytes.
+ */
+int nla_padlen(int payload)
+{
+	return nla_total_size(payload) - nla_attr_size(payload);
+}
+
+/** @} */
+
+/**
+ * @name Parsing Attributes
+ * @{
+ */
+
+/**
+ * Return type of the attribute.
+ * @arg nla		Attribute.
+ *
+ * @return Type of attribute.
+ */
+int nla_type(const struct nlattr *nla)
+{
+	return nla->nla_type & NLA_TYPE_MASK;
+}
+
+/**
+ * Return pointer to the payload section.
+ * @arg nla		Attribute.
+ *
+ * @return Pointer to start of payload section.
+ */
+void *nla_data(const struct nlattr *nla)
+{
+	return (char *) nla + NLA_HDRLEN;
+}
+
+/**
+ * Return length of the payload .
+ * @arg nla		Attribute
+ *
+ * @return Length of payload in bytes.
+ */
+int nla_len(const struct nlattr *nla)
+{
+	return nla->nla_len - NLA_HDRLEN;
+}
+
+/**
+ * Check if the attribute header and payload can be accessed safely.
+ * @arg nla		Attribute of any kind.
+ * @arg remaining	Number of bytes remaining in attribute stream.
+ *
+ * Verifies that the header and payload do not exceed the number of
+ * bytes left in the attribute stream. This function must be called
+ * before access the attribute header or payload when iterating over
+ * the attribute stream using nla_next().
+ *
+ * @return True if the attribute can be accessed safely, false otherwise.
+ */
+int nla_ok(const struct nlattr *nla, int remaining)
+{
+	return remaining >= sizeof(*nla) &&
+	       nla->nla_len >= sizeof(*nla) &&
+	       nla->nla_len <= remaining;
+}
+
+/**
+ * Return next attribute in a stream of attributes.
+ * @arg nla		Attribute of any kind.
+ * @arg remaining	Variable to count remaining bytes in stream.
+ *
+ * Calculates the offset to the next attribute based on the attribute
+ * given. The attribute provided is assumed to be accessible, the
+ * caller is responsible to use nla_ok() beforehand. The offset (length
+ * of specified attribute including padding) is then subtracted from
+ * the remaining bytes variable and a pointer to the next attribute is
+ * returned.
+ *
+ * nla_next() can be called as long as remainig is >0.
+ *
+ * @return Pointer to next attribute.
+ */
+struct nlattr *nla_next(const struct nlattr *nla, int *remaining)
+{
+	int totlen = NLA_ALIGN(nla->nla_len);
+
+	*remaining -= totlen;
+	return (struct nlattr *) ((char *) nla + totlen);
+}
+
+static uint16_t nla_attr_minlen[NLA_TYPE_MAX+1] = {
+	[NLA_U8]	= sizeof(uint8_t),
+	[NLA_U16]	= sizeof(uint16_t),
+	[NLA_U32]	= sizeof(uint32_t),
+	[NLA_U64]	= sizeof(uint64_t),
+	[NLA_STRING]	= 1,
+};
+
+static int validate_nla(struct nlattr *nla, int maxtype,
+			struct nla_policy *policy)
+{
+	struct nla_policy *pt;
+	int minlen = 0, type = nla_type(nla);
+
+	if (type <= 0 || type > maxtype)
+		return 0;
+
+	pt = &policy[type];
+
+	if (pt->type > NLA_TYPE_MAX)
+		BUG();
+
+	if (pt->minlen)
+		minlen = pt->minlen;
+	else if (pt->type != NLA_UNSPEC)
+		minlen = nla_attr_minlen[pt->type];
+
+	if (pt->type == NLA_FLAG && nla_len(nla) > 0)
+		return -NLE_RANGE;
+
+	if (nla_len(nla) < minlen)
+		return -NLE_RANGE;
+
+	if (pt->maxlen && nla_len(nla) > pt->maxlen)
+		return -NLE_RANGE;
+
+	if (pt->type == NLA_STRING) {
+		char *data = nla_data(nla);
+		if (data[nla_len(nla) - 1] != '\0')
+			return -NLE_INVAL;
+	}
+
+	return 0;
+}
+
+
+/**
+ * Create attribute index based on a stream of attributes.
+ * @arg tb		Index array to be filled (maxtype+1 elements).
+ * @arg maxtype		Maximum attribute type expected and accepted.
+ * @arg head		Head of attribute stream.
+ * @arg len		Length of attribute stream.
+ * @arg policy		Attribute validation policy.
+ *
+ * Iterates over the stream of attributes and stores a pointer to each
+ * attribute in the index array using the attribute type as index to
+ * the array. Attribute with a type greater than the maximum type
+ * specified will be silently ignored in order to maintain backwards
+ * compatibility. If \a policy is not NULL, the attribute will be
+ * validated using the specified policy.
+ *
+ * @see nla_validate
+ * @return 0 on success or a negative error code.
+ */
+int nla_parse(struct nlattr *tb[], int maxtype, struct nlattr *head, int len,
+	      struct nla_policy *policy)
+{
+	struct nlattr *nla;
+	int rem, err;
+
+	memset(tb, 0, sizeof(struct nlattr *) * (maxtype + 1));
+
+	nla_for_each_attr(nla, head, len, rem) {
+		int type = nla_type(nla);
+
+		if (type == 0) {
+			fprintf(stderr, "Illegal nla->nla_type == 0\n");
+			continue;
+		}
+
+		if (type <= maxtype) {
+			if (policy) {
+				err = validate_nla(nla, maxtype, policy);
+				if (err < 0)
+					goto errout;
+			}
+
+			tb[type] = nla;
+		}
+	}
+
+	if (rem > 0)
+		fprintf(stderr, "netlink: %d bytes leftover after parsing "
+		       "attributes.\n", rem);
+
+	err = 0;
+errout:
+	return err;
+}
+
+/**
+ * Validate a stream of attributes.
+ * @arg head		Head of attributes stream.
+ * @arg len		Length of attributes stream.
+ * @arg maxtype		Maximum attribute type expected and accepted.
+ * @arg policy		Validation policy.
+ *
+ * Iterates over the stream of attributes and validates each attribute
+ * one by one using the specified policy. Attributes with a type greater
+ * than the maximum type specified will be silently ignored in order to
+ * maintain backwards compatibility.
+ *
+ * See \ref attr_datatypes for more details on what kind of validation
+ * checks are performed on each attribute data type.
+ *
+ * @return 0 on success or a negative error code.
+ */
+int nla_validate(struct nlattr *head, int len, int maxtype,
+		 struct nla_policy *policy)
+{
+	struct nlattr *nla;
+	int rem, err;
+
+	nla_for_each_attr(nla, head, len, rem) {
+		err = validate_nla(nla, maxtype, policy);
+		if (err < 0)
+			goto errout;
+	}
+
+	err = 0;
+errout:
+	return err;
+}
+
+/**
+ * Find a single attribute in a stream of attributes.
+ * @arg head		Head of attributes stream.
+ * @arg len		Length of attributes stream.
+ * @arg attrtype	Attribute type to look for.
+ *
+ * Iterates over the stream of attributes and compares each type with
+ * the type specified. Returns the first attribute which matches the
+ * type.
+ *
+ * @return Pointer to attribute found or NULL.
+ */
+struct nlattr *nla_find(struct nlattr *head, int len, int attrtype)
+{
+	struct nlattr *nla;
+	int rem;
+
+	nla_for_each_attr(nla, head, len, rem)
+		if (nla_type(nla) == attrtype)
+			return nla;
+
+	return NULL;
+}
+
+/** @} */
+
+/**
+ * @name Helper Functions
+ * @{
+ */
+
+/**
+ * Copy attribute payload to another memory area.
+ * @arg dest		Pointer to destination memory area.
+ * @arg src		Attribute
+ * @arg count		Number of bytes to copy at most.
+ *
+ * Note: The number of bytes copied is limited by the length of
+ *       the attribute payload.
+ *
+ * @return The number of bytes copied to dest.
+ */
+int nla_memcpy(void *dest, struct nlattr *src, int count)
+{
+	int minlen;
+
+	if (!src)
+		return 0;
+	
+	minlen = min_t(int, count, nla_len(src));
+	memcpy(dest, nla_data(src), minlen);
+
+	return minlen;
+}
+
+/**
+ * Copy string attribute payload to a buffer.
+ * @arg dst		Pointer to destination buffer.
+ * @arg nla		Attribute of type NLA_STRING.
+ * @arg dstsize		Size of destination buffer in bytes.
+ *
+ * Copies at most dstsize - 1 bytes to the destination buffer.
+ * The result is always a valid NUL terminated string. Unlike
+ * strlcpy the destination buffer is always padded out.
+ *
+ * @return The length of string attribute without the terminating NUL.
+ */
+size_t nla_strlcpy(char *dst, const struct nlattr *nla, size_t dstsize)
+{
+	size_t srclen = nla_len(nla);
+	char *src = nla_data(nla);
+
+	if (srclen > 0 && src[srclen - 1] == '\0')
+		srclen--;
+
+	if (dstsize > 0) {
+		size_t len = (srclen >= dstsize) ? dstsize - 1 : srclen;
+
+		memset(dst, 0, dstsize);
+		memcpy(dst, src, len);
+	}
+
+	return srclen;
+}
+
+/**
+ * Compare attribute payload with memory area.
+ * @arg nla		Attribute.
+ * @arg data		Memory area to compare to.
+ * @arg size		Number of bytes to compare.
+ *
+ * @see memcmp(3)
+ * @return An integer less than, equal to, or greater than zero.
+ */
+int nla_memcmp(const struct nlattr *nla, const void *data, size_t size)
+{
+	int d = nla_len(nla) - size;
+
+	if (d == 0)
+		d = memcmp(nla_data(nla), data, size);
+
+	return d;
+}
+
+/**
+ * Compare string attribute payload with string
+ * @arg nla		Attribute of type NLA_STRING.
+ * @arg str		NUL terminated string.
+ *
+ * @see strcmp(3)
+ * @return An integer less than, equal to, or greater than zero.
+ */
+int nla_strcmp(const struct nlattr *nla, const char *str)
+{
+	int len = strlen(str) + 1;
+	int d = nla_len(nla) - len;
+
+	if (d == 0)
+		d = memcmp(nla_data(nla), str, len);
+
+	return d;
+}
+
+/** @} */
+
+/**
+ * @name Unspecific Attribute
+ * @{
+ */
+
+/**
+ * Reserve space for a attribute.
+ * @arg msg		Netlink Message.
+ * @arg attrtype	Attribute Type.
+ * @arg attrlen		Length of payload.
+ *
+ * Reserves room for a attribute in the specified netlink message and
+ * fills in the attribute header (type, length). Returns NULL if there
+ * is unsuficient space for the attribute.
+ *
+ * Any padding between payload and the start of the next attribute is
+ * zeroed out.
+ *
+ * @return Pointer to start of attribute or NULL on failure.
+ */
+struct nlattr *nla_reserve(struct nl_msg *msg, int attrtype, int attrlen)
+{
+	struct nlattr *nla;
+	int tlen;
+	
+	tlen = NLMSG_ALIGN(msg->nm_nlh->nlmsg_len) + nla_total_size(attrlen);
+
+	if ((tlen + msg->nm_nlh->nlmsg_len) > msg->nm_size)
+		return NULL;
+
+	nla = (struct nlattr *) nlmsg_tail(msg->nm_nlh);
+	nla->nla_type = attrtype;
+	nla->nla_len = nla_attr_size(attrlen);
+
+	memset((unsigned char *) nla + nla->nla_len, 0, nla_padlen(attrlen));
+	msg->nm_nlh->nlmsg_len = tlen;
+
+	NL_DBG(2, "msg %p: Reserved %d bytes at offset +%td for attr %d "
+		  "nlmsg_len=%d\n", msg, attrlen,
+		  (void *) nla - nlmsg_data(msg->nm_nlh),
+		  attrtype, msg->nm_nlh->nlmsg_len);
+
+	return nla;
+}
+
+/**
+ * Add a unspecific attribute to netlink message.
+ * @arg msg		Netlink message.
+ * @arg attrtype	Attribute type.
+ * @arg datalen		Length of data to be used as payload.
+ * @arg data		Pointer to data to be used as attribute payload.
+ *
+ * Reserves room for a unspecific attribute and copies the provided data
+ * into the message as payload of the attribute. Returns an error if there
+ * is insufficient space for the attribute.
+ *
+ * @see nla_reserve
+ * @return 0 on success or a negative error code.
+ */
+int nla_put(struct nl_msg *msg, int attrtype, int datalen, const void *data)
+{
+	struct nlattr *nla;
+
+	nla = nla_reserve(msg, attrtype, datalen);
+	if (!nla)
+		return -NLE_NOMEM;
+
+	memcpy(nla_data(nla), data, datalen);
+	NL_DBG(2, "msg %p: Wrote %d bytes at offset +%td for attr %d\n",
+	       msg, datalen, (void *) nla - nlmsg_data(msg->nm_nlh), attrtype);
+
+	return 0;
+}
+
+/**
+ * Add abstract data as unspecific attribute to netlink message.
+ * @arg msg		Netlink message.
+ * @arg attrtype	Attribute type.
+ * @arg data		Abstract data object.
+ *
+ * Equivalent to nla_put() except that the length of the payload is
+ * derived from the abstract data object.
+ *
+ * @see nla_put
+ * @return 0 on success or a negative error code.
+ */
+int nla_put_data(struct nl_msg *msg, int attrtype, struct nl_data *data)
+{
+	return nla_put(msg, attrtype, nl_data_get_size(data),
+		       nl_data_get(data));
+}
+
+/**
+ * Add abstract address as unspecific attribute to netlink message.
+ * @arg msg		Netlink message.
+ * @arg attrtype	Attribute type.
+ * @arg addr		Abstract address object.
+ *
+ * @see nla_put
+ * @return 0 on success or a negative error code.
+ */
+int nla_put_addr(struct nl_msg *msg, int attrtype, struct nl_addr *addr)
+{
+	return nla_put(msg, attrtype, nl_addr_get_len(addr),
+		       nl_addr_get_binary_addr(addr));
+}
+
+/** @} */
+
+/**
+ * @name Integer Attributes
+ */
+
+/**
+ * Add 8 bit integer attribute to netlink message.
+ * @arg msg		Netlink message.
+ * @arg attrtype	Attribute type.
+ * @arg value		Numeric value to store as payload.
+ *
+ * @see nla_put
+ * @return 0 on success or a negative error code.
+ */
+int nla_put_u8(struct nl_msg *msg, int attrtype, uint8_t value)
+{
+	return nla_put(msg, attrtype, sizeof(uint8_t), &value);
+}
+
+/**
+ * Return value of 8 bit integer attribute.
+ * @arg nla		8 bit integer attribute
+ *
+ * @return Payload as 8 bit integer.
+ */
+uint8_t nla_get_u8(struct nlattr *nla)
+{
+	return *(uint8_t *) nla_data(nla);
+}
+
+/**
+ * Add 16 bit integer attribute to netlink message.
+ * @arg msg		Netlink message.
+ * @arg attrtype	Attribute type.
+ * @arg value		Numeric value to store as payload.
+ *
+ * @see nla_put
+ * @return 0 on success or a negative error code.
+ */
+int nla_put_u16(struct nl_msg *msg, int attrtype, uint16_t value)
+{
+	return nla_put(msg, attrtype, sizeof(uint16_t), &value);
+}
+
+/**
+ * Return payload of 16 bit integer attribute.
+ * @arg nla		16 bit integer attribute
+ *
+ * @return Payload as 16 bit integer.
+ */
+uint16_t nla_get_u16(struct nlattr *nla)
+{
+	return *(uint16_t *) nla_data(nla);
+}
+
+/**
+ * Add 32 bit integer attribute to netlink message.
+ * @arg msg		Netlink message.
+ * @arg attrtype	Attribute type.
+ * @arg value		Numeric value to store as payload.
+ *
+ * @see nla_put
+ * @return 0 on success or a negative error code.
+ */
+int nla_put_u32(struct nl_msg *msg, int attrtype, uint32_t value)
+{
+	return nla_put(msg, attrtype, sizeof(uint32_t), &value);
+}
+
+/**
+ * Return payload of 32 bit integer attribute.
+ * @arg nla		32 bit integer attribute.
+ *
+ * @return Payload as 32 bit integer.
+ */
+uint32_t nla_get_u32(struct nlattr *nla)
+{
+	return *(uint32_t *) nla_data(nla);
+}
+
+/**
+ * Add 64 bit integer attribute to netlink message.
+ * @arg msg		Netlink message.
+ * @arg attrtype	Attribute type.
+ * @arg value		Numeric value to store as payload.
+ *
+ * @see nla_put
+ * @return 0 on success or a negative error code.
+ */
+int nla_put_u64(struct nl_msg *msg, int attrtype, uint64_t value)
+{
+	return nla_put(msg, attrtype, sizeof(uint64_t), &value);
+}
+
+/**
+ * Return payload of u64 attribute
+ * @arg nla		u64 netlink attribute
+ *
+ * @return Payload as 64 bit integer.
+ */
+uint64_t nla_get_u64(struct nlattr *nla)
+{
+	uint64_t tmp;
+
+	nla_memcpy(&tmp, nla, sizeof(tmp));
+
+	return tmp;
+}
+
+/** @} */
+
+/**
+ * @name String Attribute
+ */
+
+/**
+ * Add string attribute to netlink message.
+ * @arg msg		Netlink message.
+ * @arg attrtype	Attribute type.
+ * @arg str		NUL terminated string.
+ *
+ * @see nla_put
+ * @return 0 on success or a negative error code.
+ */
+int nla_put_string(struct nl_msg *msg, int attrtype, const char *str)
+{
+	return nla_put(msg, attrtype, strlen(str) + 1, str);
+}
+
+/**
+ * Return payload of string attribute.
+ * @arg nla		String attribute.
+ *
+ * @return Pointer to attribute payload.
+ */
+char *nla_get_string(struct nlattr *nla)
+{
+	return (char *) nla_data(nla);
+}
+
+char *nla_strdup(struct nlattr *nla)
+{
+	return strdup(nla_get_string(nla));
+}
+
+/** @} */
+
+/**
+ * @name Flag Attribute
+ */
+
+/**
+ * Add flag netlink attribute to netlink message.
+ * @arg msg		Netlink message.
+ * @arg attrtype	Attribute type.
+ *
+ * @see nla_put
+ * @return 0 on success or a negative error code.
+ */
+int nla_put_flag(struct nl_msg *msg, int attrtype)
+{
+	return nla_put(msg, attrtype, 0, NULL);
+}
+
+/**
+ * Return true if flag attribute is set.
+ * @arg nla		Flag netlink attribute.
+ *
+ * @return True if flag is set, otherwise false.
+ */
+int nla_get_flag(struct nlattr *nla)
+{
+	return !!nla;
+}
+
+/** @} */
+
+/**
+ * @name Microseconds Attribute
+ */
+
+/**
+ * Add a msecs netlink attribute to a netlink message
+ * @arg n		netlink message
+ * @arg attrtype	attribute type
+ * @arg msecs 		number of msecs
+ */
+int nla_put_msecs(struct nl_msg *n, int attrtype, unsigned long msecs)
+{
+	return nla_put_u64(n, attrtype, msecs);
+}
+
+/**
+ * Return payload of msecs attribute
+ * @arg nla		msecs netlink attribute
+ *
+ * @return the number of milliseconds.
+ */
+unsigned long nla_get_msecs(struct nlattr *nla)
+{
+	return nla_get_u64(nla);
+}
+
+/** @} */
+
+/**
+ * @name Nested Attribute
+ */
+
+/**
+ * Add nested attributes to netlink message.
+ * @arg msg		Netlink message.
+ * @arg attrtype	Attribute type.
+ * @arg nested		Message containing attributes to be nested.
+ *
+ * Takes the attributes found in the \a nested message and appends them
+ * to the message \a msg nested in a container of the type \a attrtype.
+ * The \a nested message may not have a family specific header.
+ *
+ * @see nla_put
+ * @return 0 on success or a negative error code.
+ */
+int nla_put_nested(struct nl_msg *msg, int attrtype, struct nl_msg *nested)
+{
+	return nla_put(msg, attrtype, nlmsg_len(nested->nm_nlh),
+		       nlmsg_data(nested->nm_nlh));
+}
+
+
+/**
+ * Start a new level of nested attributes.
+ * @arg msg		Netlink message.
+ * @arg attrtype	Attribute type of container.
+ *
+ * @return Pointer to container attribute.
+ */
+struct nlattr *nla_nest_start(struct nl_msg *msg, int attrtype)
+{
+	struct nlattr *start = (struct nlattr *) nlmsg_tail(msg->nm_nlh);
+
+	if (nla_put(msg, attrtype, 0, NULL) < 0)
+		return NULL;
+
+	return start;
+}
+
+/**
+ * Finalize nesting of attributes.
+ * @arg msg		Netlink message.
+ * @arg start		Container attribute as returned from nla_nest_start().
+ *
+ * Corrects the container attribute header to include the appeneded attributes.
+ *
+ * @return 0
+ */
+int nla_nest_end(struct nl_msg *msg, struct nlattr *start)
+{
+	start->nla_len = (unsigned char *) nlmsg_tail(msg->nm_nlh) -
+				(unsigned char *) start;
+	return 0;
+}
+
+/**
+ * Create attribute index based on nested attribute
+ * @arg tb		Index array to be filled (maxtype+1 elements).
+ * @arg maxtype		Maximum attribute type expected and accepted.
+ * @arg nla		Nested Attribute.
+ * @arg policy		Attribute validation policy.
+ *
+ * Feeds the stream of attributes nested into the specified attribute
+ * to nla_parse().
+ *
+ * @see nla_parse
+ * @return 0 on success or a negative error code.
+ */
+int nla_parse_nested(struct nlattr *tb[], int maxtype, struct nlattr *nla,
+		     struct nla_policy *policy)
+{
+	return nla_parse(tb, maxtype, nla_data(nla), nla_len(nla), policy);
+}
+
+/** @} */
+
+/** @} */
diff -uNr libnl_kk/lib/cache.c libnl/lib/cache.c
--- libnl_kk/lib/cache.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/cache.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,836 @@
+/*
+ * lib/cache.c		Caching Module
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup cache_mngt
+ * @defgroup cache Cache
+ *
+ * @code
+ *   Cache Management             |    | Type Specific Cache Operations
+ *                                      
+ *                                |    | +----------------+ +------------+
+ *                                       | request update | | msg_parser |
+ *                                |    | +----------------+ +------------+
+ *                                     +- - - - -^- - - - - - - -^- -|- - - -
+ *    nl_cache_update:            |              |               |   |
+ *          1) --------- co_request_update ------+               |   |
+ *                                |                              |   |
+ *          2) destroy old cache     +----------- pp_cb ---------|---+
+ *                                |  |                           |
+ *          3) ---------- nl_recvmsgs ----------+   +- cb_valid -+
+ *             +--------------+   |  |          |   |
+ *             | nl_cache_add |<-----+   + - - -v- -|- - - - - - - - - - -
+ *             +--------------+   |      | +-------------+
+ *                                         | nl_recvmsgs |
+ *                                |      | +-----|-^-----+
+ *                                           +---v-|---+
+ *                                |      |   | nl_recv |
+ *                                           +---------+
+ *                                |      |                 Core Netlink
+ * @endcode
+ * 
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink/netlink.h>
+#include <netlink/cache.h>
+#include <netlink/object.h>
+#include <netlink/utils.h>
+
+/**
+ * @name Access Functions
+ * @{
+ */
+
+/**
+ * Return the number of items in the cache
+ * @arg cache		cache handle
+ */
+int nl_cache_nitems(struct nl_cache *cache)
+{
+	return cache->c_nitems;
+}
+
+/**
+ * Return the number of items matching a filter in the cache
+ * @arg cache		Cache object.
+ * @arg filter		Filter object.
+ */
+int nl_cache_nitems_filter(struct nl_cache *cache, struct nl_object *filter)
+{
+	struct nl_object_ops *ops;
+	struct nl_object *obj;
+	int nitems = 0;
+
+	if (cache->c_ops == NULL)
+		BUG();
+
+	ops = cache->c_ops->co_obj_ops;
+	
+	nl_list_for_each_entry(obj, &cache->c_items, ce_list) {
+		if (filter && !nl_object_match_filter(obj, filter))
+			continue;
+
+		nitems++;
+	}
+
+	return nitems;
+}
+
+/**
+ * Returns \b true if the cache is empty.
+ * @arg cache		Cache to check
+ * @return \a true if the cache is empty, otherwise \b false is returned.
+ */
+int nl_cache_is_empty(struct nl_cache *cache)
+{
+	return nl_list_empty(&cache->c_items);
+}
+
+/**
+ * Return the operations set of the cache
+ * @arg cache		cache handle
+ */
+struct nl_cache_ops *nl_cache_get_ops(struct nl_cache *cache)
+{
+	return cache->c_ops;
+}
+
+/**
+ * Return the first element in the cache
+ * @arg cache		cache handle
+ */
+struct nl_object *nl_cache_get_first(struct nl_cache *cache)
+{
+	if (nl_list_empty(&cache->c_items))
+		return NULL;
+
+	return nl_list_entry(cache->c_items.next,
+			     struct nl_object, ce_list);
+}
+
+/**
+ * Return the last element in the cache
+ * @arg cache		cache handle
+ */
+struct nl_object *nl_cache_get_last(struct nl_cache *cache)
+{
+	if (nl_list_empty(&cache->c_items))
+		return NULL;
+
+	return nl_list_entry(cache->c_items.prev,
+			     struct nl_object, ce_list);
+}
+
+/**
+ * Return the next element in the cache
+ * @arg obj		current object
+ */
+struct nl_object *nl_cache_get_next(struct nl_object *obj)
+{
+	if (nl_list_at_tail(obj, &obj->ce_cache->c_items, ce_list))
+		return NULL;
+	else
+		return nl_list_entry(obj->ce_list.next,
+				     struct nl_object, ce_list);
+}
+
+/**
+ * Return the previous element in the cache
+ * @arg obj		current object
+ */
+struct nl_object *nl_cache_get_prev(struct nl_object *obj)
+{
+	if (nl_list_at_head(obj, &obj->ce_cache->c_items, ce_list))
+		return NULL;
+	else
+		return nl_list_entry(obj->ce_list.prev,
+				     struct nl_object, ce_list);
+}
+
+/** @} */
+
+/**
+ * @name Cache Creation/Deletion
+ * @{
+ */
+
+/**
+ * Allocate an empty cache
+ * @arg ops		cache operations to base the cache on
+ * 
+ * @return A newly allocated and initialized cache.
+ */
+struct nl_cache *nl_cache_alloc(struct nl_cache_ops *ops)
+{
+	struct nl_cache *cache;
+
+	cache = calloc(1, sizeof(*cache));
+	if (!cache)
+		return NULL;
+
+	nl_init_list_head(&cache->c_items);
+	cache->c_ops = ops;
+
+	NL_DBG(2, "Allocated cache %p <%s>.\n", cache, nl_cache_name(cache));
+
+	return cache;
+}
+
+int nl_cache_alloc_and_fill(struct nl_cache_ops *ops, struct nl_sock *sock,
+			    struct nl_cache **result)
+{
+	struct nl_cache *cache;
+	int err;
+	
+	if (!(cache = nl_cache_alloc(ops)))
+		return -NLE_NOMEM;
+
+	if (sock && (err = nl_cache_refill(sock, cache)) < 0) {
+		nl_cache_free(cache);
+		return err;
+	}
+
+	*result = cache;
+	return 0;
+}
+
+/**
+ * Allocate an empty cache based on type name
+ * @arg kind		Name of cache type
+ * @return A newly allocated and initialized cache.
+ */
+int nl_cache_alloc_name(const char *kind, struct nl_cache **result)
+{
+	struct nl_cache_ops *ops;
+	struct nl_cache *cache;
+
+	ops = nl_cache_ops_lookup(kind);
+	if (!ops)
+		return -NLE_NOCACHE;
+
+	if (!(cache = nl_cache_alloc(ops)))
+		return -NLE_NOMEM;
+
+	*result = cache;
+	return 0;
+}
+
+/**
+ * Allocate a new cache containing a subset of a cache
+ * @arg orig		Original cache to be based on
+ * @arg filter		Filter defining the subset to be filled into new cache
+ * @return A newly allocated cache or NULL.
+ */
+struct nl_cache *nl_cache_subset(struct nl_cache *orig,
+				 struct nl_object *filter)
+{
+	struct nl_cache *cache;
+	struct nl_object_ops *ops;
+	struct nl_object *obj;
+
+	if (!filter)
+		BUG();
+
+	cache = nl_cache_alloc(orig->c_ops);
+	if (!cache)
+		return NULL;
+
+	ops = orig->c_ops->co_obj_ops;
+
+	nl_list_for_each_entry(obj, &orig->c_items, ce_list) {
+		if (!nl_object_match_filter(obj, filter))
+			continue;
+
+		nl_cache_add(cache, obj);
+	}
+
+	return cache;
+}
+
+/**
+ * Clear a cache.
+ * @arg cache		cache to clear
+ *
+ * Removes all elements of a cache.
+ */
+void nl_cache_clear(struct nl_cache *cache)
+{
+	struct nl_object *obj, *tmp;
+
+	NL_DBG(1, "Clearing cache %p <%s>...\n", cache, nl_cache_name(cache));
+
+	nl_list_for_each_entry_safe(obj, tmp, &cache->c_items, ce_list)
+		nl_cache_remove(obj);
+}
+
+/**
+ * Free a cache.
+ * @arg cache		Cache to free.
+ *
+ * Removes all elements of a cache and frees all memory.
+ *
+ * @note Use this function if you are working with allocated caches.
+ */
+void nl_cache_free(struct nl_cache *cache)
+{
+	if (!cache)
+		return;
+
+	nl_cache_clear(cache);
+	NL_DBG(1, "Freeing cache %p <%s>...\n", cache, nl_cache_name(cache));
+	free(cache);
+}
+
+/** @} */
+
+/**
+ * @name Cache Modifications
+ * @{
+ */
+
+static int __cache_add(struct nl_cache *cache, struct nl_object *obj)
+{
+	obj->ce_cache = cache;
+
+	nl_list_add_tail(&obj->ce_list, &cache->c_items);
+	cache->c_nitems++;
+
+	NL_DBG(1, "Added %p to cache %p <%s>.\n",
+	       obj, cache, nl_cache_name(cache));
+
+	return 0;
+}
+
+/**
+ * Add object to a cache.
+ * @arg cache		Cache to add object to
+ * @arg obj		Object to be added to the cache
+ *
+ * Adds the given object to the specified cache. The object is cloned
+ * if it has been added to another cache already.
+ *
+ * @return 0 or a negative error code.
+ */
+int nl_cache_add(struct nl_cache *cache, struct nl_object *obj)
+{
+	struct nl_object *new;
+
+	if (cache->c_ops->co_obj_ops != obj->ce_ops)
+		return -NLE_OBJ_MISMATCH;
+
+	if (!nl_list_empty(&obj->ce_list)) {
+		new = nl_object_clone(obj);
+		if (!new)
+			return -NLE_NOMEM;
+	} else {
+		nl_object_get(obj);
+		new = obj;
+	}
+
+	return __cache_add(cache, new);
+}
+
+/**
+ * Move object from one cache to another
+ * @arg cache		Cache to move object to.
+ * @arg obj		Object subject to be moved
+ *
+ * Removes the given object from its associated cache if needed
+ * and adds it to the new cache.
+ *
+ * @return 0 on success or a negative error code.
+ */
+int nl_cache_move(struct nl_cache *cache, struct nl_object *obj)
+{
+	if (cache->c_ops->co_obj_ops != obj->ce_ops)
+		return -NLE_OBJ_MISMATCH;
+
+	NL_DBG(3, "Moving object %p to cache %p\n", obj, cache);
+	
+	/* Acquire reference, if already in a cache this will be
+	 * reverted during removal */
+	nl_object_get(obj);
+
+	if (!nl_list_empty(&obj->ce_list))
+		nl_cache_remove(obj);
+
+	return __cache_add(cache, obj);
+}
+
+/**
+ * Removes an object from a cache.
+ * @arg obj		Object to remove from its cache
+ *
+ * Removes the object \c obj from the cache it is assigned to, since
+ * an object can only be assigned to one cache at a time, the cache
+ * must ne be passed along with it.
+ */
+void nl_cache_remove(struct nl_object *obj)
+{
+	struct nl_cache *cache = obj->ce_cache;
+
+	if (cache == NULL)
+		return;
+
+	nl_list_del(&obj->ce_list);
+	obj->ce_cache = NULL;
+	nl_object_put(obj);
+	cache->c_nitems--;
+
+	NL_DBG(1, "Deleted %p from cache %p <%s>.\n",
+	       obj, cache, nl_cache_name(cache));
+}
+
+/**
+ * Search for an object in a cache
+ * @arg cache		Cache to search in.
+ * @arg needle		Object to look for.
+ *
+ * Iterates over the cache and looks for an object with identical
+ * identifiers as the needle.
+ *
+ * @return Reference to object or NULL if not found.
+ * @note The returned object must be returned via nl_object_put().
+ */
+struct nl_object *nl_cache_search(struct nl_cache *cache,
+				  struct nl_object *needle)
+{
+	struct nl_object *obj;
+
+	nl_list_for_each_entry(obj, &cache->c_items, ce_list) {
+		if (nl_object_identical(obj, needle)) {
+			nl_object_get(obj);
+			return obj;
+		}
+	}
+
+	return NULL;
+}
+
+
+/** @} */
+
+/**
+ * @name Synchronization
+ * @{
+ */
+
+/**
+ * Request a full dump from the kernel to fill a cache
+ * @arg sk		Netlink socket.
+ * @arg cache		Cache subjected to be filled.
+ *
+ * Send a dumping request to the kernel causing it to dump all objects
+ * related to the specified cache to the netlink socket.
+ *
+ * Use nl_cache_pickup() to read the objects from the socket and fill them
+ * into a cache.
+ */
+int nl_cache_request_full_dump(struct nl_sock *sk, struct nl_cache *cache)
+{
+	NL_DBG(2, "Requesting dump from kernel for cache %p <%s>...\n",
+	          cache, nl_cache_name(cache));
+
+	if (cache->c_ops->co_request_update == NULL)
+		return -NLE_OPNOTSUPP;
+
+	return cache->c_ops->co_request_update(cache, sk);
+}
+
+/** @cond SKIP */
+struct update_xdata {
+	struct nl_cache_ops *ops;
+	struct nl_parser_param *params;
+};
+
+static int update_msg_parser(struct nl_msg *msg, void *arg)
+{
+	struct update_xdata *x = arg;
+	
+	return nl_cache_parse(x->ops, &msg->nm_src, msg->nm_nlh, x->params);
+}
+/** @endcond */
+
+int __cache_pickup(struct nl_sock *sk, struct nl_cache *cache,
+		   struct nl_parser_param *param)
+{
+	int err;
+	struct nl_cb *cb;
+	struct update_xdata x = {
+		.ops = cache->c_ops,
+		.params = param,
+	};
+
+	NL_DBG(1, "Picking up answer for cache %p <%s>...\n",
+		  cache, nl_cache_name(cache));
+
+	cb = nl_cb_clone(sk->s_cb);
+	if (cb == NULL)
+		return -NLE_NOMEM;
+
+	nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, update_msg_parser, &x);
+
+	err = nl_recvmsgs(sk, cb);
+	if (err < 0)
+		NL_DBG(2, "While picking up for %p <%s>, recvmsgs() returned " \
+		       "%d: %s", cache, nl_cache_name(cache),
+		       err, nl_geterror(err));
+
+	nl_cb_put(cb);
+
+	return err;
+}
+
+static int pickup_cb(struct nl_object *c, struct nl_parser_param *p)
+{
+	return nl_cache_add((struct nl_cache *) p->pp_arg, c);
+}
+
+/**
+ * Pickup a netlink dump response and put it into a cache.
+ * @arg sk		Netlink socket.
+ * @arg cache		Cache to put items into.
+ *
+ * Waits for netlink messages to arrive, parses them and puts them into
+ * the specified cache.
+ *
+ * @return 0 on success or a negative error code.
+ */
+int nl_cache_pickup(struct nl_sock *sk, struct nl_cache *cache)
+{
+	struct nl_parser_param p = {
+		.pp_cb = pickup_cb,
+		.pp_arg = cache,
+	};
+
+	return __cache_pickup(sk, cache, &p);
+}
+
+static int cache_include(struct nl_cache *cache, struct nl_object *obj,
+			 struct nl_msgtype *type, change_func_t cb, void *data)
+{
+	struct nl_object *old;
+
+	switch (type->mt_act) {
+	case NL_ACT_NEW:
+	case NL_ACT_DEL:
+		old = nl_cache_search(cache, obj);
+		if (old) {
+			nl_cache_remove(old);
+			if (type->mt_act == NL_ACT_DEL) {
+				if (cb)
+					cb(cache, old, NL_ACT_DEL, data);
+				nl_object_put(old);
+			}
+		}
+
+		if (type->mt_act == NL_ACT_NEW) {
+			nl_cache_move(cache, obj);
+			if (old == NULL && cb)
+				cb(cache, obj, NL_ACT_NEW, data);
+			else if (old) {
+				if (nl_object_diff(old, obj) && cb)
+					cb(cache, obj, NL_ACT_CHANGE, data);
+
+				nl_object_put(old);
+			}
+		}
+		break;
+	default:
+		NL_DBG(2, "Unknown action associated to object %p\n", obj);
+		return 0;
+	}
+
+	return 0;
+}
+
+int nl_cache_include(struct nl_cache *cache, struct nl_object *obj,
+		     change_func_t change_cb, void *data)
+{
+	struct nl_cache_ops *ops = cache->c_ops;
+	int i;
+
+	if (ops->co_obj_ops != obj->ce_ops)
+		return -NLE_OBJ_MISMATCH;
+
+	for (i = 0; ops->co_msgtypes[i].mt_id >= 0; i++)
+		if (ops->co_msgtypes[i].mt_id == obj->ce_msgtype)
+			return cache_include(cache, obj, &ops->co_msgtypes[i],
+					     change_cb, data);
+
+	return -NLE_MSGTYPE_NOSUPPORT;
+}
+
+static int resync_cb(struct nl_object *c, struct nl_parser_param *p)
+{
+	struct nl_cache_assoc *ca = p->pp_arg;
+
+	return nl_cache_include(ca->ca_cache, c, ca->ca_change, ca->ca_change_data);
+}
+
+int nl_cache_resync(struct nl_sock *sk, struct nl_cache *cache,
+		    change_func_t change_cb, void *data)
+{
+	struct nl_object *obj, *next;
+	struct nl_cache_assoc ca = {
+		.ca_cache = cache,
+		.ca_change = change_cb,
+		.ca_change_data = data,
+	};
+	struct nl_parser_param p = {
+		.pp_cb = resync_cb,
+		.pp_arg = &ca,
+	};
+	int err;
+
+	NL_DBG(1, "Resyncing cache %p <%s>...\n", cache, nl_cache_name(cache));
+
+	/* Mark all objects so we can see if some of them are obsolete */
+	nl_cache_mark_all(cache);
+
+	err = nl_cache_request_full_dump(sk, cache);
+	if (err < 0)
+		goto errout;
+
+	err = __cache_pickup(sk, cache, &p);
+	if (err < 0)
+		goto errout;
+
+	nl_list_for_each_entry_safe(obj, next, &cache->c_items, ce_list) {
+		if (nl_object_is_marked(obj)) {
+			nl_object_get(obj);
+			nl_cache_remove(obj);
+			if (change_cb)
+				change_cb(cache, obj, NL_ACT_DEL, data);
+			nl_object_put(obj);
+		}
+	}
+
+	NL_DBG(1, "Finished resyncing %p <%s>\n", cache, nl_cache_name(cache));
+
+	err = 0;
+errout:
+	return err;
+}
+
+/** @} */
+
+/**
+ * @name Parsing
+ * @{
+ */
+
+/** @cond SKIP */
+int nl_cache_parse(struct nl_cache_ops *ops, struct sockaddr_nl *who,
+		   struct nlmsghdr *nlh, struct nl_parser_param *params)
+{
+	int i, err;
+
+	if (!nlmsg_valid_hdr(nlh, ops->co_hdrsize))
+		return -NLE_MSG_TOOSHORT;
+
+	for (i = 0; ops->co_msgtypes[i].mt_id >= 0; i++) {
+		if (ops->co_msgtypes[i].mt_id == nlh->nlmsg_type) {
+			err = ops->co_msg_parser(ops, who, nlh, params);
+			if (err != -NLE_OPNOTSUPP)
+				goto errout;
+		}
+	}
+
+
+	err = -NLE_MSGTYPE_NOSUPPORT;
+errout:
+	return err;
+}
+/** @endcond */
+
+/**
+ * Parse a netlink message and add it to the cache.
+ * @arg cache		cache to add element to
+ * @arg msg		netlink message
+ *
+ * Parses a netlink message by calling the cache specific message parser
+ * and adds the new element to the cache.
+ *
+ * @return 0 or a negative error code.
+ */
+int nl_cache_parse_and_add(struct nl_cache *cache, struct nl_msg *msg)
+{
+	struct nl_parser_param p = {
+		.pp_cb = pickup_cb,
+		.pp_arg = cache,
+	};
+
+	return nl_cache_parse(cache->c_ops, NULL, nlmsg_hdr(msg), &p);
+}
+
+/**
+ * (Re)fill a cache with the contents in the kernel.
+ * @arg sk		Netlink socket.
+ * @arg cache		cache to update
+ *
+ * Clears the specified cache and fills it with the current state in
+ * the kernel.
+ *
+ * @return 0 or a negative error code.
+ */
+int nl_cache_refill(struct nl_sock *sk, struct nl_cache *cache)
+{
+	int err;
+
+	err = nl_cache_request_full_dump(sk, cache);
+	if (err < 0)
+		return err;
+
+	NL_DBG(2, "Upading cache %p <%s>, request sent, waiting for dump...\n",
+	       cache, nl_cache_name(cache));
+	nl_cache_clear(cache);
+
+	return nl_cache_pickup(sk, cache);
+}
+
+/** @} */
+
+/**
+ * @name Utillities
+ * @{
+ */
+
+/**
+ * Mark all objects in a cache
+ * @arg cache		Cache to mark all objects in
+ */
+void nl_cache_mark_all(struct nl_cache *cache)
+{
+	struct nl_object *obj;
+
+	NL_DBG(2, "Marking all objects in cache %p <%s>...\n",
+	          cache, nl_cache_name(cache));
+
+	nl_list_for_each_entry(obj, &cache->c_items, ce_list)
+		nl_object_mark(obj);
+}
+
+/** @} */
+
+/**
+ * @name Dumping
+ * @{
+ */
+
+/**
+ * Dump all elements of a cache.
+ * @arg cache		cache to dump
+ * @arg params		dumping parameters
+ *
+ * Dumps all elements of the \a cache to the file descriptor \a fd.
+ */
+void nl_cache_dump(struct nl_cache *cache, struct nl_dump_params *params)
+{
+	nl_cache_dump_filter(cache, params, NULL);
+}
+
+/**
+ * Dump all elements of a cache (filtered).
+ * @arg cache		cache to dump
+ * @arg params		dumping parameters (optional)
+ * @arg filter		filter object
+ *
+ * Dumps all elements of the \a cache to the file descriptor \a fd
+ * given they match the given filter \a filter.
+ */
+void nl_cache_dump_filter(struct nl_cache *cache,
+			  struct nl_dump_params *params,
+			  struct nl_object *filter)
+{
+	int type = params ? params->dp_type : NL_DUMP_DETAILS;
+	struct nl_object_ops *ops;
+	struct nl_object *obj;
+
+	NL_DBG(2, "Dumping cache %p <%s> filter %p\n",
+	       cache, nl_cache_name(cache), filter);
+
+	if (type > NL_DUMP_MAX || type < 0)
+		BUG();
+
+	if (cache->c_ops == NULL)
+		BUG();
+
+	ops = cache->c_ops->co_obj_ops;
+	if (!ops->oo_dump[type])
+		return;
+
+	nl_list_for_each_entry(obj, &cache->c_items, ce_list) {
+		if (filter && !nl_object_match_filter(obj, filter))
+			continue;
+
+		NL_DBG(4, "Dumping object %p...\n", obj);
+		dump_from_ops(obj, params);
+	}
+}
+
+/** @} */
+
+/**
+ * @name Iterators
+ * @{
+ */
+
+/**
+ * Call a callback on each element of the cache.
+ * @arg cache		cache to iterate on
+ * @arg cb		callback function
+ * @arg arg		argument passed to callback function
+ *
+ * Calls a callback function \a cb on each element of the \a cache.
+ * The argument \a arg is passed on the callback function.
+ */
+void nl_cache_foreach(struct nl_cache *cache,
+		      void (*cb)(struct nl_object *, void *), void *arg)
+{
+	nl_cache_foreach_filter(cache, NULL, cb, arg);
+}
+
+/**
+ * Call a callback on each element of the cache (filtered).
+ * @arg cache		cache to iterate on
+ * @arg filter		filter object
+ * @arg cb		callback function
+ * @arg arg		argument passed to callback function
+ *
+ * Calls a callback function \a cb on each element of the \a cache
+ * that matches the \a filter. The argument \a arg is passed on
+ * to the callback function.
+ */
+void nl_cache_foreach_filter(struct nl_cache *cache, struct nl_object *filter,
+			     void (*cb)(struct nl_object *, void *), void *arg)
+{
+	struct nl_object *obj, *tmp;
+	struct nl_object_ops *ops;
+
+	if (cache->c_ops == NULL)
+		BUG();
+
+	ops = cache->c_ops->co_obj_ops;
+
+	nl_list_for_each_entry_safe(obj, tmp, &cache->c_items, ce_list) {
+		if (filter && !nl_object_match_filter(obj, filter))
+			continue;
+
+		cb(obj, arg);
+	}
+}
+
+/** @} */
+
+/** @} */
diff -uNr libnl_kk/lib/cache_mngr.c libnl/lib/cache_mngr.c
--- libnl_kk/lib/cache_mngr.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/cache_mngr.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,383 @@
+/*
+ * lib/cache_mngr.c	Cache Manager
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup cache_mngt
+ * @defgroup cache_mngr Manager
+ * @brief Helps keeping caches up to date.
+ *
+ * The purpose of a cache manager is to keep track of caches and
+ * automatically receive event notifications to keep the caches
+ * up to date with the kernel state. Each manager has exactly one
+ * netlink socket assigned which limits the scope of each manager
+ * to exactly one netlink family. Therefore all caches committed
+ * to a manager must be part of the same netlink family. Due to the
+ * nature of a manager, it is not possible to have a cache maintain
+ * two instances of the same cache type. The socket is subscribed
+ * to the event notification group of each cache and also put into
+ * non-blocking mode. Functions exist to poll() on the socket to
+ * wait for new events to be received.
+ *
+ * @code
+ * App       libnl                        Kernel
+ *        |                            |
+ *            +-----------------+        [ notification, link change ]
+ *        |   |  Cache Manager  |      | [   (IFF_UP | IFF_RUNNING)  ]
+ *            |                 |                |
+ *        |   |   +------------+|      |         |  [ notification, new addr ]
+ *    <-------|---| route/link |<-------(async)--+  [  10.0.1.1/32 dev eth1  ]
+ *        |   |   +------------+|      |                      |
+ *            |   +------------+|                             |
+ *    <---|---|---| route/addr |<------|-(async)--------------+
+ *            |   +------------+|
+ *        |   |   +------------+|      |
+ *    <-------|---| ...        ||
+ *        |   |   +------------+|      |
+ *            +-----------------+
+ *        |                            |
+ * @endcode
+ *
+ * @par 1) Creating a new cache manager
+ * @code
+ * struct nl_cache_mngr *mngr;
+ *
+ * // Allocate a new cache manager for RTNETLINK and automatically
+ * // provide the caches added to the manager.
+ * mngr = nl_cache_mngr_alloc(NETLINK_ROUTE, NL_AUTO_PROVIDE);
+ * @endcode
+ *
+ * @par 2) Keep track of a cache
+ * @code
+ * struct nl_cache *cache;
+ *
+ * // Create a new cache for links/interfaces and ask the manager to
+ * // keep it up to date for us. This will trigger a full dump request
+ * // to initially fill the cache.
+ * cache = nl_cache_mngr_add(mngr, "route/link");
+ * @endcode
+ *
+ * @par 3) Make the manager receive updates
+ * @code
+ * // Give the manager the ability to receive updates, will call poll()
+ * // with a timeout of 5 seconds.
+ * if (nl_cache_mngr_poll(mngr, 5000) > 0) {
+ *         // Manager received at least one update, dump cache?
+ *         nl_cache_dump(cache, ...);
+ * }
+ * @endcode
+ *
+ * @par 4) Release cache manager
+ * @code
+ * nl_cache_mngr_free(mngr);
+ * @endcode
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink/netlink.h>
+#include <netlink/cache.h>
+#include <netlink/utils.h>
+
+static int include_cb(struct nl_object *obj, struct nl_parser_param *p)
+{
+	struct nl_cache_assoc *ca = p->pp_arg;
+
+	NL_DBG(2, "Including object %p into cache %p\n", obj, ca->ca_cache);
+#ifdef NL_DEBUG
+	if (nl_debug >= 4)
+		nl_object_dump(obj, &nl_debug_dp);
+#endif
+	return nl_cache_include(ca->ca_cache, obj, ca->ca_change, ca->ca_change_data);
+}
+
+static int event_input(struct nl_msg *msg, void *arg)
+{
+	struct nl_cache_mngr *mngr = arg;
+	int protocol = nlmsg_get_proto(msg);
+	int type = nlmsg_hdr(msg)->nlmsg_type;
+	struct nl_cache_ops *ops;
+	int i, n;
+	struct nl_parser_param p = {
+		.pp_cb = include_cb,
+	};
+
+	NL_DBG(2, "Cache manager %p, handling new message %p as event\n",
+	       mngr, msg);
+#ifdef NL_DEBUG
+	if (nl_debug >= 4)
+		nl_msg_dump(msg, stderr);
+#endif
+
+	if (mngr->cm_protocol != protocol)
+		BUG();
+
+	for (i = 0; i < mngr->cm_nassocs; i++) {
+		if (mngr->cm_assocs[i].ca_cache) {
+			ops = mngr->cm_assocs[i].ca_cache->c_ops;
+			for (n = 0; ops->co_msgtypes[n].mt_id >= 0; n++)
+				if (ops->co_msgtypes[n].mt_id == type)
+					goto found;
+		}
+	}
+
+	return NL_SKIP;
+
+found:
+	NL_DBG(2, "Associated message %p to cache %p\n",
+	       msg, mngr->cm_assocs[i].ca_cache);
+	p.pp_arg = &mngr->cm_assocs[i];
+
+	return nl_cache_parse(ops, NULL, nlmsg_hdr(msg), &p);
+}
+
+/**
+ * Allocate new cache manager
+ * @arg sk		Netlink socket.
+ * @arg protocol	Netlink Protocol this manager is used for
+ * @arg flags		Flags
+ *
+ * @return Newly allocated cache manager or NULL on failure.
+ */
+int nl_cache_mngr_alloc(struct nl_sock *sk, int protocol, int flags,
+			struct nl_cache_mngr **result)
+{
+	struct nl_cache_mngr *mngr;
+	int err = -NLE_NOMEM;
+
+	if (sk == NULL)
+		BUG();
+
+	mngr = calloc(1, sizeof(*mngr));
+	if (!mngr)
+		goto errout;
+
+	mngr->cm_handle = sk;
+	mngr->cm_nassocs = 32;
+	mngr->cm_protocol = protocol;
+	mngr->cm_flags = flags;
+	mngr->cm_assocs = calloc(mngr->cm_nassocs,
+				 sizeof(struct nl_cache_assoc));
+	if (!mngr->cm_assocs)
+		goto errout;
+
+	nl_socket_modify_cb(mngr->cm_handle, NL_CB_VALID, NL_CB_CUSTOM,
+			    event_input, mngr);
+
+	/* Required to receive async event notifications */
+	nl_socket_disable_seq_check(mngr->cm_handle);
+
+	if ((err = nl_connect(mngr->cm_handle, protocol) < 0))
+		goto errout;
+
+	if ((err = nl_socket_set_nonblocking(mngr->cm_handle) < 0))
+		goto errout;
+
+	NL_DBG(1, "Allocated cache manager %p, protocol %d, %d caches\n",
+	       mngr, protocol, mngr->cm_nassocs);
+
+	*result = mngr;
+	return 0;
+
+errout:
+	nl_cache_mngr_free(mngr);
+	return err;
+}
+
+/**
+ * Add cache responsibility to cache manager
+ * @arg mngr		Cache manager.
+ * @arg name		Name of cache to keep track of
+ * @arg cb		Function to be called upon changes.
+ * @arg result		Pointer to store added cache.
+ *
+ * Allocates a new cache of the specified type and adds it to the manager.
+ * The operation will trigger a full dump request from the kernel to
+ * initially fill the contents of the cache. The manager will subscribe
+ * to the notification group of the cache to keep track of any further
+ * changes.
+ *
+ * @return 0 on success or a negative error code.
+ */
+int nl_cache_mngr_add(struct nl_cache_mngr *mngr, const char *name,
+		      change_func_t cb, void *data, struct nl_cache **result)
+{
+	struct nl_cache_ops *ops;
+	struct nl_cache *cache;
+	struct nl_af_group *grp;
+	int err, i;
+
+	ops = nl_cache_ops_lookup(name);
+	if (!ops)
+		return -NLE_NOCACHE;
+
+	if (ops->co_protocol != mngr->cm_protocol)
+		return -NLE_PROTO_MISMATCH;
+
+	if (ops->co_groups == NULL)
+		return -NLE_OPNOTSUPP;
+
+	for (i = 0; i < mngr->cm_nassocs; i++)
+		if (mngr->cm_assocs[i].ca_cache &&
+		    mngr->cm_assocs[i].ca_cache->c_ops == ops)
+			return -NLE_EXIST;
+
+retry:
+	for (i = 0; i < mngr->cm_nassocs; i++)
+		if (!mngr->cm_assocs[i].ca_cache)
+			break;
+
+	if (i >= mngr->cm_nassocs) {
+		mngr->cm_nassocs += 16;
+		mngr->cm_assocs = realloc(mngr->cm_assocs,
+					  mngr->cm_nassocs *
+					  sizeof(struct nl_cache_assoc));
+		if (mngr->cm_assocs == NULL)
+			return -NLE_NOMEM;
+		else {
+			NL_DBG(1, "Increased capacity of cache manager %p " \
+				  "to %d\n", mngr, mngr->cm_nassocs);
+			goto retry;
+		}
+	}
+
+	cache = nl_cache_alloc(ops);
+	if (!cache)
+		return -NLE_NOMEM;
+
+	for (grp = ops->co_groups; grp->ag_group; grp++) {
+		err = nl_socket_add_membership(mngr->cm_handle, grp->ag_group);
+		if (err < 0)
+			goto errout_free_cache;
+	}
+
+	err = nl_cache_refill(mngr->cm_handle, cache);
+	if (err < 0)
+		goto errout_drop_membership;
+
+	mngr->cm_assocs[i].ca_cache = cache;
+	mngr->cm_assocs[i].ca_change = cb;
+	mngr->cm_assocs[i].ca_change_data = data;
+
+	if (mngr->cm_flags & NL_AUTO_PROVIDE)
+		nl_cache_mngt_provide(cache);
+
+	NL_DBG(1, "Added cache %p <%s> to cache manager %p\n",
+	       cache, nl_cache_name(cache), mngr);
+
+	*result = cache;
+	return 0;
+
+errout_drop_membership:
+	for (grp = ops->co_groups; grp->ag_group; grp++)
+		nl_socket_drop_membership(mngr->cm_handle, grp->ag_group);
+errout_free_cache:
+	nl_cache_free(cache);
+
+	return err;
+}
+
+/**
+ * Get file descriptor
+ * @arg mngr		Cache Manager
+ *
+ * Get the file descriptor of the socket associated to the manager.
+ * This can be used to change socket options or monitor activity
+ * using poll()/select().
+ */
+int nl_cache_mngr_get_fd(struct nl_cache_mngr *mngr)
+{
+	return nl_socket_get_fd(mngr->cm_handle);
+}
+
+/**
+ * Check for event notifications
+ * @arg mngr		Cache Manager
+ * @arg timeout		Upper limit poll() will block, in milliseconds.
+ *
+ * Causes poll() to be called to check for new event notifications
+ * being available. Automatically receives and handles available
+ * notifications.
+ *
+ * This functionally is ideally called regularly during an idle
+ * period.
+ *
+ * @return A positive value if at least one update was handled, 0
+ *         for none, or a  negative error code.
+ */
+int nl_cache_mngr_poll(struct nl_cache_mngr *mngr, int timeout)
+{
+	int ret;
+	struct pollfd fds = {
+		.fd = nl_socket_get_fd(mngr->cm_handle),
+		.events = POLLIN,
+	};
+
+	NL_DBG(3, "Cache manager %p, poll() fd %d\n", mngr, fds.fd);
+	ret = poll(&fds, 1, timeout);
+	NL_DBG(3, "Cache manager %p, poll() returned %d\n", mngr, ret);
+	if (ret < 0)
+		return -nl_syserr2nlerr(errno);
+
+	if (ret == 0)
+		return 0;
+
+	return nl_cache_mngr_data_ready(mngr);
+}
+
+/**
+ * Receive available event notifications
+ * @arg mngr		Cache manager
+ *
+ * This function can be called if the socket associated to the manager
+ * contains updates to be received. This function should not be used
+ * if nl_cache_mngr_poll() is used.
+ *
+ * @return A positive value if at least one update was handled, 0
+ *         for none, or a  negative error code.
+ */
+int nl_cache_mngr_data_ready(struct nl_cache_mngr *mngr)
+{
+	int err;
+
+	err = nl_recvmsgs_default(mngr->cm_handle);
+	if (err < 0)
+		return err;
+
+	return 1;
+}
+
+/**
+ * Free cache manager and all caches.
+ * @arg mngr		Cache manager.
+ *
+ * Release all resources after usage of a cache manager.
+ */
+void nl_cache_mngr_free(struct nl_cache_mngr *mngr)
+{
+	int i;
+
+	if (!mngr)
+		return;
+
+	if (mngr->cm_handle)
+		nl_close(mngr->cm_handle);
+
+	for (i = 0; i < mngr->cm_nassocs; i++)
+		if (mngr->cm_assocs[i].ca_cache)
+			nl_cache_free(mngr->cm_assocs[i].ca_cache);
+
+	free(mngr->cm_assocs);
+	free(mngr);
+
+	NL_DBG(1, "Cache manager %p freed\n", mngr);
+}
+
+/** @} */
diff -uNr libnl_kk/lib/cache_mngt.c libnl/lib/cache_mngt.c
--- libnl_kk/lib/cache_mngt.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/cache_mngt.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,249 @@
+/*
+ * lib/cache_mngt.c	Cache Management
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup core
+ * @defgroup cache_mngt Caching
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink/netlink.h>
+#include <netlink/cache.h>
+#include <netlink/utils.h>
+
+static struct nl_cache_ops *cache_ops;
+
+/**
+ * @name Cache Operations Sets
+ * @{
+ */
+
+/**
+ * Lookup the set cache operations of a certain cache type
+ * @arg name		name of the cache type
+ *
+ * @return The cache operations or NULL if no operations
+ *         have been registered under the specified name.
+ */
+struct nl_cache_ops *nl_cache_ops_lookup(const char *name)
+{
+	struct nl_cache_ops *ops;
+
+	for (ops = cache_ops; ops; ops = ops->co_next)
+		if (!strcmp(ops->co_name, name))
+			return ops;
+
+	return NULL;
+}
+
+/**
+ * Associate a message type to a set of cache operations
+ * @arg protocol		netlink protocol
+ * @arg msgtype			netlink message type
+ *
+ * Associates the specified netlink message type with
+ * a registered set of cache operations.
+ *
+ * @return The cache operations or NULL if no association
+ *         could be made.
+ */
+struct nl_cache_ops *nl_cache_ops_associate(int protocol, int msgtype)
+{
+	int i;
+	struct nl_cache_ops *ops;
+
+	for (ops = cache_ops; ops; ops = ops->co_next) {
+		if (ops->co_protocol != protocol)
+			continue;
+
+		for (i = 0; ops->co_msgtypes[i].mt_id >= 0; i++)
+			if (ops->co_msgtypes[i].mt_id == msgtype)
+				return ops;
+	}
+
+	return NULL;
+}
+
+/**
+ * Lookup message type cache association
+ * @arg ops			cache operations
+ * @arg msgtype			netlink message type
+ *
+ * Searches for a matching message type association ing the specified
+ * cache operations.
+ *
+ * @return A message type association or NULL.
+ */
+struct nl_msgtype *nl_msgtype_lookup(struct nl_cache_ops *ops, int msgtype)
+{
+	int i;
+
+	for (i = 0; ops->co_msgtypes[i].mt_id >= 0; i++)
+		if (ops->co_msgtypes[i].mt_id == msgtype)
+			return &ops->co_msgtypes[i];
+
+	return NULL;
+}
+
+static struct nl_cache_ops *cache_ops_lookup_for_obj(struct nl_object_ops *obj_ops)
+{
+	struct nl_cache_ops *ops;
+
+	for (ops = cache_ops; ops; ops = ops->co_next)
+		if (ops->co_obj_ops == obj_ops)
+			return ops;
+
+	return NULL;
+
+}
+
+/**
+ * Call a function for each registered cache operation
+ * @arg cb		Callback function to be called
+ * @arg arg		User specific argument.
+ */
+void nl_cache_ops_foreach(void (*cb)(struct nl_cache_ops *, void *), void *arg)
+{
+	struct nl_cache_ops *ops;
+
+	for (ops = cache_ops; ops; ops = ops->co_next)
+		cb(ops, arg);
+}
+
+/**
+ * Register a set of cache operations
+ * @arg ops		cache operations
+ *
+ * Called by users of caches to announce the avaibility of
+ * a certain cache type.
+ *
+ * @return 0 on success or a negative error code.
+ */
+int nl_cache_mngt_register(struct nl_cache_ops *ops)
+{
+	if (!ops->co_name || !ops->co_obj_ops)
+		return -NLE_INVAL;
+
+	if (nl_cache_ops_lookup(ops->co_name))
+		return -NLE_EXIST;
+
+	ops->co_next = cache_ops;
+	cache_ops = ops;
+
+	NL_DBG(1, "Registered cache operations %s\n", ops->co_name);
+
+	return 0;
+}
+
+/**
+ * Unregister a set of cache operations
+ * @arg ops		cache operations
+ *
+ * Called by users of caches to announce a set of
+ * cache operations is no longer available. The
+ * specified cache operations must have been registered
+ * previously using nl_cache_mngt_register()
+ *
+ * @return 0 on success or a negative error code
+ */
+int nl_cache_mngt_unregister(struct nl_cache_ops *ops)
+{
+	struct nl_cache_ops *t, **tp;
+
+	for (tp = &cache_ops; (t=*tp) != NULL; tp = &t->co_next)
+		if (t == ops)
+			break;
+
+	if (!t)
+		return -NLE_NOCACHE;
+
+	NL_DBG(1, "Unregistered cache operations %s\n", ops->co_name);
+
+	*tp = t->co_next;
+	return 0;
+}
+
+/** @} */
+
+/**
+ * @name Global Cache Provisioning/Requiring
+ * @{
+ */
+
+/**
+ * Provide a cache for global use
+ * @arg cache		cache to provide
+ *
+ * Offers the specified cache to be used by other modules.
+ * Only one cache per type may be shared at a time,
+ * a previsouly provided caches will be overwritten.
+ */
+void nl_cache_mngt_provide(struct nl_cache *cache)
+{
+	struct nl_cache_ops *ops;
+
+	ops = cache_ops_lookup_for_obj(cache->c_ops->co_obj_ops);
+	if (!ops)
+		BUG();
+	else
+		ops->co_major_cache = cache;
+}
+
+/**
+ * Unprovide a cache for global use
+ * @arg cache		cache to unprovide
+ *
+ * Cancels the offer to use a cache globally. The
+ * cache will no longer be returned via lookups but
+ * may still be in use.
+ */
+void nl_cache_mngt_unprovide(struct nl_cache *cache)
+{
+	struct nl_cache_ops *ops;
+
+	ops = cache_ops_lookup_for_obj(cache->c_ops->co_obj_ops);
+	if (!ops)
+		BUG();
+	else if (ops->co_major_cache == cache)
+		ops->co_major_cache = NULL;
+}
+
+/**
+ * Demand the use of a global cache
+ * @arg name		name of the required object type
+ *
+ * Trys to find a cache of the specified type for global
+ * use.
+ *
+ * @return A cache provided by another subsystem of the
+ *         specified type marked to be available.
+ */
+struct nl_cache *nl_cache_mngt_require(const char *name)
+{
+	struct nl_cache_ops *ops;
+
+	ops = nl_cache_ops_lookup(name);
+	if (!ops || !ops->co_major_cache) {
+		fprintf(stderr, "Application BUG: Your application must "
+			"call nl_cache_mngt_provide() and\nprovide a valid "
+			"%s cache to be used for internal lookups.\nSee the "
+			" API documentation for more details.\n", name);
+
+		return NULL;
+	}
+	
+	return ops->co_major_cache;
+}
+
+/** @} */
+
+/** @} */
diff -uNr libnl_kk/lib/data.c libnl/lib/data.c
--- libnl_kk/lib/data.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/data.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,186 @@
+/*
+ * lib/data.c		Abstract Data
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup core
+ * @defgroup data Abstract Data
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink/netlink.h>
+#include <netlink/utils.h>
+#include <linux/socket.h>
+
+/**
+ * @name General
+ * @{
+ */
+
+/**
+ * Allocate a new abstract data object.
+ * @arg buf		Data buffer containing the actual data.
+ * @arg size		Size of data buffer.
+ *
+ * Allocates a new abstract data and copies the specified data
+ * buffer into the new handle.
+ * 
+ * @return Newly allocated data handle or NULL
+ */
+struct nl_data *nl_data_alloc(void *buf, size_t size)
+{
+	struct nl_data *data;
+
+	data = calloc(1, sizeof(*data));
+	if (!data)
+		goto errout;
+
+	data->d_data = calloc(1, size);
+	if (!data->d_data) {
+		free(data);
+		goto errout;
+	}
+
+	data->d_size = size;
+
+	if (buf)
+		memcpy(data->d_data, buf, size);
+
+	return data;
+errout:
+	return NULL;
+}
+
+/**
+ * Allocate abstract data object based on netlink attribute.
+ * @arg nla		Netlink attribute of unspecific type.
+ *
+ * Allocates a new abstract data and copies the payload of the
+ * attribute to the abstract data object.
+ * 
+ * @see nla_data_alloc
+ * @return Newly allocated data handle or NULL
+ */
+struct nl_data *nl_data_alloc_attr(struct nlattr *nla)
+{
+	return nl_data_alloc(nla_data(nla), nla_len(nla));
+}
+
+/**
+ * Clone an abstract data object.
+ * @arg src		Abstract data object
+ *
+ * @return Cloned object or NULL
+ */
+struct nl_data *nl_data_clone(struct nl_data *src)
+{
+	return nl_data_alloc(src->d_data, src->d_size);
+}
+
+/**
+ * Append data to an abstract data object.
+ * @arg data		Abstract data object.
+ * @arg buf		Data buffer containing the data to be appended.
+ * @arg size		Size of data to be apppended.
+ *
+ * Reallocates an abstract data and copies the specified data
+ * buffer into the new handle.
+ * 
+ * @return 0 on success or a negative error code
+ */
+int nl_data_append(struct nl_data *data, void *buf, size_t size)
+{
+	if (size < 0)
+		BUG();
+
+	if (size > 0) {
+		data->d_data = realloc(data->d_data, data->d_size + size);
+		if (!data->d_data)
+			return -NLE_NOMEM;
+
+		if (buf)
+			memcpy(data->d_data + data->d_size, buf, size);
+		else
+			memset(data->d_data + data->d_size, 0, size);
+
+		data->d_size += size;
+	}
+
+	return 0;
+}
+
+/**
+ * Free an abstract data object.
+ * @arg data		Abstract data object.
+ */
+void nl_data_free(struct nl_data *data)
+{
+	if (data)
+		free(data->d_data);
+
+	free(data);
+}
+
+/** @} */
+
+/**
+ * @name Attribute Access
+ * @{
+ */
+
+/**
+ * Get data buffer of abstract data object.
+ * @arg data		Abstract data object.
+ * @return Data buffer or NULL if empty.
+ */
+void *nl_data_get(struct nl_data *data)
+{
+	return data->d_size > 0 ? data->d_data : NULL;
+}
+
+/**
+ * Get size of data buffer of abstract data object.
+ * @arg data		Abstract data object.
+ * @return Size of data buffer.
+ */
+size_t nl_data_get_size(struct nl_data *data)
+{
+	return data->d_size;
+}
+
+/** @} */
+
+/**
+ * @name Misc
+ * @{
+ */
+
+/**
+ * Compare two abstract data objects.
+ * @arg a		Abstract data object.
+ * @arg b		Another abstract data object.
+ * @return An integer less than, equal to, or greater than zero if
+ *         a is found, respectively, to be less than, to match, or
+ *         be greater than b.
+ */
+int nl_data_cmp(struct nl_data *a, struct nl_data *b)
+{
+	void *a_ = nl_data_get(a);
+	void *b_ = nl_data_get(b);
+
+	if (a_ && b_)
+		return memcmp(a_, b_, nl_data_get_size(a));
+	else
+		return -1;
+}
+
+/** @} */
+/** @} */
diff -uNr libnl_kk/lib/doc.c libnl/lib/doc.c
--- libnl_kk/lib/doc.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/doc.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,484 @@
+/*
+ * lib/doc.c		Documentation Purpose
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @mainpage
+ *
+ * @section intro Introduction
+ *
+ * libnl is a set of libraries to deal with the netlink protocol and some
+ * of the high level protocols implemented on top of it. Its goal is to
+ * simplify netlink protocol usage and to create an abstraction layer using
+ * object based interfaces for various netlink based subsystems.The library
+ * was developed and tested on the 2.6.x kernel releases but it may work with
+ * older kernel series.
+ *
+ * @section toc Table of Contents
+ *
+ * - \subpage core_doc
+ * - \subpage route_doc
+ * - \subpage genl_doc
+ * - \subpage nf_doc
+ *
+ * @section remarks Remarks
+ *
+ * @subsection cache_alloc Allocation of Caches
+ *
+ * Almost all subsystem provide a function to allocate a new cache
+ * of some form. The function usually looks like this:
+ * @code
+ * struct nl_cache *<object name>_alloc_cache(struct nl_sock *sk);
+ * @endcode
+ *
+ * These functions allocate a new cache for the own object type,
+ * initializes it properly and updates it to represent the current
+ * state of their master, e.g. a link cache would include all
+ * links currently configured in the kernel.
+ *
+ * Some of the allocation functions may take additional arguments
+ * to further specify what will be part of the cache.
+ *
+ * All such functions return a newly allocated cache or NULL
+ * in case of an error.
+ *
+ * @subsection addr Setting of Addresses
+ * @code
+ * int <object name>_set_addr(struct nl_object *, struct nl_addr *)
+ * @endcode
+ *
+ * All attribute functions avaiable for assigning addresses to objects
+ * take a struct nl_addr argument. The provided address object is
+ * validated against the address family of the object if known already.
+ * The assignment fails if the address families mismatch. In case the
+ * address family has not been specified yet, the address family of
+ * the new address is elected to be the new requirement.
+ *
+ * The function will acquire a new reference on the address object
+ * before assignment, the caller is NOT responsible for this.
+ *
+ * All functions return 0 on success or a negative error code.
+ *
+ * @subsection flags Flags to Character StringTranslations
+ * All functions converting a set of flags to a character string follow
+ * the same principles, therefore, the following information applies
+ * to all functions convertings flags to a character string and vice versa.
+ *
+ * @subsubsection flags2str Flags to Character String
+ * @code
+ * char *<object name>_flags2str(int flags, char *buf, size_t len)
+ * @endcode
+ * @arg flags		Flags.
+ * @arg buf		Destination buffer.
+ * @arg len		Buffer length.
+ *
+ * Converts the specified flags to a character string separated by
+ * commas and stores it in the specified destination buffer.
+ *
+ * @return The destination buffer
+ *
+ * @subsubsection str2flags Character String to Flags
+ * @code
+ * int <object name>_str2flags(const char *name)
+ * @endcode
+ * @arg name		Name of flag.
+ *
+ * Converts the provided character string specifying a flag
+ * to the corresponding numeric value.
+ *
+ * @return Link flag or a negative value if none was found.
+ *
+ * @subsubsection type2str Type to Character String
+ * @code
+ * char *<object name>_<type>2str(int type, char *buf, size_t len)
+ * @endcode
+ * @arg type		Type as numeric value
+ * @arg buf		Destination buffer.
+ * @arg len		Buffer length.
+ *
+ * Converts an identifier (type) to a character string and stores
+ * it in the specified destination buffer.
+ *
+ * @return The destination buffer or the type encoded in hexidecimal
+ *         form if the identifier is unknown.
+ *
+ * @subsubsection str2type Character String to Type
+ * @code
+ * int <object name>_str2<type>(const char *name)
+ * @endcode
+ * @arg name		Name of identifier (type).
+ *
+ * Converts the provided character string specifying a identifier
+ * to the corresponding numeric value.
+ *
+ * @return Identifier as numeric value or a negative value if none was found.
+ *
+ * @page core_doc Core Library (-lnl)
+ * 
+ * @section core_intro Introduction
+ *
+ * The core library contains the fundamentals required to communicate over
+ * netlink sockets. It deals with connecting and unconnecting of sockets,
+ * sending and receiving of data, provides a customizeable receiving state
+ * machine, and provides a abstract data type framework which eases the
+ * implementation of object based netlink protocols where objects are added,
+ * removed, or modified with the help of netlink messages.
+ *
+ * @section core_toc Table of Contents
+ * 
+ * - \ref proto_fund
+ * - \ref sk_doc
+ * - \ref rxtx_doc
+ * - \ref cb_doc
+ *
+ * @section proto_fund Netlink Protocol Fundamentals
+ *
+ * The netlink protocol is a socket based IPC mechanism used for communication
+ * between userspace processes and the kernel. The netlink protocol uses the
+ * \c AF_NETLINK address family and defines a protocol type for each subsystem
+ * protocol (e.g. NETLINK_ROUTE, NETLINK_NETFILTER, etc). Its addressing
+ * schema is based on a 32 bit port number, formerly referred to as PID, which
+ * uniquely identifies each peer.
+ *
+ * The netlink protocol is based on messages each limited to the size of a
+ * memory page and consists of the netlink message header (struct nlmsghdr)
+ * plus the payload attached to it. The payload can consist of arbitary data
+ * but often contains a fixed sized family specifc header followed by a
+ * stream of \ref attr_doc. The use of attributes dramatically increases
+ * the flexibility of the protocol and allows for the protocol to be
+ * extended while maintaining backwards compatibility.
+ *
+ * The netlink message header (struct nlmsghdr):
+ * @code   
+ * 0                   1                   2                   3
+ * 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+ * +-------------------------------------------------------------+
+ * |                          Length                             |
+ * +------------------------------+------------------------------+
+ * |            Type              |           Flags              |
+ * +------------------------------+------------------------------+
+ * |                      Sequence Number                        |
+ * +-------------------------------------------------------------+
+ * |                       Port (Address)                        |
+ * +-------------------------------------------------------------+
+ * @endcode
+ *
+ * Netlink differs between requests, notifications, and replies. Requests
+ * are messages which have the \c NLM_F_REQUEST flag set and are meant to
+ * request an action from the receiver. A request is typically sent from
+ * a userspace process to the kernel. Every request should be assigned a
+ * sequence number which should be incremented for each request sent on the
+ * sending side. Depending on the nature of the request, the receiver may
+ * reply to the request with regular netlink messages which should contain
+ * the same sequence number as the request it relates to. Notifications are
+ * of informal nature and don't expect a reply, therefore the sequence number
+ * is typically set to 0. It should be noted that unlike in protocols such as
+ * TCP there is no strict enforcment of the sequence number. The sole purpose
+ * of sequence numbers is to assist a sender in relating replies to the
+ * corresponding requests.
+ *
+ * @msc
+ * A,B;
+ * A=>B [label="GET (seq=1, NLM_F_REQUEST)"];
+ * A<=B [label="PUT (seq=1)"];
+ * ...;
+ * A<=B [label="NOTIFY (seq=0)"];
+ * @endmsc
+ *
+ * If the size of a reply exceeds the size of a memory page and thus exceeds
+ * the maximum message size, the reply can be split into a series of multipart
+ * messages. A multipart message has the \c flag NLM_F_MULTI set and the
+ * receiver is expected to continue parsing the reply until the special
+ * message type \c NLMSG_DONE is received.
+ *
+ * @msc
+ * A,B;
+ * A=>B [label="GET (seq=1, NLM_F_REQUEST)"];
+ * A<=B [label="PUT (seq=1, NLM_F_MULTI)"];
+ * ...;
+ * A<=B [label="PUT (seq=1, NLM_F_MULTI)"];
+ * A<=B [label="NLMSG_DONE (seq=1)"];
+ * @endmsc
+ *
+ * Errors can be reported using the standard message type \c NLMSG_ERROR which
+ * can carry an error code and the netlink mesage header of the request.
+ * Error messages should set their sequence number to the sequence number
+ * of the message which caused the error.
+ *
+ * @msc
+ * A,B;
+ * A=>B [label="GET (seq=1, NLM_F_REQUEST)"];
+ * A<=B [label="NLMSG_ERROR code=EINVAL (seq=1)"];
+ * @endmsc
+ *
+ * The \c NLMSG_ERROR message type is also used to send acknowledge messages.
+ * An acknowledge message can be requested by setting the \c NLM_F_ACK flag
+ * message except that the error code is set to 0.
+ *
+ * @msc
+ * A,B;
+ * A=>B [label="GET (seq=1, NLM_F_REQUEST | NLM_F_ACK)"];
+ * A<=B [label="ACK (seq=1)"];
+ * @endmsc
+ *
+ * @section sk_doc Dealing with Netlink Sockets
+ *
+ * In order to use the netlink protocol, a netlink socket is required. Each
+ * socket defines a completely independent context for sending and receiving
+ * of messages. The netlink socket and all its related attributes are
+ * represented by struct nl_sock.
+ *
+ * @code
+ * nl_socket_alloc()                      Allocate new socket structure.
+ * nl_socket_free(s)                      Free socket structure.
+ * @endcode
+ *
+ * @subsection local_port Local Port
+ * The local port number uniquely identifies the socket and is used to
+ * address it. A unique local port is generated automatically when the socket
+ * is allocated. It will consist of the Process ID (22 bits) and a random
+ * number (10 bits) to allow up to 1024 sockets per process.
+ *
+ * @code
+ * nl_socket_get_local_port(sk)           Return the peer's port number.
+ * nl_socket_set_local_port(sk, port)     Set the peer's port number.
+ * @endcode
+ *
+ * @subsection peer_port Peer Port
+ * A peer port can be assigned to the socket which will result in all unicast
+ * messages sent over the socket to be addresses to the corresponding peer. If
+ * no peer is specified, the kernel will try to automatically bind the socket
+ * to a kernel side socket of the same netlink protocol family. It is common
+ * practice not to bind the socket to a peer port as typically only one kernel
+ * side socket exists per netlink protocol family.
+ *
+ * @code
+ * nl_socket_get_peer_port(sk)            Return the local port number.
+ * nl_socket_set_peer_port(sk, port)      Set the local port number.
+ * @endcode
+ *
+ * @subsection sock_fd File Descriptor
+ * The file descriptor of the socket(2).
+ *
+ * @code
+ * nl_socket_get_fd(sk)                   Return file descriptor.
+ * nl_socket_set_buffer_size(sk, rx, tx)  Set buffer size of socket.
+ * nl_socket_set_nonblocking(sk)          Set socket to non-blocking state.
+ * @endcode
+ *
+ * @subsection group_sub Group Subscriptions
+ * Each socket can subscribe to multicast groups of the netlink protocol
+ * family it is bound to. The socket will then receive a copy of each
+ * message sent to any of the groups. Multicast groups are commonly used
+ * to implement event notifications. Prior to kernel 2.6.14 the group
+ * subscription was performed using a bitmask which limited the number of
+ * groups per protocol family to 32. This outdated interface can still be
+ * accessed via the function nl_join_groups even though it is not recommended
+ * for new code. Starting with 2.6.14 a new method was introduced which
+ * supports subscribing to an almost unlimited number of multicast groups.
+ *
+ * @code
+ * nl_socket_add_membership(sk, group)    Become a member of a multicast group.
+ * nl_socket_drop_membership(sk, group)   Drop multicast group membership.
+ * nl_join_groups(sk, groupmask)          Join a multicast group (obsolete).
+ * @endcode
+ *
+ * @subsection seq_num Sequence Numbers
+ * The socket keeps track of the sequence numbers used. The library will
+ * automatically verify the sequence number of messages received unless
+ * the check was disabled using the function nl_socket_disable_seq_check().
+ * When a message is sent using nl_send_auto_complete(), the sequence number
+ * is automatically filled in, and replies will be verified correctly.
+ *
+ * @code
+ * nl_socket_disable_seq_check(sk)        Disable checking of sequece numbers.
+ * nl_socket_use_seq(sk)                  Use sequence number and bump to next.
+ * @endcode
+ *
+ * @subsection sock_cb Callback Configuration
+ * Every socket is associated a callback configuration which enables the
+ * applications to hook into various internal functions and control the
+ * receiving and sendings semantics. For more information, see section
+ * \ref cb_doc.
+ *
+ * @code
+ * nl_socket_alloc_cb(cb)                 Allocate socket based on callback set.
+ * nl_socket_get_cb(sk)                   Return callback configuration.
+ * nl_socket_set_cb(sk, cb)               Replace callback configuration.
+ * nl_socket_modify_cb(sk, ...)           Modify a specific callback function.
+ * @endcode
+ *
+ * @subsection sk_other Other Functions
+ * @code
+ * nl_socket_enable_auto_ack(sock)        Enable automatic request of ACK.
+ * nl_socket_disable_auto_ack(sock)       Disable automatic request of ACK.
+ * nl_socket_enable_msg_peek(sock)        Enable message peeking.
+ * nl_socket_disable_msg_peek(sock)       Disable message peeking.
+ * nl_socket_set_passcred(sk, state)      Enable/disable credential passing.
+ * nl_socket_recv_pktinfo(sk, state)      Enable/disable packet information.
+ * @endcode
+ *
+ * @section rxtx_doc Sending and Receiving of Data
+ *
+ * @subsection recv_semantisc Receiving Semantics
+ * @code
+ *          nl_recvmsgs_default(set)
+ *                 | cb = nl_socket_get_cb(sk)
+ *                 v
+ *          nl_recvmsgs(sk, cb)
+ *                 |           [Application provides nl_recvmsgs() replacement]
+ *                 |- - - - - - - - - - - - - - - v
+ *                 |                     cb->cb_recvmsgs_ow()
+ *                 |
+ *                 |               [Application provides nl_recv() replacement]
+ * +-------------->|- - - - - - - - - - - - - - - v
+ * |           nl_recv()                   cb->cb_recv_ow()
+ * |  +----------->|<- - - - - - - - - - - - - - -+
+ * |  |            v
+ * |  |      Parse Message
+ * |  |            |- - - - - - - - - - - - - - - v
+ * |  |            |                         NL_CB_MSG_IN()
+ * |  |            |<- - - - - - - - - - - - - - -+
+ * |  |            |
+ * |  |            |- - - - - - - - - - - - - - - v
+ * |  |      Sequence Check                NL_CB_SEQ_CHECK()
+ * |  |            |<- - - - - - - - - - - - - - -+
+ * |  |            |
+ * |  |            |- - - - - - - - - - - - - - - v  [ NLM_F_ACK is set ]
+ * |  |            |                      NL_CB_SEND_ACK()
+ * |  |            |<- - - - - - - - - - - - - - -+
+ * |  |            |
+ * |  |      +-----+------+--------------+----------------+--------------+
+ * |  |      v            v              v                v              v
+ * |  | Valid Message    ACK       NO-OP Message  End of Multipart     Error
+ * |  |      |            |              |                |              |
+ * |  |      v            v              v                v              v
+ * |  |NL_CB_VALID()  NL_CB_ACK()  NL_CB_SKIPPED()  NL_CB_FINISH()  cb->cb_err()
+ * |  |      |            |              |                |              |
+ * |  |      +------------+--------------+----------------+              v
+ * |  |                                  |                           (FAILURE)
+ * |  |                                  |  [Callback returned NL_SKIP]
+ * |  |  [More messages to be parsed]    |<-----------
+ * |  +----------------------------------|
+ * |                                     |
+ * |         [is Multipart message]      |
+ * +-------------------------------------|  [Callback returned NL_STOP]
+ *                                       |<-----------
+ *                                       v
+ *                                   (SUCCESS)
+ *
+ *                          At any time:
+ *                                Message Format Error
+ *                                         |- - - - - - - - - - - - v
+ *                                         v                  NL_CB_INVALID()
+ *                                     (FAILURE)
+ *
+ *                                Message Overrun (Kernel Lost Data)
+ *                                         |- - - - - - - - - - - - v
+ *                                         v                  NL_CB_OVERRUN()
+ *                                     (FAILURE)
+ *
+ *                                Callback returned negative error code
+ *                                     (FAILURE)
+ * @endcode
+ *
+ * @subsection send_semantics Sending Semantisc
+ *
+ * @code
+ *     nl_send_auto_complete(sk, msg)
+ *             | [Automatically completes netlink message header]
+ *             | [(local port, sequence number)                 ]
+ *             |
+ *             |                   [Application provies nl_send() replacement]
+ *             |- - - - - - - - - - - - - - - - - - - - v
+ *             v                                 cb->cb_send_ow()
+ *         nl_send(sk, msg)
+ *             | [If available, add peer port and credentials]
+ *             v
+ *        nl_sendmsg(sk, msg, msghdr)
+ *             |- - - - - - - - - - - - - - - - - - - - v
+ *             |                                 NL_CB_MSG_OUT()
+ *             |<- - - - - - - - - - - - - - - - - - - -+
+ *             v
+ *         sendmsg()
+ * @endcode
+ *
+ * @section cb_doc Callback Configurations
+ * Callbacks and overwriting capabilities are provided to control various
+ * semantics of the library. All callback functions are packed together in
+ * struct nl_cb which is attached to a netlink socket or passed on to 
+ * the respective functions directly.
+ *
+ * @subsection cb_ret_doc Callback Return Values
+ * Callback functions can control the flow of the calling layer by returning
+ * appropriate error codes:
+ * @code
+ * Action ID        | Description
+ * -----------------+-------------------------------------------------------
+ * NL_OK            | Proceed with whatever comes next.
+ * NL_SKIP          | Skip message currently being processed and continue
+ *                  | with next message.
+ * NL_STOP          | Stop parsing and discard all remaining messages in
+ *                  | this set of messages.
+ * @endcode
+ *
+ * All callbacks are optional and a default action is performed if no 
+ * application specific implementation is provided:
+ *
+ * @code
+ * Callback ID       | Default Return Value
+ * ------------------+----------------------
+ * NL_CB_VALID       | NL_OK
+ * NL_CB_FINISH      | NL_STOP
+ * NL_CB_OVERRUN     | NL_STOP
+ * NL_CB_SKIPPED     | NL_SKIP
+ * NL_CB_ACK         | NL_STOP
+ * NL_CB_MSG_IN      | NL_OK
+ * NL_CB_MSG_OUT     | NL_OK
+ * NL_CB_INVALID     | NL_STOP
+ * NL_CB_SEQ_CHECK   | NL_OK
+ * NL_CB_SEND_ACK    | NL_OK
+ *                   |
+ * Error Callback    | NL_STOP
+ * @endcode
+ *
+ * In order to simplify typical usages of the library, different sets of
+ * default callback implementations exist:
+ * @code
+ * NL_CB_DEFAULT: No additional actions
+ * NL_CB_VERBOSE: Automatically print warning and error messages to a file
+ *                descriptor as appropriate. This is useful for CLI based
+ *                applications.
+ * NL_CB_DEBUG:   Print informal debugging information for each message
+ *                received. This will result in every message beint sent or
+ *                received to be printed to the screen in a decoded,
+ *                human-readable format.
+ * @endcode
+ *
+ * @par 1) Setting up a callback set
+ * @code
+ * // Allocate a callback set and initialize it to the verbose default set
+ * struct nl_cb *cb = nl_cb_alloc(NL_CB_VERBOSE);
+ *
+ * // Modify the set to call my_func() for all valid messages
+ * nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, my_func, NULL);
+ *
+ * // Set the error message handler to the verbose default implementation
+ * // and direct it to print all errors to the given file descriptor.
+ * FILE *file = fopen(...);
+ * nl_cb_err(cb, NL_CB_VERBOSE, NULL, file);
+ * @endcode
+ *
+ * @page route_doc Routing Family
+ *
+ * @page genl_doc Generic Netlink Family
+ *
+ * @page nf_doc Netfilter Subsystem
+ */
diff -uNr libnl_kk/lib/error.c libnl/lib/error.c
--- libnl_kk/lib/error.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/error.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,110 @@
+/*
+ * lib/error.c		Error Handling
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+#include <netlink-local.h>
+#include <netlink/netlink.h>
+
+static const char *errmsg[NLE_MAX+1] = {
+[NLE_SUCCESS]		= "Success",
+[NLE_FAILURE]		= "Unspecific failure",
+[NLE_INTR]		= "Interrupted system call",
+[NLE_BAD_SOCK]		= "Bad socket",
+[NLE_AGAIN]		= "Try again",
+[NLE_NOMEM]		= "Out of memory",
+[NLE_EXIST]		= "Object exists",
+[NLE_INVAL]		= "Invalid input data or parameter",
+[NLE_RANGE]		= "Input data out of range",
+[NLE_MSGSIZE]		= "Message size not sufficient",
+[NLE_OPNOTSUPP]		= "Operation not supported",
+[NLE_AF_NOSUPPORT]	= "Address family not supported",
+[NLE_OBJ_NOTFOUND]	= "Object not found",
+[NLE_NOATTR]		= "Attribute not available",
+[NLE_MISSING_ATTR]	= "Missing attribute",
+[NLE_AF_MISMATCH]	= "Address family mismatch",
+[NLE_SEQ_MISMATCH]	= "Message sequence number mismatch",
+[NLE_MSG_OVERFLOW]	= "Kernel reported message overflow",
+[NLE_MSG_TRUNC]		= "Kernel reported truncated message",
+[NLE_NOADDR]		= "Invalid address for specified address family",
+[NLE_SRCRT_NOSUPPORT]	= "Source based routing not supported",
+[NLE_MSG_TOOSHORT]	= "Netlink message is too short",
+[NLE_MSGTYPE_NOSUPPORT]	= "Netlink message type is not supported",
+[NLE_OBJ_MISMATCH]	= "Object type does not match cache",
+[NLE_NOCACHE]		= "Unknown or invalid cache type",
+[NLE_BUSY]		= "Object busy",
+[NLE_PROTO_MISMATCH]	= "Protocol mismatch",
+[NLE_NOACCESS]		= "No Access",
+[NLE_PERM]		= "Operation not permitted",
+[NLE_PKTLOC_FILE]	= "Unable to open packet location file",
+};
+
+/**
+ * Return error message for an error code
+ * @return error message
+ */
+const char *nl_geterror(int error)
+{
+	error = abs(error);
+
+	if (error > NLE_MAX)
+		error = NLE_FAILURE;
+
+	return errmsg[error];
+}
+
+/**
+ * Print a libnl error message
+ * @arg s		error message prefix
+ *
+ * Prints the error message of the call that failed last.
+ *
+ * If s is not NULL and *s is not a null byte the argument
+ * string is printed, followed by a colon and a blank. Then
+ * the error message and a new-line.
+ */
+void nl_perror(int error, const char *s)
+{
+	if (s && *s)
+		fprintf(stderr, "%s: %s\n", s, nl_geterror(error));
+	else
+		fprintf(stderr, "%s\n", nl_geterror(error));
+}
+
+int nl_syserr2nlerr(int error)
+{
+	error = abs(error);
+
+	switch (error) {
+	case EBADF:		return NLE_BAD_SOCK;
+	case EADDRINUSE:	return NLE_EXIST;
+	case EEXIST:		return NLE_EXIST;
+	case EADDRNOTAVAIL:	return NLE_NOADDR;
+	case ENOENT:		return NLE_OBJ_NOTFOUND;
+	case EINTR:		return NLE_INTR;
+	case EAGAIN:		return NLE_AGAIN;
+	case ENOTSOCK:		return NLE_BAD_SOCK;
+	case ENOPROTOOPT:	return NLE_INVAL;
+	case EFAULT:		return NLE_INVAL;
+	case EACCES:		return NLE_NOACCESS;
+	case EINVAL:		return NLE_INVAL;
+	case ENOBUFS:		return NLE_NOMEM;
+	case ENOMEM:		return NLE_NOMEM;
+	case EAFNOSUPPORT:	return NLE_AF_NOSUPPORT;
+	case EPROTONOSUPPORT:	return NLE_PROTO_MISMATCH;
+	case EOPNOTSUPP:	return NLE_OPNOTSUPP;
+	case EPERM:		return NLE_PERM;
+	case EBUSY:		return NLE_BUSY;
+	case ERANGE:		return NLE_RANGE;
+	default:		return NLE_FAILURE;
+	}
+}
+
+/** @} */
+
diff -uNr libnl_kk/lib/fib_lookup/lookup.c libnl/lib/fib_lookup/lookup.c
--- libnl_kk/lib/fib_lookup/lookup.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/fib_lookup/lookup.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,349 @@
+/*
+ * lib/fib_lookup/lookup.c	FIB Lookup
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @defgroup fib_lookup FIB Lookup
+ * @brief
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink/netlink.h>
+#include <netlink/attr.h>
+#include <netlink/utils.h>
+#include <netlink/object.h>
+#include <netlink/route/rtnl.h>
+#include <netlink/route/route.h>
+#include <netlink/fib_lookup/request.h>
+#include <netlink/fib_lookup/lookup.h>
+
+/** @cond SKIP */
+static struct nl_cache_ops fib_lookup_ops;
+static struct nl_object_ops result_obj_ops;
+
+/* not exported so far */
+struct fib_result_nl {
+	uint32_t	fl_addr;   /* To be looked up*/ 
+	uint32_t	fl_fwmark; 
+	unsigned char	fl_tos;
+	unsigned char   fl_scope;
+	unsigned char   tb_id_in;
+
+	unsigned char   tb_id;      /* Results */
+	unsigned char	prefixlen;
+	unsigned char	nh_sel;
+	unsigned char	type;
+	unsigned char	scope;
+	int             err;      
+};
+/** @endcond */
+
+static void result_free_data(struct nl_object *obj)
+{
+	struct flnl_result *res = nl_object_priv(obj);
+
+	if (res && res->fr_req)
+		nl_object_put(OBJ_CAST(res->fr_req));
+}
+
+static int result_clone(struct nl_object *_dst, struct nl_object *_src)
+{
+	struct flnl_result *dst = nl_object_priv(_dst);
+	struct flnl_result *src = nl_object_priv(_src);
+
+	if (src->fr_req)
+		if (!(dst->fr_req = (struct flnl_request *)
+				nl_object_clone(OBJ_CAST(src->fr_req))))
+			return -NLE_NOMEM;
+	
+	return 0;
+}
+
+static int result_msg_parser(struct nl_cache_ops *ops, struct sockaddr_nl *who,
+			     struct nlmsghdr *n, struct nl_parser_param *pp)
+{
+	struct flnl_result *res;
+	struct fib_result_nl *fr;
+	struct nl_addr *addr;
+	int err = -NLE_INVAL;
+
+	res = flnl_result_alloc();
+	if (!res)
+		goto errout;
+
+	res->ce_msgtype = n->nlmsg_type;
+
+	res->fr_req = flnl_request_alloc();
+	if (!res->fr_req)
+		goto errout;
+
+	fr = nlmsg_data(n);
+	addr = nl_addr_build(AF_INET, &fr->fl_addr, 4);
+	if (!addr)
+		goto errout;
+	err = flnl_request_set_addr(res->fr_req, addr);
+	nl_addr_put(addr);
+	if (err < 0)
+		goto errout;
+
+	flnl_request_set_fwmark(res->fr_req, fr->fl_fwmark);
+	flnl_request_set_tos(res->fr_req, fr->fl_tos);
+	flnl_request_set_scope(res->fr_req, fr->fl_scope);
+	flnl_request_set_table(res->fr_req, fr->tb_id_in);
+
+	res->fr_table_id = fr->tb_id;
+	res->fr_prefixlen = fr->prefixlen;
+	res->fr_nh_sel = fr->nh_sel;
+	res->fr_type = fr->type;
+	res->fr_scope = fr->scope;
+	res->fr_error = fr->err;
+
+	err = pp->pp_cb((struct nl_object *) res, pp);
+	if (err < 0)
+		goto errout;
+
+	/* REAL HACK, fib_lookup doesn't support ACK nor does it
+	 * send a DONE message, enforce end of message stream
+	 * after just the first message */
+	err = NL_STOP;
+
+errout:
+	flnl_result_put(res);
+	return err;
+}
+
+static void result_dump_line(struct nl_object *obj, struct nl_dump_params *p)
+{
+	struct flnl_result *res = (struct flnl_result *) obj;
+	char buf[128];
+
+	nl_dump_line(p, "table %s prefixlen %u next-hop-selector %u\n",
+		rtnl_route_table2str(res->fr_table_id, buf, sizeof(buf)),
+		res->fr_prefixlen, res->fr_nh_sel);
+	nl_dump_line(p, "type %s ",
+		     nl_rtntype2str(res->fr_type, buf, sizeof(buf)));
+	nl_dump(p, "scope %s error %s (%d)\n",
+		rtnl_scope2str(res->fr_scope, buf, sizeof(buf)),
+		strerror(-res->fr_error), res->fr_error);
+}
+
+static void result_dump_details(struct nl_object *obj, struct nl_dump_params *p)
+{
+	result_dump_line(obj, p);
+}
+
+static int result_compare(struct nl_object *_a, struct nl_object *_b,
+			uint32_t attrs, int flags)
+{
+	return 0;
+}
+
+/**
+ * @name Allocation/Freeing
+ * @{
+ */
+
+struct flnl_result *flnl_result_alloc(void)
+{
+	return (struct flnl_result *) nl_object_alloc(&result_obj_ops);
+}
+
+void flnl_result_put(struct flnl_result *res)
+{
+	nl_object_put((struct nl_object *) res);
+}
+
+/** @} */
+
+/**
+ * @name Cache Management
+ * @{
+ */
+
+/**
+ * Allocate lookup result cache.
+ *
+ * Allocates a new lookup result cache and initializes it properly.
+ *
+ * @note Free the memory after usage using nl_cache_destroy_and_free().
+ * @return Newly allocated cache or NULL if an error occured.
+ */
+struct nl_cache *flnl_result_alloc_cache(void)
+{
+	return nl_cache_alloc(&fib_lookup_ops);
+}
+
+/** @} */
+
+/**
+ * @name Lookup
+ * @{
+ */
+
+/**
+ * Builds a netlink request message to do a lookup
+ * @arg req		Requested match.
+ * @arg flags		additional netlink message flags
+ *
+ * Builds a new netlink message requesting a change of link attributes.
+ * The netlink message header isn't fully equipped with all relevant
+ * fields and must be sent out via nl_send_auto_complete() or
+ * supplemented as needed.
+ * \a old must point to a link currently configured in the kernel
+ * and \a tmpl must contain the attributes to be changed set via
+ * \c rtnl_link_set_* functions.
+ *
+ * @return New netlink message
+ * @note Not all attributes can be changed, see
+ *       \ref link_changeable "Changeable Attributes" for more details.
+ */
+int flnl_lookup_build_request(struct flnl_request *req, int flags,
+			      struct nl_msg **result)
+{
+	struct nl_msg *msg;
+	struct nl_addr *addr;
+	uint64_t fwmark;
+	int tos, scope, table;
+	struct fib_result_nl fr = {0};
+
+	fwmark = flnl_request_get_fwmark(req);
+	tos = flnl_request_get_tos(req);
+	scope = flnl_request_get_scope(req);
+	table = flnl_request_get_table(req);
+
+	fr.fl_fwmark = fwmark != UINT_LEAST64_MAX ? fwmark : 0;
+	fr.fl_tos = tos >= 0 ? tos : 0;
+	fr.fl_scope = scope >= 0 ? scope : RT_SCOPE_UNIVERSE;
+	fr.tb_id_in = table >= 0 ? table : RT_TABLE_UNSPEC;
+
+	addr = flnl_request_get_addr(req);
+	if (!addr)
+		return -NLE_MISSING_ATTR;
+
+	fr.fl_addr = *(uint32_t *) nl_addr_get_binary_addr(addr);
+
+	msg = nlmsg_alloc_simple(0, flags);
+	if (!msg)
+		return -NLE_NOMEM;
+
+	if (nlmsg_append(msg, &fr, sizeof(fr), NLMSG_ALIGNTO) < 0)
+		goto errout;
+
+	*result = msg;
+	return 0;
+
+errout:
+	nlmsg_free(msg);
+	return -NLE_MSGSIZE;
+}
+
+/**
+ * Perform FIB Lookup
+ * @arg sk		Netlink socket.
+ * @arg req		Lookup request object.
+ * @arg cache		Cache for result.
+ *
+ * Builds a netlink message to request a FIB lookup, waits for the
+ * reply and adds the result to the specified cache.
+ *
+ * @return 0 on success or a negative error code.
+ */
+int flnl_lookup(struct nl_sock *sk, struct flnl_request *req,
+		struct nl_cache *cache)
+{
+	struct nl_msg *msg;
+	int err;
+
+	if ((err = flnl_lookup_build_request(req, 0, &msg)) < 0)
+		return err;
+
+	err = nl_send_auto_complete(sk, msg);
+	nlmsg_free(msg);
+	if (err < 0)
+		return err;
+
+	return nl_cache_pickup(sk, cache);
+}
+
+/** @} */
+
+/**
+ * @name Attribute Access
+ * @{
+ */
+
+int flnl_result_get_table_id(struct flnl_result *res)
+{
+	return res->fr_table_id;
+}
+
+int flnl_result_get_prefixlen(struct flnl_result *res)
+{
+	return res->fr_prefixlen;
+}
+
+int flnl_result_get_nexthop_sel(struct flnl_result *res)
+{
+	return res->fr_nh_sel;
+}
+
+int flnl_result_get_type(struct flnl_result *res)
+{
+	return res->fr_type;
+}
+
+int flnl_result_get_scope(struct flnl_result *res)
+{
+	return res->fr_scope;
+}
+
+int flnl_result_get_error(struct flnl_result *res)
+{
+	return res->fr_error;
+}
+
+/** @} */
+
+static struct nl_object_ops result_obj_ops = {
+	.oo_name		= "fib_lookup/result",
+	.oo_size		= sizeof(struct flnl_result),
+	.oo_free_data		= result_free_data,
+	.oo_clone		= result_clone,
+	.oo_dump = {
+	    [NL_DUMP_LINE]	= result_dump_line,
+	    [NL_DUMP_DETAILS]	= result_dump_details,
+	},
+	.oo_compare		= result_compare,
+};
+
+static struct nl_cache_ops fib_lookup_ops = {
+	.co_name		= "fib_lookup/fib_lookup",
+	.co_hdrsize		= sizeof(struct fib_result_nl),
+	.co_msgtypes		= {
+					{ 0, NL_ACT_UNSPEC, "any" },
+					END_OF_MSGTYPES_LIST,
+				  },
+	.co_protocol		= NETLINK_FIB_LOOKUP,
+	.co_msg_parser		= result_msg_parser,
+	.co_obj_ops		= &result_obj_ops,
+};
+
+static void __init fib_lookup_init(void)
+{
+	nl_cache_mngt_register(&fib_lookup_ops);
+}
+
+static void __exit fib_lookup_exit(void)
+{
+	nl_cache_mngt_unregister(&fib_lookup_ops);
+}
+
+/** @} */
diff -uNr libnl_kk/lib/fib_lookup/request.c libnl/lib/fib_lookup/request.c
--- libnl_kk/lib/fib_lookup/request.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/fib_lookup/request.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,185 @@
+/*
+ * lib/fib_lookup/request.c	FIB Lookup Request
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup fib_lookup
+ * @defgroup flreq Request
+ * @brief
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink/netlink.h>
+#include <netlink/attr.h>
+#include <netlink/utils.h>
+#include <netlink/object.h>
+#include <netlink/fib_lookup/request.h>
+
+static struct nl_object_ops request_obj_ops;
+
+/** @cond SKIP */
+#define REQUEST_ATTR_ADDR	0x01
+#define REQUEST_ATTR_FWMARK	0x02
+#define REQUEST_ATTR_TOS	0x04
+#define REQUEST_ATTR_SCOPE	0x08
+#define REQUEST_ATTR_TABLE	0x10
+/** @endcond */
+
+static void request_free_data(struct nl_object *obj)
+{
+	struct flnl_request *req = REQUEST_CAST(obj);
+
+	if (req)
+		nl_addr_put(req->lr_addr);
+}
+
+static int request_clone(struct nl_object *_dst, struct nl_object *_src)
+{
+	struct flnl_request *dst = nl_object_priv(_dst);
+	struct flnl_request *src = nl_object_priv(_src);
+
+	if (src->lr_addr)
+		if (!(dst->lr_addr = nl_addr_clone(src->lr_addr)))
+			return -NLE_NOMEM;
+
+	return 0;
+}
+
+static int request_compare(struct nl_object *_a, struct nl_object *_b,
+			   uint32_t attrs, int flags)
+{
+	struct flnl_request *a = (struct flnl_request *) _a;
+	struct flnl_request *b = (struct flnl_request *) _b;
+	int diff = 0;
+
+#define REQ_DIFF(ATTR, EXPR) ATTR_DIFF(attrs, REQUEST_ATTR_##ATTR, a, b, EXPR)
+
+	diff |= REQ_DIFF(FWMARK,	a->lr_fwmark != b->lr_fwmark);
+	diff |= REQ_DIFF(TOS,		a->lr_tos != b->lr_tos);
+	diff |= REQ_DIFF(SCOPE,		a->lr_scope != b->lr_scope);
+	diff |= REQ_DIFF(TABLE,		a->lr_table != b->lr_table);
+	diff |= REQ_DIFF(ADDR,		nl_addr_cmp(a->lr_addr, b->lr_addr));
+
+#undef REQ_DIFF
+
+	return diff;
+}
+
+
+/**
+ * @name Lookup Request Creation/Deletion
+ * @{
+ */
+
+struct flnl_request *flnl_request_alloc(void)
+{
+	return REQUEST_CAST(nl_object_alloc(&request_obj_ops));
+}
+
+/** @} */
+
+/**
+ * @name Attributes
+ * @{
+ */
+
+void flnl_request_set_fwmark(struct flnl_request *req, uint64_t fwmark)
+{
+	req->lr_fwmark = fwmark;
+	req->ce_mask |= REQUEST_ATTR_FWMARK;
+}
+
+uint64_t flnl_request_get_fwmark(struct flnl_request *req)
+{
+	if (req->ce_mask & REQUEST_ATTR_FWMARK)
+		return req->lr_fwmark;
+	else
+		return UINT_LEAST64_MAX;
+}
+
+void flnl_request_set_tos(struct flnl_request *req, int tos)
+{
+	req->lr_tos = tos;
+	req->ce_mask |= REQUEST_ATTR_TOS;
+}
+
+int flnl_request_get_tos(struct flnl_request *req)
+{
+	if (req->ce_mask & REQUEST_ATTR_TOS)
+		return req->lr_tos;
+	else
+		return -1;
+}
+
+void flnl_request_set_scope(struct flnl_request *req, int scope)
+{
+	req->lr_scope = scope;
+	req->ce_mask |= REQUEST_ATTR_SCOPE;
+}
+
+int flnl_request_get_scope(struct flnl_request *req)
+{
+	if (req->ce_mask & REQUEST_ATTR_SCOPE)
+		return req->lr_scope;
+	else
+		return -1;
+}
+
+void flnl_request_set_table(struct flnl_request *req, int table)
+{
+	req->lr_table = table;
+	req->ce_mask |= REQUEST_ATTR_TABLE;
+}
+
+int flnl_request_get_table(struct flnl_request *req)
+{
+	if (req->ce_mask & REQUEST_ATTR_TABLE)
+		return req->lr_table;
+	else
+		return -1;
+}
+
+int flnl_request_set_addr(struct flnl_request *req, struct nl_addr *addr)
+{
+	if (addr->a_family != AF_INET)
+		return -NLE_AF_NOSUPPORT;
+
+	if (req->lr_addr)
+		nl_addr_put(req->lr_addr);
+
+	nl_addr_get(addr);
+	req->lr_addr = addr;
+
+	req->ce_mask |= REQUEST_ATTR_ADDR;
+
+	return 0;
+}
+
+struct nl_addr *flnl_request_get_addr(struct flnl_request *req)
+{
+	if (req->ce_mask & REQUEST_ATTR_ADDR)
+		return req->lr_addr;
+	else
+		return NULL;
+}
+
+/** @} */
+
+static struct nl_object_ops request_obj_ops = {
+	.oo_name		= "fib_lookup/request",
+	.oo_size		= sizeof(struct flnl_request),
+	.oo_free_data		= request_free_data,
+	.oo_clone		= request_clone,
+	.oo_compare		= request_compare,
+	.oo_id_attrs		= ~0,
+};
+
+/** @} */
diff -uNr libnl_kk/lib/genl/ctrl.c libnl/lib/genl/ctrl.c
--- libnl_kk/lib/genl/ctrl.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/genl/ctrl.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,302 @@
+/*
+ * lib/genl/ctrl.c		Generic Netlink Controller
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup genl_mngt
+ * @defgroup ctrl Controller
+ * @brief
+ *
+ * @{
+ */
+
+#include <netlink-generic.h>
+#include <netlink/netlink.h>
+#include <netlink/genl/genl.h>
+#include <netlink/genl/family.h>
+#include <netlink/genl/mngt.h>
+#include <netlink/genl/ctrl.h>
+#include <netlink/utils.h>
+
+/** @cond SKIP */
+#define CTRL_VERSION		0x0001
+
+static struct nl_cache_ops genl_ctrl_ops;
+/** @endcond */
+
+static int ctrl_request_update(struct nl_cache *c, struct nl_sock *h)
+{
+	return genl_send_simple(h, GENL_ID_CTRL, CTRL_CMD_GETFAMILY,
+				CTRL_VERSION, NLM_F_DUMP);
+}
+
+static struct nla_policy ctrl_policy[CTRL_ATTR_MAX+1] = {
+	[CTRL_ATTR_FAMILY_ID]	= { .type = NLA_U16 },
+	[CTRL_ATTR_FAMILY_NAME]	= { .type = NLA_STRING,
+				    .maxlen = GENL_NAMSIZ },
+	[CTRL_ATTR_VERSION]	= { .type = NLA_U32 },
+	[CTRL_ATTR_HDRSIZE]	= { .type = NLA_U32 },
+	[CTRL_ATTR_MAXATTR]	= { .type = NLA_U32 },
+	[CTRL_ATTR_OPS]		= { .type = NLA_NESTED },
+};
+
+static struct nla_policy family_op_policy[CTRL_ATTR_OP_MAX+1] = {
+	[CTRL_ATTR_OP_ID]	= { .type = NLA_U32 },
+	[CTRL_ATTR_OP_FLAGS]	= { .type = NLA_U32 },
+};
+
+static int ctrl_msg_parser(struct nl_cache_ops *ops, struct genl_cmd *cmd,
+			   struct genl_info *info, void *arg)
+{
+	struct genl_family *family;
+	struct nl_parser_param *pp = arg;
+	int err;
+
+	family = genl_family_alloc();
+	if (family == NULL) {
+		err = -NLE_NOMEM;
+		goto errout;
+	}
+
+	if (info->attrs[CTRL_ATTR_FAMILY_NAME] == NULL) {
+		err = -NLE_MISSING_ATTR;
+		goto errout;
+	}
+
+	if (info->attrs[CTRL_ATTR_FAMILY_ID] == NULL) {
+		err = -NLE_MISSING_ATTR;
+		goto errout;
+	}
+
+	family->ce_msgtype = info->nlh->nlmsg_type;
+	genl_family_set_id(family,
+			   nla_get_u16(info->attrs[CTRL_ATTR_FAMILY_ID]));
+	genl_family_set_name(family,
+		     nla_get_string(info->attrs[CTRL_ATTR_FAMILY_NAME]));
+
+	if (info->attrs[CTRL_ATTR_VERSION]) {
+		uint32_t version = nla_get_u32(info->attrs[CTRL_ATTR_VERSION]);
+		genl_family_set_version(family, version);
+	}
+
+	if (info->attrs[CTRL_ATTR_HDRSIZE]) {
+		uint32_t hdrsize = nla_get_u32(info->attrs[CTRL_ATTR_HDRSIZE]);
+		genl_family_set_hdrsize(family, hdrsize);
+	}
+
+	if (info->attrs[CTRL_ATTR_MAXATTR]) {
+		uint32_t maxattr = nla_get_u32(info->attrs[CTRL_ATTR_MAXATTR]);
+		genl_family_set_maxattr(family, maxattr);
+	}
+
+	if (info->attrs[CTRL_ATTR_OPS]) {
+		struct nlattr *nla, *nla_ops;
+		int remaining;
+
+		nla_ops = info->attrs[CTRL_ATTR_OPS];
+		nla_for_each_nested(nla, nla_ops, remaining) {
+			struct nlattr *tb[CTRL_ATTR_OP_MAX+1];
+			int flags = 0, id;
+
+			err = nla_parse_nested(tb, CTRL_ATTR_OP_MAX, nla,
+					       family_op_policy);
+			if (err < 0)
+				goto errout;
+
+			if (tb[CTRL_ATTR_OP_ID] == NULL) {
+				err = -NLE_MISSING_ATTR;
+				goto errout;
+			}
+			
+			id = nla_get_u32(tb[CTRL_ATTR_OP_ID]);
+
+			if (tb[CTRL_ATTR_OP_FLAGS])
+				flags = nla_get_u32(tb[CTRL_ATTR_OP_FLAGS]);
+
+			err = genl_family_add_op(family, id, flags);
+			if (err < 0)
+				goto errout;
+
+		}
+	}
+
+	err = pp->pp_cb((struct nl_object *) family, pp);
+errout:
+	genl_family_put(family);
+	return err;
+}
+
+/**
+ * @name Cache Management
+ * @{
+ */
+
+int genl_ctrl_alloc_cache(struct nl_sock *sock, struct nl_cache **result)
+{
+	return nl_cache_alloc_and_fill(&genl_ctrl_ops, sock, result);
+}
+
+/**
+ * Look up generic netlink family by id in the provided cache.
+ * @arg cache		Generic netlink family cache.
+ * @arg id		Family identifier.
+ *
+ * Searches through the cache looking for a registered family
+ * matching the specified identifier. The caller will own a
+ * reference on the returned object which needs to be given
+ * back after usage using genl_family_put().
+ *
+ * @return Generic netlink family object or NULL if no match was found.
+ */
+struct genl_family *genl_ctrl_search(struct nl_cache *cache, int id)
+{
+	struct genl_family *fam;
+
+	if (cache->c_ops != &genl_ctrl_ops)
+		BUG();
+
+	nl_list_for_each_entry(fam, &cache->c_items, ce_list) {
+		if (fam->gf_id == id) {
+			nl_object_get((struct nl_object *) fam);
+			return fam;
+		}
+	}
+
+	return NULL;
+}
+
+/**
+ * @name Resolver
+ * @{
+ */
+
+/**
+ * Look up generic netlink family by family name in the provided cache.
+ * @arg cache		Generic netlink family cache.
+ * @arg name		Family name.
+ *
+ * Searches through the cache looking for a registered family
+ * matching the specified name. The caller will own a reference
+ * on the returned object which needs to be given back after
+ * usage using genl_family_put().
+ *
+ * @return Generic netlink family object or NULL if no match was found.
+ */
+struct genl_family *genl_ctrl_search_by_name(struct nl_cache *cache,
+					    const char *name)
+{
+	struct genl_family *fam;
+
+	if (cache->c_ops != &genl_ctrl_ops)
+		BUG();
+
+	nl_list_for_each_entry(fam, &cache->c_items, ce_list) {
+		if (!strcmp(name, fam->gf_name)) {
+			nl_object_get((struct nl_object *) fam);
+			return fam;
+		}
+	}
+
+	return NULL;
+}
+
+/** @} */
+
+/**
+ * Resolve generic netlink family name to its identifier
+ * @arg sk		Netlink socket.
+ * @arg name		Name of generic netlink family
+ *
+ * Resolves the generic netlink family name to its identifer and returns
+ * it.
+ *
+ * @return A positive identifier or a negative error code.
+ */
+int genl_ctrl_resolve(struct nl_sock *sk, const char *name)
+{
+	struct nl_cache *cache;
+	struct genl_family *family;
+	int err;
+
+	if ((err = genl_ctrl_alloc_cache(sk, &cache)) < 0)
+		return err;
+
+	family = genl_ctrl_search_by_name(cache, name);
+	if (family == NULL) {
+		err = -NLE_OBJ_NOTFOUND;
+		goto errout;
+	}
+
+	err = genl_family_get_id(family);
+	genl_family_put(family);
+errout:
+	nl_cache_free(cache);
+
+	return err;
+}
+
+/** @} */
+
+static struct genl_cmd genl_cmds[] = {
+	{
+		.c_id		= CTRL_CMD_NEWFAMILY,
+		.c_name		= "NEWFAMILY" ,
+		.c_maxattr	= CTRL_ATTR_MAX,
+		.c_attr_policy	= ctrl_policy,
+		.c_msg_parser	= ctrl_msg_parser,
+	},
+	{
+		.c_id		= CTRL_CMD_DELFAMILY,
+		.c_name		= "DELFAMILY" ,
+	},
+	{
+		.c_id		= CTRL_CMD_GETFAMILY,
+		.c_name		= "GETFAMILY" ,
+	},
+	{
+		.c_id		= CTRL_CMD_NEWOPS,
+		.c_name		= "NEWOPS" ,
+	},
+	{
+		.c_id		= CTRL_CMD_DELOPS,
+		.c_name		= "DELOPS" ,
+	},
+};
+
+static struct genl_ops genl_ops = {
+	.o_cmds			= genl_cmds,
+	.o_ncmds		= ARRAY_SIZE(genl_cmds),
+};
+
+/** @cond SKIP */
+extern struct nl_object_ops genl_family_ops;
+/** @endcond */
+
+static struct nl_cache_ops genl_ctrl_ops = {
+	.co_name		= "genl/family",
+	.co_hdrsize		= GENL_HDRSIZE(0),
+	.co_msgtypes		= GENL_FAMILY(GENL_ID_CTRL, "nlctrl"),
+	.co_genl		= &genl_ops,
+	.co_protocol		= NETLINK_GENERIC,
+	.co_request_update      = ctrl_request_update,
+	.co_obj_ops		= &genl_family_ops,
+};
+
+static void __init ctrl_init(void)
+{
+	genl_register(&genl_ctrl_ops);
+}
+
+static void __exit ctrl_exit(void)
+{
+	genl_unregister(&genl_ctrl_ops);
+}
+
+/** @} */
diff -uNr libnl_kk/lib/genl/family.c libnl/lib/genl/family.c
--- libnl_kk/lib/genl/family.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/genl/family.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,277 @@
+/*
+ * lib/genl/family.c		Generic Netlink Family
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2006 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup genl
+ * @defgroup genl_family Generic Netlink Family
+ * @brief
+ *
+ * @{
+ */
+
+#include <netlink-generic.h>
+#include <netlink/netlink.h>
+#include <netlink/genl/genl.h>
+#include <netlink/genl/family.h>
+#include <netlink/utils.h>
+
+/** @cond SKIP */
+#define FAMILY_ATTR_ID		0x01
+#define FAMILY_ATTR_NAME	0x02
+#define FAMILY_ATTR_VERSION	0x04
+#define FAMILY_ATTR_HDRSIZE	0x08
+#define FAMILY_ATTR_MAXATTR	0x10
+#define FAMILY_ATTR_OPS		0x20
+
+struct nl_object_ops genl_family_ops;
+/** @endcond */
+
+static void family_constructor(struct nl_object *c)
+{
+	struct genl_family *family = (struct genl_family *) c;
+
+	nl_init_list_head(&family->gf_ops);
+}
+
+static void family_free_data(struct nl_object *c)
+{
+	struct genl_family *family = (struct genl_family *) c;
+	struct genl_family_op *ops, *tmp;
+
+	if (family == NULL)
+		return;
+
+	nl_list_for_each_entry_safe(ops, tmp, &family->gf_ops, o_list) {
+		nl_list_del(&ops->o_list);
+		free(ops);
+	}
+}
+
+static int family_clone(struct nl_object *_dst, struct nl_object *_src)
+{
+	struct genl_family *dst = nl_object_priv(_dst);
+	struct genl_family *src = nl_object_priv(_src);
+	struct genl_family_op *ops;
+	int err;
+
+	nl_list_for_each_entry(ops, &src->gf_ops, o_list) {
+		err = genl_family_add_op(dst, ops->o_id, ops->o_flags);
+		if (err < 0)
+			return err;
+	}
+	
+	return 0;
+}
+
+static void family_dump_line(struct nl_object *obj, struct nl_dump_params *p)
+{
+	struct genl_family *family = (struct genl_family *) obj;
+
+	nl_dump(p, "0x%04x %s version %u\n",
+		family->gf_id, family->gf_name, family->gf_version);
+}
+
+static struct trans_tbl ops_flags[] = {
+	__ADD(GENL_ADMIN_PERM, admin-perm)
+	__ADD(GENL_CMD_CAP_DO, has-doit)
+	__ADD(GENL_CMD_CAP_DUMP, has-dump)
+	__ADD(GENL_CMD_CAP_HASPOL, has-policy)
+};
+
+static char *ops_flags2str(int flags, char *buf, size_t len)
+{
+	return __flags2str(flags, buf, len, ops_flags, ARRAY_SIZE(ops_flags));
+}
+
+static void family_dump_details(struct nl_object *obj, struct nl_dump_params *p)
+{
+	struct genl_family *family = (struct genl_family *) obj;
+
+	family_dump_line(obj, p);
+	nl_dump_line(p, "    hdrsize %u maxattr %u\n",
+		     family->gf_hdrsize, family->gf_maxattr);
+
+	if (family->ce_mask & FAMILY_ATTR_OPS) {
+		struct genl_family_op *op;
+		char buf[64];
+
+		nl_list_for_each_entry(op, &family->gf_ops, o_list) {
+			ops_flags2str(op->o_flags, buf, sizeof(buf));
+
+			genl_op2name(family->gf_id, op->o_id, buf, sizeof(buf));
+
+			nl_dump_line(p, "      op %s (0x%02x)", buf, op->o_id);
+
+			if (op->o_flags)
+				nl_dump(p, " <%s>",
+					ops_flags2str(op->o_flags, buf,
+						      sizeof(buf)));
+
+			nl_dump(p, "\n");
+		}
+	}
+}
+
+static void family_dump_stats(struct nl_object *obj, struct nl_dump_params *p)
+{
+	family_dump_details(obj, p);
+}
+
+static int family_compare(struct nl_object *_a, struct nl_object *_b,
+			  uint32_t attrs, int flags)
+{
+	struct genl_family *a = (struct genl_family *) _a;
+	struct genl_family *b = (struct genl_family *) _b;
+	int diff = 0;
+
+#define FAM_DIFF(ATTR, EXPR) ATTR_DIFF(attrs, FAMILY_ATTR_##ATTR, a, b, EXPR)
+
+	diff |= FAM_DIFF(ID,		a->gf_id != b->gf_id);
+	diff |= FAM_DIFF(VERSION,	a->gf_version != b->gf_version);
+	diff |= FAM_DIFF(HDRSIZE,	a->gf_hdrsize != b->gf_hdrsize);
+	diff |= FAM_DIFF(MAXATTR,	a->gf_maxattr != b->gf_maxattr);
+	diff |= FAM_DIFF(NAME,		strcmp(a->gf_name, b->gf_name));
+
+#undef FAM_DIFF
+
+	return diff;
+}
+
+
+/**
+ * @name Family Object
+ * @{
+ */
+
+struct genl_family *genl_family_alloc(void)
+{
+	return (struct genl_family *) nl_object_alloc(&genl_family_ops);
+}
+
+void genl_family_put(struct genl_family *family)
+{
+	nl_object_put((struct nl_object *) family);
+}
+
+/** @} */
+
+/**
+ * @name Attributes
+ * @{
+ */
+
+unsigned int genl_family_get_id(struct genl_family *family)
+{
+	if (family->ce_mask & FAMILY_ATTR_ID)
+		return family->gf_id;
+	else
+		return GENL_ID_GENERATE;
+}
+
+void genl_family_set_id(struct genl_family *family, unsigned int id)
+{
+	family->gf_id = id;
+	family->ce_mask |= FAMILY_ATTR_ID;
+}
+
+char *genl_family_get_name(struct genl_family *family)
+{
+	if (family->ce_mask & FAMILY_ATTR_NAME)
+		return family->gf_name;
+	else
+		return NULL;
+}
+
+void genl_family_set_name(struct genl_family *family, const char *name)
+{
+	strncpy(family->gf_name, name, GENL_NAMSIZ-1);
+	family->ce_mask |= FAMILY_ATTR_NAME;
+}
+
+uint8_t genl_family_get_version(struct genl_family *family)
+{
+	if (family->ce_mask & FAMILY_ATTR_VERSION)
+		return family->gf_version;
+	else
+		return 0;
+}
+
+void genl_family_set_version(struct genl_family *family, uint8_t version)
+{
+	family->gf_version = version;
+	family->ce_mask |= FAMILY_ATTR_VERSION;
+}
+
+uint32_t genl_family_get_hdrsize(struct genl_family *family)
+{
+	if (family->ce_mask & FAMILY_ATTR_HDRSIZE)
+		return family->gf_hdrsize;
+	else
+		return 0;
+}
+
+void genl_family_set_hdrsize(struct genl_family *family, uint32_t hdrsize)
+{
+	family->gf_hdrsize = hdrsize;
+	family->ce_mask |= FAMILY_ATTR_HDRSIZE;
+}
+
+uint32_t genl_family_get_maxattr(struct genl_family *family)
+{
+	if (family->ce_mask & FAMILY_ATTR_MAXATTR)
+		return family->gf_maxattr;
+	else
+		return family->gf_maxattr;
+}
+
+void genl_family_set_maxattr(struct genl_family *family, uint32_t maxattr)
+{
+	family->gf_maxattr = maxattr;
+	family->ce_mask |= FAMILY_ATTR_MAXATTR;
+}
+
+int genl_family_add_op(struct genl_family *family, int id, int flags)
+{
+	struct genl_family_op *op;
+
+	op = calloc(1, sizeof(*op));
+	if (op == NULL)
+		return -NLE_NOMEM;
+
+	op->o_id = id;
+	op->o_flags = flags;
+
+	nl_list_add_tail(&op->o_list, &family->gf_ops);
+	family->ce_mask |= FAMILY_ATTR_OPS;
+
+	return 0;
+}
+
+/** @} */
+
+/** @cond SKIP */
+struct nl_object_ops genl_family_ops = {
+	.oo_name		= "genl/family",
+	.oo_size		= sizeof(struct genl_family),
+	.oo_constructor		= family_constructor,
+	.oo_free_data		= family_free_data,
+	.oo_clone		= family_clone,
+	.oo_dump = {
+	    [NL_DUMP_LINE]	= family_dump_line,
+	    [NL_DUMP_DETAILS]	= family_dump_details,
+	    [NL_DUMP_STATS]	= family_dump_stats,
+	},
+	.oo_compare		= family_compare,
+	.oo_id_attrs		= FAMILY_ATTR_ID,
+};
+/** @endcond */
+
+/** @} */
diff -uNr libnl_kk/lib/genl/genl.c libnl/lib/genl/genl.c
--- libnl_kk/lib/genl/genl.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/genl/genl.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,268 @@
+/*
+ * lib/genl/genl.c		Generic Netlink
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @defgroup genl Generic Netlink
+ *
+ * @par Message Format
+ * @code
+ *  <------- NLMSG_ALIGN(hlen) ------> <---- NLMSG_ALIGN(len) --->
+ * +----------------------------+- - -+- - - - - - - - - - -+- - -+
+ * |           Header           | Pad |       Payload       | Pad |
+ * |      struct nlmsghdr       |     |                     |     |
+ * +----------------------------+- - -+- - - - - - - - - - -+- - -+
+ * @endcode
+ * @code
+ *  <-------- GENL_HDRLEN -------> <--- hdrlen -->
+ *                                 <------- genlmsg_len(ghdr) ------>
+ * +------------------------+- - -+---------------+- - -+------------+
+ * | Generic Netlink Header | Pad | Family Header | Pad | Attributes |
+ * |    struct genlmsghdr   |     |               |     |            |
+ * +------------------------+- - -+---------------+- - -+------------+
+ * genlmsg_data(ghdr)--------------^                     ^
+ * genlmsg_attrdata(ghdr, hdrlen)-------------------------
+ * @endcode
+ *
+ * @par Example
+ * @code
+ * #include <netlink/netlink.h>
+ * #include <netlink/genl/genl.h>
+ * #include <netlink/genl/ctrl.h>
+ *
+ * struct nl_sock *sock;
+ * struct nl_msg *msg;
+ * int family;
+ *
+ * // Allocate a new netlink socket
+ * sock = nl_socket_alloc();
+ *
+ * // Connect to generic netlink socket on kernel side
+ * genl_connect(sock);
+ *
+ * // Ask kernel to resolve family name to family id
+ * family = genl_ctrl_resolve(sock, "generic_netlink_family_name");
+ *
+ * // Construct a generic netlink by allocating a new message, fill in
+ * // the header and append a simple integer attribute.
+ * msg = nlmsg_alloc();
+ * genlmsg_put(msg, NL_AUTO_PID, NL_AUTO_SEQ, family, 0, NLM_F_ECHO,
+ *             CMD_FOO_GET, FOO_VERSION);
+ * nla_put_u32(msg, ATTR_FOO, 123);
+ *
+ * // Send message over netlink socket
+ * nl_send_auto_complete(sock, msg);
+ *
+ * // Free message
+ * nlmsg_free(msg);
+ *
+ * // Prepare socket to receive the answer by specifying the callback
+ * // function to be called for valid messages.
+ * nl_socket_modify_cb(sock, NL_CB_VALID, NL_CB_CUSTOM, parse_cb, NULL);
+ *
+ * // Wait for the answer and receive it
+ * nl_recvmsgs_default(sock);
+ *
+ * static int parse_cb(struct nl_msg *msg, void *arg)
+ * {
+ *     struct nlmsghdr *nlh = nlmsg_hdr(msg);
+ *     struct nlattr *attrs[ATTR_MAX+1];
+ *
+ *     // Validate message and parse attributes
+ *     genlmsg_parse(nlh, 0, attrs, ATTR_MAX, policy);
+ *
+ *     if (attrs[ATTR_FOO]) {
+ *         uint32_t value = nla_get_u32(attrs[ATTR_FOO]);
+ *         ...
+ *     }
+ *
+ *     return 0;
+ * }
+ * @endcode
+ * @{
+ */
+
+#include <netlink-generic.h>
+#include <netlink/netlink.h>
+#include <netlink/genl/genl.h>
+#include <netlink/utils.h>
+
+/**
+ * @name Socket Creating
+ * @{
+ */
+
+int genl_connect(struct nl_sock *sk)
+{
+	return nl_connect(sk, NETLINK_GENERIC);
+}
+
+/** @} */
+
+/**
+ * @name Sending
+ * @{
+ */
+
+/**
+ * Send trivial generic netlink message
+ * @arg sk		Netlink socket.
+ * @arg family		Generic netlink family
+ * @arg cmd		Command
+ * @arg version		Version
+ * @arg flags		Additional netlink message flags.
+ *
+ * Fills out a routing netlink request message and sends it out
+ * using nl_send_simple().
+ *
+ * @return 0 on success or a negative error code.
+ */
+int genl_send_simple(struct nl_sock *sk, int family, int cmd,
+		     int version, int flags)
+{
+	struct genlmsghdr hdr = {
+		.cmd = cmd,
+		.version = version,
+	};
+
+	return nl_send_simple(sk, family, flags, &hdr, sizeof(hdr));
+}
+
+/** @} */
+
+
+/**
+ * @name Message Parsing
+ * @{
+ */
+
+int genlmsg_valid_hdr(struct nlmsghdr *nlh, int hdrlen)
+{
+	struct genlmsghdr *ghdr;
+
+	if (!nlmsg_valid_hdr(nlh, GENL_HDRLEN))
+		return 0;
+
+	ghdr = nlmsg_data(nlh);
+	if (genlmsg_len(ghdr) < NLMSG_ALIGN(hdrlen))
+		return 0;
+
+	return 1;
+}
+
+int genlmsg_validate(struct nlmsghdr *nlh, int hdrlen, int maxtype,
+		   struct nla_policy *policy)
+{
+	struct genlmsghdr *ghdr;
+
+	if (!genlmsg_valid_hdr(nlh, hdrlen))
+		return -NLE_MSG_TOOSHORT;
+
+	ghdr = nlmsg_data(nlh);
+	return nla_validate(genlmsg_attrdata(ghdr, hdrlen),
+			    genlmsg_attrlen(ghdr, hdrlen), maxtype, policy);
+}
+
+int genlmsg_parse(struct nlmsghdr *nlh, int hdrlen, struct nlattr *tb[],
+		  int maxtype, struct nla_policy *policy)
+{
+	struct genlmsghdr *ghdr;
+
+	if (!genlmsg_valid_hdr(nlh, hdrlen))
+		return -NLE_MSG_TOOSHORT;
+
+	ghdr = nlmsg_data(nlh);
+	return nla_parse(tb, maxtype, genlmsg_attrdata(ghdr, hdrlen),
+			 genlmsg_attrlen(ghdr, hdrlen), policy);
+}
+
+/**
+ * Get head of message payload
+ * @arg gnlh	genetlink messsage header
+ */
+void *genlmsg_data(const struct genlmsghdr *gnlh)
+{
+	return ((unsigned char *) gnlh + GENL_HDRLEN);
+}
+
+/**
+ * Get lenght of message payload
+ * @arg gnlh	genetlink message header
+ */
+int genlmsg_len(const struct genlmsghdr *gnlh)
+{
+	struct nlmsghdr *nlh = (struct nlmsghdr *)((unsigned char *)gnlh -
+							NLMSG_HDRLEN);
+	return (nlh->nlmsg_len - GENL_HDRLEN - NLMSG_HDRLEN);
+}
+
+/**
+ * Get head of attribute data
+ * @arg gnlh	generic netlink message header
+ * @arg hdrlen	length of family specific header
+ */
+struct nlattr *genlmsg_attrdata(const struct genlmsghdr *gnlh, int hdrlen)
+{
+	return genlmsg_data(gnlh) + NLMSG_ALIGN(hdrlen);
+}
+
+/**
+ * Get length of attribute data
+ * @arg gnlh	generic netlink message header
+ * @arg hdrlen	length of family specific header
+ */
+int genlmsg_attrlen(const struct genlmsghdr *gnlh, int hdrlen)
+{
+	return genlmsg_len(gnlh) - NLMSG_ALIGN(hdrlen);
+}
+
+/** @} */
+
+/**
+ * @name Message Building
+ * @{
+ */
+
+/**
+ * Add generic netlink header to netlink message
+ * @arg msg		netlink message
+ * @arg pid		netlink process id or NL_AUTO_PID
+ * @arg seq		sequence number of message or NL_AUTO_SEQ
+ * @arg family		generic netlink family
+ * @arg hdrlen		length of user specific header
+ * @arg flags		message flags
+ * @arg cmd		generic netlink command
+ * @arg version		protocol version
+ *
+ * Returns pointer to user specific header.
+ */
+void *genlmsg_put(struct nl_msg *msg, uint32_t pid, uint32_t seq, int family,
+		  int hdrlen, int flags, uint8_t cmd, uint8_t version)
+{
+	struct nlmsghdr *nlh;
+	struct genlmsghdr hdr = {
+		.cmd = cmd,
+		.version = version,
+	};
+
+	nlh = nlmsg_put(msg, pid, seq, family, GENL_HDRLEN + hdrlen, flags);
+	if (nlh == NULL)
+		return NULL;
+
+	memcpy(nlmsg_data(nlh), &hdr, sizeof(hdr));
+	NL_DBG(2, "msg %p: Added generic netlink header cmd=%d version=%d\n",
+	       msg, cmd, version);
+
+	return nlmsg_data(nlh) + GENL_HDRLEN;
+}
+
+/** @} */
+
+/** @} */
diff -uNr libnl_kk/lib/genl/mngt.c libnl/lib/genl/mngt.c
--- libnl_kk/lib/genl/mngt.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/genl/mngt.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,273 @@
+/*
+ * lib/genl/mngt.c		Generic Netlink Management
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup genl
+ * @defgroup genl_mngt Management
+ *
+ * @par 1) Registering a generic netlink module
+ * @code
+ * #include <netlink/genl/mngt.h>
+ *
+ * // First step is to define all the commands being used in
+ * // particular generic netlink family. The ID and name are
+ * // mandatory to be filled out. A callback function and
+ * // most the attribute policy that comes with it must be
+ * // defined for commands expected to be issued towards
+ * // userspace.
+ * static struct genl_cmd foo_cmds[] = {
+ * 	{
+ * 		.c_id		= FOO_CMD_NEW,
+ * 		.c_name		= "NEWFOO" ,
+ * 		.c_maxattr	= FOO_ATTR_MAX,
+ * 		.c_attr_policy	= foo_policy,
+ * 		.c_msg_parser	= foo_msg_parser,
+ * 	},
+ * 	{
+ * 		.c_id		= FOO_CMD_DEL,
+ * 		.c_name		= "DELFOO" ,
+ * 	},
+ * };
+ *
+ * // The list of commands must then be integrated into a
+ * // struct genl_ops serving as handle for this particular
+ * // family.
+ * static struct genl_ops my_genl_ops = {
+ * 	.o_cmds			= foo_cmds,
+ * 	.o_ncmds		= ARRAY_SIZE(foo_cmds),
+ * };
+ *
+ * // Using the above struct genl_ops an arbitary number of
+ * // cache handles can be associated to it.
+ * //
+ * // The macro GENL_HDRSIZE() must be used to specify the
+ * // length of the header to automatically take headers on
+ * // generic layers into account.
+ * //
+ * // The macro GENL_FAMILY() is used to represent the generic
+ * // netlink family id.
+ * static struct nl_cache_ops genl_foo_ops = {
+ * 	.co_name		= "genl/foo",
+ * 	.co_hdrsize		= GENL_HDRSIZE(sizeof(struct my_hdr)),
+ * 	.co_msgtypes		= GENL_FAMILY(GENL_ID_GENERATE, "foo"),
+ * 	.co_genl		= &my_genl_ops,
+ * 	.co_protocol		= NETLINK_GENERIC,
+ * 	.co_request_update      = foo_request_update,
+ * 	.co_obj_ops		= &genl_foo_ops,
+ * };
+ *
+ * // Finally each cache handle for a generic netlink family
+ * // must be registered using genl_register().
+ * static void __init foo_init(void)
+ * {
+ * 	genl_register(&genl_foo_ops);
+ * }
+ *
+ * // ... respectively unregsted again.
+ * static void __exit foo_exit(void)
+ * {
+ * 	genl_unregister(&genl_foo_ops);
+ * }
+ * @endcode
+ * @{
+ */
+
+#include <netlink-generic.h>
+#include <netlink/netlink.h>
+#include <netlink/genl/genl.h>
+#include <netlink/genl/mngt.h>
+#include <netlink/genl/family.h>
+#include <netlink/genl/ctrl.h>
+#include <netlink/utils.h>
+
+static NL_LIST_HEAD(genl_ops_list);
+
+static int genl_msg_parser(struct nl_cache_ops *ops, struct sockaddr_nl *who,
+			   struct nlmsghdr *nlh, struct nl_parser_param *pp)
+{
+	int i, err;
+	struct genlmsghdr *ghdr;
+	struct genl_cmd *cmd;
+
+	ghdr = nlmsg_data(nlh);
+
+	if (ops->co_genl == NULL)
+		BUG();
+
+	for (i = 0; i < ops->co_genl->o_ncmds; i++) {
+		cmd = &ops->co_genl->o_cmds[i];
+		if (cmd->c_id == ghdr->cmd)
+			goto found;
+	}
+
+	err = -NLE_MSGTYPE_NOSUPPORT;
+	goto errout;
+
+found:
+	if (cmd->c_msg_parser == NULL)
+		err = -NLE_OPNOTSUPP;
+	else {
+		struct nlattr *tb[cmd->c_maxattr + 1];
+		struct genl_info info = {
+			.who = who,
+			.nlh = nlh,
+			.genlhdr = ghdr,
+			.userhdr = genlmsg_data(ghdr),
+			.attrs = tb,
+		};
+
+		err = nlmsg_parse(nlh, ops->co_hdrsize, tb, cmd->c_maxattr,
+				  cmd->c_attr_policy);
+		if (err < 0)
+			goto errout;
+
+		err = cmd->c_msg_parser(ops, cmd, &info, pp);
+	}
+errout:
+	return err;
+
+}
+
+char *genl_op2name(int family, int op, char *buf, size_t len)
+{
+	struct genl_ops *ops;
+	int i;
+
+	nl_list_for_each_entry(ops, &genl_ops_list, o_list) {
+		if (ops->o_family == family) {
+			for (i = 0; i < ops->o_ncmds; i++) {
+				struct genl_cmd *cmd;
+				cmd = &ops->o_cmds[i];
+
+				if (cmd->c_id == op) {
+					strncpy(buf, cmd->c_name, len - 1);
+					return buf;
+				}
+			}
+		}
+	}
+
+	strncpy(buf, "unknown", len - 1);
+	return NULL;
+}
+
+
+/**
+ * @name Register/Unregister
+ * @{
+ */
+
+/**
+ * Register generic netlink operations
+ * @arg ops		cache operations
+ */
+int genl_register(struct nl_cache_ops *ops)
+{
+	int err;
+
+	if (ops->co_protocol != NETLINK_GENERIC) {
+		err = -NLE_PROTO_MISMATCH;
+		goto errout;
+	}
+
+	if (ops->co_hdrsize < GENL_HDRSIZE(0)) {
+		err = -NLE_INVAL;
+		goto errout;
+	}
+
+	if (ops->co_genl == NULL) {
+		err = -NLE_INVAL;
+		goto errout;
+	}
+
+	ops->co_genl->o_cache_ops = ops;
+	ops->co_genl->o_name = ops->co_msgtypes[0].mt_name;
+	ops->co_genl->o_family = ops->co_msgtypes[0].mt_id;
+	ops->co_msg_parser = genl_msg_parser;
+
+	/* FIXME: check for dup */
+
+	nl_list_add_tail(&ops->co_genl->o_list, &genl_ops_list);
+
+	err = nl_cache_mngt_register(ops);
+errout:
+	return err;
+}
+
+/**
+ * Unregister generic netlink operations
+ * @arg ops		cache operations
+ */
+void genl_unregister(struct nl_cache_ops *ops)
+{
+	nl_cache_mngt_unregister(ops);
+	nl_list_del(&ops->co_genl->o_list);
+}
+
+/** @} */
+
+/**
+ * @name Resolving ID/Name
+ * @{
+ */
+
+static int __genl_ops_resolve(struct nl_cache *ctrl, struct genl_ops *ops)
+{
+	struct genl_family *family;
+
+	family = genl_ctrl_search_by_name(ctrl, ops->o_name);
+	if (family != NULL) {
+		ops->o_id = genl_family_get_id(family);
+		genl_family_put(family);
+
+		return 0;
+	}
+
+	return -NLE_OBJ_NOTFOUND;
+}
+
+int genl_ops_resolve(struct nl_sock *sk, struct genl_ops *ops)
+{
+	struct nl_cache *ctrl;
+	int err;
+
+	if ((err = genl_ctrl_alloc_cache(sk, &ctrl)) < 0)
+		goto errout;
+
+	err = __genl_ops_resolve(ctrl, ops);
+
+	nl_cache_free(ctrl);
+errout:
+	return err;
+}
+
+int genl_mngt_resolve(struct nl_sock *sk)
+{
+	struct nl_cache *ctrl;
+	struct genl_ops *ops;
+	int err = 0;
+
+	if ((err = genl_ctrl_alloc_cache(sk, &ctrl)) < 0)
+		goto errout;
+
+	nl_list_for_each_entry(ops, &genl_ops_list, o_list) {
+		err = __genl_ops_resolve(ctrl, ops);
+	}
+
+	nl_cache_free(ctrl);
+errout:
+	return err;
+}
+
+/** @} */
+
+
+/** @} */
diff -uNr libnl_kk/lib/.gitignore libnl/lib/.gitignore
--- libnl_kk/lib/.gitignore	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/.gitignore	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,2 @@
+libnl.so*
+libnl-*.so*
diff -uNr libnl_kk/lib/handlers.c libnl/lib/handlers.c
--- libnl_kk/lib/handlers.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/handlers.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,395 @@
+/*
+ * lib/handlers.c	default netlink message handlers
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup core
+ * @defgroup cb Callbacks/Customization
+ *
+ * @details
+ * @par 1) Setting up a callback set
+ * @code
+ * // Allocate a callback set and initialize it to the verbose default set
+ * struct nl_cb *cb = nl_cb_alloc(NL_CB_VERBOSE);
+ *
+ * // Modify the set to call my_func() for all valid messages
+ * nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, my_func, NULL);
+ *
+ * // Set the error message handler to the verbose default implementation
+ * // and direct it to print all errors to the given file descriptor.
+ * FILE *file = fopen(...);
+ * nl_cb_err(cb, NL_CB_VERBOSE, NULL, file);
+ * @endcode
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink/netlink.h>
+#include <netlink/utils.h>
+#include <netlink/msg.h>
+#include <netlink/handlers.h>
+
+static void print_header_content(FILE *ofd, struct nlmsghdr *n)
+{
+	char flags[128];
+	char type[32];
+	
+	fprintf(ofd, "type=%s length=%u flags=<%s> sequence-nr=%u pid=%u",
+		nl_nlmsgtype2str(n->nlmsg_type, type, sizeof(type)),
+		n->nlmsg_len, nl_nlmsg_flags2str(n->nlmsg_flags, flags,
+		sizeof(flags)), n->nlmsg_seq, n->nlmsg_pid);
+}
+
+static int nl_valid_handler_verbose(struct nl_msg *msg, void *arg)
+{
+	FILE *ofd = arg ? arg : stdout;
+
+	fprintf(ofd, "-- Warning: unhandled valid message: ");
+	print_header_content(ofd, nlmsg_hdr(msg));
+	fprintf(ofd, "\n");
+
+	return NL_OK;
+}
+
+static int nl_invalid_handler_verbose(struct nl_msg *msg, void *arg)
+{
+	FILE *ofd = arg ? arg : stderr;
+
+	fprintf(ofd, "-- Error: Invalid message: ");
+	print_header_content(ofd, nlmsg_hdr(msg));
+	fprintf(ofd, "\n");
+
+	return NL_STOP;
+}
+
+static int nl_overrun_handler_verbose(struct nl_msg *msg, void *arg)
+{
+	FILE *ofd = arg ? arg : stderr;
+
+	fprintf(ofd, "-- Error: Netlink Overrun: ");
+	print_header_content(ofd, nlmsg_hdr(msg));
+	fprintf(ofd, "\n");
+	
+	return NL_STOP;
+}
+
+static int nl_error_handler_verbose(struct sockaddr_nl *who,
+				    struct nlmsgerr *e, void *arg)
+{
+	FILE *ofd = arg ? arg : stderr;
+
+	fprintf(ofd, "-- Error received: %s\n-- Original message: ",
+		strerror(-e->error));
+	print_header_content(ofd, &e->msg);
+	fprintf(ofd, "\n");
+
+	return -nl_syserr2nlerr(e->error);
+}
+
+static int nl_valid_handler_debug(struct nl_msg *msg, void *arg)
+{
+	FILE *ofd = arg ? arg : stderr;
+
+	fprintf(ofd, "-- Debug: Unhandled Valid message: ");
+	print_header_content(ofd, nlmsg_hdr(msg));
+	fprintf(ofd, "\n");
+
+	return NL_OK;
+}
+
+static int nl_finish_handler_debug(struct nl_msg *msg, void *arg)
+{
+	FILE *ofd = arg ? arg : stderr;
+
+	fprintf(ofd, "-- Debug: End of multipart message block: ");
+	print_header_content(ofd, nlmsg_hdr(msg));
+	fprintf(ofd, "\n");
+	
+	return NL_STOP;
+}
+
+static int nl_msg_in_handler_debug(struct nl_msg *msg, void *arg)
+{
+	FILE *ofd = arg ? arg : stderr;
+
+	fprintf(ofd, "-- Debug: Received Message:\n");
+	nl_msg_dump(msg, ofd);
+	
+	return NL_OK;
+}
+
+static int nl_msg_out_handler_debug(struct nl_msg *msg, void *arg)
+{
+	FILE *ofd = arg ? arg : stderr;
+
+	fprintf(ofd, "-- Debug: Sent Message:\n");
+	nl_msg_dump(msg, ofd);
+
+	return NL_OK;
+}
+
+static int nl_skipped_handler_debug(struct nl_msg *msg, void *arg)
+{
+	FILE *ofd = arg ? arg : stderr;
+
+	fprintf(ofd, "-- Debug: Skipped message: ");
+	print_header_content(ofd, nlmsg_hdr(msg));
+	fprintf(ofd, "\n");
+
+	return NL_SKIP;
+}
+
+static int nl_ack_handler_debug(struct nl_msg *msg, void *arg)
+{
+	FILE *ofd = arg ? arg : stderr;
+
+	fprintf(ofd, "-- Debug: ACK: ");
+	print_header_content(ofd, nlmsg_hdr(msg));
+	fprintf(ofd, "\n");
+
+	return NL_STOP;
+}
+
+static nl_recvmsg_msg_cb_t cb_def[NL_CB_TYPE_MAX+1][NL_CB_KIND_MAX+1] = {
+	[NL_CB_VALID] = {
+		[NL_CB_VERBOSE]	= nl_valid_handler_verbose,
+		[NL_CB_DEBUG]	= nl_valid_handler_debug,
+	},
+	[NL_CB_FINISH] = {
+		[NL_CB_DEBUG]	= nl_finish_handler_debug,
+	},
+	[NL_CB_INVALID] = {
+		[NL_CB_VERBOSE]	= nl_invalid_handler_verbose,
+		[NL_CB_DEBUG]	= nl_invalid_handler_verbose,
+	},
+	[NL_CB_MSG_IN] = {
+		[NL_CB_DEBUG]	= nl_msg_in_handler_debug,
+	},
+	[NL_CB_MSG_OUT] = {
+		[NL_CB_DEBUG]	= nl_msg_out_handler_debug,
+	},
+	[NL_CB_OVERRUN] = {
+		[NL_CB_VERBOSE]	= nl_overrun_handler_verbose,
+		[NL_CB_DEBUG]	= nl_overrun_handler_verbose,
+	},
+	[NL_CB_SKIPPED] = {
+		[NL_CB_DEBUG]	= nl_skipped_handler_debug,
+	},
+	[NL_CB_ACK] = {
+		[NL_CB_DEBUG]	= nl_ack_handler_debug,
+	},
+};
+
+static nl_recvmsg_err_cb_t cb_err_def[NL_CB_KIND_MAX+1] = {
+	[NL_CB_VERBOSE]	= nl_error_handler_verbose,
+	[NL_CB_DEBUG]	= nl_error_handler_verbose,
+};
+
+/**
+ * @name Callback Handle Management
+ * @{
+ */
+
+/**
+ * Allocate a new callback handle
+ * @arg kind		callback kind to be used for initialization
+ * @return Newly allocated callback handle or NULL
+ */
+struct nl_cb *nl_cb_alloc(enum nl_cb_kind kind)
+{
+	int i;
+	struct nl_cb *cb;
+
+	if (kind < 0 || kind > NL_CB_KIND_MAX)
+		return NULL;
+
+	cb = calloc(1, sizeof(*cb));
+	if (!cb)
+		return NULL;
+
+	cb->cb_refcnt = 1;
+
+	for (i = 0; i <= NL_CB_TYPE_MAX; i++)
+		nl_cb_set(cb, i, kind, NULL, NULL);
+
+	nl_cb_err(cb, kind, NULL, NULL);
+
+	return cb;
+}
+
+/**
+ * Clone an existing callback handle
+ * @arg orig		original callback handle
+ * @return Newly allocated callback handle being a duplicate of
+ *         orig or NULL
+ */
+struct nl_cb *nl_cb_clone(struct nl_cb *orig)
+{
+	struct nl_cb *cb;
+	
+	cb = nl_cb_alloc(NL_CB_DEFAULT);
+	if (!cb)
+		return NULL;
+
+	memcpy(cb, orig, sizeof(*orig));
+	cb->cb_refcnt = 1;
+
+	return cb;
+}
+
+struct nl_cb *nl_cb_get(struct nl_cb *cb)
+{
+	cb->cb_refcnt++;
+
+	return cb;
+}
+
+void nl_cb_put(struct nl_cb *cb)
+{
+	if (!cb)
+		return;
+
+	cb->cb_refcnt--;
+
+	if (cb->cb_refcnt < 0)
+		BUG();
+
+	if (cb->cb_refcnt <= 0)
+		free(cb);
+}
+
+/** @} */
+
+/**
+ * @name Callback Setup
+ * @{
+ */
+
+/**
+ * Set up a callback 
+ * @arg cb		callback set
+ * @arg type		callback to modify
+ * @arg kind		kind of implementation
+ * @arg func		callback function (NL_CB_CUSTOM)
+ * @arg arg		argument passed to callback
+ *
+ * @return 0 on success or a negative error code
+ */
+int nl_cb_set(struct nl_cb *cb, enum nl_cb_type type, enum nl_cb_kind kind,
+	      nl_recvmsg_msg_cb_t func, void *arg)
+{
+	if (type < 0 || type > NL_CB_TYPE_MAX)
+		return -NLE_RANGE;
+
+	if (kind < 0 || kind > NL_CB_KIND_MAX)
+		return -NLE_RANGE;
+
+	if (kind == NL_CB_CUSTOM) {
+		cb->cb_set[type] = func;
+		cb->cb_args[type] = arg;
+	} else {
+		cb->cb_set[type] = cb_def[type][kind];
+		cb->cb_args[type] = arg;
+	}
+
+	return 0;
+}
+
+/**
+ * Set up a all callbacks
+ * @arg cb		callback set
+ * @arg kind		kind of callback
+ * @arg func		callback function
+ * @arg arg		argument to be passwd to callback function
+ *
+ * @return 0 on success or a negative error code
+ */
+int nl_cb_set_all(struct nl_cb *cb, enum nl_cb_kind kind,
+		  nl_recvmsg_msg_cb_t func, void *arg)
+{
+	int i, err;
+
+	for (i = 0; i <= NL_CB_TYPE_MAX; i++) {
+		err = nl_cb_set(cb, i, kind, func, arg);
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
+}
+
+/**
+ * Set up an error callback
+ * @arg cb		callback set
+ * @arg kind		kind of callback
+ * @arg func		callback function
+ * @arg arg		argument to be passed to callback function
+ */
+int nl_cb_err(struct nl_cb *cb, enum nl_cb_kind kind,
+	      nl_recvmsg_err_cb_t func, void *arg)
+{
+	if (kind < 0 || kind > NL_CB_KIND_MAX)
+		return -NLE_RANGE;
+
+	if (kind == NL_CB_CUSTOM) {
+		cb->cb_err = func;
+		cb->cb_err_arg = arg;
+	} else {
+		cb->cb_err = cb_err_def[kind];
+		cb->cb_err_arg = arg;
+	}
+
+	return 0;
+}
+
+/** @} */
+
+/**
+ * @name Overwriting
+ * @{
+ */
+
+/**
+ * Overwrite internal calls to nl_recvmsgs()
+ * @arg cb		callback set
+ * @arg func		replacement callback for nl_recvmsgs()
+ */
+void nl_cb_overwrite_recvmsgs(struct nl_cb *cb,
+			      int (*func)(struct nl_sock *, struct nl_cb *))
+{
+	cb->cb_recvmsgs_ow = func;
+}
+
+/**
+ * Overwrite internal calls to nl_recv()
+ * @arg cb		callback set
+ * @arg func		replacement callback for nl_recv()
+ */
+void nl_cb_overwrite_recv(struct nl_cb *cb,
+			  int (*func)(struct nl_sock *, struct sockaddr_nl *,
+				      unsigned char **, struct ucred **))
+{
+	cb->cb_recv_ow = func;
+}
+
+/**
+ * Overwrite internal calls to nl_send()
+ * @arg cb		callback set
+ * @arg func		replacement callback for nl_send()
+ */
+void nl_cb_overwrite_send(struct nl_cb *cb,
+			  int (*func)(struct nl_sock *, struct nl_msg *))
+{
+	cb->cb_send_ow = func;
+}
+
+/** @} */
+
+/** @} */
diff -uNr libnl_kk/lib/Makefile.am libnl/lib/Makefile.am
--- libnl_kk/lib/Makefile.am	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/Makefile.am	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,57 @@
+# -*- Makefile -*-
+
+AM_CPPFLAGS  = -Wall -I${top_srcdir}/include -I${top_builddir}/include -D_GNU_SOURCE -DSYSCONFDIR=\"$(sysconfdir)/libnl\"
+
+lib_LTLIBRARIES = \
+	libnl.la libnl-genl.la libnl-route.la libnl-nf.la
+
+libnl_la_LDFLAGS = -version-info 2:0:0
+libnl_la_SOURCES = \
+	addr.c attr.c cache.c cache_mngr.c cache_mngt.c data.c doc.c \
+	error.c handlers.c msg.c nl.c object.c socket.c utils.c
+
+libnl_genl_la_LDFLAGS = -version-info 2:0:0
+libnl_genl_la_LIBADD  = libnl.la
+libnl_genl_la_SOURCES = \
+	genl/ctrl.c genl/family.c genl/genl.c genl/mngt.c
+
+libnl_nf_la_LDFLAGS = -version-info 2:0:0
+libnl_nf_la_LIBADD  = libnl-route.la
+libnl_nf_la_SOURCES = \
+	netfilter/ct.c netfilter/ct_obj.c netfilter/log.c \
+	netfilter/log_msg.c netfilter/log_msg_obj.c netfilter/log_obj.c \
+	netfilter/netfilter.c netfilter/nfnl.c netfilter/queue.c \
+	netfilter/queue_msg.c netfilter/queue_msg_obj.c netfilter/queue_obj.c
+
+CLEANFILES = \
+	route/pktloc_grammar.c route/pktloc_grammar.h \
+	route/pktloc_syntax.c route/pktloc_syntax.h
+
+# Hack to avoid using ylwrap. It does not function correctly in combination
+# with --header-file=
+route/pktloc_grammar.c: route/pktloc_grammar.l
+	$(LEX) --header-file=route/pktloc_grammar.h $(LFLAGS) -o $@ $^
+
+route/pktloc_syntax.c: route/pktloc_syntax.y
+	$(YACC) -d $(YFLAGS) -o $@ $^
+
+libnl_route_la_LDFLAGS = -version-info 2:0:0
+libnl_route_la_LIBADD  = libnl.la
+libnl_route_la_SOURCES = \
+	route/addr.c route/class.c route/class_api.c route/class_obj.c \
+	route/cls.c route/cls_api.c route/cls_obj.c route/link.c \
+	route/neigh.c route/neightbl.c route/nexthop.c route/qdisc.c \
+	route/qdisc_api.c route/qdisc_obj.c route/route.c route/route_obj.c \
+	route/route_utils.c route/rtnl.c route/rule.c route/tc.c \
+	\
+	route/cls/fw.c route/cls/police.c route/cls/u32.c \
+	\
+	route/link/api.c route/link/vlan.c \
+	\
+	route/sch/blackhole.c route/sch/cbq.c route/sch/dsmark.c \
+	route/sch/fifo.c route/sch/htb.c route/sch/netem.c route/sch/prio.c \
+	route/sch/red.c route/sch/sfq.c route/sch/tbf.c \
+	\
+	fib_lookup/lookup.c fib_lookup/request.c \
+	\
+	route/pktloc_syntax.c route/pktloc_grammar.c route/pktloc.c
diff -uNr libnl_kk/lib/msg.c libnl/lib/msg.c
--- libnl_kk/lib/msg.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/msg.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,1021 @@
+/*
+ * lib/msg.c		Netlink Messages Interface
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup core
+ * @defgroup msg Messages
+ * Netlink Message Construction/Parsing Interface
+ * 
+ * The following information is partly extracted from RFC3549
+ * (ftp://ftp.rfc-editor.org/in-notes/rfc3549.txt)
+ *
+ * @par Message Format
+ * Netlink messages consist of a byte stream with one or multiple
+ * Netlink headers and an associated payload.  If the payload is too big
+ * to fit into a single message it, can be split over multiple Netlink
+ * messages, collectively called a multipart message.  For multipart
+ * messages, the first and all following headers have the \c NLM_F_MULTI
+ * Netlink header flag set, except for the last header which has the
+ * Netlink header type \c NLMSG_DONE.
+ *
+ * @par
+ * The Netlink message header (\link nlmsghdr struct nlmsghdr\endlink) is shown below.
+ * @code   
+ * 0                   1                   2                   3
+ * 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ * |                          Length                             |
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ * |            Type              |           Flags              |
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ * |                      Sequence Number                        |
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ * |                      Process ID (PID)                       |
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ * @endcode
+ *
+ * @par
+ * The netlink message header and payload must be aligned properly:
+ * @code
+ *  <------- NLMSG_ALIGN(hlen) ------> <---- NLMSG_ALIGN(len) --->
+ * +----------------------------+- - -+- - - - - - - - - - -+- - -+
+ * |           Header           | Pad |       Payload       | Pad |
+ * |      struct nlmsghdr       |     |                     |     |
+ * +----------------------------+- - -+- - - - - - - - - - -+- - -+
+ * @endcode
+ * @par
+ * Message Format:
+ * @code
+ *    <--- nlmsg_total_size(payload)  --->
+ *    <-- nlmsg_msg_size(payload) ->
+ *   +----------+- - -+-------------+- - -+-------- - -
+ *   | nlmsghdr | Pad |   Payload   | Pad | nlmsghdr
+ *   +----------+- - -+-------------+- - -+-------- - -
+ *   nlmsg_data(nlh)---^                   ^
+ *   nlmsg_next(nlh)-----------------------+
+ * @endcode
+ * @par
+ * The payload may consist of arbitary data but may have strict
+ * alignment and formatting rules depening on the specific netlink
+ * families.
+ * @par
+ * @code
+ *    <---------------------- nlmsg_len(nlh) --------------------->
+ *    <------ hdrlen ------>       <- nlmsg_attrlen(nlh, hdrlen) ->
+ *   +----------------------+- - -+--------------------------------+
+ *   |     Family Header    | Pad |           Attributes           |
+ *   +----------------------+- - -+--------------------------------+
+ *   nlmsg_attrdata(nlh, hdrlen)---^
+ * @endcode
+ * @par The ACK Netlink Message
+ * This message is actually used to denote both an ACK and a NACK.
+ * Typically, the direction is from FEC to CPC (in response to an ACK
+ * request message).  However, the CPC should be able to send ACKs back
+ * to FEC when requested.
+ * @code
+ *  0                   1                   2                   3
+ *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ * |                       Netlink message header                  |
+ * |                       type = NLMSG_ERROR                      |
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ * |                          Error code                           |
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ * |                       OLD Netlink message header              |
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ * @endcode
+ *
+ * @par Example
+ * @code
+ * // Various methods exist to create/allocate a new netlink
+ * // message. 
+ * //
+ * // nlmsg_alloc() will allocate an empty netlink message with
+ * // a maximum payload size which defaults to the page size of
+ * // the system. This default size can be modified using the
+ * // function nlmsg_set_default_size().
+ * struct nl_msg *msg = nlmsg_alloc();
+ *
+ * // Very often, the message type and message flags are known
+ * // at allocation time while the other fields are auto generated:
+ * struct nl_msg *msg = nlmsg_alloc_simple(MY_TYPE, MY_FLAGS);
+ *
+ * // Alternatively an existing netlink message header can be used
+ * // to inherit the header values:
+ * struct nlmsghdr hdr = {
+ * 	.nlmsg_type = MY_TYPE,
+ * 	.nlmsg_flags = MY_FLAGS,
+ * };
+ * struct nl_msg *msg = nlmsg_inherit(&hdr);
+ *
+ * // Last but not least, netlink messages received from netlink sockets
+ * // can be converted into nl_msg objects using nlmsg_convert(). This
+ * // will create a message with a maximum payload size which equals the
+ * // length of the existing netlink message, therefore no more data can
+ * // be appened without calling nlmsg_expand() first.
+ * struct nl_msg *msg = nlmsg_convert(nlh_from_nl_sock);
+ *
+ * // Payload may be added to the message via nlmsg_append(). The fourth
+ * // parameter specifies the number of alignment bytes the data should
+ * // be padding with at the end. Common values are 0 to disable it or
+ * // NLMSG_ALIGNTO to ensure proper netlink message padding.
+ * nlmsg_append(msg, &mydata, sizeof(mydata), 0);
+ *
+ * // Sometimes it may be necessary to reserve room for data but defer
+ * // the actual copying to a later point, nlmsg_reserve() can be used
+ * // for this purpose:
+ * void *data = nlmsg_reserve(msg, sizeof(mydata), NLMSG_ALIGNTO);
+ *
+ * // Attributes may be added using the attributes interface.
+ *
+ * // After successful use of the message, the memory must be freed
+ * // using nlmsg_free()
+ * nlmsg_free(msg);
+ * @endcode
+ * 
+ * @par 4) Parsing messages
+ * @code
+ * int n;
+ * unsigned char *buf;
+ * struct nlmsghdr *hdr;
+ *
+ * n = nl_recv(handle, NULL, &buf);
+ * 
+ * hdr = (struct nlmsghdr *) buf;
+ * while (nlmsg_ok(hdr, n)) {
+ * 	// Process message here...
+ * 	hdr = nlmsg_next(hdr, &n);
+ * }
+ * @endcode
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink/netlink.h>
+#include <netlink/utils.h>
+#include <netlink/cache.h>
+#include <netlink/attr.h>
+#include <linux/socket.h>
+
+static size_t default_msg_size;
+
+static void __init init_msg_size(void)
+{
+	default_msg_size = getpagesize();
+}
+
+/**
+ * @name Size Calculations
+ * @{
+ */
+
+/**
+ * length of netlink message not including padding
+ * @arg payload		length of message payload
+ */
+int nlmsg_msg_size(int payload)
+{
+	return NLMSG_HDRLEN + payload;
+}
+
+/**
+ * length of netlink message including padding
+ * @arg payload		length of message payload
+ */
+int nlmsg_total_size(int payload)
+{
+	return NLMSG_ALIGN(nlmsg_msg_size(payload));
+}
+
+/**
+ * length of padding at the message's tail
+ * @arg payload		length of message payload
+ */
+int nlmsg_padlen(int payload)
+{
+	return nlmsg_total_size(payload) - nlmsg_msg_size(payload);
+}
+
+/** @} */
+
+/**
+ * @name Payload Access
+ * @{
+ */
+
+/**
+ * head of message payload
+ * @arg nlh		netlink messsage header
+ */
+void *nlmsg_data(const struct nlmsghdr *nlh)
+{
+	return (unsigned char *) nlh + NLMSG_HDRLEN;
+}
+
+void *nlmsg_tail(const struct nlmsghdr *nlh)
+{
+	return (unsigned char *) nlh + NLMSG_ALIGN(nlh->nlmsg_len);
+}
+
+/**
+ * length of message payload
+ * @arg nlh		netlink message header
+ */
+int nlmsg_len(const struct nlmsghdr *nlh)
+{
+	return nlh->nlmsg_len - NLMSG_HDRLEN;
+}
+
+/** @} */
+
+/**
+ * @name Attribute Access
+ * @{
+ */
+
+/**
+ * head of attributes data
+ * @arg nlh		netlink message header
+ * @arg hdrlen		length of family specific header
+ */
+struct nlattr *nlmsg_attrdata(const struct nlmsghdr *nlh, int hdrlen)
+{
+	unsigned char *data = nlmsg_data(nlh);
+	return (struct nlattr *) (data + NLMSG_ALIGN(hdrlen));
+}
+
+/**
+ * length of attributes data
+ * @arg nlh		netlink message header
+ * @arg hdrlen		length of family specific header
+ */
+int nlmsg_attrlen(const struct nlmsghdr *nlh, int hdrlen)
+{
+	return nlmsg_len(nlh) - NLMSG_ALIGN(hdrlen);
+}
+
+/** @} */
+
+/**
+ * @name Message Parsing
+ * @{
+ */
+
+int nlmsg_valid_hdr(const struct nlmsghdr *nlh, int hdrlen)
+{
+	if (nlh->nlmsg_len < nlmsg_msg_size(hdrlen))
+		return 0;
+
+	return 1;
+}
+
+/**
+ * check if the netlink message fits into the remaining bytes
+ * @arg nlh		netlink message header
+ * @arg remaining	number of bytes remaining in message stream
+ */
+int nlmsg_ok(const struct nlmsghdr *nlh, int remaining)
+{
+	return (remaining >= (int)sizeof(struct nlmsghdr) &&
+		nlh->nlmsg_len >= sizeof(struct nlmsghdr) &&
+		nlh->nlmsg_len <= remaining);
+}
+
+/**
+ * next netlink message in message stream
+ * @arg nlh		netlink message header
+ * @arg remaining	number of bytes remaining in message stream
+ *
+ * @returns the next netlink message in the message stream and
+ * decrements remaining by the size of the current message.
+ */
+struct nlmsghdr *nlmsg_next(struct nlmsghdr *nlh, int *remaining)
+{
+	int totlen = NLMSG_ALIGN(nlh->nlmsg_len);
+
+	*remaining -= totlen;
+
+	return (struct nlmsghdr *) ((unsigned char *) nlh + totlen);
+}
+
+/**
+ * parse attributes of a netlink message
+ * @arg nlh		netlink message header
+ * @arg hdrlen		length of family specific header
+ * @arg tb		destination array with maxtype+1 elements
+ * @arg maxtype		maximum attribute type to be expected
+ * @arg policy		validation policy
+ *
+ * See nla_parse()
+ */
+int nlmsg_parse(struct nlmsghdr *nlh, int hdrlen, struct nlattr *tb[],
+		int maxtype, struct nla_policy *policy)
+{
+	if (!nlmsg_valid_hdr(nlh, hdrlen))
+		return -NLE_MSG_TOOSHORT;
+
+	return nla_parse(tb, maxtype, nlmsg_attrdata(nlh, hdrlen),
+			 nlmsg_attrlen(nlh, hdrlen), policy);
+}
+
+/**
+ * nlmsg_find_attr - find a specific attribute in a netlink message
+ * @arg nlh		netlink message header
+ * @arg hdrlen		length of familiy specific header
+ * @arg attrtype	type of attribute to look for
+ *
+ * Returns the first attribute which matches the specified type.
+ */
+struct nlattr *nlmsg_find_attr(struct nlmsghdr *nlh, int hdrlen, int attrtype)
+{
+	return nla_find(nlmsg_attrdata(nlh, hdrlen),
+			nlmsg_attrlen(nlh, hdrlen), attrtype);
+}
+
+/**
+ * nlmsg_validate - validate a netlink message including attributes
+ * @arg nlh		netlinket message header
+ * @arg hdrlen		length of familiy specific header
+ * @arg maxtype		maximum attribute type to be expected
+ * @arg policy		validation policy
+ */
+int nlmsg_validate(struct nlmsghdr *nlh, int hdrlen, int maxtype,
+		   struct nla_policy *policy)
+{
+	if (!nlmsg_valid_hdr(nlh, hdrlen))
+		return -NLE_MSG_TOOSHORT;
+
+	return nla_validate(nlmsg_attrdata(nlh, hdrlen),
+			    nlmsg_attrlen(nlh, hdrlen), maxtype, policy);
+}
+
+/** @} */
+
+/**
+ * @name Message Building/Access
+ * @{
+ */
+
+static struct nl_msg *__nlmsg_alloc(size_t len)
+{
+	struct nl_msg *nm;
+
+	nm = calloc(1, sizeof(*nm));
+	if (!nm)
+		goto errout;
+
+	nm->nm_refcnt = 1;
+
+	nm->nm_nlh = malloc(len);
+	if (!nm->nm_nlh)
+		goto errout;
+
+	memset(nm->nm_nlh, 0, sizeof(struct nlmsghdr));
+
+	nm->nm_protocol = -1;
+	nm->nm_size = len;
+	nm->nm_nlh->nlmsg_len = nlmsg_total_size(0);
+
+	NL_DBG(2, "msg %p: Allocated new message, maxlen=%zu\n", nm, len);
+
+	return nm;
+errout:
+	free(nm);
+	return NULL;
+}
+
+/**
+ * Allocate a new netlink message with the default maximum payload size.
+ *
+ * Allocates a new netlink message without any further payload. The
+ * maximum payload size defaults to PAGESIZE or as otherwise specified
+ * with nlmsg_set_default_size().
+ *
+ * @return Newly allocated netlink message or NULL.
+ */
+struct nl_msg *nlmsg_alloc(void)
+{
+	return __nlmsg_alloc(default_msg_size);
+}
+
+/**
+ * Allocate a new netlink message with maximum payload size specified.
+ */
+struct nl_msg *nlmsg_alloc_size(size_t max)
+{
+	return __nlmsg_alloc(max);
+}
+
+/**
+ * Allocate a new netlink message and inherit netlink message header
+ * @arg hdr		Netlink message header template
+ *
+ * Allocates a new netlink message and inherits the original message
+ * header. If \a hdr is not NULL it will be used as a template for
+ * the netlink message header, otherwise the header is left blank.
+ * 
+ * @return Newly allocated netlink message or NULL
+ */ 
+struct nl_msg *nlmsg_inherit(struct nlmsghdr *hdr)
+{
+	struct nl_msg *nm;
+
+	nm = nlmsg_alloc();
+	if (nm && hdr) {
+		struct nlmsghdr *new = nm->nm_nlh;
+
+		new->nlmsg_type = hdr->nlmsg_type;
+		new->nlmsg_flags = hdr->nlmsg_flags;
+		new->nlmsg_seq = hdr->nlmsg_seq;
+		new->nlmsg_pid = hdr->nlmsg_pid;
+	}
+
+	return nm;
+}
+
+/**
+ * Allocate a new netlink message
+ * @arg nlmsgtype	Netlink message type
+ * @arg flags		Message flags.
+ *
+ * @return Newly allocated netlink message or NULL.
+ */
+struct nl_msg *nlmsg_alloc_simple(int nlmsgtype, int flags)
+{
+	struct nl_msg *msg;
+	struct nlmsghdr nlh = {
+		.nlmsg_type = nlmsgtype,
+		.nlmsg_flags = flags,
+	};
+
+	msg = nlmsg_inherit(&nlh);
+	if (msg)
+		NL_DBG(2, "msg %p: Allocated new simple message\n", msg);
+
+	return msg;
+}
+
+/**
+ * Set the default maximum message payload size for allocated messages
+ * @arg max		Size of payload in bytes.
+ */
+void nlmsg_set_default_size(size_t max)
+{
+	if (max < nlmsg_total_size(0))
+		max = nlmsg_total_size(0);
+
+	default_msg_size = max;
+}
+
+/**
+ * Convert a netlink message received from a netlink socket to a nl_msg
+ * @arg hdr		Netlink message received from netlink socket.
+ *
+ * Allocates a new netlink message and copies all of the data pointed to
+ * by \a hdr into the new message object.
+ *
+ * @return Newly allocated netlink message or NULL.
+ */
+struct nl_msg *nlmsg_convert(struct nlmsghdr *hdr)
+{
+	struct nl_msg *nm;
+
+	nm = __nlmsg_alloc(NLMSG_ALIGN(hdr->nlmsg_len));
+	if (!nm)
+		goto errout;
+
+	memcpy(nm->nm_nlh, hdr, hdr->nlmsg_len);
+
+	return nm;
+errout:
+	nlmsg_free(nm);
+	return NULL;
+}
+
+/**
+ * Reserve room for additional data in a netlink message
+ * @arg n		netlink message
+ * @arg len		length of additional data to reserve room for
+ * @arg pad		number of bytes to align data to
+ *
+ * Reserves room for additional data at the tail of the an
+ * existing netlink message. Eventual padding required will
+ * be zeroed out.
+ *
+ * @return Pointer to start of additional data tailroom or NULL.
+ */
+void *nlmsg_reserve(struct nl_msg *n, size_t len, int pad)
+{
+	void *buf = n->nm_nlh;
+	size_t nlmsg_len = n->nm_nlh->nlmsg_len;
+	size_t tlen;
+
+	tlen = pad ? ((len + (pad - 1)) & ~(pad - 1)) : len;
+
+	if ((tlen + nlmsg_len) > n->nm_size)
+		return NULL;
+
+	buf += nlmsg_len;
+	n->nm_nlh->nlmsg_len += tlen;
+
+	if (tlen > len)
+		memset(buf + len, 0, tlen - len);
+
+	NL_DBG(2, "msg %p: Reserved %zu bytes, pad=%d, nlmsg_len=%d\n",
+		  n, len, pad, n->nm_nlh->nlmsg_len);
+
+	return buf;
+}
+
+/**
+ * Append data to tail of a netlink message
+ * @arg n		netlink message
+ * @arg data		data to add
+ * @arg len		length of data
+ * @arg pad		Number of bytes to align data to.
+ *
+ * Extends the netlink message as needed and appends the data of given
+ * length to the message. 
+ *
+ * @return 0 on success or a negative error code
+ */
+int nlmsg_append(struct nl_msg *n, void *data, size_t len, int pad)
+{
+	void *tmp;
+
+	tmp = nlmsg_reserve(n, len, pad);
+	if (tmp == NULL)
+		return -NLE_NOMEM;
+
+	memcpy(tmp, data, len);
+	NL_DBG(2, "msg %p: Appended %zu bytes with padding %d\n", n, len, pad);
+
+	return 0;
+}
+
+/**
+ * Expand maximum payload size of a netlink message
+ * @arg n		Netlink message.
+ * @arg newlen		New maximum payload size.
+ *
+ * Reallocates the payload section of a netlink message and increases
+ * the maximum payload size of the message.
+ *
+ * @note Any pointers pointing to old payload block will be stale and
+ *       need to be refetched. Therfore, do not expand while constructing
+ *       nested attributes or while reserved data blocks are held.
+ *
+ * @return 0 on success or a negative error code.
+ */
+int nlmsg_expand(struct nl_msg *n, size_t newlen)
+{
+	void *tmp;
+
+	if (newlen <= n->nm_size)
+		return -NLE_INVAL;
+
+	tmp = realloc(n->nm_nlh, newlen);
+	if (tmp == NULL)
+		return -NLE_NOMEM;
+
+	n->nm_nlh = tmp;
+	n->nm_size = newlen;
+
+	return 0;
+}
+
+/**
+ * Add a netlink message header to a netlink message
+ * @arg n		netlink message
+ * @arg pid		netlink process id or NL_AUTO_PID
+ * @arg seq		sequence number of message or NL_AUTO_SEQ
+ * @arg type		message type
+ * @arg payload		length of message payload
+ * @arg flags		message flags
+ *
+ * Adds or overwrites the netlink message header in an existing message
+ * object. If \a payload is greater-than zero additional room will be
+ * reserved, f.e. for family specific headers. It can be accesed via
+ * nlmsg_data().
+ *
+ * @return A pointer to the netlink message header or NULL.
+ */
+struct nlmsghdr *nlmsg_put(struct nl_msg *n, uint32_t pid, uint32_t seq,
+			   int type, int payload, int flags)
+{
+	struct nlmsghdr *nlh;
+
+	if (n->nm_nlh->nlmsg_len < NLMSG_HDRLEN)
+		BUG();
+
+	nlh = (struct nlmsghdr *) n->nm_nlh;
+	nlh->nlmsg_type = type;
+	nlh->nlmsg_flags = flags;
+	nlh->nlmsg_pid = pid;
+	nlh->nlmsg_seq = seq;
+
+	NL_DBG(2, "msg %p: Added netlink header type=%d, flags=%d, pid=%d, "
+		  "seq=%d\n", n, type, flags, pid, seq);
+
+	if (payload > 0 &&
+	    nlmsg_reserve(n, payload, NLMSG_ALIGNTO) == NULL)
+		return NULL;
+
+	return nlh;
+}
+
+/**
+ * Return actual netlink message
+ * @arg n		netlink message
+ * 
+ * Returns the actual netlink message casted to the type of the netlink
+ * message header.
+ * 
+ * @return A pointer to the netlink message.
+ */
+struct nlmsghdr *nlmsg_hdr(struct nl_msg *n)
+{
+	return n->nm_nlh;
+}
+
+/**
+ * Acquire a reference on a netlink message
+ * @arg msg		message to acquire reference from
+ */
+void nlmsg_get(struct nl_msg *msg)
+{
+	msg->nm_refcnt++;
+	NL_DBG(4, "New reference to message %p, total %d\n",
+	       msg, msg->nm_refcnt);
+}
+
+/**
+ * Release a reference from an netlink message
+ * @arg msg		message to release reference from
+ *
+ * Frees memory after the last reference has been released.
+ */
+void nlmsg_free(struct nl_msg *msg)
+{
+	if (!msg)
+		return;
+
+	msg->nm_refcnt--;
+	NL_DBG(4, "Returned message reference %p, %d remaining\n",
+	       msg, msg->nm_refcnt);
+
+	if (msg->nm_refcnt < 0)
+		BUG();
+
+	if (msg->nm_refcnt <= 0) {
+		free(msg->nm_nlh);
+		free(msg);
+		NL_DBG(2, "msg %p: Freed\n", msg);
+	}
+}
+
+/** @} */
+
+/**
+ * @name Attributes
+ * @{
+ */
+
+void nlmsg_set_proto(struct nl_msg *msg, int protocol)
+{
+	msg->nm_protocol = protocol;
+}
+
+int nlmsg_get_proto(struct nl_msg *msg)
+{
+	return msg->nm_protocol;
+}
+
+size_t nlmsg_get_max_size(struct nl_msg *msg)
+{
+	return msg->nm_size;
+}
+
+void nlmsg_set_src(struct nl_msg *msg, struct sockaddr_nl *addr)
+{
+	memcpy(&msg->nm_src, addr, sizeof(*addr));
+}
+
+struct sockaddr_nl *nlmsg_get_src(struct nl_msg *msg)
+{
+	return &msg->nm_src;
+}
+
+void nlmsg_set_dst(struct nl_msg *msg, struct sockaddr_nl *addr)
+{
+	memcpy(&msg->nm_dst, addr, sizeof(*addr));
+}
+
+struct sockaddr_nl *nlmsg_get_dst(struct nl_msg *msg)
+{
+	return &msg->nm_dst;
+}
+
+void nlmsg_set_creds(struct nl_msg *msg, struct ucred *creds)
+{
+	memcpy(&msg->nm_creds, creds, sizeof(*creds));
+	msg->nm_flags |= NL_MSG_CRED_PRESENT;
+}
+
+struct ucred *nlmsg_get_creds(struct nl_msg *msg)
+{
+	if (msg->nm_flags & NL_MSG_CRED_PRESENT)
+		return &msg->nm_creds;
+	return NULL;
+}
+
+/** @} */
+
+/**
+ * @name Netlink Message Type Translations
+ * @{
+ */
+
+static struct trans_tbl nl_msgtypes[] = {
+	__ADD(NLMSG_NOOP,NOOP)
+	__ADD(NLMSG_ERROR,ERROR)
+	__ADD(NLMSG_DONE,DONE)
+	__ADD(NLMSG_OVERRUN,OVERRUN)
+};
+
+char *nl_nlmsgtype2str(int type, char *buf, size_t size)
+{
+	return __type2str(type, buf, size, nl_msgtypes,
+			  ARRAY_SIZE(nl_msgtypes));
+}
+
+int nl_str2nlmsgtype(const char *name)
+{
+	return __str2type(name, nl_msgtypes, ARRAY_SIZE(nl_msgtypes));
+}
+
+/** @} */
+
+/**
+ * @name Netlink Message Flags Translations
+ * @{
+ */
+
+char *nl_nlmsg_flags2str(int flags, char *buf, size_t len)
+{
+	memset(buf, 0, len);
+
+#define PRINT_FLAG(f) \
+	if (flags & NLM_F_##f) { \
+		flags &= ~NLM_F_##f; \
+		strncat(buf, #f, len - strlen(buf) - 1); \
+		if (flags) \
+			strncat(buf, ",", len - strlen(buf) - 1); \
+	}
+	
+	PRINT_FLAG(REQUEST);
+	PRINT_FLAG(MULTI);
+	PRINT_FLAG(ACK);
+	PRINT_FLAG(ECHO);
+	PRINT_FLAG(ROOT);
+	PRINT_FLAG(MATCH);
+	PRINT_FLAG(ATOMIC);
+	PRINT_FLAG(REPLACE);
+	PRINT_FLAG(EXCL);
+	PRINT_FLAG(CREATE);
+	PRINT_FLAG(APPEND);
+
+	if (flags) {
+		char s[32];
+		snprintf(s, sizeof(s), "0x%x", flags);
+		strncat(buf, s, len - strlen(buf) - 1);
+	}
+#undef PRINT_FLAG
+
+	return buf;
+}
+
+/** @} */
+
+/**
+ * @name Direct Parsing
+ * @{
+ */
+
+/** @cond SKIP */
+struct dp_xdata {
+	void (*cb)(struct nl_object *, void *);
+	void *arg;
+};
+/** @endcond */
+
+static int parse_cb(struct nl_object *obj, struct nl_parser_param *p)
+{
+	struct dp_xdata *x = p->pp_arg;
+
+	x->cb(obj, x->arg);
+	return 0;
+}
+
+int nl_msg_parse(struct nl_msg *msg, void (*cb)(struct nl_object *, void *),
+		 void *arg)
+{
+	struct nl_cache_ops *ops;
+	struct nl_parser_param p = {
+		.pp_cb = parse_cb
+	};
+	struct dp_xdata x = {
+		.cb = cb,
+		.arg = arg,
+	};
+
+	ops = nl_cache_ops_associate(nlmsg_get_proto(msg),
+				     nlmsg_hdr(msg)->nlmsg_type);
+	if (ops == NULL)
+		return -NLE_MSGTYPE_NOSUPPORT;
+	p.pp_arg = &x;
+
+	return nl_cache_parse(ops, NULL, nlmsg_hdr(msg), &p);
+}
+
+/** @} */
+
+/**
+ * @name Dumping
+ * @{
+ */
+
+static void prefix_line(FILE *ofd, int prefix)
+{
+	int i;
+
+	for (i = 0; i < prefix; i++)
+		fprintf(ofd, "  ");
+}
+
+static inline void dump_hex(FILE *ofd, char *start, int len, int prefix)
+{
+	int i, a, c, limit;
+	char ascii[21] = {0};
+
+	limit = 18 - (prefix * 2);
+	prefix_line(ofd, prefix);
+	fprintf(ofd, "    ");
+
+	for (i = 0, a = 0, c = 0; i < len; i++) {
+		int v = *(uint8_t *) (start + i);
+
+		fprintf(ofd, "%02x ", v);
+		ascii[a++] = isprint(v) ? v : '.';
+
+		if (c == limit-1) {
+			fprintf(ofd, "%s\n", ascii);
+			if (i < (len - 1)) {
+				prefix_line(ofd, prefix);
+				fprintf(ofd, "    ");
+			}
+			a = c = 0;
+			memset(ascii, 0, sizeof(ascii));
+		} else
+			c++;
+	}
+
+	if (c != 0) {
+		for (i = 0; i < (limit - c); i++)
+			fprintf(ofd, "   ");
+		fprintf(ofd, "%s\n", ascii);
+	}
+}
+
+static void print_hdr(FILE *ofd, struct nl_msg *msg)
+{
+	struct nlmsghdr *nlh = nlmsg_hdr(msg);
+	struct nl_cache_ops *ops;
+	struct nl_msgtype *mt;
+	char buf[128];
+
+	fprintf(ofd, "    .nlmsg_len = %d\n", nlh->nlmsg_len);
+
+	ops = nl_cache_ops_associate(nlmsg_get_proto(msg), nlh->nlmsg_type);
+	if (ops) {
+		mt = nl_msgtype_lookup(ops, nlh->nlmsg_type);
+		if (!mt)
+			BUG();
+
+		snprintf(buf, sizeof(buf), "%s::%s", ops->co_name, mt->mt_name);
+	} else
+		nl_nlmsgtype2str(nlh->nlmsg_type, buf, sizeof(buf));
+
+	fprintf(ofd, "    .nlmsg_type = %d <%s>\n", nlh->nlmsg_type, buf);
+	fprintf(ofd, "    .nlmsg_flags = %d <%s>\n", nlh->nlmsg_flags,
+		nl_nlmsg_flags2str(nlh->nlmsg_flags, buf, sizeof(buf)));
+	fprintf(ofd, "    .nlmsg_seq = %d\n", nlh->nlmsg_seq);
+	fprintf(ofd, "    .nlmsg_pid = %d\n", nlh->nlmsg_pid);
+
+}
+
+static void dump_attrs(FILE *ofd, struct nlattr *attrs, int attrlen,
+		       int prefix)
+{
+	int rem;
+	struct nlattr *nla;
+
+	nla_for_each_attr(nla, attrs, attrlen, rem) {
+		int padlen, alen = nla_len(nla);
+
+		prefix_line(ofd, prefix);
+		fprintf(ofd, "  [ATTR %02d%s] %d octets\n", nla_type(nla),
+			nla->nla_type & NLA_F_NESTED ? " NESTED" : "",
+			alen);
+
+		if (nla->nla_type & NLA_F_NESTED)
+			dump_attrs(ofd, nla_data(nla), alen, prefix+1);
+		else
+			dump_hex(ofd, nla_data(nla), alen, prefix);
+
+		padlen = nla_padlen(alen);
+		if (padlen > 0) {
+			prefix_line(ofd, prefix);
+			fprintf(ofd, "  [PADDING] %d octets\n",
+				padlen);
+			dump_hex(ofd, nla_data(nla) + alen,
+				 padlen, prefix);
+		}
+	}
+
+	if (rem) {
+		prefix_line(ofd, prefix);
+		fprintf(ofd, "  [LEFTOVER] %d octets\n", rem);
+	}
+}
+
+/**
+ * Dump message in human readable format to file descriptor
+ * @arg msg		Message to print
+ * @arg ofd		File descriptor.
+ */
+void nl_msg_dump(struct nl_msg *msg, FILE *ofd)
+{
+	struct nlmsghdr *hdr = nlmsg_hdr(msg);
+	
+	fprintf(ofd, 
+	"--------------------------   BEGIN NETLINK MESSAGE "
+	"---------------------------\n");
+
+	fprintf(ofd, "  [HEADER] %Zu octets\n", sizeof(struct nlmsghdr));
+	print_hdr(ofd, msg);
+
+	if (hdr->nlmsg_type == NLMSG_ERROR &&
+	    hdr->nlmsg_len >= nlmsg_msg_size(sizeof(struct nlmsgerr))) {
+		struct nl_msg *errmsg;
+		struct nlmsgerr *err = nlmsg_data(hdr);
+
+		fprintf(ofd, "  [ERRORMSG] %Zu octets\n", sizeof(*err));
+		fprintf(ofd, "    .error = %d \"%s\"\n", err->error,
+			strerror(-err->error));
+		fprintf(ofd, "  [ORIGINAL MESSAGE] %Zu octets\n", sizeof(*hdr));
+
+		errmsg = nlmsg_inherit(&err->msg);
+		print_hdr(ofd, errmsg);
+		nlmsg_free(errmsg);
+	} else if (nlmsg_len(hdr) > 0) {
+		struct nl_cache_ops *ops;
+		int payloadlen = nlmsg_len(hdr);
+		int attrlen = 0;
+
+		ops = nl_cache_ops_associate(nlmsg_get_proto(msg),
+					     hdr->nlmsg_type);
+		if (ops) {
+			attrlen = nlmsg_attrlen(hdr, ops->co_hdrsize);
+			payloadlen -= attrlen;
+		}
+
+		fprintf(ofd, "  [PAYLOAD] %d octets\n", payloadlen);
+		dump_hex(ofd, nlmsg_data(hdr), payloadlen, 0);
+
+		if (attrlen) {
+			struct nlattr *attrs;
+			int attrlen;
+			
+			attrs = nlmsg_attrdata(hdr, ops->co_hdrsize);
+			attrlen = nlmsg_attrlen(hdr, ops->co_hdrsize);
+			dump_attrs(ofd, attrs, attrlen, 0);
+		}
+	}
+
+	fprintf(ofd, 
+	"---------------------------  END NETLINK MESSAGE   "
+	"---------------------------\n");
+}
+
+/** @} */
+
+/** @} */
diff -uNr libnl_kk/lib/netfilter/ct.c libnl/lib/netfilter/ct.c
--- libnl_kk/lib/netfilter/ct.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/netfilter/ct.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,601 @@
+/*
+ * lib/netfilter/ct.c	Conntrack
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ * Copyright (c) 2007 Philip Craig <philipc@snapgear.com>
+ * Copyright (c) 2007 Secure Computing Corporation
+ * Copyright (c= 2008 Patrick McHardy <kaber@trash.net>
+ */
+
+/**
+ * @ingroup nfnl
+ * @defgroup ct Conntrack
+ * @brief
+ * @{
+ */
+
+#include <byteswap.h>
+#include <sys/types.h>
+#include <linux/netfilter/nfnetlink_conntrack.h>
+
+#include <netlink-local.h>
+#include <netlink/attr.h>
+#include <netlink/netfilter/nfnl.h>
+#include <netlink/netfilter/ct.h>
+
+static struct nl_cache_ops nfnl_ct_ops;
+
+#if __BYTE_ORDER == __BIG_ENDIAN
+static uint64_t ntohll(uint64_t x)
+{
+	return x;
+}
+#elif __BYTE_ORDER == __LITTLE_ENDIAN
+static uint64_t ntohll(uint64_t x)
+{
+	return __bswap_64(x);
+}
+#endif
+
+static struct nla_policy ct_policy[CTA_MAX+1] = {
+	[CTA_TUPLE_ORIG]	= { .type = NLA_NESTED },
+	[CTA_TUPLE_REPLY]	= { .type = NLA_NESTED },
+	[CTA_STATUS]		= { .type = NLA_U32 },
+	[CTA_PROTOINFO]		= { .type = NLA_NESTED },
+	//[CTA_HELP]
+	//[CTA_NAT_SRC]
+	[CTA_TIMEOUT]		= { .type = NLA_U32 },
+	[CTA_MARK]		= { .type = NLA_U32 },
+	[CTA_COUNTERS_ORIG]	= { .type = NLA_NESTED },
+	[CTA_COUNTERS_REPLY]	= { .type = NLA_NESTED },
+	[CTA_USE]		= { .type = NLA_U32 },
+	[CTA_ID]		= { .type = NLA_U32 },
+	//[CTA_NAT_DST]
+};
+
+static struct nla_policy ct_tuple_policy[CTA_TUPLE_MAX+1] = {
+	[CTA_TUPLE_IP]		= { .type = NLA_NESTED },
+	[CTA_TUPLE_PROTO]	= { .type = NLA_NESTED },
+};
+
+static struct nla_policy ct_ip_policy[CTA_IP_MAX+1] = {
+	[CTA_IP_V4_SRC]		= { .type = NLA_U32 },
+	[CTA_IP_V4_DST]		= { .type = NLA_U32 },
+	[CTA_IP_V6_SRC]		= { .minlen = 16 },
+	[CTA_IP_V6_DST]		= { .minlen = 16 },
+};
+
+static struct nla_policy ct_proto_policy[CTA_PROTO_MAX+1] = {
+	[CTA_PROTO_NUM]		= { .type = NLA_U8 },
+	[CTA_PROTO_SRC_PORT]	= { .type = NLA_U16 },
+	[CTA_PROTO_DST_PORT]	= { .type = NLA_U16 },
+	[CTA_PROTO_ICMP_ID]	= { .type = NLA_U16 },
+	[CTA_PROTO_ICMP_TYPE]	= { .type = NLA_U8 },
+	[CTA_PROTO_ICMP_CODE]	= { .type = NLA_U8 },
+	[CTA_PROTO_ICMPV6_ID]	= { .type = NLA_U16 },
+	[CTA_PROTO_ICMPV6_TYPE]	= { .type = NLA_U8 },
+	[CTA_PROTO_ICMPV6_CODE]	= { .type = NLA_U8 },
+};
+
+static struct nla_policy ct_protoinfo_policy[CTA_PROTOINFO_MAX+1] = {
+	[CTA_PROTOINFO_TCP]	= { .type = NLA_NESTED },
+};
+
+static struct nla_policy ct_protoinfo_tcp_policy[CTA_PROTOINFO_TCP_MAX+1] = {
+	[CTA_PROTOINFO_TCP_STATE]		= { .type = NLA_U8 },
+	[CTA_PROTOINFO_TCP_WSCALE_ORIGINAL]	= { .type = NLA_U8 },
+	[CTA_PROTOINFO_TCP_WSCALE_REPLY]	= { .type = NLA_U8 },
+	[CTA_PROTOINFO_TCP_FLAGS_ORIGINAL]	= { .minlen = 2 },
+	[CTA_PROTOINFO_TCP_FLAGS_REPLY]		= { .minlen = 2 },
+
+};
+
+static struct nla_policy ct_counters_policy[CTA_COUNTERS_MAX+1] = {
+	[CTA_COUNTERS_PACKETS]	= { .type = NLA_U64 },
+	[CTA_COUNTERS_BYTES]	= { .type = NLA_U64 },
+	[CTA_COUNTERS32_PACKETS]= { .type = NLA_U32 },
+	[CTA_COUNTERS32_BYTES]	= { .type = NLA_U32 },
+};
+
+static int ct_parse_ip(struct nfnl_ct *ct, int repl, struct nlattr *attr)
+{
+	struct nlattr *tb[CTA_IP_MAX+1];
+	struct nl_addr *addr;
+	int err;
+
+        err = nla_parse_nested(tb, CTA_IP_MAX, attr, ct_ip_policy);
+	if (err < 0)
+		goto errout;
+
+	if (tb[CTA_IP_V4_SRC]) {
+		addr = nl_addr_alloc_attr(tb[CTA_IP_V4_SRC], AF_INET);
+		if (addr == NULL)
+			goto errout_enomem;
+		err = nfnl_ct_set_src(ct, repl, addr);
+		nl_addr_put(addr);
+		if (err < 0)
+			goto errout;
+	}
+	if (tb[CTA_IP_V4_DST]) {
+		addr = nl_addr_alloc_attr(tb[CTA_IP_V4_DST], AF_INET);
+		if (addr == NULL)
+			goto errout_enomem;
+		err = nfnl_ct_set_dst(ct, repl, addr);
+		nl_addr_put(addr);
+		if (err < 0)
+			goto errout;
+	}
+	if (tb[CTA_IP_V6_SRC]) {
+		addr = nl_addr_alloc_attr(tb[CTA_IP_V6_SRC], AF_INET6);
+		if (addr == NULL)
+			goto errout_enomem;
+		err = nfnl_ct_set_src(ct, repl, addr);
+		nl_addr_put(addr);
+		if (err < 0)
+			goto errout;
+	}
+	if (tb[CTA_IP_V6_DST]) {
+		addr = nl_addr_alloc_attr(tb[CTA_IP_V6_DST], AF_INET6);
+		if (addr == NULL)
+			goto errout_enomem;
+		err = nfnl_ct_set_dst(ct, repl, addr);
+		nl_addr_put(addr);
+		if (err < 0)
+			goto errout;
+	}
+
+	return 0;
+
+errout_enomem:
+	err = -NLE_NOMEM;
+errout:
+	return err;
+}
+
+static int ct_parse_proto(struct nfnl_ct *ct, int repl, struct nlattr *attr)
+{
+	struct nlattr *tb[CTA_PROTO_MAX+1];
+	int err;
+
+	err = nla_parse_nested(tb, CTA_PROTO_MAX, attr, ct_proto_policy);
+	if (err < 0)
+		return err;
+
+	if (!repl && tb[CTA_PROTO_NUM])
+		nfnl_ct_set_proto(ct, nla_get_u8(tb[CTA_PROTO_NUM]));
+	if (tb[CTA_PROTO_SRC_PORT])
+		nfnl_ct_set_src_port(ct, repl,
+			ntohs(nla_get_u16(tb[CTA_PROTO_SRC_PORT])));
+	if (tb[CTA_PROTO_DST_PORT])
+		nfnl_ct_set_dst_port(ct, repl,
+			ntohs(nla_get_u16(tb[CTA_PROTO_DST_PORT])));
+	if (tb[CTA_PROTO_ICMP_ID])
+		nfnl_ct_set_icmp_id(ct, repl,
+			ntohs(nla_get_u16(tb[CTA_PROTO_ICMP_ID])));
+	if (tb[CTA_PROTO_ICMP_TYPE])
+		nfnl_ct_set_icmp_type(ct, repl,
+				nla_get_u8(tb[CTA_PROTO_ICMP_TYPE]));
+	if (tb[CTA_PROTO_ICMP_CODE])
+		nfnl_ct_set_icmp_code(ct, repl,
+				nla_get_u8(tb[CTA_PROTO_ICMP_CODE]));
+
+	return 0;
+}
+
+static int ct_parse_tuple(struct nfnl_ct *ct, int repl, struct nlattr *attr)
+{
+	struct nlattr *tb[CTA_TUPLE_MAX+1];
+	int err;
+
+	err = nla_parse_nested(tb, CTA_TUPLE_MAX, attr, ct_tuple_policy);
+	if (err < 0)
+		return err;
+
+	if (tb[CTA_TUPLE_IP]) {
+		err = ct_parse_ip(ct, repl, tb[CTA_TUPLE_IP]);
+		if (err < 0)
+			return err;
+	}
+
+	if (tb[CTA_TUPLE_PROTO]) {
+		err = ct_parse_proto(ct, repl, tb[CTA_TUPLE_PROTO]);
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
+}
+
+static int ct_parse_protoinfo_tcp(struct nfnl_ct *ct, struct nlattr *attr)
+{
+	struct nlattr *tb[CTA_PROTOINFO_TCP_MAX+1];
+	int err;
+
+	err = nla_parse_nested(tb, CTA_PROTOINFO_TCP_MAX, attr,
+			       ct_protoinfo_tcp_policy);
+	if (err < 0)
+		return err;
+
+	if (tb[CTA_PROTOINFO_TCP_STATE])
+		nfnl_ct_set_tcp_state(ct,
+				nla_get_u8(tb[CTA_PROTOINFO_TCP_STATE]));
+
+	return 0;
+}
+
+static int ct_parse_protoinfo(struct nfnl_ct *ct, struct nlattr *attr)
+{
+	struct nlattr *tb[CTA_PROTOINFO_MAX+1];
+	int err;
+
+	err = nla_parse_nested(tb, CTA_PROTOINFO_MAX, attr,
+			       ct_protoinfo_policy);
+	if (err < 0)
+		return err;
+
+	if (tb[CTA_PROTOINFO_TCP]) {
+		err = ct_parse_protoinfo_tcp(ct, tb[CTA_PROTOINFO_TCP]);
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
+}
+
+static int ct_parse_counters(struct nfnl_ct *ct, int repl, struct nlattr *attr)
+{
+	struct nlattr *tb[CTA_COUNTERS_MAX+1];
+	int err;
+
+	err = nla_parse_nested(tb, CTA_COUNTERS_MAX, attr, ct_counters_policy);
+	if (err < 0)
+		return err;
+
+	if (tb[CTA_COUNTERS_PACKETS])
+		nfnl_ct_set_packets(ct, repl,
+			ntohll(nla_get_u64(tb[CTA_COUNTERS_PACKETS])));
+	if (tb[CTA_COUNTERS32_PACKETS])
+		nfnl_ct_set_packets(ct, repl,
+			ntohl(nla_get_u32(tb[CTA_COUNTERS32_PACKETS])));
+	if (tb[CTA_COUNTERS_BYTES])
+		nfnl_ct_set_bytes(ct, repl,
+			ntohll(nla_get_u64(tb[CTA_COUNTERS_BYTES])));
+	if (tb[CTA_COUNTERS32_BYTES])
+		nfnl_ct_set_bytes(ct, repl,
+			ntohl(nla_get_u32(tb[CTA_COUNTERS32_BYTES])));
+
+	return 0;
+}
+
+int nfnlmsg_ct_group(struct nlmsghdr *nlh)
+{
+	switch (nfnlmsg_subtype(nlh)) {
+	case IPCTNL_MSG_CT_NEW:
+		if (nlh->nlmsg_flags & (NLM_F_CREATE|NLM_F_EXCL))
+			return NFNLGRP_CONNTRACK_NEW;
+		else
+			return NFNLGRP_CONNTRACK_UPDATE;
+	case IPCTNL_MSG_CT_DELETE:
+		return NFNLGRP_CONNTRACK_DESTROY;
+	default:
+		return NFNLGRP_NONE;
+	}
+}
+
+int nfnlmsg_ct_parse(struct nlmsghdr *nlh, struct nfnl_ct **result)
+{
+	struct nfnl_ct *ct;
+	struct nlattr *tb[CTA_MAX+1];
+	int err;
+
+	ct = nfnl_ct_alloc();
+	if (!ct)
+		return -NLE_NOMEM;
+
+	ct->ce_msgtype = nlh->nlmsg_type;
+
+	err = nlmsg_parse(nlh, sizeof(struct nfgenmsg), tb, CTA_MAX,
+			  ct_policy);
+	if (err < 0)
+		goto errout;
+
+	nfnl_ct_set_family(ct, nfnlmsg_family(nlh));
+
+	if (tb[CTA_TUPLE_ORIG]) {
+		err = ct_parse_tuple(ct, 0, tb[CTA_TUPLE_ORIG]);
+		if (err < 0)
+			goto errout;
+	}
+	if (tb[CTA_TUPLE_REPLY]) {
+		err = ct_parse_tuple(ct, 1, tb[CTA_TUPLE_REPLY]);
+		if (err < 0)
+			goto errout;
+	}
+
+	if (tb[CTA_PROTOINFO]) {
+		err = ct_parse_protoinfo(ct, tb[CTA_PROTOINFO]);
+		if (err < 0)
+			goto errout;
+	}
+
+	if (tb[CTA_STATUS])
+		nfnl_ct_set_status(ct, ntohl(nla_get_u32(tb[CTA_STATUS])));
+	if (tb[CTA_TIMEOUT])
+		nfnl_ct_set_timeout(ct, ntohl(nla_get_u32(tb[CTA_TIMEOUT])));
+	if (tb[CTA_MARK])
+		nfnl_ct_set_mark(ct, ntohl(nla_get_u32(tb[CTA_MARK])));
+	if (tb[CTA_USE])
+		nfnl_ct_set_use(ct, ntohl(nla_get_u32(tb[CTA_USE])));
+	if (tb[CTA_ID])
+		nfnl_ct_set_id(ct, ntohl(nla_get_u32(tb[CTA_ID])));
+
+	if (tb[CTA_COUNTERS_ORIG]) {
+		err = ct_parse_counters(ct, 0, tb[CTA_COUNTERS_ORIG]);
+		if (err < 0)
+			goto errout;
+	}
+
+	if (tb[CTA_COUNTERS_REPLY]) {
+		err = ct_parse_counters(ct, 1, tb[CTA_COUNTERS_REPLY]);
+		if (err < 0)
+			goto errout;
+	}
+
+	*result = ct;
+	return 0;
+
+errout:
+	nfnl_ct_put(ct);
+	return err;
+}
+
+static int ct_msg_parser(struct nl_cache_ops *ops, struct sockaddr_nl *who,
+			 struct nlmsghdr *nlh, struct nl_parser_param *pp)
+{
+	struct nfnl_ct *ct;
+	int err;
+
+	if ((err = nfnlmsg_ct_parse(nlh, &ct)) < 0)
+		goto errout;
+
+	err = pp->pp_cb((struct nl_object *) ct, pp);
+errout:
+	nfnl_ct_put(ct);
+	return err;
+}
+
+int nfnl_ct_dump_request(struct nl_sock *sk)
+{
+	return nfnl_send_simple(sk, NFNL_SUBSYS_CTNETLINK, IPCTNL_MSG_CT_GET,
+				NLM_F_DUMP, AF_UNSPEC, 0);
+}
+
+static int ct_request_update(struct nl_cache *cache, struct nl_sock *sk)
+{
+	return nfnl_ct_dump_request(sk);
+}
+
+static int nfnl_ct_build_tuple(struct nl_msg *msg, const struct nfnl_ct *ct,
+			       int repl)
+{
+	struct nlattr *tuple, *ip, *proto;
+	struct nl_addr *addr;
+	int family;
+
+	family = nfnl_ct_get_family(ct);
+
+	tuple = nla_nest_start(msg, repl ? CTA_TUPLE_REPLY : CTA_TUPLE_ORIG);
+	if (!tuple)
+		goto nla_put_failure;
+
+	ip = nla_nest_start(msg, CTA_TUPLE_IP);
+	if (!ip)
+		goto nla_put_failure;
+
+	addr = nfnl_ct_get_src(ct, repl);
+	if (addr)
+		NLA_PUT_ADDR(msg,
+			     family == AF_INET ? CTA_IP_V4_SRC : CTA_IP_V6_SRC,
+			     addr);
+
+	addr = nfnl_ct_get_dst(ct, repl);
+	if (addr)
+		NLA_PUT_ADDR(msg,
+			     family == AF_INET ? CTA_IP_V4_DST : CTA_IP_V6_DST,
+			     addr);
+
+	nla_nest_end(msg, ip);
+
+	proto = nla_nest_start(msg, CTA_TUPLE_PROTO);
+	if (!proto)
+		goto nla_put_failure;
+
+	if (nfnl_ct_test_proto(ct))
+		NLA_PUT_U8(msg, CTA_PROTO_NUM, nfnl_ct_get_proto(ct));
+
+	if (nfnl_ct_test_src_port(ct, repl))
+		NLA_PUT_U16(msg, CTA_PROTO_SRC_PORT,
+			htons(nfnl_ct_get_src_port(ct, repl)));
+
+	if (nfnl_ct_test_dst_port(ct, repl))
+		NLA_PUT_U16(msg, CTA_PROTO_DST_PORT,
+			htons(nfnl_ct_get_dst_port(ct, repl)));
+
+	if (nfnl_ct_test_icmp_id(ct, repl))
+		NLA_PUT_U16(msg, CTA_PROTO_ICMP_ID,
+			htons(nfnl_ct_get_icmp_id(ct, repl)));
+
+	if (nfnl_ct_test_icmp_type(ct, repl))
+		NLA_PUT_U8(msg, CTA_PROTO_ICMP_TYPE,
+			    nfnl_ct_get_icmp_type(ct, repl));
+
+	if (nfnl_ct_test_icmp_code(ct, repl))
+		NLA_PUT_U8(msg, CTA_PROTO_ICMP_CODE,
+			    nfnl_ct_get_icmp_code(ct, repl));
+
+	nla_nest_end(msg, proto);
+
+	nla_nest_end(msg, tuple);
+	return 0;
+
+nla_put_failure:
+	return -NLE_MSGSIZE;
+}
+
+static int nfnl_ct_build_message(const struct nfnl_ct *ct, int cmd, int flags,
+				 struct nl_msg **result)
+{
+	struct nl_msg *msg;
+	int err;
+
+	msg = nfnlmsg_alloc_simple(NFNL_SUBSYS_CTNETLINK, cmd, flags,
+				   nfnl_ct_get_family(ct), 0);
+	if (msg == NULL)
+		return -NLE_NOMEM;
+
+	if ((err = nfnl_ct_build_tuple(msg, ct, 0)) < 0)
+		goto err_out;
+
+	*result = msg;
+	return 0;
+
+err_out:
+	nlmsg_free(msg);
+	return err;
+}
+
+int nfnl_ct_build_add_request(const struct nfnl_ct *ct, int flags,
+			      struct nl_msg **result)
+{
+	return nfnl_ct_build_message(ct, IPCTNL_MSG_CT_NEW, flags, result);
+}
+
+int nfnl_ct_add(struct nl_sock *sk, const struct nfnl_ct *ct, int flags)
+{
+	struct nl_msg *msg;
+	int err;
+
+	if ((err = nfnl_ct_build_add_request(ct, flags, &msg)) < 0)
+		return err;
+
+	err = nl_send_auto_complete(sk, msg);
+	nlmsg_free(msg);
+	if (err < 0)
+		return err;
+
+	return wait_for_ack(sk);
+}
+
+int nfnl_ct_build_delete_request(const struct nfnl_ct *ct, int flags,
+				 struct nl_msg **result)
+{
+	return nfnl_ct_build_message(ct, IPCTNL_MSG_CT_DELETE, flags, result);
+}
+
+int nfnl_ct_del(struct nl_sock *sk, const struct nfnl_ct *ct, int flags)
+{
+	struct nl_msg *msg;
+	int err;
+
+	if ((err = nfnl_ct_build_delete_request(ct, flags, &msg)) < 0)
+		return err;
+
+	err = nl_send_auto_complete(sk, msg);
+	nlmsg_free(msg);
+	if (err < 0)
+		return err;
+
+	return wait_for_ack(sk);
+}
+
+int nfnl_ct_build_query_request(const struct nfnl_ct *ct, int flags,
+				struct nl_msg **result)
+{
+	return nfnl_ct_build_message(ct, IPCTNL_MSG_CT_GET, flags, result);
+}
+
+int nfnl_ct_query(struct nl_sock *sk, const struct nfnl_ct *ct, int flags)
+{
+	struct nl_msg *msg;
+	int err;
+
+	if ((err = nfnl_ct_build_query_request(ct, flags, &msg)) < 0)
+		return err;
+
+	err = nl_send_auto_complete(sk, msg);
+	nlmsg_free(msg);
+	if (err < 0)
+		return err;
+
+	return wait_for_ack(sk);
+}
+
+/**
+ * @name Cache Management
+ * @{
+ */
+
+/**
+ * Build a conntrack cache holding all conntrack currently in the kernel
+ * @arg sk		Netlink socket.
+ * @arg result		Pointer to store resulting cache.
+ *
+ * Allocates a new cache, initializes it properly and updates it to
+ * contain all conntracks currently in the kernel.
+ *
+ * @return 0 on success or a negative error code.
+ */
+int nfnl_ct_alloc_cache(struct nl_sock *sk, struct nl_cache **result)
+{
+	return nl_cache_alloc_and_fill(&nfnl_ct_ops, sk, result);
+}
+
+/** @} */
+
+/**
+ * @name Conntrack Addition
+ * @{
+ */
+
+/** @} */
+
+static struct nl_af_group ct_groups[] = {
+	{ AF_UNSPEC, NFNLGRP_CONNTRACK_NEW },
+	{ AF_UNSPEC, NFNLGRP_CONNTRACK_UPDATE },
+	{ AF_UNSPEC, NFNLGRP_CONNTRACK_DESTROY },
+	{ END_OF_GROUP_LIST },
+};
+
+#define NFNLMSG_CT_TYPE(type) NFNLMSG_TYPE(NFNL_SUBSYS_CTNETLINK, (type))
+static struct nl_cache_ops nfnl_ct_ops = {
+	.co_name		= "netfilter/ct",
+	.co_hdrsize		= NFNL_HDRLEN,
+	.co_msgtypes		= {
+		{ NFNLMSG_CT_TYPE(IPCTNL_MSG_CT_NEW), NL_ACT_NEW, "new" },
+		{ NFNLMSG_CT_TYPE(IPCTNL_MSG_CT_GET), NL_ACT_GET, "get" },
+		{ NFNLMSG_CT_TYPE(IPCTNL_MSG_CT_DELETE), NL_ACT_DEL, "del" },
+		END_OF_MSGTYPES_LIST,
+	},
+	.co_protocol		= NETLINK_NETFILTER,
+	.co_groups		= ct_groups,
+	.co_request_update	= ct_request_update,
+	.co_msg_parser		= ct_msg_parser,
+	.co_obj_ops		= &ct_obj_ops,
+};
+
+static void __init ct_init(void)
+{
+	nl_cache_mngt_register(&nfnl_ct_ops);
+}
+
+static void __exit ct_exit(void)
+{
+	nl_cache_mngt_unregister(&nfnl_ct_ops);
+}
+
+/** @} */
diff -uNr libnl_kk/lib/netfilter/ct_obj.c libnl/lib/netfilter/ct_obj.c
--- libnl_kk/lib/netfilter/ct_obj.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/netfilter/ct_obj.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,785 @@
+/*
+ * lib/netfilter/ct_obj.c	Conntrack Object
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ * Copyright (c) 2007 Philip Craig <philipc@snapgear.com>
+ * Copyright (c) 2007 Secure Computing Corporation
+ */
+
+#include <sys/types.h>
+#include <linux/netfilter/nfnetlink_conntrack.h>
+#include <linux/netfilter/nf_conntrack_common.h>
+#include <linux/netfilter/nf_conntrack_tcp.h>
+
+#include <netlink-local.h>
+#include <netlink/netfilter/nfnl.h>
+#include <netlink/netfilter/ct.h>
+
+/** @cond SKIP */
+#define CT_ATTR_FAMILY		(1UL << 0)
+#define CT_ATTR_PROTO		(1UL << 1)
+
+#define CT_ATTR_TCP_STATE	(1UL << 2)
+
+#define CT_ATTR_STATUS		(1UL << 3)
+#define CT_ATTR_TIMEOUT		(1UL << 4)
+#define CT_ATTR_MARK		(1UL << 5)
+#define CT_ATTR_USE		(1UL << 6)
+#define CT_ATTR_ID		(1UL << 7)
+
+#define CT_ATTR_ORIG_SRC	(1UL << 8)
+#define CT_ATTR_ORIG_DST	(1UL << 9)
+#define CT_ATTR_ORIG_SRC_PORT	(1UL << 10)
+#define CT_ATTR_ORIG_DST_PORT	(1UL << 11)
+#define CT_ATTR_ORIG_ICMP_ID	(1UL << 12)
+#define CT_ATTR_ORIG_ICMP_TYPE	(1UL << 13)
+#define CT_ATTR_ORIG_ICMP_CODE	(1UL << 14)
+#define CT_ATTR_ORIG_PACKETS	(1UL << 15)
+#define CT_ATTR_ORIG_BYTES	(1UL << 16)
+
+#define CT_ATTR_REPL_SRC	(1UL << 17)
+#define CT_ATTR_REPL_DST	(1UL << 18)
+#define CT_ATTR_REPL_SRC_PORT	(1UL << 19)
+#define CT_ATTR_REPL_DST_PORT	(1UL << 20)
+#define CT_ATTR_REPL_ICMP_ID	(1UL << 21)
+#define CT_ATTR_REPL_ICMP_TYPE	(1UL << 22)
+#define CT_ATTR_REPL_ICMP_CODE	(1UL << 23)
+#define CT_ATTR_REPL_PACKETS	(1UL << 24)
+#define CT_ATTR_REPL_BYTES	(1UL << 25)
+/** @endcond */
+
+static void ct_free_data(struct nl_object *c)
+{
+	struct nfnl_ct *ct = (struct nfnl_ct *) c;
+
+	if (ct == NULL)
+		return;
+
+	nl_addr_put(ct->ct_orig.src);
+	nl_addr_put(ct->ct_orig.dst);
+	nl_addr_put(ct->ct_repl.src);
+	nl_addr_put(ct->ct_repl.dst);
+}
+
+static int ct_clone(struct nl_object *_dst, struct nl_object *_src)
+{
+	struct nfnl_ct *dst = (struct nfnl_ct *) _dst;
+	struct nfnl_ct *src = (struct nfnl_ct *) _src;
+	struct nl_addr *addr;
+
+	if (src->ct_orig.src) {
+		addr = nl_addr_clone(src->ct_orig.src);
+		if (!addr)
+			return -NLE_NOMEM;
+		dst->ct_orig.src = addr;
+	}
+
+	if (src->ct_orig.dst) {
+		addr = nl_addr_clone(src->ct_orig.dst);
+		if (!addr)
+			return -NLE_NOMEM;
+		dst->ct_orig.dst = addr;
+	}
+
+	if (src->ct_repl.src) {
+		addr = nl_addr_clone(src->ct_repl.src);
+		if (!addr)
+			return -NLE_NOMEM;
+		dst->ct_repl.src = addr;
+	}
+
+	if (src->ct_repl.dst) {
+		addr = nl_addr_clone(src->ct_repl.dst);
+		if (!addr)
+			return -NLE_NOMEM;
+		dst->ct_repl.dst = addr;
+	}
+
+	return 0;
+}
+
+static void dump_addr(struct nl_dump_params *p, struct nl_addr *addr, int port)
+{
+	char buf[64];
+
+	if (addr)
+		nl_dump(p, "%s", nl_addr2str(addr, buf, sizeof(buf)));
+
+	if (port)
+		nl_dump(p, ":%u ", port);
+	else if (addr)
+		nl_dump(p, " ");
+}
+
+static void dump_icmp(struct nl_dump_params *p, struct nfnl_ct *ct, int reply)
+{
+	if (nfnl_ct_test_icmp_type(ct, reply))
+		nl_dump(p, "icmp type %d ", nfnl_ct_get_icmp_type(ct, reply));
+
+	if (nfnl_ct_test_icmp_type(ct, reply))
+		nl_dump(p, "code %d ", nfnl_ct_get_icmp_code(ct, reply));
+
+	if (nfnl_ct_test_icmp_type(ct, reply))
+		nl_dump(p, "id %d ", nfnl_ct_get_icmp_id(ct, reply));
+}
+
+static void ct_dump_tuples(struct nfnl_ct *ct, struct nl_dump_params *p)
+{
+	struct nl_addr *orig_src, *orig_dst, *reply_src, *reply_dst;
+	int orig_sport = 0, orig_dport = 0, reply_sport = 0, reply_dport = 0;
+	int sync = 0;
+
+	orig_src = nfnl_ct_get_src(ct, 0);
+	orig_dst = nfnl_ct_get_dst(ct, 0);
+	reply_src = nfnl_ct_get_src(ct, 1);
+	reply_dst = nfnl_ct_get_dst(ct, 1);
+
+	if (nfnl_ct_test_src_port(ct, 0))
+		orig_sport = nfnl_ct_get_src_port(ct, 0);
+
+	if (nfnl_ct_test_dst_port(ct, 0))
+		orig_dport = nfnl_ct_get_dst_port(ct, 0);
+
+	if (nfnl_ct_test_src_port(ct, 1))
+		reply_sport = nfnl_ct_get_src_port(ct, 1);
+
+	if (nfnl_ct_test_dst_port(ct, 1))
+		reply_dport = nfnl_ct_get_dst_port(ct, 1);
+
+	if (orig_src && orig_dst && reply_src && reply_dst &&
+	    orig_sport == reply_dport && orig_dport == reply_sport &&
+	    !nl_addr_cmp(orig_src, reply_dst) &&
+	    !nl_addr_cmp(orig_dst, reply_src))
+		sync = 1;
+
+	dump_addr(p, orig_src, orig_sport);
+	nl_dump(p, sync ? "<-> " : "-> ");
+	dump_addr(p, orig_dst, orig_dport);
+	dump_icmp(p, ct, 0);
+
+	if (!sync) {
+		dump_addr(p, reply_src, reply_sport);
+		nl_dump(p, "<- ");
+		dump_addr(p, reply_dst, reply_dport);
+		dump_icmp(p, ct, 1);
+	}
+}
+
+/* Compatible with /proc/net/nf_conntrack */
+static void ct_dump_line(struct nl_object *a, struct nl_dump_params *p)
+{
+	struct nfnl_ct *ct = (struct nfnl_ct *) a;
+	char buf[64];
+
+	nl_new_line(p);
+
+	if (nfnl_ct_test_proto(ct))
+		nl_dump(p, "%s ",
+		  nl_ip_proto2str(nfnl_ct_get_proto(ct), buf, sizeof(buf)));
+
+	if (nfnl_ct_test_tcp_state(ct))
+		nl_dump(p, "%s ",
+			nfnl_ct_tcp_state2str(nfnl_ct_get_tcp_state(ct),
+					      buf, sizeof(buf)));
+
+	ct_dump_tuples(ct, p);
+
+	if (nfnl_ct_test_mark(ct) && nfnl_ct_get_mark(ct))
+		nl_dump(p, "mark %u ", nfnl_ct_get_mark(ct));
+
+	nl_dump(p, "\n");
+}
+
+static void ct_dump_details(struct nl_object *a, struct nl_dump_params *p)
+{
+	struct nfnl_ct *ct = (struct nfnl_ct *) a;
+	char buf[64];
+	int fp = 0;
+
+	ct_dump_line(a, p);
+
+	nl_dump(p, "    id 0x%x ", ct->ct_id);
+	nl_dump_line(p, "family %s ",
+		nl_af2str(ct->ct_family, buf, sizeof(buf)));
+
+	if (nfnl_ct_test_use(ct))
+		nl_dump(p, "refcnt %u ", nfnl_ct_get_use(ct));
+
+	if (nfnl_ct_test_timeout(ct)) {
+		uint64_t timeout_ms = nfnl_ct_get_timeout(ct) * 1000UL;
+		nl_dump(p, "timeout %s ",
+			nl_msec2str(timeout_ms, buf, sizeof(buf)));
+	}
+
+	if (ct->ct_status)
+		nl_dump(p, "<");
+
+#define PRINT_FLAG(str) \
+	{ nl_dump(p, "%s%s", fp++ ? "," : "", (str)); }
+
+	if (ct->ct_status & IPS_EXPECTED)
+		PRINT_FLAG("EXPECTED");
+	if (!(ct->ct_status & IPS_SEEN_REPLY))
+		PRINT_FLAG("NOREPLY");
+	if (ct->ct_status & IPS_ASSURED)
+		PRINT_FLAG("ASSURED");
+	if (!(ct->ct_status & IPS_CONFIRMED))
+		PRINT_FLAG("NOTSENT");
+	if (ct->ct_status & IPS_SRC_NAT)
+		PRINT_FLAG("SNAT");
+	if (ct->ct_status & IPS_DST_NAT)
+		PRINT_FLAG("DNAT");
+	if (ct->ct_status & IPS_SEQ_ADJUST)
+		PRINT_FLAG("SEQADJUST");
+	if (!(ct->ct_status & IPS_SRC_NAT_DONE))
+		PRINT_FLAG("SNAT_INIT");
+	if (!(ct->ct_status & IPS_DST_NAT_DONE))
+		PRINT_FLAG("DNAT_INIT");
+	if (ct->ct_status & IPS_DYING)
+		PRINT_FLAG("DYING");
+	if (ct->ct_status & IPS_FIXED_TIMEOUT)
+		PRINT_FLAG("FIXED_TIMEOUT");
+#undef PRINT_FLAG
+
+	if (ct->ct_status)
+		nl_dump(p, ">");
+	nl_dump(p, "\n");
+}
+
+static void ct_dump_stats(struct nl_object *a, struct nl_dump_params *p)
+{
+	struct nfnl_ct *ct = (struct nfnl_ct *) a;
+	double res;
+	char *unit;
+
+	ct_dump_details(a, p);
+
+	nl_dump_line(p, "        # packets      volume\n");
+
+	res = nl_cancel_down_bytes(nfnl_ct_get_bytes(ct, 1), &unit);
+	nl_dump_line(p, "    rx %10llu %7.2f %s\n",
+		nfnl_ct_get_packets(ct, 1), res, unit);
+
+	res = nl_cancel_down_bytes(nfnl_ct_get_bytes(ct, 0), &unit);
+	nl_dump_line(p, "    tx %10llu %7.2f %s\n",
+		nfnl_ct_get_packets(ct, 0), res, unit);
+}
+
+static int ct_compare(struct nl_object *_a, struct nl_object *_b,
+			uint32_t attrs, int flags)
+{
+	struct nfnl_ct *a = (struct nfnl_ct *) _a;
+	struct nfnl_ct *b = (struct nfnl_ct *) _b;
+	int diff = 0;
+
+#define CT_DIFF(ATTR, EXPR) ATTR_DIFF(attrs, CT_ATTR_##ATTR, a, b, EXPR)
+#define CT_DIFF_VAL(ATTR, FIELD) CT_DIFF(ATTR, a->FIELD != b->FIELD)
+#define CT_DIFF_ADDR(ATTR, FIELD) \
+	((flags & LOOSE_COMPARISON) \
+		? CT_DIFF(ATTR, nl_addr_cmp_prefix(a->FIELD, b->FIELD)) \
+		: CT_DIFF(ATTR, nl_addr_cmp(a->FIELD, b->FIELD)))
+
+	diff |= CT_DIFF_VAL(FAMILY,		ct_family);
+	diff |= CT_DIFF_VAL(PROTO,		ct_proto);
+	diff |= CT_DIFF_VAL(TCP_STATE,		ct_protoinfo.tcp.state);
+	diff |= CT_DIFF_VAL(TIMEOUT,		ct_timeout);
+	diff |= CT_DIFF_VAL(MARK,		ct_mark);
+	diff |= CT_DIFF_VAL(USE,		ct_use);
+	diff |= CT_DIFF_VAL(ID,			ct_id);
+	diff |= CT_DIFF_ADDR(ORIG_SRC,		ct_orig.src);
+	diff |= CT_DIFF_ADDR(ORIG_DST,		ct_orig.dst);
+	diff |= CT_DIFF_VAL(ORIG_SRC_PORT,	ct_orig.proto.port.src);
+	diff |= CT_DIFF_VAL(ORIG_DST_PORT,	ct_orig.proto.port.dst);
+	diff |= CT_DIFF_VAL(ORIG_ICMP_ID,	ct_orig.proto.icmp.id);
+	diff |= CT_DIFF_VAL(ORIG_ICMP_TYPE,	ct_orig.proto.icmp.type);
+	diff |= CT_DIFF_VAL(ORIG_ICMP_CODE,	ct_orig.proto.icmp.code);
+	diff |= CT_DIFF_VAL(ORIG_PACKETS,	ct_orig.packets);
+	diff |= CT_DIFF_VAL(ORIG_BYTES,		ct_orig.bytes);
+	diff |= CT_DIFF_ADDR(REPL_SRC,		ct_repl.src);
+	diff |= CT_DIFF_ADDR(REPL_DST,		ct_repl.dst);
+	diff |= CT_DIFF_VAL(REPL_SRC_PORT,	ct_repl.proto.port.src);
+	diff |= CT_DIFF_VAL(REPL_DST_PORT,	ct_repl.proto.port.dst);
+	diff |= CT_DIFF_VAL(REPL_ICMP_ID,	ct_repl.proto.icmp.id);
+	diff |= CT_DIFF_VAL(REPL_ICMP_TYPE,	ct_repl.proto.icmp.type);
+	diff |= CT_DIFF_VAL(REPL_ICMP_CODE,	ct_repl.proto.icmp.code);
+	diff |= CT_DIFF_VAL(REPL_PACKETS,	ct_repl.packets);
+	diff |= CT_DIFF_VAL(REPL_BYTES,		ct_repl.bytes);
+
+	if (flags & LOOSE_COMPARISON)
+		diff |= CT_DIFF(STATUS, (a->ct_status ^ b->ct_status) &
+					b->ct_status_mask);
+	else
+		diff |= CT_DIFF(STATUS, a->ct_status != b->ct_status);
+
+#undef CT_DIFF
+#undef CT_DIFF_VAL
+#undef CT_DIFF_ADDR
+
+	return diff;
+}
+
+static struct trans_tbl ct_attrs[] = {
+	__ADD(CT_ATTR_FAMILY,		family)
+	__ADD(CT_ATTR_PROTO,		proto)
+	__ADD(CT_ATTR_TCP_STATE,	tcpstate)
+	__ADD(CT_ATTR_STATUS,		status)
+	__ADD(CT_ATTR_TIMEOUT,		timeout)
+	__ADD(CT_ATTR_MARK,		mark)
+	__ADD(CT_ATTR_USE,		use)
+	__ADD(CT_ATTR_ID,		id)
+	__ADD(CT_ATTR_ORIG_SRC,		origsrc)
+	__ADD(CT_ATTR_ORIG_DST,		origdst)
+	__ADD(CT_ATTR_ORIG_SRC_PORT,	origsrcport)
+	__ADD(CT_ATTR_ORIG_DST_PORT,	origdstport)
+	__ADD(CT_ATTR_ORIG_ICMP_ID,	origicmpid)
+	__ADD(CT_ATTR_ORIG_ICMP_TYPE,	origicmptype)
+	__ADD(CT_ATTR_ORIG_ICMP_CODE,	origicmpcode)
+	__ADD(CT_ATTR_ORIG_PACKETS,	origpackets)
+	__ADD(CT_ATTR_ORIG_BYTES,	origbytes)
+	__ADD(CT_ATTR_REPL_SRC,		replysrc)
+	__ADD(CT_ATTR_REPL_DST,		replydst)
+	__ADD(CT_ATTR_REPL_SRC_PORT,	replysrcport)
+	__ADD(CT_ATTR_REPL_DST_PORT,	replydstport)
+	__ADD(CT_ATTR_REPL_ICMP_ID,	replyicmpid)
+	__ADD(CT_ATTR_REPL_ICMP_TYPE,	replyicmptype)
+	__ADD(CT_ATTR_REPL_ICMP_CODE,	replyicmpcode)
+	__ADD(CT_ATTR_REPL_PACKETS,	replypackets)
+	__ADD(CT_ATTR_REPL_BYTES,	replybytes)
+};
+
+static char *ct_attrs2str(int attrs, char *buf, size_t len)
+{
+	return __flags2str(attrs, buf, len, ct_attrs, ARRAY_SIZE(ct_attrs));
+}
+
+/**
+ * @name Allocation/Freeing
+ * @{
+ */
+
+struct nfnl_ct *nfnl_ct_alloc(void)
+{
+	return (struct nfnl_ct *) nl_object_alloc(&ct_obj_ops);
+}
+
+void nfnl_ct_get(struct nfnl_ct *ct)
+{
+	nl_object_get((struct nl_object *) ct);
+}
+
+void nfnl_ct_put(struct nfnl_ct *ct)
+{
+	nl_object_put((struct nl_object *) ct);
+}
+
+/** @} */
+
+/**
+ * @name Attributes
+ * @{
+ */
+
+void nfnl_ct_set_family(struct nfnl_ct *ct, uint8_t family)
+{
+	ct->ct_family = family;
+	ct->ce_mask |= CT_ATTR_FAMILY;
+}
+
+uint8_t nfnl_ct_get_family(const struct nfnl_ct *ct)
+{
+	if (ct->ce_mask & CT_ATTR_FAMILY)
+		return ct->ct_family;
+	else
+		return AF_UNSPEC;
+}
+
+void nfnl_ct_set_proto(struct nfnl_ct *ct, uint8_t proto)
+{
+	ct->ct_proto = proto;
+	ct->ce_mask |= CT_ATTR_PROTO;
+}
+
+int nfnl_ct_test_proto(const struct nfnl_ct *ct)
+{
+	return !!(ct->ce_mask & CT_ATTR_PROTO);
+}
+
+uint8_t nfnl_ct_get_proto(const struct nfnl_ct *ct)
+{
+	return ct->ct_proto;
+}
+
+void nfnl_ct_set_tcp_state(struct nfnl_ct *ct, uint8_t state)
+{
+	ct->ct_protoinfo.tcp.state = state;
+	ct->ce_mask |= CT_ATTR_TCP_STATE;
+}
+
+int nfnl_ct_test_tcp_state(const struct nfnl_ct *ct)
+{
+	return !!(ct->ce_mask & CT_ATTR_TCP_STATE);
+}
+
+uint8_t nfnl_ct_get_tcp_state(const struct nfnl_ct *ct)
+{
+	return ct->ct_protoinfo.tcp.state;
+}
+
+static struct trans_tbl tcp_states[] = {
+	__ADD(TCP_CONNTRACK_NONE,NONE)
+	__ADD(TCP_CONNTRACK_SYN_SENT,SYN_SENT)
+	__ADD(TCP_CONNTRACK_SYN_RECV,SYN_RECV)
+	__ADD(TCP_CONNTRACK_ESTABLISHED,ESTABLISHED)
+	__ADD(TCP_CONNTRACK_FIN_WAIT,FIN_WAIT)
+	__ADD(TCP_CONNTRACK_CLOSE_WAIT,CLOSE_WAIT)
+	__ADD(TCP_CONNTRACK_LAST_ACK,LAST_ACK)
+	__ADD(TCP_CONNTRACK_TIME_WAIT,TIME_WAIT)
+	__ADD(TCP_CONNTRACK_CLOSE,CLOSE)
+	__ADD(TCP_CONNTRACK_LISTEN,LISTEN)
+};
+
+char *nfnl_ct_tcp_state2str(uint8_t state, char *buf, size_t len)
+{
+	return __type2str(state, buf, len, tcp_states, ARRAY_SIZE(tcp_states));
+}
+
+int nfnl_ct_str2tcp_state(const char *name)
+{
+        return __str2type(name, tcp_states, ARRAY_SIZE(tcp_states));
+}
+
+void nfnl_ct_set_status(struct nfnl_ct *ct, uint32_t status)
+{
+	ct->ct_status_mask |= status;
+	ct->ct_status |= status;
+	ct->ce_mask |= CT_ATTR_STATUS;
+}
+
+void nfnl_ct_unset_status(struct nfnl_ct *ct, uint32_t status)
+{
+	ct->ct_status_mask |= status;
+	ct->ct_status &= ~status;
+	ct->ce_mask |= CT_ATTR_STATUS;
+}
+
+uint32_t nfnl_ct_get_status(const struct nfnl_ct *ct)
+{
+	return ct->ct_status;
+}
+
+static struct trans_tbl status_flags[] = {
+	__ADD(IPS_EXPECTED, expected)
+	__ADD(IPS_SEEN_REPLY, seen_reply)
+	__ADD(IPS_ASSURED, assured)
+	__ADD(IPS_CONFIRMED, confirmed)
+	__ADD(IPS_SRC_NAT, snat)
+	__ADD(IPS_DST_NAT, dnat)
+	__ADD(IPS_SEQ_ADJUST, seqadjust)
+	__ADD(IPS_SRC_NAT_DONE, snat_done)
+	__ADD(IPS_DST_NAT_DONE, dnat_done)
+	__ADD(IPS_DYING, dying)
+	__ADD(IPS_FIXED_TIMEOUT, fixed_timeout)
+};
+
+char * nfnl_ct_status2str(int flags, char *buf, size_t len)
+{
+	return __flags2str(flags, buf, len, status_flags,
+			   ARRAY_SIZE(status_flags));
+}
+
+int nfnl_ct_str2status(const char *name)
+{
+	return __str2flags(name, status_flags, ARRAY_SIZE(status_flags));
+}
+
+void nfnl_ct_set_timeout(struct nfnl_ct *ct, uint32_t timeout)
+{
+	ct->ct_timeout = timeout;
+	ct->ce_mask |= CT_ATTR_TIMEOUT;
+}
+
+int nfnl_ct_test_timeout(const struct nfnl_ct *ct)
+{
+	return !!(ct->ce_mask & CT_ATTR_TIMEOUT);
+}
+
+uint32_t nfnl_ct_get_timeout(const struct nfnl_ct *ct)
+{
+	return ct->ct_timeout;
+}
+
+void nfnl_ct_set_mark(struct nfnl_ct *ct, uint32_t mark)
+{
+	ct->ct_mark = mark;
+	ct->ce_mask |= CT_ATTR_MARK;
+}
+
+int nfnl_ct_test_mark(const struct nfnl_ct *ct)
+{
+	return !!(ct->ce_mask & CT_ATTR_MARK);
+}
+
+uint32_t nfnl_ct_get_mark(const struct nfnl_ct *ct)
+{
+	return ct->ct_mark;
+}
+
+void nfnl_ct_set_use(struct nfnl_ct *ct, uint32_t use)
+{
+	ct->ct_use = use;
+	ct->ce_mask |= CT_ATTR_USE;
+}
+
+int nfnl_ct_test_use(const struct nfnl_ct *ct)
+{
+	return !!(ct->ce_mask & CT_ATTR_USE);
+}
+
+uint32_t nfnl_ct_get_use(const struct nfnl_ct *ct)
+{
+	return ct->ct_use;
+}
+
+void nfnl_ct_set_id(struct nfnl_ct *ct, uint32_t id)
+{
+	ct->ct_id = id;
+	ct->ce_mask |= CT_ATTR_ID;
+}
+
+int nfnl_ct_test_id(const struct nfnl_ct *ct)
+{
+	return !!(ct->ce_mask & CT_ATTR_ID);
+}
+
+uint32_t nfnl_ct_get_id(const struct nfnl_ct *ct)
+{
+	return ct->ct_id;
+}
+
+static int ct_set_addr(struct nfnl_ct *ct, struct nl_addr *addr,
+		int attr, struct nl_addr ** ct_addr)
+{
+	if (ct->ce_mask & CT_ATTR_FAMILY) {
+		if (addr->a_family != ct->ct_family)
+			return -NLE_AF_MISMATCH;
+	} else
+		nfnl_ct_set_family(ct, addr->a_family);
+
+	if (*ct_addr)
+		nl_addr_put(*ct_addr);
+
+	nl_addr_get(addr);
+	*ct_addr = addr;
+	ct->ce_mask |= attr;
+
+	return 0;
+}
+
+int nfnl_ct_set_src(struct nfnl_ct *ct, int repl, struct nl_addr *addr)
+{
+	struct nfnl_ct_dir *dir = repl ? &ct->ct_repl : &ct->ct_orig;
+	int attr = repl ? CT_ATTR_REPL_SRC : CT_ATTR_ORIG_SRC;
+	return ct_set_addr(ct, addr, attr, &dir->src);
+}
+
+int nfnl_ct_set_dst(struct nfnl_ct *ct, int repl, struct nl_addr *addr)
+{
+	struct nfnl_ct_dir *dir = repl ? &ct->ct_repl : &ct->ct_orig;
+	int attr = repl ? CT_ATTR_REPL_DST : CT_ATTR_ORIG_DST;
+	return ct_set_addr(ct, addr, attr, &dir->dst);
+}
+
+struct nl_addr *nfnl_ct_get_src(const struct nfnl_ct *ct, int repl)
+{
+	const struct nfnl_ct_dir *dir = repl ? &ct->ct_repl : &ct->ct_orig;
+	int attr = repl ? CT_ATTR_REPL_SRC : CT_ATTR_ORIG_SRC;
+	if (!(ct->ce_mask & attr))
+		return NULL;
+	return dir->src;
+}
+
+struct nl_addr *nfnl_ct_get_dst(const struct nfnl_ct *ct, int repl)
+{
+	const struct nfnl_ct_dir *dir = repl ? &ct->ct_repl : &ct->ct_orig;
+	int attr = repl ? CT_ATTR_REPL_DST : CT_ATTR_ORIG_DST;
+	if (!(ct->ce_mask & attr))
+		return NULL;
+	return dir->dst;
+}
+
+void nfnl_ct_set_src_port(struct nfnl_ct *ct, int repl, uint16_t port)
+{
+	struct nfnl_ct_dir *dir = repl ? &ct->ct_repl : &ct->ct_orig;
+	int attr = repl ? CT_ATTR_REPL_SRC_PORT : CT_ATTR_ORIG_SRC_PORT;
+
+	dir->proto.port.src = port;
+	ct->ce_mask |= attr;
+}
+
+int nfnl_ct_test_src_port(const struct nfnl_ct *ct, int repl)
+{
+	int attr = repl ? CT_ATTR_REPL_SRC_PORT : CT_ATTR_ORIG_SRC_PORT;
+	return !!(ct->ce_mask & attr);
+}
+
+uint16_t nfnl_ct_get_src_port(const struct nfnl_ct *ct, int repl)
+{
+	const struct nfnl_ct_dir *dir = repl ? &ct->ct_repl : &ct->ct_orig;
+
+	return dir->proto.port.src;
+}
+
+void nfnl_ct_set_dst_port(struct nfnl_ct *ct, int repl, uint16_t port)
+{
+	struct nfnl_ct_dir *dir = repl ? &ct->ct_repl : &ct->ct_orig;
+	int attr = repl ? CT_ATTR_REPL_DST_PORT : CT_ATTR_ORIG_DST_PORT;
+
+	dir->proto.port.dst = port;
+	ct->ce_mask |= attr;
+}
+
+int nfnl_ct_test_dst_port(const struct nfnl_ct *ct, int repl)
+{
+	int attr = repl ? CT_ATTR_REPL_DST_PORT : CT_ATTR_ORIG_DST_PORT;
+	return !!(ct->ce_mask & attr);
+}
+
+uint16_t nfnl_ct_get_dst_port(const struct nfnl_ct *ct, int repl)
+{
+	const struct nfnl_ct_dir *dir = repl ? &ct->ct_repl : &ct->ct_orig;
+
+	return dir->proto.port.dst;
+}
+
+void nfnl_ct_set_icmp_id(struct nfnl_ct *ct, int repl, uint16_t id)
+{
+	struct nfnl_ct_dir *dir = repl ? &ct->ct_repl : &ct->ct_orig;
+	int attr = repl ? CT_ATTR_REPL_ICMP_ID : CT_ATTR_ORIG_ICMP_ID;
+
+	dir->proto.icmp.id = id;
+	ct->ce_mask |= attr;
+}
+
+int nfnl_ct_test_icmp_id(const struct nfnl_ct *ct, int repl)
+{
+	int attr = repl ? CT_ATTR_REPL_ICMP_ID : CT_ATTR_ORIG_ICMP_ID;
+	return !!(ct->ce_mask & attr);
+}
+
+uint16_t nfnl_ct_get_icmp_id(const struct nfnl_ct *ct, int repl)
+{
+	const struct nfnl_ct_dir *dir = repl ? &ct->ct_repl : &ct->ct_orig;
+
+	return dir->proto.icmp.id;
+}
+
+void nfnl_ct_set_icmp_type(struct nfnl_ct *ct, int repl, uint8_t type)
+{
+	struct nfnl_ct_dir *dir = repl ? &ct->ct_repl : &ct->ct_orig;
+	int attr = repl ? CT_ATTR_REPL_ICMP_TYPE : CT_ATTR_ORIG_ICMP_TYPE;
+
+	dir->proto.icmp.type = type;
+	ct->ce_mask |= attr;
+}
+
+int nfnl_ct_test_icmp_type(const struct nfnl_ct *ct, int repl)
+{
+	int attr = repl ? CT_ATTR_REPL_ICMP_TYPE : CT_ATTR_ORIG_ICMP_TYPE;
+	return !!(ct->ce_mask & attr);
+}
+
+uint8_t nfnl_ct_get_icmp_type(const struct nfnl_ct *ct, int repl)
+{
+	const struct nfnl_ct_dir *dir = repl ? &ct->ct_repl : &ct->ct_orig;
+
+	return dir->proto.icmp.type;
+}
+
+void nfnl_ct_set_icmp_code(struct nfnl_ct *ct, int repl, uint8_t code)
+{
+	struct nfnl_ct_dir *dir = repl ? &ct->ct_repl : &ct->ct_orig;
+	int attr = repl ? CT_ATTR_REPL_ICMP_CODE : CT_ATTR_ORIG_ICMP_CODE;
+
+	dir->proto.icmp.code = code;
+	ct->ce_mask |= attr;
+}
+
+int nfnl_ct_test_icmp_code(const struct nfnl_ct *ct, int repl)
+{
+	int attr = repl ? CT_ATTR_REPL_ICMP_CODE : CT_ATTR_ORIG_ICMP_CODE;
+	return !!(ct->ce_mask & attr);
+}
+
+uint8_t nfnl_ct_get_icmp_code(const struct nfnl_ct *ct, int repl)
+{
+	const struct nfnl_ct_dir *dir = repl ? &ct->ct_repl : &ct->ct_orig;
+
+	return dir->proto.icmp.code;
+}
+
+void nfnl_ct_set_packets(struct nfnl_ct *ct, int repl, uint64_t packets)
+{
+	struct nfnl_ct_dir *dir = repl ? &ct->ct_repl : &ct->ct_orig;
+	int attr = repl ? CT_ATTR_REPL_PACKETS : CT_ATTR_ORIG_PACKETS;
+
+	dir->packets = packets;
+	ct->ce_mask |= attr;
+}
+
+int nfnl_ct_test_packets(const struct nfnl_ct *ct, int repl)
+{
+	int attr = repl ? CT_ATTR_REPL_PACKETS : CT_ATTR_ORIG_PACKETS;
+	return !!(ct->ce_mask & attr);
+}
+
+uint64_t nfnl_ct_get_packets(const struct nfnl_ct *ct, int repl)
+{
+	const struct nfnl_ct_dir *dir = repl ? &ct->ct_repl : &ct->ct_orig;
+
+	return dir->packets;
+}
+
+void nfnl_ct_set_bytes(struct nfnl_ct *ct, int repl, uint64_t bytes)
+{
+	struct nfnl_ct_dir *dir = repl ? &ct->ct_repl : &ct->ct_orig;
+	int attr = repl ? CT_ATTR_REPL_BYTES : CT_ATTR_ORIG_BYTES;
+
+	dir->bytes = bytes;
+	ct->ce_mask |= attr;
+}
+
+int nfnl_ct_test_bytes(const struct nfnl_ct *ct, int repl)
+{
+	int attr = repl ? CT_ATTR_REPL_BYTES : CT_ATTR_ORIG_BYTES;
+	return !!(ct->ce_mask & attr);
+}
+
+uint64_t nfnl_ct_get_bytes(const struct nfnl_ct *ct, int repl)
+{
+	const struct nfnl_ct_dir *dir = repl ? &ct->ct_repl : &ct->ct_orig;
+
+	return dir->bytes;
+}
+
+/** @} */
+
+struct nl_object_ops ct_obj_ops = {
+	.oo_name		= "netfilter/ct",
+	.oo_size		= sizeof(struct nfnl_ct),
+	.oo_free_data		= ct_free_data,
+	.oo_clone		= ct_clone,
+	.oo_dump = {
+	    [NL_DUMP_LINE]	= ct_dump_line,
+	    [NL_DUMP_DETAILS]	= ct_dump_details,
+	    [NL_DUMP_STATS]	= ct_dump_stats,
+	},
+	.oo_compare		= ct_compare,
+	.oo_attrs2str		= ct_attrs2str,
+};
+
+/** @} */
diff -uNr libnl_kk/lib/netfilter/log.c libnl/lib/netfilter/log.c
--- libnl_kk/lib/netfilter/log.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/netfilter/log.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,251 @@
+/*
+ * lib/netfilter/log.c	Netfilter Log
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ * Copyright (c) 2007 Philip Craig <philipc@snapgear.com>
+ * Copyright (c) 2007 Secure Computing Corporation
+ */
+
+/**
+ * @ingroup nfnl
+ * @defgroup log Log
+ * @brief
+ * @{
+ */
+
+#include <sys/types.h>
+#include <linux/netfilter/nfnetlink_log.h>
+
+#include <netlink-local.h>
+#include <netlink/attr.h>
+#include <netlink/netfilter/nfnl.h>
+#include <netlink/netfilter/log.h>
+
+/**
+ * @name Log Commands
+ * @{
+ */
+
+static int build_log_cmd_request(uint8_t family, uint16_t queuenum,
+				 uint8_t command, struct nl_msg **result)
+{
+	struct nl_msg *msg;
+	struct nfulnl_msg_config_cmd cmd;
+
+	msg = nfnlmsg_alloc_simple(NFNL_SUBSYS_ULOG, NFULNL_MSG_CONFIG, 0,
+				   family, queuenum);
+	if (msg == NULL)
+		return -NLE_NOMEM;
+
+	cmd.command = command;
+	if (nla_put(msg, NFULA_CFG_CMD, sizeof(cmd), &cmd) < 0)
+		goto nla_put_failure;
+
+	*result = msg;
+	return 0;
+
+nla_put_failure:
+	nlmsg_free(msg);
+	return -NLE_MSGSIZE;
+}
+
+static int send_log_request(struct nl_sock *sk, struct nl_msg *msg)
+{
+	int err;
+
+	err = nl_send_auto_complete(sk, msg);
+	nlmsg_free(msg);
+	if (err < 0)
+		return err;
+
+	return wait_for_ack(sk);
+}
+
+int nfnl_log_build_pf_bind(uint8_t pf, struct nl_msg **result)
+{
+	return build_log_cmd_request(pf, 0, NFULNL_CFG_CMD_PF_BIND, result);
+}
+
+int nfnl_log_pf_bind(struct nl_sock *nlh, uint8_t pf)
+{
+	struct nl_msg *msg;
+	int err;
+
+	if ((err = nfnl_log_build_pf_bind(pf, &msg)) < 0)
+		return err;
+
+	return send_log_request(nlh, msg);
+}
+
+int nfnl_log_build_pf_unbind(uint8_t pf, struct nl_msg **result)
+{
+	return build_log_cmd_request(pf, 0, NFULNL_CFG_CMD_PF_UNBIND, result);
+}
+
+int nfnl_log_pf_unbind(struct nl_sock *nlh, uint8_t pf)
+{
+	struct nl_msg *msg;
+	int err;
+
+	if ((err = nfnl_log_build_pf_unbind(pf, &msg)) < 0)
+		return err;
+
+	return send_log_request(nlh, msg);
+}
+
+static int nfnl_log_build_request(const struct nfnl_log *log,
+				  struct nl_msg **result)
+{
+	struct nl_msg *msg;
+
+	if (!nfnl_log_test_group(log))
+		return -NLE_MISSING_ATTR;
+
+	msg = nfnlmsg_alloc_simple(NFNL_SUBSYS_ULOG, NFULNL_MSG_CONFIG, 0,
+				   0, nfnl_log_get_group(log));
+	if (msg == NULL)
+		return -NLE_NOMEM;
+
+	/* This sucks. The nfnetlink_log interface always expects both
+	 * parameters to be present. Needs to be done properly.
+	 */
+	if (nfnl_log_test_copy_mode(log)) {
+		struct nfulnl_msg_config_mode mode;
+
+		switch (nfnl_log_get_copy_mode(log)) {
+		case NFNL_LOG_COPY_NONE:
+			mode.copy_mode = NFULNL_COPY_NONE;
+			break;
+		case NFNL_LOG_COPY_META:
+			mode.copy_mode = NFULNL_COPY_META;
+			break;
+		case NFNL_LOG_COPY_PACKET:
+			mode.copy_mode = NFULNL_COPY_PACKET;
+			break;
+		}
+		mode.copy_range = htonl(nfnl_log_get_copy_range(log));
+		mode._pad = 0;
+
+		if (nla_put(msg, NFULA_CFG_MODE, sizeof(mode), &mode) < 0)
+			goto nla_put_failure;
+	}
+
+	if (nfnl_log_test_flush_timeout(log) &&
+	    nla_put_u32(msg, NFULA_CFG_TIMEOUT,
+			htonl(nfnl_log_get_flush_timeout(log))) < 0)
+		goto nla_put_failure;
+
+	if (nfnl_log_test_alloc_size(log) &&
+	    nla_put_u32(msg, NFULA_CFG_NLBUFSIZ,
+			htonl(nfnl_log_get_alloc_size(log))) < 0)
+		goto nla_put_failure;
+
+	if (nfnl_log_test_queue_threshold(log) &&
+	    nla_put_u32(msg, NFULA_CFG_QTHRESH,
+			htonl(nfnl_log_get_queue_threshold(log))) < 0)
+		goto nla_put_failure;
+
+	*result = msg;
+	return 0;
+
+nla_put_failure:
+	nlmsg_free(msg);
+	return -NLE_MSGSIZE;
+}
+
+int nfnl_log_build_create_request(const struct nfnl_log *log,
+				  struct nl_msg **result)
+{
+	struct nfulnl_msg_config_cmd cmd;
+	int err;
+
+	if ((err = nfnl_log_build_request(log, result)) < 0)
+		return err;
+
+	cmd.command = NFULNL_CFG_CMD_BIND;
+
+	if (nla_put(*result, NFULA_CFG_CMD, sizeof(cmd), &cmd) < 0)
+		goto nla_put_failure;
+
+	return 0;
+
+nla_put_failure:
+	nlmsg_free(*result);
+	return -NLE_MSGSIZE;
+}
+
+int nfnl_log_create(struct nl_sock *nlh, const struct nfnl_log *log)
+{
+	struct nl_msg *msg;
+	int err;
+
+	if ((err = nfnl_log_build_create_request(log, &msg)) < 0)
+		return err;
+
+	return send_log_request(nlh, msg);
+}
+
+int nfnl_log_build_change_request(const struct nfnl_log *log,
+				  struct nl_msg **result)
+{
+	return nfnl_log_build_request(log, result);
+}
+
+int nfnl_log_change(struct nl_sock *nlh, const struct nfnl_log *log)
+{
+	struct nl_msg *msg;
+	int err;
+
+	if ((err = nfnl_log_build_change_request(log, &msg)) < 0)
+		return err;
+
+	return send_log_request(nlh, msg);
+}
+
+int nfnl_log_build_delete_request(const struct nfnl_log *log,
+				  struct nl_msg **result)
+{
+	if (!nfnl_log_test_group(log))
+		return -NLE_MISSING_ATTR;
+
+	return build_log_cmd_request(0, nfnl_log_get_group(log),
+				     NFULNL_CFG_CMD_UNBIND, result);
+}
+
+int nfnl_log_delete(struct nl_sock *nlh, const struct nfnl_log *log)
+{
+	struct nl_msg *msg;
+	int err;
+
+	if ((err = nfnl_log_build_delete_request(log, &msg)) < 0)
+		return err;
+
+	return send_log_request(nlh, msg);
+}
+
+/** @} */
+
+static struct nl_cache_ops nfnl_log_ops = {
+	.co_name		= "netfilter/log",
+	.co_obj_ops		= &log_obj_ops,
+	.co_msgtypes		= {
+		END_OF_MSGTYPES_LIST,
+	},
+};
+
+static void __init log_init(void)
+{
+	nl_cache_mngt_register(&nfnl_log_ops);
+}
+
+static void __exit log_exit(void)
+{
+	nl_cache_mngt_unregister(&nfnl_log_ops);
+}
+
+/** @} */
diff -uNr libnl_kk/lib/netfilter/log_msg.c libnl/lib/netfilter/log_msg.c
--- libnl_kk/lib/netfilter/log_msg.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/netfilter/log_msg.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,209 @@
+/*
+ * lib/netfilter/log_msg.c	Netfilter Log Message
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ * Copyright (c) 2007 Philip Craig <philipc@snapgear.com>
+ * Copyright (c) 2007 Secure Computing Corporation
+ * Copyright (c) 2008 Patrick McHardy <kaber@trash.net>
+ */
+
+/**
+ * @ingroup nfnl
+ * @defgroup log Log
+ * @brief
+ * @{
+ */
+
+#include <sys/types.h>
+#include <linux/netfilter/nfnetlink_log.h>
+
+#include <netlink-local.h>
+#include <netlink/attr.h>
+#include <netlink/netfilter/nfnl.h>
+#include <netlink/netfilter/log_msg.h>
+
+#if __BYTE_ORDER == __BIG_ENDIAN
+static uint64_t ntohll(uint64_t x)
+{
+	return x;
+}
+#elif __BYTE_ORDER == __LITTLE_ENDIAN
+static uint64_t ntohll(uint64_t x)
+{
+	return __bswap_64(x);
+}
+#endif
+
+static struct nla_policy log_msg_policy[NFULA_MAX+1] = {
+	[NFULA_PACKET_HDR]		= {
+		.minlen = sizeof(struct nfulnl_msg_packet_hdr)
+	},
+	[NFULA_MARK]			= { .type = NLA_U32 },
+	[NFULA_TIMESTAMP]		= {
+		.minlen = sizeof(struct nfulnl_msg_packet_timestamp)
+	},
+	[NFULA_IFINDEX_INDEV]		= { .type = NLA_U32 },
+	[NFULA_IFINDEX_OUTDEV]		= { .type = NLA_U32 },
+	[NFULA_IFINDEX_PHYSINDEV]	= { .type = NLA_U32 },
+	[NFULA_IFINDEX_PHYSOUTDEV]	= { .type = NLA_U32 },
+	[NFULA_HWADDR]			= {
+		.minlen = sizeof(struct nfulnl_msg_packet_hw)
+	},
+	//[NFULA_PAYLOAD]
+	[NFULA_PREFIX]			= { .type = NLA_STRING, },
+	[NFULA_UID]			= { .type = NLA_U32 },
+	[NFULA_GID]			= { .type = NLA_U32 },
+	[NFULA_SEQ]			= { .type = NLA_U32 },
+	[NFULA_SEQ_GLOBAL]		= { .type = NLA_U32 },
+};
+
+int nfnlmsg_log_msg_parse(struct nlmsghdr *nlh, struct nfnl_log_msg **result)
+{
+	struct nfnl_log_msg *msg;
+	struct nlattr *tb[NFULA_MAX+1];
+	struct nlattr *attr;
+	int err;
+
+	msg = nfnl_log_msg_alloc();
+	if (!msg)
+		return -NLE_NOMEM;
+
+	msg->ce_msgtype = nlh->nlmsg_type;
+
+	err = nlmsg_parse(nlh, sizeof(struct nfgenmsg), tb, NFULA_MAX,
+			  log_msg_policy);
+	if (err < 0)
+		goto errout;
+
+	nfnl_log_msg_set_family(msg, nfnlmsg_family(nlh));
+
+	attr = tb[NFULA_PACKET_HDR];
+	if (attr) {
+		struct nfulnl_msg_packet_hdr *hdr = nla_data(attr);
+
+		if (hdr->hw_protocol)
+			nfnl_log_msg_set_hwproto(msg, hdr->hw_protocol);
+		nfnl_log_msg_set_hook(msg, hdr->hook);
+	}
+
+	attr = tb[NFULA_MARK];
+	if (attr)
+		nfnl_log_msg_set_mark(msg, ntohl(nla_get_u32(attr)));
+
+	attr = tb[NFULA_TIMESTAMP];
+	if (attr) {
+		struct nfulnl_msg_packet_timestamp *timestamp = nla_data(attr);
+		struct timeval tv;
+
+		tv.tv_sec = ntohll(timestamp->sec);
+		tv.tv_usec = ntohll(timestamp->usec);
+		nfnl_log_msg_set_timestamp(msg, &tv);
+	}
+
+	attr = tb[NFULA_IFINDEX_INDEV];
+	if (attr)
+		nfnl_log_msg_set_indev(msg, ntohl(nla_get_u32(attr)));
+
+	attr = tb[NFULA_IFINDEX_OUTDEV];
+	if (attr)
+		nfnl_log_msg_set_outdev(msg, ntohl(nla_get_u32(attr)));
+
+	attr = tb[NFULA_IFINDEX_PHYSINDEV];
+	if (attr)
+		nfnl_log_msg_set_physindev(msg, ntohl(nla_get_u32(attr)));
+
+	attr = tb[NFULA_IFINDEX_PHYSOUTDEV];
+	if (attr)
+		nfnl_log_msg_set_physoutdev(msg, ntohl(nla_get_u32(attr)));
+
+	attr = tb[NFULA_HWADDR];
+	if (attr) {
+		struct nfulnl_msg_packet_hw *hw = nla_data(attr);
+
+		nfnl_log_msg_set_hwaddr(msg, hw->hw_addr, ntohs(hw->hw_addrlen));
+	}
+
+	attr = tb[NFULA_PAYLOAD];
+	if (attr) {
+		err = nfnl_log_msg_set_payload(msg, nla_data(attr), nla_len(attr));
+		if (err < 0)
+			goto errout;
+	}
+
+	attr = tb[NFULA_PREFIX];
+	if (attr) {
+		err = nfnl_log_msg_set_prefix(msg, nla_data(attr));
+		if (err < 0)
+			goto errout;
+	}
+
+	attr = tb[NFULA_UID];
+	if (attr)
+		nfnl_log_msg_set_uid(msg, ntohl(nla_get_u32(attr)));
+
+	attr = tb[NFULA_GID];
+	if (attr)
+		nfnl_log_msg_set_gid(msg, ntohl(nla_get_u32(attr)));
+
+	attr = tb[NFULA_SEQ];
+	if (attr)
+		nfnl_log_msg_set_seq(msg, ntohl(nla_get_u32(attr)));
+
+	attr = tb[NFULA_SEQ_GLOBAL];
+	if (attr)
+		nfnl_log_msg_set_seq_global(msg, ntohl(nla_get_u32(attr)));
+
+	*result = msg;
+	return 0;
+
+errout:
+	nfnl_log_msg_put(msg);
+	return err;
+}
+
+static int log_msg_parser(struct nl_cache_ops *ops, struct sockaddr_nl *who,
+			  struct nlmsghdr *nlh, struct nl_parser_param *pp)
+{
+	struct nfnl_log_msg *msg;
+	int err;
+
+	if ((err = nfnlmsg_log_msg_parse(nlh, &msg)) < 0)
+		goto errout;
+
+	err = pp->pp_cb((struct nl_object *) msg, pp);
+errout:
+	nfnl_log_msg_put(msg);
+	return err;
+}
+
+/** @} */
+
+#define NFNLMSG_LOG_TYPE(type) NFNLMSG_TYPE(NFNL_SUBSYS_ULOG, (type))
+static struct nl_cache_ops nfnl_log_msg_ops = {
+	.co_name		= "netfilter/log_msg",
+	.co_hdrsize		= NFNL_HDRLEN,
+	.co_msgtypes		= {
+		{ NFNLMSG_LOG_TYPE(NFULNL_MSG_PACKET), NL_ACT_NEW, "new" },
+		END_OF_MSGTYPES_LIST,
+	},
+	.co_protocol		= NETLINK_NETFILTER,
+	.co_msg_parser		= log_msg_parser,
+	.co_obj_ops		= &log_msg_obj_ops,
+};
+
+static void __init log_msg_init(void)
+{
+	nl_cache_mngt_register(&nfnl_log_msg_ops);
+}
+
+static void __exit log_msg_exit(void)
+{
+	nl_cache_mngt_unregister(&nfnl_log_msg_ops);
+}
+
+/** @} */
diff -uNr libnl_kk/lib/netfilter/log_msg_obj.c libnl/lib/netfilter/log_msg_obj.c
--- libnl_kk/lib/netfilter/log_msg_obj.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/netfilter/log_msg_obj.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,458 @@
+/*
+ * lib/netfilter/log_msg_obj.c	Netfilter Log Object
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ * Copyright (c) 2007 Philip Craig <philipc@snapgear.com>
+ * Copyright (c) 2007 Secure Computing Corporation
+ */
+
+#include <netlink-local.h>
+#include <netlink/netfilter/nfnl.h>
+#include <netlink/netfilter/netfilter.h>
+#include <netlink/netfilter/log_msg.h>
+
+/** @cond SKIP */
+#define LOG_MSG_ATTR_FAMILY		(1UL << 0)
+#define LOG_MSG_ATTR_HWPROTO		(1UL << 1)
+#define LOG_MSG_ATTR_HOOK		(1UL << 2)
+#define LOG_MSG_ATTR_MARK		(1UL << 3)
+#define LOG_MSG_ATTR_TIMESTAMP		(1UL << 4)
+#define LOG_MSG_ATTR_INDEV		(1UL << 5)
+#define LOG_MSG_ATTR_OUTDEV		(1UL << 6)
+#define LOG_MSG_ATTR_PHYSINDEV		(1UL << 7)
+#define LOG_MSG_ATTR_PHYSOUTDEV		(1UL << 8)
+#define LOG_MSG_ATTR_HWADDR		(1UL << 9)
+#define LOG_MSG_ATTR_PAYLOAD		(1UL << 10)
+#define LOG_MSG_ATTR_PREFIX		(1UL << 11)
+#define LOG_MSG_ATTR_UID		(1UL << 12)
+#define LOG_MSG_ATTR_GID		(1UL << 13)
+#define LOG_MSG_ATTR_SEQ		(1UL << 14)
+#define LOG_MSG_ATTR_SEQ_GLOBAL		(1UL << 15)
+/** @endcond */
+
+static void log_msg_free_data(struct nl_object *c)
+{
+	struct nfnl_log_msg *msg = (struct nfnl_log_msg *) c;
+
+	if (msg == NULL)
+		return;
+
+	free(msg->log_msg_payload);
+	free(msg->log_msg_prefix);
+}
+
+static int log_msg_clone(struct nl_object *_dst, struct nl_object *_src)
+{
+	struct nfnl_log_msg *dst = (struct nfnl_log_msg *) _dst;
+	struct nfnl_log_msg *src = (struct nfnl_log_msg *) _src;
+	int err;
+
+	if (src->log_msg_payload) {
+		err = nfnl_log_msg_set_payload(dst, src->log_msg_payload,
+					       src->log_msg_payload_len);
+		if (err < 0)
+			goto errout;
+	}
+
+	if (src->log_msg_prefix) {
+		err = nfnl_log_msg_set_prefix(dst, src->log_msg_prefix);
+		if (err < 0)
+			goto errout;
+	}
+
+	return 0;
+errout:
+	return err;
+}
+
+static void log_msg_dump(struct nl_object *a, struct nl_dump_params *p)
+{
+	struct nfnl_log_msg *msg = (struct nfnl_log_msg *) a;
+	struct nl_cache *link_cache;
+	char buf[64];
+
+	link_cache = nl_cache_mngt_require("route/link");
+
+	nl_new_line(p);
+
+	if (msg->ce_mask & LOG_MSG_ATTR_PREFIX)
+		nl_dump(p, "%s", msg->log_msg_prefix);
+
+	if (msg->ce_mask & LOG_MSG_ATTR_INDEV) {
+		if (link_cache)
+			nl_dump(p, "IN=%s ",
+				rtnl_link_i2name(link_cache,
+						 msg->log_msg_indev,
+						 buf, sizeof(buf)));
+		else
+			nl_dump(p, "IN=%d ", msg->log_msg_indev);
+	}
+
+	if (msg->ce_mask & LOG_MSG_ATTR_PHYSINDEV) {
+		if (link_cache)
+			nl_dump(p, "PHYSIN=%s ",
+				rtnl_link_i2name(link_cache,
+						 msg->log_msg_physindev,
+						 buf, sizeof(buf)));
+		else
+			nl_dump(p, "IN=%d ", msg->log_msg_physindev);
+	}
+
+	if (msg->ce_mask & LOG_MSG_ATTR_OUTDEV) {
+		if (link_cache)
+			nl_dump(p, "OUT=%s ",
+				rtnl_link_i2name(link_cache,
+						 msg->log_msg_outdev,
+						 buf, sizeof(buf)));
+		else
+			nl_dump(p, "OUT=%d ", msg->log_msg_outdev);
+	}
+
+	if (msg->ce_mask & LOG_MSG_ATTR_PHYSOUTDEV) {
+		if (link_cache)
+			nl_dump(p, "PHYSOUT=%s ",
+				rtnl_link_i2name(link_cache,
+						 msg->log_msg_physoutdev,
+						 buf, sizeof(buf)));
+		else
+			nl_dump(p, "PHYSOUT=%d ", msg->log_msg_physoutdev);
+	}
+
+	if (msg->ce_mask & LOG_MSG_ATTR_HWADDR) {
+		int i;
+
+		nl_dump(p, "MAC");
+		for (i = 0; i < msg->log_msg_hwaddr_len; i++)
+			nl_dump(p, "%c%02x", i?':':'=', msg->log_msg_hwaddr[i]);
+		nl_dump(p, " ");
+	}
+
+	/* FIXME: parse the payload to get iptables LOG compatible format */
+
+	if (msg->ce_mask & LOG_MSG_ATTR_FAMILY)
+		nl_dump(p, "FAMILY=%s ",
+			nl_af2str(msg->log_msg_family, buf, sizeof(buf)));
+
+	if (msg->ce_mask & LOG_MSG_ATTR_HWPROTO)
+		nl_dump(p, "HWPROTO=%s ",
+			nl_ether_proto2str(ntohs(msg->log_msg_hwproto),
+					   buf, sizeof(buf)));
+
+	if (msg->ce_mask & LOG_MSG_ATTR_HOOK)
+		nl_dump(p, "HOOK=%s ",
+			nfnl_inet_hook2str(msg->log_msg_hook,
+					   buf, sizeof(buf)));
+
+	if (msg->ce_mask & LOG_MSG_ATTR_MARK)
+		nl_dump(p, "MARK=%u ", msg->log_msg_mark);
+
+	if (msg->ce_mask & LOG_MSG_ATTR_PAYLOAD)
+		nl_dump(p, "PAYLOADLEN=%d ", msg->log_msg_payload_len);
+
+	if (msg->ce_mask & LOG_MSG_ATTR_UID)
+		nl_dump(p, "UID=%u ", msg->log_msg_uid);
+
+	if (msg->ce_mask & LOG_MSG_ATTR_GID)
+		nl_dump(p, "GID=%u ", msg->log_msg_gid);
+
+	if (msg->ce_mask & LOG_MSG_ATTR_SEQ)
+		nl_dump(p, "SEQ=%d ", msg->log_msg_seq);
+
+	if (msg->ce_mask & LOG_MSG_ATTR_SEQ_GLOBAL)
+		nl_dump(p, "SEQGLOBAL=%d ", msg->log_msg_seq_global);
+
+	nl_dump(p, "\n");
+}
+
+/**
+ * @name Allocation/Freeing
+ * @{
+ */
+
+struct nfnl_log_msg *nfnl_log_msg_alloc(void)
+{
+	return (struct nfnl_log_msg *) nl_object_alloc(&log_msg_obj_ops);
+}
+
+void nfnl_log_msg_get(struct nfnl_log_msg *msg)
+{
+	nl_object_get((struct nl_object *) msg);
+}
+
+void nfnl_log_msg_put(struct nfnl_log_msg *msg)
+{
+	nl_object_put((struct nl_object *) msg);
+}
+
+/** @} */
+
+/**
+ * @name Attributes
+ * @{
+ */
+
+void nfnl_log_msg_set_family(struct nfnl_log_msg *msg, uint8_t family)
+{
+	msg->log_msg_family = family;
+	msg->ce_mask |= LOG_MSG_ATTR_FAMILY;
+}
+
+uint8_t nfnl_log_msg_get_family(const struct nfnl_log_msg *msg)
+{
+	if (msg->ce_mask & LOG_MSG_ATTR_FAMILY)
+		return msg->log_msg_family;
+	else
+		return AF_UNSPEC;
+}
+
+void nfnl_log_msg_set_hwproto(struct nfnl_log_msg *msg, uint16_t hwproto)
+{
+	msg->log_msg_hwproto = hwproto;
+	msg->ce_mask |= LOG_MSG_ATTR_HWPROTO;
+}
+
+int nfnl_log_msg_test_hwproto(const struct nfnl_log_msg *msg)
+{
+	return !!(msg->ce_mask & LOG_MSG_ATTR_HWPROTO);
+}
+
+uint16_t nfnl_log_msg_get_hwproto(const struct nfnl_log_msg *msg)
+{
+	return msg->log_msg_hwproto;
+}
+
+void nfnl_log_msg_set_hook(struct nfnl_log_msg *msg, uint8_t hook)
+{
+	msg->log_msg_hook = hook;
+	msg->ce_mask |= LOG_MSG_ATTR_HOOK;
+}
+
+int nfnl_log_msg_test_hook(const struct nfnl_log_msg *msg)
+{
+	return !!(msg->ce_mask & LOG_MSG_ATTR_HOOK);
+}
+
+uint8_t nfnl_log_msg_get_hook(const struct nfnl_log_msg *msg)
+{
+	return msg->log_msg_hook;
+}
+
+void nfnl_log_msg_set_mark(struct nfnl_log_msg *msg, uint32_t mark)
+{
+	msg->log_msg_mark = mark;
+	msg->ce_mask |= LOG_MSG_ATTR_MARK;
+}
+
+int nfnl_log_msg_test_mark(const struct nfnl_log_msg *msg)
+{
+	return !!(msg->ce_mask & LOG_MSG_ATTR_MARK);
+}
+
+uint32_t nfnl_log_msg_get_mark(const struct nfnl_log_msg *msg)
+{
+	return msg->log_msg_mark;
+}
+
+void nfnl_log_msg_set_timestamp(struct nfnl_log_msg *msg, struct timeval *tv)
+{
+	msg->log_msg_timestamp.tv_sec = tv->tv_sec;
+	msg->log_msg_timestamp.tv_usec = tv->tv_usec;
+	msg->ce_mask |= LOG_MSG_ATTR_TIMESTAMP;
+}
+
+const struct timeval *nfnl_log_msg_get_timestamp(const struct nfnl_log_msg *msg)
+{
+	if (!(msg->ce_mask & LOG_MSG_ATTR_TIMESTAMP))
+		return NULL;
+	return &msg->log_msg_timestamp;
+}
+
+void nfnl_log_msg_set_indev(struct nfnl_log_msg *msg, uint32_t indev)
+{
+	msg->log_msg_indev = indev;
+	msg->ce_mask |= LOG_MSG_ATTR_INDEV;
+}
+
+uint32_t nfnl_log_msg_get_indev(const struct nfnl_log_msg *msg)
+{
+	return msg->log_msg_indev;
+}
+
+void nfnl_log_msg_set_outdev(struct nfnl_log_msg *msg, uint32_t outdev)
+{
+	msg->log_msg_outdev = outdev;
+	msg->ce_mask |= LOG_MSG_ATTR_OUTDEV;
+}
+
+uint32_t nfnl_log_msg_get_outdev(const struct nfnl_log_msg *msg)
+{
+	return msg->log_msg_outdev;
+}
+
+void nfnl_log_msg_set_physindev(struct nfnl_log_msg *msg, uint32_t physindev)
+{
+	msg->log_msg_physindev = physindev;
+	msg->ce_mask |= LOG_MSG_ATTR_PHYSINDEV;
+}
+
+uint32_t nfnl_log_msg_get_physindev(const struct nfnl_log_msg *msg)
+{
+	return msg->log_msg_physindev;
+}
+
+void nfnl_log_msg_set_physoutdev(struct nfnl_log_msg *msg, uint32_t physoutdev)
+{
+	msg->log_msg_physoutdev = physoutdev;
+	msg->ce_mask |= LOG_MSG_ATTR_PHYSOUTDEV;
+}
+
+uint32_t nfnl_log_msg_get_physoutdev(const struct nfnl_log_msg *msg)
+{
+	return msg->log_msg_physoutdev;
+}
+
+void nfnl_log_msg_set_hwaddr(struct nfnl_log_msg *msg, uint8_t *hwaddr, int len)
+{
+	if (len > sizeof(msg->log_msg_hwaddr))
+		len = sizeof(msg->log_msg_hwaddr);
+	msg->log_msg_hwaddr_len = len;
+	memcpy(msg->log_msg_hwaddr, hwaddr, len);
+	msg->ce_mask |= LOG_MSG_ATTR_HWADDR;
+}
+
+const uint8_t *nfnl_log_msg_get_hwaddr(const struct nfnl_log_msg *msg, int *len)
+{
+	if (!(msg->ce_mask & LOG_MSG_ATTR_HWADDR)) {
+		*len = 0;
+		return NULL;
+	}
+
+	*len = msg->log_msg_hwaddr_len;
+	return msg->log_msg_hwaddr;
+}
+
+int nfnl_log_msg_set_payload(struct nfnl_log_msg *msg, uint8_t *payload, int len)
+{
+	free(msg->log_msg_payload);
+	msg->log_msg_payload = malloc(len);
+	if (!msg->log_msg_payload)
+		return -NLE_NOMEM;
+
+	memcpy(msg->log_msg_payload, payload, len);
+	msg->log_msg_payload_len = len;
+	msg->ce_mask |= LOG_MSG_ATTR_PAYLOAD;
+	return 0;
+}
+
+const void *nfnl_log_msg_get_payload(const struct nfnl_log_msg *msg, int *len)
+{
+	if (!(msg->ce_mask & LOG_MSG_ATTR_PAYLOAD)) {
+		*len = 0;
+		return NULL;
+	}
+
+	*len = msg->log_msg_payload_len;
+	return msg->log_msg_payload;
+}
+
+int nfnl_log_msg_set_prefix(struct nfnl_log_msg *msg, void *prefix)
+{
+	free(msg->log_msg_prefix);
+	msg->log_msg_prefix = strdup(prefix);
+	if (!msg->log_msg_prefix)
+		return -NLE_NOMEM;
+
+	msg->ce_mask |= LOG_MSG_ATTR_PREFIX;
+	return 0;
+}
+
+const char *nfnl_log_msg_get_prefix(const struct nfnl_log_msg *msg)
+{
+	return msg->log_msg_prefix;
+}
+
+void nfnl_log_msg_set_uid(struct nfnl_log_msg *msg, uint32_t uid)
+{
+	msg->log_msg_uid = uid;
+	msg->ce_mask |= LOG_MSG_ATTR_UID;
+}
+
+int nfnl_log_msg_test_uid(const struct nfnl_log_msg *msg)
+{
+	return !!(msg->ce_mask & LOG_MSG_ATTR_UID);
+}
+
+uint32_t nfnl_log_msg_get_uid(const struct nfnl_log_msg *msg)
+{
+	return msg->log_msg_uid;
+}
+
+void nfnl_log_msg_set_gid(struct nfnl_log_msg *msg, uint32_t gid)
+{
+	msg->log_msg_gid = gid;
+	msg->ce_mask |= LOG_MSG_ATTR_GID;
+}
+
+int nfnl_log_msg_test_gid(const struct nfnl_log_msg *msg)
+{
+	return !!(msg->ce_mask & LOG_MSG_ATTR_GID);
+}
+
+uint32_t nfnl_log_msg_get_gid(const struct nfnl_log_msg *msg)
+{
+	return msg->log_msg_gid;
+}
+
+
+void nfnl_log_msg_set_seq(struct nfnl_log_msg *msg, uint32_t seq)
+{
+	msg->log_msg_seq = seq;
+	msg->ce_mask |= LOG_MSG_ATTR_SEQ;
+}
+
+int nfnl_log_msg_test_seq(const struct nfnl_log_msg *msg)
+{
+	return !!(msg->ce_mask & LOG_MSG_ATTR_SEQ);
+}
+
+uint32_t nfnl_log_msg_get_seq(const struct nfnl_log_msg *msg)
+{
+	return msg->log_msg_seq;
+}
+
+void nfnl_log_msg_set_seq_global(struct nfnl_log_msg *msg, uint32_t seq_global)
+{
+	msg->log_msg_seq_global = seq_global;
+	msg->ce_mask |= LOG_MSG_ATTR_SEQ_GLOBAL;
+}
+
+int nfnl_log_msg_test_seq_global(const struct nfnl_log_msg *msg)
+{
+	return !!(msg->ce_mask & LOG_MSG_ATTR_SEQ_GLOBAL);
+}
+
+uint32_t nfnl_log_msg_get_seq_global(const struct nfnl_log_msg *msg)
+{
+	return msg->log_msg_seq_global;
+}
+
+/** @} */
+
+struct nl_object_ops log_msg_obj_ops = {
+	.oo_name		= "netfilter/log_msg",
+	.oo_size		= sizeof(struct nfnl_log_msg),
+	.oo_free_data		= log_msg_free_data,
+	.oo_clone		= log_msg_clone,
+	.oo_dump = {
+	    [NL_DUMP_LINE]	= log_msg_dump,
+	    [NL_DUMP_DETAILS]	= log_msg_dump,
+	    [NL_DUMP_STATS]	= log_msg_dump,
+	},
+};
+
+/** @} */
diff -uNr libnl_kk/lib/netfilter/log_obj.c libnl/lib/netfilter/log_obj.c
--- libnl_kk/lib/netfilter/log_obj.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/netfilter/log_obj.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,287 @@
+/*
+ * lib/netfilter/log_obj.c	Netfilter Log Object
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ * Copyright (c) 2007 Philip Craig <philipc@snapgear.com>
+ * Copyright (c) 2007 Secure Computing Corporation
+ * Copyright (c) 2008 Patrick McHardy <kaber@trash.net>
+ */
+
+#include <netlink-local.h>
+#include <netlink/netfilter/nfnl.h>
+#include <netlink/netfilter/log.h>
+
+/** @cond SKIP */
+#define LOG_ATTR_GROUP			(1UL << 0)
+#define LOG_ATTR_COPY_MODE		(1UL << 1)
+#define LOG_ATTR_COPY_RANGE		(1UL << 3)
+#define LOG_ATTR_FLUSH_TIMEOUT		(1UL << 4)
+#define LOG_ATTR_ALLOC_SIZE		(1UL << 5)
+#define LOG_ATTR_QUEUE_THRESHOLD	(1UL << 6)
+
+/** @endcond */
+
+static void nfnl_log_dump(struct nl_object *a, struct nl_dump_params *p)
+{
+	struct nfnl_log *log = (struct nfnl_log *) a;
+	char buf[64];
+
+	nl_new_line(p);
+
+	if (log->ce_mask & LOG_ATTR_GROUP)
+		nl_dump(p, "group=%u ", log->log_group);
+
+	if (log->ce_mask & LOG_ATTR_COPY_MODE)
+		nl_dump(p, "copy_mode=%s ",
+			nfnl_log_copy_mode2str(log->log_copy_mode,
+					       buf, sizeof(buf)));
+
+	if (log->ce_mask & LOG_ATTR_COPY_RANGE)
+		nl_dump(p, "copy_range=%u ", log->log_copy_range);
+
+	if (log->ce_mask & LOG_ATTR_FLUSH_TIMEOUT)
+		nl_dump(p, "flush_timeout=%u ", log->log_flush_timeout);
+
+	if (log->ce_mask & LOG_ATTR_ALLOC_SIZE)
+		nl_dump(p, "alloc_size=%u ", log->log_alloc_size);
+
+	if (log->ce_mask & LOG_ATTR_QUEUE_THRESHOLD)
+		nl_dump(p, "queue_threshold=%u ", log->log_queue_threshold);
+
+	nl_dump(p, "\n");
+}
+
+static struct trans_tbl copy_modes[] = {
+	__ADD(NFNL_LOG_COPY_NONE,	none)
+	__ADD(NFNL_LOG_COPY_META,	meta)
+	__ADD(NFNL_LOG_COPY_PACKET,	packet)
+};
+
+char *nfnl_log_copy_mode2str(enum nfnl_log_copy_mode copy_mode, char *buf,
+			     size_t len)
+{
+	return __type2str(copy_mode, buf, len, copy_modes,
+			  ARRAY_SIZE(copy_modes));
+}
+
+enum nfnl_log_copy_mode nfnl_log_str2copy_mode(const char *name)
+{
+	return __str2type(name, copy_modes, ARRAY_SIZE(copy_modes));
+}
+
+/**
+ * @name Allocation/Freeing
+ * @{
+ */
+
+struct nfnl_log *nfnl_log_alloc(void)
+{
+	return (struct nfnl_log *) nl_object_alloc(&log_obj_ops);
+}
+
+void nfnl_log_get(struct nfnl_log *log)
+{
+	nl_object_get((struct nl_object *) log);
+}
+
+void nfnl_log_put(struct nfnl_log *log)
+{
+	nl_object_put((struct nl_object *) log);
+}
+
+/** @} */
+
+/**
+ * @name Attributes
+ * @{
+ */
+
+void nfnl_log_set_group(struct nfnl_log *log, uint16_t group)
+{
+	log->log_group = group;
+	log->ce_mask |= LOG_ATTR_GROUP;
+}
+
+int nfnl_log_test_group(const struct nfnl_log *log)
+{
+	return !!(log->ce_mask & LOG_ATTR_GROUP);
+}
+
+uint16_t nfnl_log_get_group(const struct nfnl_log *log)
+{
+	return log->log_group;
+}
+
+void nfnl_log_set_copy_mode(struct nfnl_log *log, enum nfnl_log_copy_mode mode)
+{
+	log->log_copy_mode = mode;
+	log->ce_mask |= LOG_ATTR_COPY_MODE;
+}
+
+int nfnl_log_test_copy_mode(const struct nfnl_log *log)
+{
+	return !!(log->ce_mask & LOG_ATTR_COPY_MODE);
+}
+
+enum nfnl_log_copy_mode nfnl_log_get_copy_mode(const struct nfnl_log *log)
+{
+	return log->log_copy_mode;
+}
+
+void nfnl_log_set_copy_range(struct nfnl_log *log, uint32_t copy_range)
+{
+	log->log_copy_range = copy_range;
+	log->ce_mask |= LOG_ATTR_COPY_RANGE;
+}
+
+int nfnl_log_test_copy_range(const struct nfnl_log *log)
+{
+	return !!(log->ce_mask & LOG_ATTR_COPY_RANGE);
+}
+
+uint32_t nfnl_log_get_copy_range(const struct nfnl_log *log)
+{
+	return log->log_copy_range;
+}
+
+void nfnl_log_set_flush_timeout(struct nfnl_log *log, uint32_t timeout)
+{
+	log->log_flush_timeout = timeout;
+	log->ce_mask |= LOG_ATTR_FLUSH_TIMEOUT;
+}
+
+int nfnl_log_test_flush_timeout(const struct nfnl_log *log)
+{
+	return !!(log->ce_mask & LOG_ATTR_FLUSH_TIMEOUT);
+}
+
+uint32_t nfnl_log_get_flush_timeout(const struct nfnl_log *log)
+{
+	return log->log_flush_timeout;
+}
+
+void nfnl_log_set_alloc_size(struct nfnl_log *log, uint32_t alloc_size)
+{
+	log->log_alloc_size = alloc_size;
+	log->ce_mask |= LOG_ATTR_ALLOC_SIZE;
+}
+
+int nfnl_log_test_alloc_size(const struct nfnl_log *log)
+{
+	return !!(log->ce_mask & LOG_ATTR_ALLOC_SIZE);
+}
+
+uint32_t nfnl_log_get_alloc_size(const struct nfnl_log *log)
+{
+	return log->log_alloc_size;
+}
+
+void nfnl_log_set_queue_threshold(struct nfnl_log *log, uint32_t threshold)
+{
+	log->log_queue_threshold = threshold;
+	log->ce_mask |= LOG_ATTR_QUEUE_THRESHOLD;
+}
+
+int nfnl_log_test_queue_threshold(const struct nfnl_log *log)
+{
+	return !!(log->ce_mask & LOG_ATTR_QUEUE_THRESHOLD);
+}
+
+uint32_t nfnl_log_get_queue_threshold(const struct nfnl_log *log)
+{
+	return log->log_queue_threshold;
+}
+
+/* We don't actually use the flags for anything yet since the
+ * nfnetlog_log interface truly sucks - it only contains the
+ * flag value, but not mask, so we would have to make assumptions
+ * about the supported flags.
+ */
+void nfnl_log_set_flags(struct nfnl_log *log, unsigned int flags)
+{
+	log->log_flags |= flags;
+	log->log_flag_mask |= flags;
+}
+
+void nfnl_log_unset_flags(struct nfnl_log *log, unsigned int flags)
+{
+	log->log_flags &= ~flags;
+	log->log_flag_mask |= flags;
+}
+
+static struct trans_tbl log_flags[] = {
+	__ADD(NFNL_LOG_FLAG_SEQ,	seq)
+	__ADD(NFNL_LOG_FLAG_SEQ_GLOBAL,	seq_global)
+};
+
+char *nfnl_log_flags2str(unsigned int flags, char *buf, size_t len)
+{
+	return __flags2str(flags, buf, len, log_flags, ARRAY_SIZE(log_flags));
+}
+
+unsigned int nfnl_log_str2flags(const char *name)
+{
+	return __str2flags(name, log_flags, ARRAY_SIZE(log_flags));
+}
+
+static int nfnl_log_compare(struct nl_object *_a, struct nl_object *_b,
+			    uint32_t attrs, int flags)
+{
+	struct nfnl_log *a = (struct nfnl_log *) _a;
+	struct nfnl_log *b = (struct nfnl_log *) _b;
+	int diff = 0;
+
+#define NFNL_LOG_DIFF(ATTR, EXPR) \
+	ATTR_DIFF(attrs, LOG_ATTR_##ATTR, a, b, EXPR)
+#define NFNL_LOG_DIFF_VAL(ATTR, FIELD) \
+	NFNL_LOG_DIFF(ATTR, a->FIELD != b->FIELD)
+
+	diff |= NFNL_LOG_DIFF_VAL(GROUP,		log_group);
+	diff |= NFNL_LOG_DIFF_VAL(COPY_MODE,		log_copy_mode);
+	diff |= NFNL_LOG_DIFF_VAL(COPY_RANGE,		log_copy_range);
+	diff |= NFNL_LOG_DIFF_VAL(FLUSH_TIMEOUT,	log_flush_timeout);
+	diff |= NFNL_LOG_DIFF_VAL(ALLOC_SIZE,		log_alloc_size);
+	diff |= NFNL_LOG_DIFF_VAL(QUEUE_THRESHOLD,	log_queue_threshold);
+
+#undef NFNL_LOG_DIFF
+#undef NFNL_LOG_DIFF_VAL
+
+	return diff;
+}
+
+static struct trans_tbl nfnl_log_attrs[] = {
+	__ADD(LOG_ATTR_GROUP,		group)
+	__ADD(LOG_ATTR_COPY_MODE,	copy_mode)
+	__ADD(LOG_ATTR_COPY_RANGE,	copy_range)
+	__ADD(LOG_ATTR_FLUSH_TIMEOUT,	flush_timeout)
+	__ADD(LOG_ATTR_ALLOC_SIZE,	alloc_size)
+	__ADD(LOG_ATTR_QUEUE_THRESHOLD, queue_threshold)
+};
+
+static char *nfnl_log_attrs2str(int attrs, char *buf, size_t len)
+{
+	return __flags2str(attrs, buf, len, nfnl_log_attrs,
+			   ARRAY_SIZE(nfnl_log_attrs));
+}
+
+/** @} */
+
+struct nl_object_ops log_obj_ops = {
+	.oo_name		= "netfilter/log",
+	.oo_size		= sizeof(struct nfnl_log),
+	.oo_dump = {
+	    [NL_DUMP_LINE]	= nfnl_log_dump,
+	    [NL_DUMP_DETAILS]	= nfnl_log_dump,
+	    [NL_DUMP_STATS]	= nfnl_log_dump,
+	},
+	.oo_compare		= nfnl_log_compare,
+	.oo_attrs2str		= nfnl_log_attrs2str,
+	.oo_id_attrs		= LOG_ATTR_GROUP,
+};
+
+/** @} */
diff -uNr libnl_kk/lib/netfilter/netfilter.c libnl/lib/netfilter/netfilter.c
--- libnl_kk/lib/netfilter/netfilter.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/netfilter/netfilter.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,53 @@
+/*
+ * lib/netfilter/netfilter.c    Netfilter Generic Functions
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2008 Patrick McHardy <kaber@trash.net>
+ */
+
+#include <netlink-local.h>
+#include <netlink/netfilter/netfilter.h>
+#include <linux/netfilter.h>
+
+static struct trans_tbl nfnl_verdicts[] = {
+	__ADD(NF_DROP,		NF_DROP)
+	__ADD(NF_ACCEPT,	NF_ACCEPT)
+	__ADD(NF_STOLEN,	NF_STOLEN)
+	__ADD(NF_QUEUE,		NF_QUEUE)
+	__ADD(NF_REPEAT,	NF_REPEAT)
+	__ADD(NF_STOP,		NF_STOP)
+};
+
+char *nfnl_verdict2str(unsigned int verdict, char *buf, size_t len)
+{
+	return __type2str(verdict, buf, len, nfnl_verdicts,
+			  ARRAY_SIZE(nfnl_verdicts));
+}
+
+unsigned int nfnl_str2verdict(const char *name)
+{
+	return __str2type(name, nfnl_verdicts, ARRAY_SIZE(nfnl_verdicts));
+}
+
+static struct trans_tbl nfnl_inet_hooks[] = {
+	__ADD(NF_INET_PRE_ROUTING,	NF_INET_PREROUTING)
+	__ADD(NF_INET_LOCAL_IN,		NF_INET_LOCAL_IN)
+	__ADD(NF_INET_FORWARD,		NF_INET_FORWARD)
+	__ADD(NF_INET_LOCAL_OUT,	NF_INET_LOCAL_OUT)
+	__ADD(NF_INET_POST_ROUTING,	NF_INET_POST_ROUTING)
+};
+
+char *nfnl_inet_hook2str(unsigned int hook, char *buf, size_t len)
+{
+	return __type2str(hook, buf, len, nfnl_inet_hooks,
+			  ARRAY_SIZE(nfnl_inet_hooks));
+}
+
+unsigned int nfnl_str2inet_hook(const char *name)
+{
+	return __str2type(name, nfnl_inet_hooks, ARRAY_SIZE(nfnl_inet_hooks));
+}
diff -uNr libnl_kk/lib/netfilter/nfnl.c libnl/lib/netfilter/nfnl.c
--- libnl_kk/lib/netfilter/nfnl.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/netfilter/nfnl.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,245 @@
+/*
+ * lib/netfilter/nfnl.c		Netfilter Netlink
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ * Copyright (c) 2007 Philip Craig <philipc@snapgear.com>
+ * Copyright (c) 2007 Secure Computing Corporation
+ */
+
+/**
+ * @defgroup nfnl Netfilter Netlink
+ *
+ * @par Message Format
+ * @code
+ *  <------- NLMSG_ALIGN(hlen) ------> <---- NLMSG_ALIGN(len) --->
+ * +----------------------------+- - -+- - - - - - - - - - -+- - -+
+ * |           Header           | Pad |       Payload       | Pad |
+ * |      struct nlmsghdr       |     |                     |     |
+ * +----------------------------+- - -+- - - - - - - - - - -+- - -+
+ * @endcode
+ * @code
+ *  <-------- NFNL_HDRLEN --------->
+ * +--------------------------+- - -+------------+
+ * | Netfilter Netlink Header | Pad | Attributes |
+ * |    struct nfgenmsg       |     |            |
+ * +--------------------------+- - -+------------+
+ * nfnlmsg_attrdata(nfg, hdrlen)-----^
+ * @endcode
+ *
+ * @par 1) Creating a new netfilter netlink message
+ * @code
+ * struct nl_msg *msg;
+ *
+ * // Create a new empty netlink message
+ * msg = nlmsg_alloc();
+ *
+ * // Append the netlink and netfilter netlink message header
+ * hdr = nfnlmsg_put(msg, PID, SEQ, SUBSYS, TYPE, NLM_F_ECHO,
+ *                   FAMILY, RES_ID);
+ *
+ * // Append the attributes.
+ * nla_put_u32(msg, 1, 0x10);
+ *
+ * // Message is ready to be sent.
+ * nl_send_auto_complete(sk, msg);
+ *
+ * // All done? Free the message.
+ * nlmsg_free(msg);
+ * @endcode
+ *
+ * @par 2) Sending of trivial messages
+ * @code
+ * // For trivial messages not requiring any subsys specific header or
+ * // attributes, nfnl_send_simple() may be used to send messages directly.
+ * nfnl_send_simple(sk, SUBSYS, TYPE, 0, FAMILY, RES_ID);
+ * @endcode
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink/netlink.h>
+#include <netlink/netfilter/nfnl.h>
+
+/**
+ * @name Socket Creating
+ * @{
+ */
+
+/**
+ * Create and connect netfilter netlink socket.
+ * @arg sk		Netlink socket.
+ *
+ * Creates a NETLINK_NETFILTER netlink socket, binds the socket and
+ * issues a connection attempt.
+ *
+ * @see nl_connect()
+ *
+ * @return 0 on success or a negative error code.
+ */
+int nfnl_connect(struct nl_sock *sk)
+{
+	return nl_connect(sk, NETLINK_NETFILTER);
+}
+
+/** @} */
+
+/**
+ * @name Sending
+ * @{
+ */
+
+/**
+ * Send trivial netfilter netlink message
+ * @arg sk		Netlink socket.
+ * @arg subsys_id	nfnetlink subsystem
+ * @arg type		nfnetlink message type
+ * @arg flags		message flags
+ * @arg family		nfnetlink address family
+ * @arg res_id		nfnetlink resource id
+ *
+ * @return Newly allocated netlink message or NULL.
+ */
+int nfnl_send_simple(struct nl_sock *sk, uint8_t subsys_id, uint8_t type,
+		     int flags, uint8_t family, uint16_t res_id)
+{
+	struct nfgenmsg hdr = {
+		.nfgen_family = family,
+		.version = NFNETLINK_V0,
+		.res_id = htons(res_id),
+	};
+
+	return nl_send_simple(sk, NFNLMSG_TYPE(subsys_id, type), flags,
+			      &hdr, sizeof(hdr));
+}
+
+/** @} */
+
+/**
+ * @name Message Parsing
+ * @{
+ */
+
+/**
+ * Get netfilter subsystem id from message
+ * @arg nlh	netlink messsage header
+ */
+uint8_t nfnlmsg_subsys(struct nlmsghdr *nlh)
+{
+	return NFNL_SUBSYS_ID(nlh->nlmsg_type);
+}
+
+/**
+ * Get netfilter message type from message
+ * @arg nlh	netlink messsage header
+ */
+uint8_t nfnlmsg_subtype(struct nlmsghdr *nlh)
+{
+	return NFNL_MSG_TYPE(nlh->nlmsg_type);
+}
+
+/**
+ * Get netfilter family from message
+ * @arg nlh	netlink messsage header
+ */
+uint8_t nfnlmsg_family(struct nlmsghdr *nlh)
+{
+	struct nfgenmsg *nfg = nlmsg_data(nlh);
+
+	return nfg->nfgen_family;
+}
+
+/**
+ * Get netfilter resource id from message
+ * @arg nlh	netlink messsage header
+ */
+uint16_t nfnlmsg_res_id(struct nlmsghdr *nlh)
+{
+	struct nfgenmsg *nfg = nlmsg_data(nlh);
+
+	return ntohs(nfg->res_id);
+}
+
+/** @} */
+
+/**
+ * @name Message Building
+ * @{
+ */
+
+static int nfnlmsg_append(struct nl_msg *msg, uint8_t family, uint16_t res_id)
+{
+	struct nfgenmsg *nfg;
+
+	nfg = nlmsg_reserve(msg, sizeof(*nfg), NLMSG_ALIGNTO);
+	if (nfg == NULL)
+		return -NLE_NOMEM;
+
+	nfg->nfgen_family = family;
+	nfg->version = NFNETLINK_V0;
+	nfg->res_id = htons(res_id);
+	NL_DBG(2, "msg %p: Added nfnetlink header family=%d res_id=%d\n",
+	       msg, family, res_id);
+	return 0;
+}
+
+/**
+ * Allocate a new netfilter netlink message
+ * @arg subsys_id	nfnetlink subsystem
+ * @arg type		nfnetlink message type
+ * @arg flags		message flags
+ * @arg family		nfnetlink address family
+ * @arg res_id		nfnetlink resource id
+ *
+ * @return Newly allocated netlink message or NULL.
+ */
+struct nl_msg *nfnlmsg_alloc_simple(uint8_t subsys_id, uint8_t type, int flags,
+				    uint8_t family, uint16_t res_id)
+{
+	struct nl_msg *msg;
+
+	msg = nlmsg_alloc_simple(NFNLMSG_TYPE(subsys_id, type), flags);
+	if (msg == NULL)
+		return NULL;
+
+	if (nfnlmsg_append(msg, family, res_id) < 0)
+		goto nla_put_failure;
+
+	return msg;
+
+nla_put_failure:
+	nlmsg_free(msg);
+	return NULL;
+}
+
+/**
+ * Add netlink and netfilter netlink headers to netlink message
+ * @arg msg		netlink message
+ * @arg pid		netlink process id
+ * @arg seq		sequence number of message
+ * @arg subsys_id	nfnetlink subsystem
+ * @arg type		nfnetlink message type
+ * @arg flags		message flags
+ * @arg family		nfnetlink address family
+ * @arg res_id		nfnetlink resource id
+ */
+int nfnlmsg_put(struct nl_msg *msg, uint32_t pid, uint32_t seq,
+		uint8_t subsys_id, uint8_t type, int flags, uint8_t family,
+		uint16_t res_id)
+{
+	struct nlmsghdr *nlh;
+
+	nlh = nlmsg_put(msg, pid, seq, NFNLMSG_TYPE(subsys_id, type), 0, flags);
+	if (nlh == NULL)
+		return -NLE_MSGSIZE;
+
+	return nfnlmsg_append(msg, family, res_id);
+}
+
+/** @} */
+
+/** @} */
diff -uNr libnl_kk/lib/netfilter/queue.c libnl/lib/netfilter/queue.c
--- libnl_kk/lib/netfilter/queue.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/netfilter/queue.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,251 @@
+/*
+ * lib/netfilter/queue.c	Netfilter Queue
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2007, 2008 Patrick McHardy <kaber@trash.net>
+ */
+
+/**
+ * @ingroup nfnl
+ * @defgroup queue Queue
+ * @brief
+ * @{
+ */
+
+#include <sys/types.h>
+#include <linux/netfilter/nfnetlink_queue.h>
+
+#include <netlink-local.h>
+#include <netlink/attr.h>
+#include <netlink/netfilter/nfnl.h>
+#include <netlink/netfilter/queue.h>
+
+struct nl_sock *nfnl_queue_socket_alloc(void)
+{
+	struct nl_sock *nlsk;
+
+	nlsk = nl_socket_alloc();
+	if (nlsk)
+		nl_socket_disable_auto_ack(nlsk);
+	return nlsk;
+}
+
+static int send_queue_request(struct nl_sock *sk, struct nl_msg *msg)
+{
+	int err;
+
+	err = nl_send_auto_complete(sk, msg);
+	nlmsg_free(msg);
+	if (err < 0)
+		return err;
+
+	return wait_for_ack(sk);
+}
+
+/**
+ * @name Queue Commands
+ * @{
+ */
+
+static int build_queue_cmd_request(uint8_t family, uint16_t queuenum,
+				   uint8_t command, struct nl_msg **result)
+{
+	struct nl_msg *msg;
+	struct nfqnl_msg_config_cmd cmd;
+
+	msg = nfnlmsg_alloc_simple(NFNL_SUBSYS_QUEUE, NFQNL_MSG_CONFIG, 0,
+				   family, queuenum);
+	if (msg == NULL)
+		return -NLE_NOMEM;
+
+	cmd.pf = htons(family);
+	cmd._pad = 0;
+	cmd.command = command;
+	if (nla_put(msg, NFQA_CFG_CMD, sizeof(cmd), &cmd) < 0)
+		goto nla_put_failure;
+
+	*result = msg;
+	return 0;
+
+nla_put_failure:
+	nlmsg_free(msg);
+	return -NLE_MSGSIZE;
+}
+
+int nfnl_queue_build_pf_bind(uint8_t pf, struct nl_msg **result)
+{
+	return build_queue_cmd_request(pf, 0, NFQNL_CFG_CMD_PF_BIND, result);
+}
+
+int nfnl_queue_pf_bind(struct nl_sock *nlh, uint8_t pf)
+{
+	struct nl_msg *msg;
+	int err;
+
+	if ((err = nfnl_queue_build_pf_bind(pf, &msg)) < 0)
+		return err;
+
+	return send_queue_request(nlh, msg);
+}
+
+int nfnl_queue_build_pf_unbind(uint8_t pf, struct nl_msg **result)
+{
+	return build_queue_cmd_request(pf, 0, NFQNL_CFG_CMD_PF_UNBIND, result);
+}
+
+int nfnl_queue_pf_unbind(struct nl_sock *nlh, uint8_t pf)
+{
+	struct nl_msg *msg;
+	int err;
+
+	if ((err = nfnl_queue_build_pf_unbind(pf, &msg)) < 0)
+		return err;
+
+	return send_queue_request(nlh, msg);
+}
+
+static int nfnl_queue_build_request(const struct nfnl_queue *queue,
+				    struct nl_msg **result)
+{
+	struct nl_msg *msg;
+
+	if (!nfnl_queue_test_group(queue))
+		return -NLE_MISSING_ATTR;
+
+	msg = nfnlmsg_alloc_simple(NFNL_SUBSYS_QUEUE, NFQNL_MSG_CONFIG, 0,
+				   0, nfnl_queue_get_group(queue));
+	if (msg == NULL)
+		return -NLE_NOMEM;
+
+	if (nfnl_queue_test_maxlen(queue) &&
+	    nla_put_u32(msg, NFQA_CFG_QUEUE_MAXLEN,
+			htonl(nfnl_queue_get_maxlen(queue))) < 0)
+		goto nla_put_failure;
+
+	/* This sucks, the nfnetlink_queue interface always expects both
+	 * parameters to be present. Needs to be done properly.
+	 */
+	if (nfnl_queue_test_copy_mode(queue)) {
+		struct nfqnl_msg_config_params params;
+
+		switch (nfnl_queue_get_copy_mode(queue)) {
+		case NFNL_QUEUE_COPY_NONE:
+			params.copy_mode = NFQNL_COPY_NONE;
+			break;
+		case NFNL_QUEUE_COPY_META:
+			params.copy_mode = NFQNL_COPY_META;
+			break;
+		case NFNL_QUEUE_COPY_PACKET:
+			params.copy_mode = NFQNL_COPY_PACKET;
+			break;
+		}
+		params.copy_range = htonl(nfnl_queue_get_copy_range(queue));
+
+		if (nla_put(msg, NFQA_CFG_PARAMS, sizeof(params), &params) < 0)
+			goto nla_put_failure;
+	}
+
+	*result = msg;
+	return 0;
+
+nla_put_failure:
+	nlmsg_free(msg);
+	return -NLE_MSGSIZE;
+}
+
+int nfnl_queue_build_create_request(const struct nfnl_queue *queue,
+				    struct nl_msg **result)
+{
+	struct nfqnl_msg_config_cmd cmd;
+	int err;
+
+	if ((err = nfnl_queue_build_request(queue, result)) < 0)
+		return err;
+
+	cmd.pf = 0;
+	cmd._pad = 0;
+	cmd.command = NFQNL_CFG_CMD_BIND;
+
+	NLA_PUT(*result, NFQA_CFG_CMD, sizeof(cmd), &cmd);
+
+	return 0;
+
+nla_put_failure:
+	nlmsg_free(*result);
+	return -NLE_MSGSIZE;
+}
+
+int nfnl_queue_create(struct nl_sock *nlh, const struct nfnl_queue *queue)
+{
+	struct nl_msg *msg;
+	int err;
+
+	if ((err = nfnl_queue_build_create_request(queue, &msg)) < 0)
+		return err;
+
+	return send_queue_request(nlh, msg);
+}
+
+int nfnl_queue_build_change_request(const struct nfnl_queue *queue,
+				    struct nl_msg **result)
+{
+	return nfnl_queue_build_request(queue, result);
+}
+
+int nfnl_queue_change(struct nl_sock *nlh, const struct nfnl_queue *queue)
+{
+	struct nl_msg *msg;
+	int err;
+
+	if ((err = nfnl_queue_build_change_request(queue, &msg)) < 0)
+		return err;
+
+	return send_queue_request(nlh, msg);
+}
+
+int nfnl_queue_build_delete_request(const struct nfnl_queue *queue,
+				    struct nl_msg **result)
+{
+	if (!nfnl_queue_test_group(queue))
+		return -NLE_MISSING_ATTR;
+
+	return build_queue_cmd_request(0, nfnl_queue_get_group(queue),
+				       NFQNL_CFG_CMD_UNBIND, result);
+}
+
+int nfnl_queue_delete(struct nl_sock *nlh, const struct nfnl_queue *queue)
+{
+	struct nl_msg *msg;
+	int err;
+
+	if ((err = nfnl_queue_build_delete_request(queue, &msg)) < 0)
+		return err;
+
+	return send_queue_request(nlh, msg);
+}
+
+/** @} */
+
+static struct nl_cache_ops nfnl_queue_ops = {
+	.co_name		= "netfilter/queue",
+	.co_obj_ops		= &queue_obj_ops,
+	.co_msgtypes		= {
+		END_OF_MSGTYPES_LIST,
+	},
+};
+
+static void __init nfnl_queue_init(void)
+{
+	nl_cache_mngt_register(&nfnl_queue_ops);
+}
+
+static void __exit nfnl_queue_exit(void)
+{
+	nl_cache_mngt_unregister(&nfnl_queue_ops);
+}
+
+/** @} */
diff -uNr libnl_kk/lib/netfilter/queue_msg.c libnl/lib/netfilter/queue_msg.c
--- libnl_kk/lib/netfilter/queue_msg.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/netfilter/queue_msg.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,284 @@
+/*
+ * lib/netfilter/queue_msg.c	Netfilter Queue Messages
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2007, 2008 Patrick McHardy <kaber@trash.net>
+ * Copyright (c) 2010       Karl Hiramoto <karl@hiramoto.org>
+ */
+
+/**
+ * @ingroup nfnl
+ * @defgroup queue Queue
+ * @brief
+ * @{
+ */
+
+#include <sys/types.h>
+#include <linux/netfilter/nfnetlink_queue.h>
+
+#include <netlink-local.h>
+#include <netlink/attr.h>
+#include <netlink/netfilter/nfnl.h>
+#include <netlink/netfilter/queue_msg.h>
+
+static struct nl_cache_ops nfnl_queue_msg_ops;
+
+#if __BYTE_ORDER == __BIG_ENDIAN
+static uint64_t ntohll(uint64_t x)
+{
+	return x;
+}
+#elif __BYTE_ORDER == __LITTLE_ENDIAN
+static uint64_t ntohll(uint64_t x)
+{
+	return __bswap_64(x);
+}
+#endif
+
+static struct nla_policy queue_policy[NFQA_MAX+1] = {
+	[NFQA_PACKET_HDR]		= {
+		.minlen	= sizeof(struct nfqnl_msg_packet_hdr),
+	},
+	[NFQA_VERDICT_HDR]		= {
+		.minlen	= sizeof(struct nfqnl_msg_verdict_hdr),
+	},
+	[NFQA_MARK]			= { .type = NLA_U32 },
+	[NFQA_TIMESTAMP]		= {
+		.minlen = sizeof(struct nfqnl_msg_packet_timestamp),
+	},
+	[NFQA_IFINDEX_INDEV]		= { .type = NLA_U32 },
+	[NFQA_IFINDEX_OUTDEV]		= { .type = NLA_U32 },
+	[NFQA_IFINDEX_PHYSINDEV]	= { .type = NLA_U32 },
+	[NFQA_IFINDEX_PHYSOUTDEV]	= { .type = NLA_U32 },
+	[NFQA_HWADDR]			= {
+		.minlen	= sizeof(struct nfqnl_msg_packet_hw),
+	},
+};
+
+int nfnlmsg_queue_msg_parse(struct nlmsghdr *nlh,
+			    struct nfnl_queue_msg **result)
+{
+	struct nfnl_queue_msg *msg;
+	struct nlattr *tb[NFQA_MAX+1];
+	struct nlattr *attr;
+	int err;
+
+	msg = nfnl_queue_msg_alloc();
+	if (!msg)
+		return -NLE_NOMEM;
+
+	msg->ce_msgtype = nlh->nlmsg_type;
+
+	err = nlmsg_parse(nlh, sizeof(struct nfgenmsg), tb, NFQA_MAX,
+			  queue_policy);
+	if (err < 0)
+		goto errout;
+
+	nfnl_queue_msg_set_group(msg, nfnlmsg_res_id(nlh));
+	nfnl_queue_msg_set_family(msg, nfnlmsg_family(nlh));
+
+	attr = tb[NFQA_PACKET_HDR];
+	if (attr) {
+		struct nfqnl_msg_packet_hdr *hdr = nla_data(attr);
+
+		nfnl_queue_msg_set_packetid(msg, ntohl(hdr->packet_id));
+		if (hdr->hw_protocol)
+			nfnl_queue_msg_set_hwproto(msg, hdr->hw_protocol);
+		nfnl_queue_msg_set_hook(msg, hdr->hook);
+	}
+
+	attr = tb[NFQA_MARK];
+	if (attr)
+		nfnl_queue_msg_set_mark(msg, ntohl(nla_get_u32(attr)));
+
+	attr = tb[NFQA_TIMESTAMP];
+	if (attr) {
+		struct nfqnl_msg_packet_timestamp *timestamp = nla_data(attr);
+		struct timeval tv;
+
+		tv.tv_sec = ntohll(timestamp->sec);
+		tv.tv_usec = ntohll(timestamp->usec);
+		nfnl_queue_msg_set_timestamp(msg, &tv);
+	}
+
+	attr = tb[NFQA_IFINDEX_INDEV];
+	if (attr)
+		nfnl_queue_msg_set_indev(msg, ntohl(nla_get_u32(attr)));
+
+	attr = tb[NFQA_IFINDEX_OUTDEV];
+	if (attr)
+		nfnl_queue_msg_set_outdev(msg, ntohl(nla_get_u32(attr)));
+
+	attr = tb[NFQA_IFINDEX_PHYSINDEV];
+	if (attr)
+		nfnl_queue_msg_set_physindev(msg, ntohl(nla_get_u32(attr)));
+
+	attr = tb[NFQA_IFINDEX_PHYSOUTDEV];
+	if (attr)
+		nfnl_queue_msg_set_physoutdev(msg, ntohl(nla_get_u32(attr)));
+
+	attr = tb[NFQA_HWADDR];
+	if (attr) {
+		struct nfqnl_msg_packet_hw *hw = nla_data(attr);
+
+		nfnl_queue_msg_set_hwaddr(msg, hw->hw_addr,
+					  ntohs(hw->hw_addrlen));
+	}
+
+	attr = tb[NFQA_PAYLOAD];
+	if (attr) {
+		err = nfnl_queue_msg_set_payload(msg, nla_data(attr),
+						 nla_len(attr));
+		if (err < 0)
+			goto errout;
+	}
+
+	*result = msg;
+	return 0;
+
+errout:
+	nfnl_queue_msg_put(msg);
+	return err;
+}
+
+static int queue_msg_parser(struct nl_cache_ops *ops, struct sockaddr_nl *who,
+			    struct nlmsghdr *nlh, struct nl_parser_param *pp)
+{
+	struct nfnl_queue_msg *msg;
+	int err;
+
+	if ((err = nfnlmsg_queue_msg_parse(nlh, &msg)) < 0)
+		goto errout;
+
+	err = pp->pp_cb((struct nl_object *) msg, pp);
+errout:
+	nfnl_queue_msg_put(msg);
+	return err;
+}
+
+/** @} */
+
+struct nl_msg *nfnl_queue_msg_build_verdict(const struct nfnl_queue_msg *msg)
+{
+	struct nl_msg *nlmsg;
+	struct nfqnl_msg_verdict_hdr verdict;
+
+	nlmsg = nfnlmsg_alloc_simple(NFNL_SUBSYS_QUEUE, NFQNL_MSG_VERDICT, 0,
+				     nfnl_queue_msg_get_family(msg),
+				     nfnl_queue_msg_get_group(msg));
+	if (nlmsg == NULL)
+		return NULL;
+
+	verdict.id = htonl(nfnl_queue_msg_get_packetid(msg));
+	verdict.verdict = htonl(nfnl_queue_msg_get_verdict(msg));
+	if (nla_put(nlmsg, NFQA_VERDICT_HDR, sizeof(verdict), &verdict) < 0)
+		goto nla_put_failure;
+
+	if (nfnl_queue_msg_test_mark(msg) &&
+	    nla_put_u32(nlmsg, NFQA_MARK,
+			ntohl(nfnl_queue_msg_get_mark(msg))) < 0)
+		goto nla_put_failure;
+
+	return nlmsg;
+
+nla_put_failure:
+	nlmsg_free(nlmsg);
+	return NULL;
+}
+
+/**
+* Send a message verdict/mark
+* @arg nlh            netlink messsage header
+* @arg msg            queue msg
+* @return 0 on OK or error code
+*/
+int nfnl_queue_msg_send_verdict(struct nl_sock *nlh,
+				const struct nfnl_queue_msg *msg)
+{
+	struct nl_msg *nlmsg;
+	int err;
+
+	nlmsg = nfnl_queue_msg_build_verdict(msg);
+	if (nlmsg == NULL)
+		return -NLE_NOMEM;
+
+	err = nl_send_auto_complete(nlh, nlmsg);
+	nlmsg_free(nlmsg);
+	if (err < 0)
+		return err;
+	return wait_for_ack(nlh);
+}
+
+/**
+* Send a message verdict including the payload
+* @arg nlh            netlink messsage header
+* @arg msg            queue msg
+* @arg payload_data   packet payload data
+* @arg payload_len    payload length
+* @return 0 on OK or error code
+*/
+int nfnl_queue_msg_send_verdict_payload(struct nl_sock *nlh,
+				const struct nfnl_queue_msg *msg,
+				const void *payload_data, unsigned payload_len)
+{
+	struct nl_msg *nlmsg;
+	int err;
+	struct iovec iov[3];
+	struct nlattr nla;
+
+	nlmsg = nfnl_queue_msg_build_verdict(msg);
+	if (nlmsg == NULL)
+		return -NLE_NOMEM;
+
+	memset(iov, 0, sizeof(iov));
+
+	iov[0].iov_base = (void *) nlmsg_hdr(nlmsg);
+	iov[0].iov_len = nlmsg_hdr(nlmsg)->nlmsg_len;
+
+	nla.nla_type = NFQA_PAYLOAD;
+	nla.nla_len = payload_len + sizeof(nla);
+	nlmsg_hdr(nlmsg)->nlmsg_len += nla.nla_len;
+
+	iov[1].iov_base = (void *) &nla;
+	iov[1].iov_len = sizeof(nla);
+
+	iov[2].iov_base = (void *) payload_data;
+	iov[2].iov_len = NLA_ALIGN(payload_len);
+
+	nl_auto_complete(nlh, nlmsg);
+	err = nl_send_iovec(nlh, nlmsg, iov, 3);
+
+	nlmsg_free(nlmsg);
+	if (err < 0)
+		return err;
+	return wait_for_ack(nlh);
+}
+
+#define NFNLMSG_QUEUE_TYPE(type) NFNLMSG_TYPE(NFNL_SUBSYS_QUEUE, (type))
+static struct nl_cache_ops nfnl_queue_msg_ops = {
+	.co_name		= "netfilter/queue_msg",
+	.co_hdrsize		= NFNL_HDRLEN,
+	.co_msgtypes		= {
+		{ NFNLMSG_QUEUE_TYPE(NFQNL_MSG_PACKET), NL_ACT_NEW, "new" },
+		END_OF_MSGTYPES_LIST,
+	},
+	.co_protocol		= NETLINK_NETFILTER,
+	.co_msg_parser		= queue_msg_parser,
+	.co_obj_ops		= &queue_msg_obj_ops,
+};
+
+static void __init nfnl_msg_queue_init(void)
+{
+	nl_cache_mngt_register(&nfnl_queue_msg_ops);
+}
+
+static void __exit nfnl_queue_msg_exit(void)
+{
+	nl_cache_mngt_unregister(&nfnl_queue_msg_ops);
+}
+
+/** @} */
diff -uNr libnl_kk/lib/netfilter/queue_msg_obj.c libnl/lib/netfilter/queue_msg_obj.c
--- libnl_kk/lib/netfilter/queue_msg_obj.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/netfilter/queue_msg_obj.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,492 @@
+/*
+ * lib/netfilter/queue_msg_obj.c	Netfilter Queue Message Object
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2007, 2008 Patrick McHardy <kaber@trash.net>
+ */
+
+#include <netlink-local.h>
+#include <netlink/netfilter/nfnl.h>
+#include <netlink/netfilter/netfilter.h>
+#include <netlink/netfilter/queue_msg.h>
+#include <linux/netfilter.h>
+
+/** @cond SKIP */
+#define QUEUE_MSG_ATTR_GROUP		(1UL << 0)
+#define QUEUE_MSG_ATTR_FAMILY		(1UL << 1)
+#define QUEUE_MSG_ATTR_PACKETID		(1UL << 2)
+#define QUEUE_MSG_ATTR_HWPROTO		(1UL << 3)
+#define QUEUE_MSG_ATTR_HOOK		(1UL << 4)
+#define QUEUE_MSG_ATTR_MARK		(1UL << 5)
+#define QUEUE_MSG_ATTR_TIMESTAMP	(1UL << 6)
+#define QUEUE_MSG_ATTR_INDEV		(1UL << 7)
+#define QUEUE_MSG_ATTR_OUTDEV		(1UL << 8)
+#define QUEUE_MSG_ATTR_PHYSINDEV	(1UL << 9)
+#define QUEUE_MSG_ATTR_PHYSOUTDEV	(1UL << 10)
+#define QUEUE_MSG_ATTR_HWADDR		(1UL << 11)
+#define QUEUE_MSG_ATTR_PAYLOAD		(1UL << 12)
+#define QUEUE_MSG_ATTR_VERDICT		(1UL << 13)
+/** @endcond */
+
+static void nfnl_queue_msg_free_data(struct nl_object *c)
+{
+	struct nfnl_queue_msg *msg = (struct nfnl_queue_msg *) c;
+
+	if (msg == NULL)
+		return;
+
+	free(msg->queue_msg_payload);
+}
+
+static int nfnl_queue_msg_clone(struct nl_object *_dst, struct nl_object *_src)
+{
+	struct nfnl_queue_msg *dst = (struct nfnl_queue_msg *) _dst;
+	struct nfnl_queue_msg *src = (struct nfnl_queue_msg *) _src;
+	int err;
+
+	if (src->queue_msg_payload) {
+		err = nfnl_queue_msg_set_payload(dst, src->queue_msg_payload,
+						 src->queue_msg_payload_len);
+		if (err < 0)
+			goto errout;
+	}
+
+	return 0;
+errout:
+	return err;
+}
+
+static void nfnl_queue_msg_dump(struct nl_object *a, struct nl_dump_params *p)
+{
+	struct nfnl_queue_msg *msg = (struct nfnl_queue_msg *) a;
+	struct nl_cache *link_cache;
+	char buf[64];
+
+	link_cache = nl_cache_mngt_require("route/link");
+
+	nl_new_line(p);
+
+	if (msg->ce_mask & QUEUE_MSG_ATTR_GROUP)
+		nl_dump(p, "GROUP=%u ", msg->queue_msg_group);
+
+	if (msg->ce_mask & QUEUE_MSG_ATTR_INDEV) {
+		if (link_cache)
+			nl_dump(p, "IN=%s ",
+				rtnl_link_i2name(link_cache,
+						 msg->queue_msg_indev,
+						 buf, sizeof(buf)));
+		else
+			nl_dump(p, "IN=%d ", msg->queue_msg_indev);
+	}
+
+	if (msg->ce_mask & QUEUE_MSG_ATTR_PHYSINDEV) {
+		if (link_cache)
+			nl_dump(p, "PHYSIN=%s ",
+				rtnl_link_i2name(link_cache,
+						 msg->queue_msg_physindev,
+						 buf, sizeof(buf)));
+		else
+			nl_dump(p, "IN=%d ", msg->queue_msg_physindev);
+	}
+
+	if (msg->ce_mask & QUEUE_MSG_ATTR_OUTDEV) {
+		if (link_cache)
+			nl_dump(p, "OUT=%s ",
+				rtnl_link_i2name(link_cache,
+						 msg->queue_msg_outdev,
+						 buf, sizeof(buf)));
+		else
+			nl_dump(p, "OUT=%d ", msg->queue_msg_outdev);
+	}
+
+	if (msg->ce_mask & QUEUE_MSG_ATTR_PHYSOUTDEV) {
+		if (link_cache)
+			nl_dump(p, "PHYSOUT=%s ",
+				rtnl_link_i2name(link_cache,
+						 msg->queue_msg_physoutdev,
+						 buf, sizeof(buf)));
+		else
+			nl_dump(p, "PHYSOUT=%d ", msg->queue_msg_physoutdev);
+	}
+
+	if (msg->ce_mask & QUEUE_MSG_ATTR_HWADDR) {
+		int i;
+
+		nl_dump(p, "MAC");
+		for (i = 0; i < msg->queue_msg_hwaddr_len; i++)
+			nl_dump(p, "%c%02x", i?':':'=',
+				msg->queue_msg_hwaddr[i]);
+		nl_dump(p, " ");
+	}
+
+	if (msg->ce_mask & QUEUE_MSG_ATTR_FAMILY)
+		nl_dump(p, "FAMILY=%s ",
+			nl_af2str(msg->queue_msg_family, buf, sizeof(buf)));
+
+	if (msg->ce_mask & QUEUE_MSG_ATTR_HWPROTO)
+		nl_dump(p, "HWPROTO=%s ",
+			nl_ether_proto2str(ntohs(msg->queue_msg_hwproto),
+					   buf, sizeof(buf)));
+
+	if (msg->ce_mask & QUEUE_MSG_ATTR_HOOK)
+		nl_dump(p, "HOOK=%s ",
+			nfnl_inet_hook2str(msg->queue_msg_hook,
+					   buf, sizeof(buf)));
+
+	if (msg->ce_mask & QUEUE_MSG_ATTR_MARK)
+		nl_dump(p, "MARK=%d ", msg->queue_msg_mark);
+
+	if (msg->ce_mask & QUEUE_MSG_ATTR_PAYLOAD)
+		nl_dump(p, "PAYLOADLEN=%d ", msg->queue_msg_payload_len);
+
+	if (msg->ce_mask & QUEUE_MSG_ATTR_PACKETID)
+		nl_dump(p, "PACKETID=%u ", msg->queue_msg_packetid);
+
+	if (msg->ce_mask & QUEUE_MSG_ATTR_VERDICT)
+		nl_dump(p, "VERDICT=%s ",
+			nfnl_verdict2str(msg->queue_msg_verdict,
+					 buf, sizeof(buf)));
+
+	nl_dump(p, "\n");
+}
+
+/**
+ * @name Allocation/Freeing
+ * @{
+ */
+
+struct nfnl_queue_msg *nfnl_queue_msg_alloc(void)
+{
+	return (struct nfnl_queue_msg *) nl_object_alloc(&queue_msg_obj_ops);
+}
+
+void nfnl_queue_msg_get(struct nfnl_queue_msg *msg)
+{
+	nl_object_get((struct nl_object *) msg);
+}
+
+void nfnl_queue_msg_put(struct nfnl_queue_msg *msg)
+{
+	nl_object_put((struct nl_object *) msg);
+}
+
+/** @} */
+
+/**
+ * @name Attributes
+ * @{
+ */
+
+void nfnl_queue_msg_set_group(struct nfnl_queue_msg *msg, uint16_t group)
+{
+	msg->queue_msg_group = group;
+	msg->ce_mask |= QUEUE_MSG_ATTR_GROUP;
+}
+
+int nfnl_queue_msg_test_group(const struct nfnl_queue_msg *msg)
+{
+	return !!(msg->ce_mask & QUEUE_MSG_ATTR_GROUP);
+}
+
+uint16_t nfnl_queue_msg_get_group(const struct nfnl_queue_msg *msg)
+{
+	return msg->queue_msg_group;
+}
+
+/**
+* Set the protocol family
+* @arg msg         NF queue message
+* @arg family      AF_XXX  address family  example: AF_INET, AF_UNIX, etc
+*/
+void nfnl_queue_msg_set_family(struct nfnl_queue_msg *msg, uint8_t family)
+{
+	msg->queue_msg_family = family;
+	msg->ce_mask |= QUEUE_MSG_ATTR_FAMILY;
+}
+
+int nfnl_queue_msg_test_family(const struct nfnl_queue_msg *msg)
+{
+	return !!(msg->ce_mask & QUEUE_MSG_ATTR_FAMILY);
+}
+
+uint8_t nfnl_queue_msg_get_family(const struct nfnl_queue_msg *msg)
+{
+	if (msg->ce_mask & QUEUE_MSG_ATTR_FAMILY)
+		return msg->queue_msg_family;
+	else
+		return AF_UNSPEC;
+}
+
+void nfnl_queue_msg_set_packetid(struct nfnl_queue_msg *msg, uint32_t packetid)
+{
+	msg->queue_msg_packetid = packetid;
+	msg->ce_mask |= QUEUE_MSG_ATTR_PACKETID;
+}
+
+int nfnl_queue_msg_test_packetid(const struct nfnl_queue_msg *msg)
+{
+	return !!(msg->ce_mask & QUEUE_MSG_ATTR_PACKETID);
+}
+
+uint32_t nfnl_queue_msg_get_packetid(const struct nfnl_queue_msg *msg)
+{
+	return msg->queue_msg_packetid;
+}
+
+void nfnl_queue_msg_set_hwproto(struct nfnl_queue_msg *msg, uint16_t hwproto)
+{
+	msg->queue_msg_hwproto = hwproto;
+	msg->ce_mask |= QUEUE_MSG_ATTR_HWPROTO;
+}
+
+int nfnl_queue_msg_test_hwproto(const struct nfnl_queue_msg *msg)
+{
+	return !!(msg->ce_mask & QUEUE_MSG_ATTR_HWPROTO);
+}
+
+uint16_t nfnl_queue_msg_get_hwproto(const struct nfnl_queue_msg *msg)
+{
+	return msg->queue_msg_hwproto;
+}
+
+void nfnl_queue_msg_set_hook(struct nfnl_queue_msg *msg, uint8_t hook)
+{
+	msg->queue_msg_hook = hook;
+	msg->ce_mask |= QUEUE_MSG_ATTR_HOOK;
+}
+
+int nfnl_queue_msg_test_hook(const struct nfnl_queue_msg *msg)
+{
+	return !!(msg->ce_mask & QUEUE_MSG_ATTR_HOOK);
+}
+
+uint8_t nfnl_queue_msg_get_hook(const struct nfnl_queue_msg *msg)
+{
+	return msg->queue_msg_hook;
+}
+
+void nfnl_queue_msg_set_mark(struct nfnl_queue_msg *msg, uint32_t mark)
+{
+	msg->queue_msg_mark = mark;
+	msg->ce_mask |= QUEUE_MSG_ATTR_MARK;
+}
+
+int nfnl_queue_msg_test_mark(const struct nfnl_queue_msg *msg)
+{
+	return !!(msg->ce_mask & QUEUE_MSG_ATTR_MARK);
+}
+
+uint32_t nfnl_queue_msg_get_mark(const struct nfnl_queue_msg *msg)
+{
+	return msg->queue_msg_mark;
+}
+
+void nfnl_queue_msg_set_timestamp(struct nfnl_queue_msg *msg,
+				  struct timeval *tv)
+{
+	msg->queue_msg_timestamp.tv_sec = tv->tv_sec;
+	msg->queue_msg_timestamp.tv_usec = tv->tv_usec;
+	msg->ce_mask |= QUEUE_MSG_ATTR_TIMESTAMP;
+}
+
+int nfnl_queue_msg_test_timestamp(const struct nfnl_queue_msg *msg)
+{
+	return !!(msg->ce_mask & QUEUE_MSG_ATTR_TIMESTAMP);
+}
+
+const struct timeval *nfnl_queue_msg_get_timestamp(const struct nfnl_queue_msg *msg)
+{
+	if (!(msg->ce_mask & QUEUE_MSG_ATTR_TIMESTAMP))
+		return NULL;
+	return &msg->queue_msg_timestamp;
+}
+
+void nfnl_queue_msg_set_indev(struct nfnl_queue_msg *msg, uint32_t indev)
+{
+	msg->queue_msg_indev = indev;
+	msg->ce_mask |= QUEUE_MSG_ATTR_INDEV;
+}
+
+int nfnl_queue_msg_test_indev(const struct nfnl_queue_msg *msg)
+{
+	return !!(msg->ce_mask & QUEUE_MSG_ATTR_INDEV);
+}
+
+uint32_t nfnl_queue_msg_get_indev(const struct nfnl_queue_msg *msg)
+{
+	return msg->queue_msg_indev;
+}
+
+void nfnl_queue_msg_set_outdev(struct nfnl_queue_msg *msg, uint32_t outdev)
+{
+	msg->queue_msg_outdev = outdev;
+	msg->ce_mask |= QUEUE_MSG_ATTR_OUTDEV;
+}
+
+int nfnl_queue_msg_test_outdev(const struct nfnl_queue_msg *msg)
+{
+	return !!(msg->ce_mask & QUEUE_MSG_ATTR_OUTDEV);
+}
+
+uint32_t nfnl_queue_msg_get_outdev(const struct nfnl_queue_msg *msg)
+{
+	return msg->queue_msg_outdev;
+}
+
+void nfnl_queue_msg_set_physindev(struct nfnl_queue_msg *msg,
+				  uint32_t physindev)
+{
+	msg->queue_msg_physindev = physindev;
+	msg->ce_mask |= QUEUE_MSG_ATTR_PHYSINDEV;
+}
+
+int nfnl_queue_msg_test_physindev(const struct nfnl_queue_msg *msg)
+{
+	return !!(msg->ce_mask & QUEUE_MSG_ATTR_PHYSINDEV);
+}
+
+uint32_t nfnl_queue_msg_get_physindev(const struct nfnl_queue_msg *msg)
+{
+	return msg->queue_msg_physindev;
+}
+
+void nfnl_queue_msg_set_physoutdev(struct nfnl_queue_msg *msg,
+				   uint32_t physoutdev)
+{
+	msg->queue_msg_physoutdev = physoutdev;
+	msg->ce_mask |= QUEUE_MSG_ATTR_PHYSOUTDEV;
+}
+
+int nfnl_queue_msg_test_physoutdev(const struct nfnl_queue_msg *msg)
+{
+	return !!(msg->ce_mask & QUEUE_MSG_ATTR_PHYSOUTDEV);
+}
+
+uint32_t nfnl_queue_msg_get_physoutdev(const struct nfnl_queue_msg *msg)
+{
+	return msg->queue_msg_physoutdev;
+}
+
+void nfnl_queue_msg_set_hwaddr(struct nfnl_queue_msg *msg, uint8_t *hwaddr,
+			       int len)
+{
+	if (len > sizeof(msg->queue_msg_hwaddr))
+		len = sizeof(msg->queue_msg_hwaddr);
+
+	msg->queue_msg_hwaddr_len = len;
+	memcpy(msg->queue_msg_hwaddr, hwaddr, len);
+	msg->ce_mask |= QUEUE_MSG_ATTR_HWADDR;
+}
+
+int nfnl_queue_msg_test_hwaddr(const struct nfnl_queue_msg *msg)
+{
+	return !!(msg->ce_mask & QUEUE_MSG_ATTR_HWADDR);
+}
+
+const uint8_t *nfnl_queue_msg_get_hwaddr(const struct nfnl_queue_msg *msg,
+					 int *len)
+{
+	if (!(msg->ce_mask & QUEUE_MSG_ATTR_HWADDR)) {
+		*len = 0;
+		return NULL;
+	}
+
+	*len = msg->queue_msg_hwaddr_len;
+	return msg->queue_msg_hwaddr;
+}
+
+int nfnl_queue_msg_set_payload(struct nfnl_queue_msg *msg, uint8_t *payload,
+			       int len)
+{
+	free(msg->queue_msg_payload);
+	msg->queue_msg_payload = malloc(len);
+	if (!msg->queue_msg_payload)
+		return -NLE_NOMEM;
+
+	memcpy(msg->queue_msg_payload, payload, len);
+	msg->queue_msg_payload_len = len;
+	msg->ce_mask |= QUEUE_MSG_ATTR_PAYLOAD;
+	return 0;
+}
+
+int nfnl_queue_msg_test_payload(const struct nfnl_queue_msg *msg)
+{
+	return !!(msg->ce_mask & QUEUE_MSG_ATTR_PAYLOAD);
+}
+
+const void *nfnl_queue_msg_get_payload(const struct nfnl_queue_msg *msg, int *len)
+{
+	if (!(msg->ce_mask & QUEUE_MSG_ATTR_PAYLOAD)) {
+		*len = 0;
+		return NULL;
+	}
+
+	*len = msg->queue_msg_payload_len;
+	return msg->queue_msg_payload;
+}
+
+/**
+* Return the number of items matching a filter in the cache
+* @arg msg        queue msg
+* @arg verdict    NF_DROP, NF_ACCEPT, NF_REPEAT, etc
+*/
+void nfnl_queue_msg_set_verdict(struct nfnl_queue_msg *msg,
+				unsigned int verdict)
+{
+	msg->queue_msg_verdict = verdict;
+	msg->ce_mask |= QUEUE_MSG_ATTR_VERDICT;
+}
+
+int nfnl_queue_msg_test_verdict(const struct nfnl_queue_msg *msg)
+{
+	return !!(msg->ce_mask & QUEUE_MSG_ATTR_VERDICT);
+}
+
+unsigned int nfnl_queue_msg_get_verdict(const struct nfnl_queue_msg *msg)
+{
+	return msg->queue_msg_verdict;
+}
+
+static struct trans_tbl nfnl_queue_msg_attrs[] = {
+	__ADD(QUEUE_MSG_ATTR_GROUP,		group)
+	__ADD(QUEUE_MSG_ATTR_FAMILY,		family)
+	__ADD(QUEUE_MSG_ATTR_PACKETID,		packetid)
+	__ADD(QUEUE_MSG_ATTR_HWPROTO,		hwproto)
+	__ADD(QUEUE_MSG_ATTR_HOOK,		hook)
+	__ADD(QUEUE_MSG_ATTR_MARK,		mark)
+	__ADD(QUEUE_MSG_ATTR_TIMESTAMP,		timestamp)
+	__ADD(QUEUE_MSG_ATTR_INDEV,		indev)
+	__ADD(QUEUE_MSG_ATTR_OUTDEV,		outdev)
+	__ADD(QUEUE_MSG_ATTR_PHYSINDEV,		physindev)
+	__ADD(QUEUE_MSG_ATTR_PHYSOUTDEV,	physoutdev)
+	__ADD(QUEUE_MSG_ATTR_HWADDR,		hwaddr)
+	__ADD(QUEUE_MSG_ATTR_PAYLOAD,		payload)
+	__ADD(QUEUE_MSG_ATTR_VERDICT,		verdict)
+};
+
+static char *nfnl_queue_msg_attrs2str(int attrs, char *buf, size_t len)
+{
+	return __flags2str(attrs, buf, len, nfnl_queue_msg_attrs,
+			   ARRAY_SIZE(nfnl_queue_msg_attrs));
+}
+
+/** @} */
+
+struct nl_object_ops queue_msg_obj_ops = {
+	.oo_name		= "netfilter/queuemsg",
+	.oo_size		= sizeof(struct nfnl_queue_msg),
+	.oo_free_data		= nfnl_queue_msg_free_data,
+	.oo_clone		= nfnl_queue_msg_clone,
+	.oo_dump = {
+	    [NL_DUMP_LINE]	= nfnl_queue_msg_dump,
+	    [NL_DUMP_DETAILS]	= nfnl_queue_msg_dump,
+	    [NL_DUMP_STATS]	= nfnl_queue_msg_dump,
+	},
+	.oo_attrs2str		= nfnl_queue_msg_attrs2str,
+};
+
+/** @} */
diff -uNr libnl_kk/lib/netfilter/queue_obj.c libnl/lib/netfilter/queue_obj.c
--- libnl_kk/lib/netfilter/queue_obj.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/netfilter/queue_obj.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,215 @@
+/*
+ * lib/netfilter/queue_obj.c	Netfilter Queue
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2007, 2008 Patrick McHardy <kaber@trash.net>
+ */
+
+/**
+ * @ingroup nfnl
+ * @defgroup queue Queue
+ * @brief
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink/netfilter/nfnl.h>
+#include <netlink/netfilter/queue.h>
+
+/** @cond SKIP */
+#define QUEUE_ATTR_GROUP		(1UL << 0)
+#define QUEUE_ATTR_MAXLEN		(1UL << 1)
+#define QUEUE_ATTR_COPY_MODE		(1UL << 2)
+#define QUEUE_ATTR_COPY_RANGE		(1UL << 3)
+/** @endcond */
+
+
+static void nfnl_queue_dump(struct nl_object *a, struct nl_dump_params *p)
+{
+	struct nfnl_queue *queue = (struct nfnl_queue *) a;
+	char buf[64];
+
+	nl_new_line(p);
+
+	if (queue->ce_mask & QUEUE_ATTR_GROUP)
+		nl_dump(p, "group=%u ", queue->queue_group);
+
+	if (queue->ce_mask & QUEUE_ATTR_MAXLEN)
+		nl_dump(p, "maxlen=%u ", queue->queue_maxlen);
+
+	if (queue->ce_mask & QUEUE_ATTR_COPY_MODE)
+		nl_dump(p, "copy_mode=%s ",
+			nfnl_queue_copy_mode2str(queue->queue_copy_mode,
+						 buf, sizeof(buf)));
+
+	if (queue->ce_mask & QUEUE_ATTR_COPY_RANGE)
+		nl_dump(p, "copy_range=%u ", queue->queue_copy_range);
+
+	nl_dump(p, "\n");
+}
+
+static struct trans_tbl copy_modes[] = {
+	__ADD(NFNL_QUEUE_COPY_NONE,	none)
+	__ADD(NFNL_QUEUE_COPY_META,	meta)
+	__ADD(NFNL_QUEUE_COPY_PACKET,	packet)
+};
+
+char *nfnl_queue_copy_mode2str(enum nfnl_queue_copy_mode copy_mode, char *buf,
+			       size_t len)
+{
+	return __type2str(copy_mode, buf, len, copy_modes,
+			   ARRAY_SIZE(copy_modes));
+}
+
+enum nfnl_queue_copy_mode nfnl_queue_str2copy_mode(const char *name)
+{
+	return __str2type(name, copy_modes, ARRAY_SIZE(copy_modes));
+}
+
+/**
+ * @name Allocation/Freeing
+ * @{
+ */
+
+struct nfnl_queue *nfnl_queue_alloc(void)
+{
+	return (struct nfnl_queue *) nl_object_alloc(&queue_obj_ops);
+}
+
+void nfnl_queue_get(struct nfnl_queue *queue)
+{
+	nl_object_get((struct nl_object *) queue);
+}
+
+void nfnl_queue_put(struct nfnl_queue *queue)
+{
+	nl_object_put((struct nl_object *) queue);
+}
+
+/** @} */
+
+/**
+ * @name Attributes
+ * @{
+ */
+
+void nfnl_queue_set_group(struct nfnl_queue *queue, uint16_t group)
+{
+	queue->queue_group = group;
+	queue->ce_mask |= QUEUE_ATTR_GROUP;
+}
+
+int nfnl_queue_test_group(const struct nfnl_queue *queue)
+{
+	return !!(queue->ce_mask & QUEUE_ATTR_GROUP);
+}
+
+uint16_t nfnl_queue_get_group(const struct nfnl_queue *queue)
+{
+	return queue->queue_group;
+}
+
+void nfnl_queue_set_maxlen(struct nfnl_queue *queue, uint32_t maxlen)
+{
+	queue->queue_maxlen = maxlen;
+	queue->ce_mask |= QUEUE_ATTR_MAXLEN;
+}
+
+int nfnl_queue_test_maxlen(const struct nfnl_queue *queue)
+{
+	return !!(queue->ce_mask & QUEUE_ATTR_MAXLEN);
+}
+
+uint32_t nfnl_queue_get_maxlen(const struct nfnl_queue *queue)
+{
+	return queue->queue_maxlen;
+}
+
+void nfnl_queue_set_copy_mode(struct nfnl_queue *queue, enum nfnl_queue_copy_mode mode)
+{
+	queue->queue_copy_mode = mode;
+	queue->ce_mask |= QUEUE_ATTR_COPY_MODE;
+}
+
+int nfnl_queue_test_copy_mode(const struct nfnl_queue *queue)
+{
+	return !!(queue->ce_mask & QUEUE_ATTR_COPY_MODE);
+}
+
+enum nfnl_queue_copy_mode nfnl_queue_get_copy_mode(const struct nfnl_queue *queue)
+{
+	return queue->queue_copy_mode;
+}
+
+void nfnl_queue_set_copy_range(struct nfnl_queue *queue, uint32_t copy_range)
+{
+	queue->queue_copy_range = copy_range;
+	queue->ce_mask |= QUEUE_ATTR_COPY_RANGE;
+}
+
+int nfnl_queue_test_copy_range(const struct nfnl_queue *queue)
+{
+	return !!(queue->ce_mask & QUEUE_ATTR_COPY_RANGE);
+}
+
+uint32_t nfnl_queue_get_copy_range(const struct nfnl_queue *queue)
+{
+	return queue->queue_copy_range;
+}
+
+static int nfnl_queue_compare(struct nl_object *_a, struct nl_object *_b,
+			      uint32_t attrs, int flags)
+{
+	struct nfnl_queue *a = (struct nfnl_queue *) _a;
+	struct nfnl_queue *b = (struct nfnl_queue *) _b;
+	int diff = 0;
+
+#define NFNL_QUEUE_DIFF(ATTR, EXPR) \
+	ATTR_DIFF(attrs, QUEUE_ATTR_##ATTR, a, b, EXPR)
+#define NFNL_QUEUE_DIFF_VAL(ATTR, FIELD) \
+	NFNL_QUEUE_DIFF(ATTR, a->FIELD != b->FIELD)
+
+	diff |= NFNL_QUEUE_DIFF_VAL(GROUP,	queue_group);
+	diff |= NFNL_QUEUE_DIFF_VAL(MAXLEN,	queue_maxlen);
+	diff |= NFNL_QUEUE_DIFF_VAL(COPY_MODE,	queue_copy_mode);
+	diff |= NFNL_QUEUE_DIFF_VAL(COPY_RANGE,	queue_copy_range);
+
+#undef NFNL_QUEUE_DIFF
+#undef NFNL_QUEUE_DIFF_VAL
+
+	return diff;
+}
+
+static struct trans_tbl nfnl_queue_attrs[] = {
+	__ADD(QUEUE_ATTR_GROUP,		group)
+	__ADD(QUEUE_ATTR_MAXLEN,	maxlen)
+	__ADD(QUEUE_ATTR_COPY_MODE,	copy_mode)
+	__ADD(QUEUE_ATTR_COPY_RANGE,	copy_range)
+};
+
+static char *nfnl_queue_attrs2str(int attrs, char *buf, size_t len)
+{
+	return __flags2str(attrs, buf, len, nfnl_queue_attrs,
+			   ARRAY_SIZE(nfnl_queue_attrs));
+}
+
+/** @} */
+
+struct nl_object_ops queue_obj_ops = {
+	.oo_name		= "netfilter/queue",
+	.oo_size		= sizeof(struct nfnl_queue),
+	.oo_dump = {
+	    [NL_DUMP_LINE]	= nfnl_queue_dump,
+	    [NL_DUMP_DETAILS]	= nfnl_queue_dump,
+	    [NL_DUMP_STATS]	= nfnl_queue_dump,
+	},
+	.oo_compare		= nfnl_queue_compare,
+	.oo_attrs2str		= nfnl_queue_attrs2str,
+	.oo_id_attrs		= QUEUE_ATTR_GROUP,
+};
+
+/** @} */
diff -uNr libnl_kk/lib/nl.c libnl/lib/nl.c
--- libnl_kk/lib/nl.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/nl.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,752 @@
+/*
+ * lib/nl.c		Core Netlink Interface
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @defgroup core Core
+ *
+ * @details
+ * @par 1) Connecting the socket
+ * @code
+ * // Bind and connect the socket to a protocol, NETLINK_ROUTE in this example.
+ * nl_connect(sk, NETLINK_ROUTE);
+ * @endcode
+ *
+ * @par 2) Sending data
+ * @code
+ * // The most rudimentary method is to use nl_sendto() simply pushing
+ * // a piece of data to the other netlink peer. This method is not
+ * // recommended.
+ * const char buf[] = { 0x01, 0x02, 0x03, 0x04 };
+ * nl_sendto(sk, buf, sizeof(buf));
+ *
+ * // A more comfortable interface is nl_send() taking a pointer to
+ * // a netlink message.
+ * struct nl_msg *msg = my_msg_builder();
+ * nl_send(sk, nlmsg_hdr(msg));
+ *
+ * // nl_sendmsg() provides additional control over the sendmsg() message
+ * // header in order to allow more specific addressing of multiple peers etc.
+ * struct msghdr hdr = { ... };
+ * nl_sendmsg(sk, nlmsg_hdr(msg), &hdr);
+ *
+ * // You're probably too lazy to fill out the netlink pid, sequence number
+ * // and message flags all the time. nl_send_auto_complete() automatically
+ * // extends your message header as needed with an appropriate sequence
+ * // number, the netlink pid stored in the netlink socket and the message
+ * // flags NLM_F_REQUEST and NLM_F_ACK (if not disabled in the socket)
+ * nl_send_auto_complete(sk, nlmsg_hdr(msg));
+ *
+ * // Simple protocols don't require the complex message construction interface
+ * // and may favour nl_send_simple() to easly send a bunch of payload
+ * // encapsulated in a netlink message header.
+ * nl_send_simple(sk, MY_MSG_TYPE, 0, buf, sizeof(buf));
+ * @endcode
+ *
+ * @par 3) Receiving data
+ * @code
+ * // nl_recv() receives a single message allocating a buffer for the message
+ * // content and gives back the pointer to you.
+ * struct sockaddr_nl peer;
+ * unsigned char *msg;
+ * nl_recv(sk, &peer, &msg);
+ *
+ * // nl_recvmsgs() receives a bunch of messages until the callback system
+ * // orders it to state, usually after receving a compolete multi part
+ * // message series.
+ * nl_recvmsgs(sk, my_callback_configuration);
+ *
+ * // nl_recvmsgs_default() acts just like nl_recvmsg() but uses the callback
+ * // configuration stored in the socket.
+ * nl_recvmsgs_default(sk);
+ *
+ * // In case you want to wait for the ACK to be recieved that you requested
+ * // with your latest message, you can call nl_wait_for_ack()
+ * nl_wait_for_ack(sk);
+ * @endcode
+ *
+ * @par 4) Closing
+ * @code
+ * // Close the socket first to release kernel memory
+ * nl_close(sk);
+ * @endcode
+ * 
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink/netlink.h>
+#include <netlink/utils.h>
+#include <netlink/handlers.h>
+#include <netlink/msg.h>
+#include <netlink/attr.h>
+
+/**
+ * @name Connection Management
+ * @{
+ */
+
+/**
+ * Create and connect netlink socket.
+ * @arg sk		Netlink socket.
+ * @arg protocol	Netlink protocol to use.
+ *
+ * Creates a netlink socket using the specified protocol, binds the socket
+ * and issues a connection attempt.
+ *
+ * @return 0 on success or a negative error code.
+ */
+int nl_connect(struct nl_sock *sk, int protocol)
+{
+	int err;
+	socklen_t addrlen;
+
+	sk->s_fd = socket(AF_NETLINK, SOCK_RAW, protocol);
+	if (sk->s_fd < 0) {
+		err = -nl_syserr2nlerr(errno);
+		goto errout;
+	}
+
+	if (!(sk->s_flags & NL_SOCK_BUFSIZE_SET)) {
+		err = nl_socket_set_buffer_size(sk, 0, 0);
+		if (err < 0)
+			goto errout;
+	}
+
+	err = bind(sk->s_fd, (struct sockaddr*) &sk->s_local,
+		   sizeof(sk->s_local));
+	if (err < 0) {
+		err = -nl_syserr2nlerr(errno);
+		goto errout;
+	}
+
+	addrlen = sizeof(sk->s_local);
+	err = getsockname(sk->s_fd, (struct sockaddr *) &sk->s_local,
+			  &addrlen);
+	if (err < 0) {
+		err = -nl_syserr2nlerr(errno);
+		goto errout;
+	}
+
+	if (addrlen != sizeof(sk->s_local)) {
+		err = -NLE_NOADDR;
+		goto errout;
+	}
+
+	if (sk->s_local.nl_family != AF_NETLINK) {
+		err = -NLE_AF_NOSUPPORT;
+		goto errout;
+	}
+
+	sk->s_proto = protocol;
+
+	return 0;
+errout:
+	close(sk->s_fd);
+	sk->s_fd = -1;
+
+	return err;
+}
+
+/**
+ * Close/Disconnect netlink socket.
+ * @arg sk		Netlink socket.
+ */
+void nl_close(struct nl_sock *sk)
+{
+	if (sk->s_fd >= 0) {
+		close(sk->s_fd);
+		sk->s_fd = -1;
+	}
+
+	sk->s_proto = 0;
+}
+
+/** @} */
+
+/**
+ * @name Send
+ * @{
+ */
+
+/**
+ * Send raw data over netlink socket.
+ * @arg sk		Netlink socket.
+ * @arg buf		Data buffer.
+ * @arg size		Size of data buffer.
+ * @return Number of characters written on success or a negative error code.
+ */
+int nl_sendto(struct nl_sock *sk, void *buf, size_t size)
+{
+	int ret;
+
+	ret = sendto(sk->s_fd, buf, size, 0, (struct sockaddr *)
+		     &sk->s_peer, sizeof(sk->s_peer));
+	if (ret < 0)
+		return -nl_syserr2nlerr(errno);
+
+	return ret;
+}
+
+/**
+ * Send netlink message with control over sendmsg() message header.
+ * @arg sk		Netlink socket.
+ * @arg msg		Netlink message to be sent.
+ * @arg hdr		Sendmsg() message header.
+ * @return Number of characters sent on sucess or a negative error code.
+ */
+int nl_sendmsg(struct nl_sock *sk, struct nl_msg *msg, struct msghdr *hdr)
+{
+	struct nl_cb *cb;
+	int ret;
+
+	nlmsg_set_src(msg, &sk->s_local);
+
+	cb = sk->s_cb;
+	if (cb->cb_set[NL_CB_MSG_OUT])
+		if (nl_cb_call(cb, NL_CB_MSG_OUT, msg) != NL_OK)
+			return 0;
+
+	ret = sendmsg(sk->s_fd, hdr, 0);
+	if (ret < 0)
+		return -nl_syserr2nlerr(errno);
+
+	NL_DBG(4, "sent %d bytes\n", ret);
+	return ret;
+}
+
+
+/**
+ * Send netlink message.
+ * @arg sk		Netlink socket.
+ * @arg msg		Netlink message to be sent.
+ * @arg iov		iovec to be sent.
+ * @arg iovlen		number of struct iovec to be sent.
+ * @see nl_sendmsg()
+ * @return Number of characters sent on success or a negative error code.
+ */
+int nl_send_iovec(struct nl_sock *sk, struct nl_msg *msg, struct iovec *iov, unsigned iovlen)
+{
+	struct sockaddr_nl *dst;
+	struct ucred *creds;
+	struct msghdr hdr = {
+		.msg_name = (void *) &sk->s_peer,
+		.msg_namelen = sizeof(struct sockaddr_nl),
+		.msg_iov = iov,
+		.msg_iovlen = iovlen,
+	};
+
+	/* Overwrite destination if specified in the message itself, defaults
+	 * to the peer address of the socket.
+	 */
+	dst = nlmsg_get_dst(msg);
+	if (dst->nl_family == AF_NETLINK)
+		hdr.msg_name = dst;
+
+	/* Add credentials if present. */
+	creds = nlmsg_get_creds(msg);
+	if (creds != NULL) {
+		char buf[CMSG_SPACE(sizeof(struct ucred))];
+		struct cmsghdr *cmsg;
+
+		hdr.msg_control = buf;
+		hdr.msg_controllen = sizeof(buf);
+
+		cmsg = CMSG_FIRSTHDR(&hdr);
+		cmsg->cmsg_level = SOL_SOCKET;
+		cmsg->cmsg_type = SCM_CREDENTIALS;
+		cmsg->cmsg_len = CMSG_LEN(sizeof(struct ucred));
+		memcpy(CMSG_DATA(cmsg), creds, sizeof(struct ucred));
+	}
+
+	return nl_sendmsg(sk, msg, &hdr);
+}
+
+
+
+/**
+* Send netlink message.
+* @arg sk		Netlink socket.
+* @arg msg		Netlink message to be sent.
+* @see nl_sendmsg()
+* @return Number of characters sent on success or a negative error code.
+*/
+int nl_send(struct nl_sock *sk, struct nl_msg *msg)
+{
+	struct iovec iov = {
+		.iov_base = (void *) nlmsg_hdr(msg),
+		.iov_len = nlmsg_hdr(msg)->nlmsg_len,
+	};
+
+	return nl_send_iovec(sk, msg, &iov, 1);
+}
+
+void nl_auto_complete(struct nl_sock *sk, struct nl_msg *msg)
+{
+	struct nlmsghdr *nlh;
+
+	nlh = nlmsg_hdr(msg);
+	if (nlh->nlmsg_pid == 0)
+		nlh->nlmsg_pid = sk->s_local.nl_pid;
+
+	if (nlh->nlmsg_seq == 0)
+		nlh->nlmsg_seq = sk->s_seq_next++;
+
+	if (msg->nm_protocol == -1)
+		msg->nm_protocol = sk->s_proto;
+
+	nlh->nlmsg_flags |= NLM_F_REQUEST;
+
+	if (!(sk->s_flags & NL_NO_AUTO_ACK))
+		nlh->nlmsg_flags |= NLM_F_ACK;
+}
+
+/**
+ * Send netlink message and check & extend header values as needed.
+ * @arg sk		Netlink socket.
+ * @arg msg		Netlink message to be sent.
+ *
+ * Checks the netlink message \c nlh for completness and extends it
+ * as required before sending it out. Checked fields include pid,
+ * sequence nr, and flags.
+ *
+ * @see nl_send()
+ * @return Number of characters sent or a negative error code.
+ */
+int nl_send_auto_complete(struct nl_sock *sk, struct nl_msg *msg)
+{
+	struct nl_cb *cb = sk->s_cb;
+
+	nl_auto_complete(sk, msg);
+
+	if (cb->cb_send_ow)
+		return cb->cb_send_ow(sk, msg);
+	else
+		return nl_send(sk, msg);
+}
+
+/**
+ * Send simple netlink message using nl_send_auto_complete()
+ * @arg sk		Netlink socket.
+ * @arg type		Netlink message type.
+ * @arg flags		Netlink message flags.
+ * @arg buf		Data buffer.
+ * @arg size		Size of data buffer.
+ *
+ * Builds a netlink message with the specified type and flags and
+ * appends the specified data as payload to the message.
+ *
+ * @see nl_send_auto_complete()
+ * @return Number of characters sent on success or a negative error code.
+ */
+int nl_send_simple(struct nl_sock *sk, int type, int flags, void *buf,
+		   size_t size)
+{
+	int err;
+	struct nl_msg *msg;
+
+	msg = nlmsg_alloc_simple(type, flags);
+	if (!msg)
+		return -NLE_NOMEM;
+
+	if (buf && size) {
+		err = nlmsg_append(msg, buf, size, NLMSG_ALIGNTO);
+		if (err < 0)
+			goto errout;
+	}
+	
+
+	err = nl_send_auto_complete(sk, msg);
+errout:
+	nlmsg_free(msg);
+
+	return err;
+}
+
+/** @} */
+
+/**
+ * @name Receive
+ * @{
+ */
+
+/**
+ * Receive data from netlink socket
+ * @arg sk		Netlink socket.
+ * @arg nla		Destination pointer for peer's netlink address.
+ * @arg buf		Destination pointer for message content.
+ * @arg creds		Destination pointer for credentials.
+ *
+ * Receives a netlink message, allocates a buffer in \c *buf and
+ * stores the message content. The peer's netlink address is stored
+ * in \c *nla. The caller is responsible for freeing the buffer allocated
+ * in \c *buf if a positive value is returned.  Interruped system calls
+ * are handled by repeating the read. The input buffer size is determined
+ * by peeking before the actual read is done.
+ *
+ * A non-blocking sockets causes the function to return immediately with
+ * a return value of 0 if no data is available.
+ *
+ * @return Number of octets read, 0 on EOF or a negative error code.
+ */
+int nl_recv(struct nl_sock *sk, struct sockaddr_nl *nla,
+	    unsigned char **buf, struct ucred **creds)
+{
+	int n;
+	int flags = 0;
+	static int page_size = 0;
+	struct iovec iov;
+	struct msghdr msg = {
+		.msg_name = (void *) nla,
+		.msg_namelen = sizeof(struct sockaddr_nl),
+		.msg_iov = &iov,
+		.msg_iovlen = 1,
+		.msg_control = NULL,
+		.msg_controllen = 0,
+		.msg_flags = 0,
+	};
+	struct cmsghdr *cmsg;
+
+	if (sk->s_flags & NL_MSG_PEEK)
+		flags |= MSG_PEEK;
+
+	if (page_size == 0)
+		page_size = getpagesize();
+
+	iov.iov_len = page_size;
+	iov.iov_base = *buf = malloc(iov.iov_len);
+
+	if (sk->s_flags & NL_SOCK_PASSCRED) {
+		msg.msg_controllen = CMSG_SPACE(sizeof(struct ucred));
+		msg.msg_control = calloc(1, msg.msg_controllen);
+	}
+retry:
+
+	n = recvmsg(sk->s_fd, &msg, flags);
+	if (!n)
+		goto abort;
+	else if (n < 0) {
+		if (errno == EINTR) {
+			NL_DBG(3, "recvmsg() returned EINTR, retrying\n");
+			goto retry;
+		} else if (errno == EAGAIN) {
+			NL_DBG(3, "recvmsg() returned EAGAIN, aborting\n");
+			goto abort;
+		} else {
+			free(msg.msg_control);
+			free(*buf);
+			return -nl_syserr2nlerr(errno);
+		}
+	}
+
+	if (iov.iov_len < n ||
+	    msg.msg_flags & MSG_TRUNC) {
+		/* Provided buffer is not long enough, enlarge it
+		 * and try again. */
+		iov.iov_len *= 2;
+		iov.iov_base = *buf = realloc(*buf, iov.iov_len);
+		goto retry;
+	} else if (msg.msg_flags & MSG_CTRUNC) {
+		msg.msg_controllen *= 2;
+		msg.msg_control = realloc(msg.msg_control, msg.msg_controllen);
+		goto retry;
+	} else if (flags != 0) {
+		/* Buffer is big enough, do the actual reading */
+		flags = 0;
+		goto retry;
+	}
+
+	if (msg.msg_namelen != sizeof(struct sockaddr_nl)) {
+		free(msg.msg_control);
+		free(*buf);
+		return -NLE_NOADDR;
+	}
+
+	for (cmsg = CMSG_FIRSTHDR(&msg); cmsg; cmsg = CMSG_NXTHDR(&msg, cmsg)) {
+		if (cmsg->cmsg_level == SOL_SOCKET &&
+		    cmsg->cmsg_type == SCM_CREDENTIALS) {
+			*creds = calloc(1, sizeof(struct ucred));
+			memcpy(*creds, CMSG_DATA(cmsg), sizeof(struct ucred));
+			break;
+		}
+	}
+
+	free(msg.msg_control);
+	return n;
+
+abort:
+	free(msg.msg_control);
+	free(*buf);
+	return 0;
+}
+
+#define NL_CB_CALL(cb, type, msg) \
+do { \
+	err = nl_cb_call(cb, type, msg); \
+	switch (err) { \
+	case NL_OK: \
+		err = 0; \
+		break; \
+	case NL_SKIP: \
+		goto skip; \
+	case NL_STOP: \
+		goto stop; \
+	default: \
+		goto out; \
+	} \
+} while (0)
+
+static int recvmsgs(struct nl_sock *sk, struct nl_cb *cb)
+{
+	int n, err = 0, multipart = 0;
+	unsigned char *buf = NULL;
+	struct nlmsghdr *hdr;
+	struct sockaddr_nl nla = {0};
+	struct nl_msg *msg = NULL;
+	struct ucred *creds = NULL;
+
+continue_reading:
+	NL_DBG(3, "Attempting to read from %p\n", sk);
+	if (cb->cb_recv_ow)
+		n = cb->cb_recv_ow(sk, &nla, &buf, &creds);
+	else
+		n = nl_recv(sk, &nla, &buf, &creds);
+
+	if (n <= 0)
+		return n;
+
+	NL_DBG(3, "recvmsgs(%p): Read %d bytes\n", sk, n);
+
+	hdr = (struct nlmsghdr *) buf;
+	while (nlmsg_ok(hdr, n)) {
+		NL_DBG(3, "recgmsgs(%p): Processing valid message...\n", sk);
+
+		nlmsg_free(msg);
+		msg = nlmsg_convert(hdr);
+		if (!msg) {
+			err = -NLE_NOMEM;
+			goto out;
+		}
+
+		nlmsg_set_proto(msg, sk->s_proto);
+		nlmsg_set_src(msg, &nla);
+		if (creds)
+			nlmsg_set_creds(msg, creds);
+
+		/* Raw callback is the first, it gives the most control
+		 * to the user and he can do his very own parsing. */
+		if (cb->cb_set[NL_CB_MSG_IN])
+			NL_CB_CALL(cb, NL_CB_MSG_IN, msg);
+
+		/* Sequence number checking. The check may be done by
+		 * the user, otherwise a very simple check is applied
+		 * enforcing strict ordering */
+		if (cb->cb_set[NL_CB_SEQ_CHECK])
+			NL_CB_CALL(cb, NL_CB_SEQ_CHECK, msg);
+		else if (hdr->nlmsg_seq != sk->s_seq_expect) {
+			if (cb->cb_set[NL_CB_INVALID])
+				NL_CB_CALL(cb, NL_CB_INVALID, msg);
+			else {
+				err = -NLE_SEQ_MISMATCH;
+				goto out;
+			}
+		}
+
+		if (hdr->nlmsg_type == NLMSG_DONE ||
+		    hdr->nlmsg_type == NLMSG_ERROR ||
+		    hdr->nlmsg_type == NLMSG_NOOP ||
+		    hdr->nlmsg_type == NLMSG_OVERRUN) {
+			/* We can't check for !NLM_F_MULTI since some netlink
+			 * users in the kernel are broken. */
+			sk->s_seq_expect++;
+			NL_DBG(3, "recvmsgs(%p): Increased expected " \
+			       "sequence number to %d\n",
+			       sk, sk->s_seq_expect);
+		}
+
+		if (hdr->nlmsg_flags & NLM_F_MULTI)
+			multipart = 1;
+	
+		/* Other side wishes to see an ack for this message */
+		if (hdr->nlmsg_flags & NLM_F_ACK) {
+			if (cb->cb_set[NL_CB_SEND_ACK])
+				NL_CB_CALL(cb, NL_CB_SEND_ACK, msg);
+			else {
+				/* FIXME: implement */
+			}
+		}
+
+		/* messages terminates a multpart message, this is
+		 * usually the end of a message and therefore we slip
+		 * out of the loop by default. the user may overrule
+		 * this action by skipping this packet. */
+		if (hdr->nlmsg_type == NLMSG_DONE) {
+			multipart = 0;
+			if (cb->cb_set[NL_CB_FINISH])
+				NL_CB_CALL(cb, NL_CB_FINISH, msg);
+		}
+
+		/* Message to be ignored, the default action is to
+		 * skip this message if no callback is specified. The
+		 * user may overrule this action by returning
+		 * NL_PROCEED. */
+		else if (hdr->nlmsg_type == NLMSG_NOOP) {
+			if (cb->cb_set[NL_CB_SKIPPED])
+				NL_CB_CALL(cb, NL_CB_SKIPPED, msg);
+			else
+				goto skip;
+		}
+
+		/* Data got lost, report back to user. The default action is to
+		 * quit parsing. The user may overrule this action by retuning
+		 * NL_SKIP or NL_PROCEED (dangerous) */
+		else if (hdr->nlmsg_type == NLMSG_OVERRUN) {
+			if (cb->cb_set[NL_CB_OVERRUN])
+				NL_CB_CALL(cb, NL_CB_OVERRUN, msg);
+			else {
+				err = -NLE_MSG_OVERFLOW;
+				goto out;
+			}
+		}
+
+		/* Message carries a nlmsgerr */
+		else if (hdr->nlmsg_type == NLMSG_ERROR) {
+			struct nlmsgerr *e = nlmsg_data(hdr);
+
+			if (hdr->nlmsg_len < nlmsg_msg_size(sizeof(*e))) {
+				/* Truncated error message, the default action
+				 * is to stop parsing. The user may overrule
+				 * this action by returning NL_SKIP or
+				 * NL_PROCEED (dangerous) */
+				if (cb->cb_set[NL_CB_INVALID])
+					NL_CB_CALL(cb, NL_CB_INVALID, msg);
+				else {
+					err = -NLE_MSG_TRUNC;
+					goto out;
+				}
+			} else if (e->error) {
+				/* Error message reported back from kernel. */
+				if (cb->cb_err) {
+					err = cb->cb_err(&nla, e,
+							   cb->cb_err_arg);
+					if (err < 0)
+						goto out;
+					else if (err == NL_SKIP)
+						goto skip;
+					else if (err == NL_STOP) {
+						err = -nl_syserr2nlerr(e->error);
+						goto out;
+					}
+				} else {
+					err = -nl_syserr2nlerr(e->error);
+					goto out;
+				}
+			} else if (cb->cb_set[NL_CB_ACK])
+				NL_CB_CALL(cb, NL_CB_ACK, msg);
+		} else {
+			/* Valid message (not checking for MULTIPART bit to
+			 * get along with broken kernels. NL_SKIP has no
+			 * effect on this.  */
+			if (cb->cb_set[NL_CB_VALID])
+				NL_CB_CALL(cb, NL_CB_VALID, msg);
+		}
+skip:
+		err = 0;
+		hdr = nlmsg_next(hdr, &n);
+	}
+	
+	nlmsg_free(msg);
+	free(buf);
+	free(creds);
+	buf = NULL;
+	msg = NULL;
+	creds = NULL;
+
+	if (multipart) {
+		/* Multipart message not yet complete, continue reading */
+		goto continue_reading;
+	}
+stop:
+	err = 0;
+out:
+	nlmsg_free(msg);
+	free(buf);
+	free(creds);
+
+	return err;
+}
+
+/**
+ * Receive a set of messages from a netlink socket.
+ * @arg sk		Netlink socket.
+ * @arg cb		set of callbacks to control behaviour.
+ *
+ * Repeatedly calls nl_recv() or the respective replacement if provided
+ * by the application (see nl_cb_overwrite_recv()) and parses the
+ * received data as netlink messages. Stops reading if one of the
+ * callbacks returns NL_STOP or nl_recv returns either 0 or a negative error code.
+ *
+ * A non-blocking sockets causes the function to return immediately if
+ * no data is available.
+ *
+ * @return 0 on success or a negative error code from nl_recv().
+ */
+int nl_recvmsgs(struct nl_sock *sk, struct nl_cb *cb)
+{
+	if (cb->cb_recvmsgs_ow)
+		return cb->cb_recvmsgs_ow(sk, cb);
+	else
+		return recvmsgs(sk, cb);
+}
+
+/**
+ * Receive a set of message from a netlink socket using handlers in nl_sock.
+ * @arg sk		Netlink socket.
+ *
+ * Calls nl_recvmsgs() with the handlers configured in the netlink socket.
+ */
+int nl_recvmsgs_default(struct nl_sock *sk)
+{
+	return nl_recvmsgs(sk, sk->s_cb);
+
+}
+
+static int ack_wait_handler(struct nl_msg *msg, void *arg)
+{
+	return NL_STOP;
+}
+
+/**
+ * Wait for ACK.
+ * @arg sk		Netlink socket.
+ * @pre The netlink socket must be in blocking state.
+ *
+ * Waits until an ACK is received for the latest not yet acknowledged
+ * netlink message.
+ */
+int nl_wait_for_ack(struct nl_sock *sk)
+{
+	int err;
+	struct nl_cb *cb;
+
+	cb = nl_cb_clone(sk->s_cb);
+	if (cb == NULL)
+		return -NLE_NOMEM;
+
+	nl_cb_set(cb, NL_CB_ACK, NL_CB_CUSTOM, ack_wait_handler, NULL);
+	err = nl_recvmsgs(sk, cb);
+	nl_cb_put(cb);
+
+	return err;
+}
+
+/** @} */
+
+/** @} */
diff -uNr libnl_kk/lib/object.c libnl/lib/object.c
--- libnl_kk/lib/object.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/object.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,383 @@
+/*
+ * lib/object.c		Generic Cacheable Object
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup cache
+ * @defgroup object Object
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink/netlink.h>
+#include <netlink/cache.h>
+#include <netlink/object.h>
+#include <netlink/utils.h>
+
+static inline struct nl_object_ops *obj_ops(struct nl_object *obj)
+{
+	if (!obj->ce_ops)
+		BUG();
+
+	return obj->ce_ops;
+}
+
+/**
+ * @name Object Creation/Deletion
+ * @{
+ */
+
+/**
+ * Allocate a new object of kind specified by the operations handle
+ * @arg ops		cache operations handle
+ * @return The new object or NULL
+ */
+struct nl_object *nl_object_alloc(struct nl_object_ops *ops)
+{
+	struct nl_object *new;
+
+	if (ops->oo_size < sizeof(*new))
+		BUG();
+
+	new = calloc(1, ops->oo_size);
+	if (!new)
+		return NULL;
+
+	new->ce_refcnt = 1;
+	nl_init_list_head(&new->ce_list);
+
+	new->ce_ops = ops;
+	if (ops->oo_constructor)
+		ops->oo_constructor(new);
+
+	NL_DBG(4, "Allocated new object %p\n", new);
+
+	return new;
+}
+
+/**
+ * Allocate a new object of kind specified by the name
+ * @arg kind		name of object type
+ * @return The new object or nULL
+ */
+int nl_object_alloc_name(const char *kind, struct nl_object **result)
+{
+	struct nl_cache_ops *ops;
+
+	ops = nl_cache_ops_lookup(kind);
+	if (!ops)
+		return -NLE_OPNOTSUPP;
+
+	if (!(*result = nl_object_alloc(ops->co_obj_ops)))
+		return -NLE_NOMEM;
+
+	return 0;
+}
+
+struct nl_derived_object {
+	NLHDR_COMMON
+	char data;
+};
+
+/**
+ * Allocate a new object and copy all data from an existing object
+ * @arg obj		object to inherite data from
+ * @return The new object or NULL.
+ */
+struct nl_object *nl_object_clone(struct nl_object *obj)
+{
+	struct nl_object *new;
+	struct nl_object_ops *ops = obj_ops(obj);
+	int doff = offsetof(struct nl_derived_object, data);
+	int size;
+
+	new = nl_object_alloc(ops);
+	if (!new)
+		return NULL;
+
+	size = ops->oo_size - doff;
+	if (size < 0)
+		BUG();
+
+	new->ce_ops = obj->ce_ops;
+	new->ce_msgtype = obj->ce_msgtype;
+	new->ce_mask = obj->ce_mask;
+
+	if (size)
+		memcpy((void *)new + doff, (void *)obj + doff, size);
+
+	if (ops->oo_clone) {
+		if (ops->oo_clone(new, obj) < 0) {
+			nl_object_free(new);
+			return NULL;
+		}
+	} else if (size && ops->oo_free_data)
+		BUG();
+
+	return new;
+}
+
+/**
+ * Free a cacheable object
+ * @arg obj		object to free
+ *
+ * @return 0 or a negative error code.
+ */
+void nl_object_free(struct nl_object *obj)
+{
+	struct nl_object_ops *ops = obj_ops(obj);
+
+	if (obj->ce_refcnt > 0)
+		NL_DBG(1, "Warning: Freeing object in use...\n");
+
+	if (obj->ce_cache)
+		nl_cache_remove(obj);
+
+	if (ops->oo_free_data)
+		ops->oo_free_data(obj);
+
+	free(obj);
+
+	NL_DBG(4, "Freed object %p\n", obj);
+}
+
+/** @} */
+
+/**
+ * @name Reference Management
+ * @{
+ */
+
+/**
+ * Acquire a reference on a object
+ * @arg obj		object to acquire reference from
+ */
+void nl_object_get(struct nl_object *obj)
+{
+	obj->ce_refcnt++;
+	NL_DBG(4, "New reference to object %p, total %d\n",
+	       obj, obj->ce_refcnt);
+}
+
+/**
+ * Release a reference from an object
+ * @arg obj		object to release reference from
+ */
+void nl_object_put(struct nl_object *obj)
+{
+	if (!obj)
+		return;
+
+	obj->ce_refcnt--;
+	NL_DBG(4, "Returned object reference %p, %d remaining\n",
+	       obj, obj->ce_refcnt);
+
+	if (obj->ce_refcnt < 0)
+		BUG();
+
+	if (obj->ce_refcnt <= 0)
+		nl_object_free(obj);
+}
+
+/**
+ * Check whether this object is used by multiple users
+ * @arg obj		object to check
+ * @return true or false
+ */
+int nl_object_shared(struct nl_object *obj)
+{
+	return obj->ce_refcnt > 1;
+}
+
+/** @} */
+
+/**
+ * @name Marks
+ * @{
+ */
+
+/**
+ * Add mark to object
+ * @arg obj		Object to mark
+ */
+void nl_object_mark(struct nl_object *obj)
+{
+	obj->ce_flags |= NL_OBJ_MARK;
+}
+
+/**
+ * Remove mark from object
+ * @arg obj		Object to unmark
+ */
+void nl_object_unmark(struct nl_object *obj)
+{
+	obj->ce_flags &= ~NL_OBJ_MARK;
+}
+
+/**
+ * Return true if object is marked
+ * @arg obj		Object to check
+ * @return true if object is marked, otherwise false
+ */
+int nl_object_is_marked(struct nl_object *obj)
+{
+	return (obj->ce_flags & NL_OBJ_MARK);
+}
+
+/** @} */
+
+/**
+ * @name Utillities
+ * @{
+ */
+
+/**
+ * Dump this object according to the specified parameters
+ * @arg obj		object to dump
+ * @arg params		dumping parameters
+ */
+void nl_object_dump(struct nl_object *obj, struct nl_dump_params *params)
+{
+	dump_from_ops(obj, params);
+}
+
+/**
+ * Check if the identifiers of two objects are identical 
+ * @arg a		an object
+ * @arg b		another object of same type
+ *
+ * @return true if both objects have equal identifiers, otherwise false.
+ */
+int nl_object_identical(struct nl_object *a, struct nl_object *b)
+{
+	struct nl_object_ops *ops = obj_ops(a);
+	int req_attrs;
+
+	/* Both objects must be of same type */
+	if (ops != obj_ops(b))
+		return 0;
+
+	req_attrs = ops->oo_id_attrs;
+	if (req_attrs == ~0)
+		req_attrs = a->ce_mask & b->ce_mask;
+
+	/* Both objects must provide all required attributes to uniquely
+	 * identify an object */
+	if ((a->ce_mask & req_attrs) != req_attrs ||
+	    (b->ce_mask & req_attrs) != req_attrs)
+		return 0;
+
+	/* Can't judge unless we can compare */
+	if (ops->oo_compare == NULL)
+		return 0;
+
+	return !(ops->oo_compare(a, b, req_attrs, 0));
+}
+
+/**
+ * Compute bitmask representing difference in attribute values
+ * @arg a		an object
+ * @arg b		another object of same type
+ *
+ * The bitmask returned is specific to an object type, each bit set represents
+ * an attribute which mismatches in either of the two objects. Unavailability
+ * of an attribute in one object and presence in the other is regarded a
+ * mismatch as well.
+ *
+ * @return Bitmask describing differences or 0 if they are completely identical.
+ */
+uint32_t nl_object_diff(struct nl_object *a, struct nl_object *b)
+{
+	struct nl_object_ops *ops = obj_ops(a);
+
+	if (ops != obj_ops(b) || ops->oo_compare == NULL)
+		return UINT_MAX;
+
+	return ops->oo_compare(a, b, ~0, 0);
+}
+
+/**
+ * Match a filter against an object
+ * @arg obj		object to check
+ * @arg filter		object of same type acting as filter
+ *
+ * @return 1 if the object matches the filter or 0
+ *           if no filter procedure is available or if the
+ *           filter does not match.
+ */
+int nl_object_match_filter(struct nl_object *obj, struct nl_object *filter)
+{
+	struct nl_object_ops *ops = obj_ops(obj);
+
+	if (ops != obj_ops(filter) || ops->oo_compare == NULL)
+		return 0;
+	
+	return !(ops->oo_compare(obj, filter, filter->ce_mask,
+				 LOOSE_COMPARISON));
+}
+
+/**
+ * Convert bitmask of attributes to a character string
+ * @arg obj		object of same type as attribute bitmask
+ * @arg attrs		bitmask of attribute types
+ * @arg buf		destination buffer
+ * @arg len		length of destination buffer
+ *
+ * Converts the bitmask of attribute types into a list of attribute
+ * names separated by comas.
+ *
+ * @return destination buffer.
+ */
+char *nl_object_attrs2str(struct nl_object *obj, uint32_t attrs,
+			  char *buf, size_t len)
+{
+	struct nl_object_ops *ops = obj_ops(obj);
+
+	if (ops->oo_attrs2str != NULL)
+		return ops->oo_attrs2str(attrs, buf, len);
+	else {
+		memset(buf, 0, len);
+		return buf;
+	}
+}
+
+/**
+ * Return list of attributes present in an object
+ * @arg obj		an object
+ * @arg buf		destination buffer
+ * @arg len		length of destination buffer
+ *
+ * @return destination buffer.
+ */
+char *nl_object_attr_list(struct nl_object *obj, char *buf, size_t len)
+{
+	return nl_object_attrs2str(obj, obj->ce_mask, buf, len);
+}
+
+/** @} */
+
+/**
+ * @name Attributes
+ * @{
+ */
+
+int nl_object_get_refcnt(struct nl_object *obj)
+{
+	return obj->ce_refcnt;
+}
+
+struct nl_cache *nl_object_get_cache(struct nl_object *obj)
+{
+	return obj->ce_cache;
+}
+
+/** @} */
+
+/** @} */
diff -uNr libnl_kk/lib/route/addr.c libnl/lib/route/addr.c
--- libnl_kk/lib/route/addr.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/addr.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,1053 @@
+/*
+ * lib/route/addr.c		Addresses
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ * Copyright (c) 2003-2006 Baruch Even <baruch@ev-en.org>,
+ *                         Mediatrix Telecom, inc. <ericb@mediatrix.com>
+ */
+
+/**
+ * @ingroup rtnl
+ * @defgroup rtaddr Addresses
+ * @brief
+ *
+ * @note The maximum size of an address label is IFNAMSIZ.
+ *
+ * @note The address may not contain a prefix length if the peer address
+ *       has been specified already.
+ *
+ * @par 1) Address Addition
+ * @code
+ * // Allocate an empty address object to be filled out with the attributes
+ * // of the new address.
+ * struct rtnl_addr *addr = rtnl_addr_alloc();
+ *
+ * // Fill out the mandatory attributes of the new address. Setting the
+ * // local address will automatically set the address family and the
+ * // prefix length to the correct values.
+ * rtnl_addr_set_ifindex(addr, ifindex);
+ * rtnl_addr_set_local(addr, local_addr);
+ *
+ * // The label of the address can be specified, currently only supported
+ * // by IPv4 and DECnet.
+ * rtnl_addr_set_label(addr, "mylabel");
+ *
+ * // The peer address can be specified if necessary, in either case a peer
+ * // address will be sent to the kernel in order to fullfil the interface
+ * // requirements. If none is set, it will equal the local address.
+ * // Note: Real peer addresses are only supported by IPv4 for now.
+ * rtnl_addr_set_peer(addr, peer_addr);
+ *
+ * // In case you want to have the address have a scope other than global
+ * // it may be overwritten using rtnl_addr_set_scope(). The scope currently
+ * // cannot be set for IPv6 addresses.
+ * rtnl_addr_set_scope(addr, rtnl_str2scope("site"));
+ *
+ * // Broadcast address may be specified using the relevant
+ * // functions, the address family will be verified if one of the other
+ * // addresses has been set already. Currently only works for IPv4.
+ * rtnl_addr_set_broadcast(addr, broadcast_addr);
+ *
+ * // Build the netlink message and send it to the kernel, the operation will
+ * // block until the operation has been completed. Alternatively the required
+ * // netlink message can be built using rtnl_addr_build_add_request() to be
+ * // sent out using nl_send_auto_complete().
+ * rtnl_addr_add(sk, addr, 0);
+ *
+ * // Free the memory
+ * rtnl_addr_put(addr);
+ * @endcode
+ *
+ * @par 2) Address Deletion
+ * @code
+ * // Allocate an empty address object to be filled out with the attributes
+ * // matching the address to be deleted. Alternatively a fully equipped
+ * // address object out of a cache can be used instead.
+ * struct rtnl_addr *addr = rtnl_addr_alloc();
+ *
+ * // The only mandatory parameter besides the address family is the interface
+ * // index the address is on, i.e. leaving out all other parameters will
+ * // result in all addresses of the specified address family interface tuple
+ * // to be deleted.
+ * rtnl_addr_set_ifindex(addr, ifindex);
+ *
+ * // Specyfing the address family manually is only required if neither the
+ * // local nor peer address have been specified.
+ * rtnl_addr_set_family(addr, AF_INET);
+ *
+ * // Specyfing the local address is optional but the best choice to delete
+ * // specific addresses.
+ * rtnl_addr_set_local(addr, local_addr);
+ *
+ * // The label of the address can be specified, currently only supported
+ * // by IPv4 and DECnet.
+ * rtnl_addr_set_label(addr, "mylabel");
+ *
+ * // The peer address can be specified if necessary, in either case a peer
+ * // address will be sent to the kernel in order to fullfil the interface
+ * // requirements. If none is set, it will equal the local address.
+ * // Note: Real peer addresses are only supported by IPv4 for now.
+ * rtnl_addr_set_peer(addr, peer_addr);
+ *
+ * // Build the netlink message and send it to the kernel, the operation will
+ * // block until the operation has been completed. Alternatively the required
+ * // netlink message can be built using rtnl_addr_build_delete_request()
+ * // to be sent out using nl_send_auto_complete().
+ * rtnl_addr_delete(sk, addr, 0);
+ *
+ * // Free the memory
+ * rtnl_addr_put(addr);
+ * @endcode
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink/netlink.h>
+#include <netlink/route/rtnl.h>
+#include <netlink/route/addr.h>
+#include <netlink/route/route.h>
+#include <netlink/route/link.h>
+#include <netlink/utils.h>
+
+/** @cond SKIP */
+#define ADDR_ATTR_FAMILY	0x0001
+#define ADDR_ATTR_PREFIXLEN	0x0002
+#define ADDR_ATTR_FLAGS		0x0004
+#define ADDR_ATTR_SCOPE		0x0008
+#define ADDR_ATTR_IFINDEX	0x0010
+#define ADDR_ATTR_LABEL		0x0020
+#define ADDR_ATTR_CACHEINFO	0x0040
+#define ADDR_ATTR_PEER		0x0080
+#define ADDR_ATTR_LOCAL		0x0100
+#define ADDR_ATTR_BROADCAST	0x0200
+#define ADDR_ATTR_MULTICAST	0x0400
+#define ADDR_ATTR_ANYCAST	0x0800
+
+static struct nl_cache_ops rtnl_addr_ops;
+static struct nl_object_ops addr_obj_ops;
+/** @endcond */
+
+static void addr_constructor(struct nl_object *obj)
+{
+	struct rtnl_addr *addr = nl_object_priv(obj);
+
+	addr->a_scope = RT_SCOPE_NOWHERE;
+}
+
+static void addr_free_data(struct nl_object *obj)
+{
+	struct rtnl_addr *addr = nl_object_priv(obj);
+
+	if (!addr)
+		return;
+
+	nl_addr_put(addr->a_peer);
+	nl_addr_put(addr->a_local);
+	nl_addr_put(addr->a_bcast);
+	nl_addr_put(addr->a_multicast);
+	nl_addr_put(addr->a_anycast);
+}
+
+static int addr_clone(struct nl_object *_dst, struct nl_object *_src)
+{
+	struct rtnl_addr *dst = nl_object_priv(_dst);
+	struct rtnl_addr *src = nl_object_priv(_src);
+
+	if (src->a_peer)
+		if (!(dst->a_peer = nl_addr_clone(src->a_peer)))
+			return -NLE_NOMEM;
+	
+	if (src->a_local)
+		if (!(dst->a_local = nl_addr_clone(src->a_local)))
+			return -NLE_NOMEM;
+
+	if (src->a_bcast)
+		if (!(dst->a_bcast = nl_addr_clone(src->a_bcast)))
+			return -NLE_NOMEM;
+
+	if (src->a_multicast)
+		if (!(dst->a_multicast = nl_addr_clone(src->a_multicast)))
+			return -NLE_NOMEM;
+
+	if (src->a_anycast)
+		if (!(dst->a_anycast = nl_addr_clone(src->a_anycast)))
+			return -NLE_NOMEM;
+
+	return 0;
+}
+
+static struct nla_policy addr_policy[IFA_MAX+1] = {
+	[IFA_LABEL]	= { .type = NLA_STRING,
+			    .maxlen = IFNAMSIZ },
+	[IFA_CACHEINFO]	= { .minlen = sizeof(struct ifa_cacheinfo) },
+};
+
+static int addr_msg_parser(struct nl_cache_ops *ops, struct sockaddr_nl *who,
+			   struct nlmsghdr *nlh, struct nl_parser_param *pp)
+{
+	struct rtnl_addr *addr;
+	struct ifaddrmsg *ifa;
+	struct nlattr *tb[IFA_MAX+1];
+	int err, peer_prefix = 0, family;
+
+	addr = rtnl_addr_alloc();
+	if (!addr)
+		return -NLE_NOMEM;
+
+	addr->ce_msgtype = nlh->nlmsg_type;
+
+	err = nlmsg_parse(nlh, sizeof(*ifa), tb, IFA_MAX, addr_policy);
+	if (err < 0)
+		goto errout;
+
+	ifa = nlmsg_data(nlh);
+	addr->a_family = family = ifa->ifa_family;
+	addr->a_prefixlen = ifa->ifa_prefixlen;
+	addr->a_flags = ifa->ifa_flags;
+	addr->a_scope = ifa->ifa_scope;
+	addr->a_ifindex = ifa->ifa_index;
+
+	addr->ce_mask = (ADDR_ATTR_FAMILY | ADDR_ATTR_PREFIXLEN |
+			 ADDR_ATTR_FLAGS | ADDR_ATTR_SCOPE | ADDR_ATTR_IFINDEX);
+
+	if (tb[IFA_LABEL]) {
+		nla_strlcpy(addr->a_label, tb[IFA_LABEL], IFNAMSIZ);
+		addr->ce_mask |= ADDR_ATTR_LABEL;
+	}
+
+	if (tb[IFA_CACHEINFO]) {
+		struct ifa_cacheinfo *ca;
+		
+		ca = nla_data(tb[IFA_CACHEINFO]);
+		addr->a_cacheinfo.aci_prefered = ca->ifa_prefered;
+		addr->a_cacheinfo.aci_valid = ca->ifa_valid;
+		addr->a_cacheinfo.aci_cstamp = ca->cstamp;
+		addr->a_cacheinfo.aci_tstamp = ca->tstamp;
+		addr->ce_mask |= ADDR_ATTR_CACHEINFO;
+	}
+
+	if (tb[IFA_LOCAL]) {
+		addr->a_local = nl_addr_alloc_attr(tb[IFA_LOCAL], family);
+		if (!addr->a_local)
+			goto errout_nomem;
+		addr->ce_mask |= ADDR_ATTR_LOCAL;
+	}
+
+	if (tb[IFA_ADDRESS]) {
+		struct nl_addr *a;
+
+		a = nl_addr_alloc_attr(tb[IFA_ADDRESS], family);
+		if (!a)
+			goto errout_nomem;
+
+		/* IPv6 sends the local address as IFA_ADDRESS with
+		 * no IFA_LOCAL, IPv4 sends both IFA_LOCAL and IFA_ADDRESS
+		 * with IFA_ADDRESS being the peer address if they differ */
+		if (!tb[IFA_LOCAL] || !nl_addr_cmp(a, addr->a_local)) {
+			nl_addr_put(addr->a_local);
+			addr->a_local = a;
+			addr->ce_mask |= ADDR_ATTR_LOCAL;
+		} else {
+			addr->a_peer = a;
+			addr->ce_mask |= ADDR_ATTR_PEER;
+			peer_prefix = 1;
+		}
+	}
+
+	nl_addr_set_prefixlen(peer_prefix ? addr->a_peer : addr->a_local,
+			      addr->a_prefixlen);
+
+	if (tb[IFA_BROADCAST]) {
+		addr->a_bcast = nl_addr_alloc_attr(tb[IFA_BROADCAST], family);
+		if (!addr->a_bcast)
+			goto errout_nomem;
+
+		addr->ce_mask |= ADDR_ATTR_BROADCAST;
+	}
+
+	if (tb[IFA_MULTICAST]) {
+		addr->a_multicast = nl_addr_alloc_attr(tb[IFA_MULTICAST],
+						       family);
+		if (!addr->a_multicast)
+			goto errout_nomem;
+
+		addr->ce_mask |= ADDR_ATTR_MULTICAST;
+	}
+
+	if (tb[IFA_ANYCAST]) {
+		addr->a_anycast = nl_addr_alloc_attr(tb[IFA_ANYCAST],
+						       family);
+		if (!addr->a_anycast)
+			goto errout_nomem;
+
+		addr->ce_mask |= ADDR_ATTR_ANYCAST;
+	}
+
+	err = pp->pp_cb((struct nl_object *) addr, pp);
+errout:
+	rtnl_addr_put(addr);
+
+	return err;
+
+errout_nomem:
+	err = -NLE_NOMEM;
+	goto errout;
+}
+
+static int addr_request_update(struct nl_cache *cache, struct nl_sock *sk)
+{
+	return nl_rtgen_request(sk, RTM_GETADDR, AF_UNSPEC, NLM_F_DUMP);
+}
+
+static void addr_dump_line(struct nl_object *obj, struct nl_dump_params *p)
+{
+	struct rtnl_addr *addr = (struct rtnl_addr *) obj;
+	struct nl_cache *link_cache;
+	char buf[128];
+
+	link_cache = nl_cache_mngt_require("route/link");
+
+	if (addr->ce_mask & ADDR_ATTR_LOCAL)
+		nl_dump_line(p, "%s",
+			nl_addr2str(addr->a_local, buf, sizeof(buf)));
+	else
+		nl_dump_line(p, "none");
+
+	if (addr->ce_mask & ADDR_ATTR_PEER)
+		nl_dump(p, " peer %s",
+			nl_addr2str(addr->a_peer, buf, sizeof(buf)));
+
+	nl_dump(p, " %s ", nl_af2str(addr->a_family, buf, sizeof(buf)));
+
+	if (link_cache)
+		nl_dump(p, "dev %s ",
+			rtnl_link_i2name(link_cache, addr->a_ifindex,
+					 buf, sizeof(buf)));
+	else
+		nl_dump(p, "dev %d ", addr->a_ifindex);
+
+	nl_dump(p, "scope %s",
+		rtnl_scope2str(addr->a_scope, buf, sizeof(buf)));
+
+	rtnl_addr_flags2str(addr->a_flags, buf, sizeof(buf));
+	if (buf[0])
+		nl_dump(p, " <%s>", buf);
+
+	nl_dump(p, "\n");
+}
+
+static void addr_dump_details(struct nl_object *obj, struct nl_dump_params *p)
+{
+	struct rtnl_addr *addr = (struct rtnl_addr *) obj;
+	char buf[128];
+
+	addr_dump_line(obj, p);
+
+	if (addr->ce_mask & (ADDR_ATTR_LABEL | ADDR_ATTR_BROADCAST |
+			     ADDR_ATTR_MULTICAST)) {
+		nl_dump_line(p, "  ");
+
+		if (addr->ce_mask & ADDR_ATTR_LABEL)
+			nl_dump(p, " label %s", addr->a_label);
+
+		if (addr->ce_mask & ADDR_ATTR_BROADCAST)
+			nl_dump(p, " broadcast %s",
+				nl_addr2str(addr->a_bcast, buf, sizeof(buf)));
+
+		if (addr->ce_mask & ADDR_ATTR_MULTICAST)
+			nl_dump(p, " multicast %s",
+				nl_addr2str(addr->a_multicast, buf,
+					      sizeof(buf)));
+
+		if (addr->ce_mask & ADDR_ATTR_ANYCAST)
+			nl_dump(p, " anycast %s",
+				nl_addr2str(addr->a_anycast, buf,
+					      sizeof(buf)));
+
+		nl_dump(p, "\n");
+	}
+
+	if (addr->ce_mask & ADDR_ATTR_CACHEINFO) {
+		struct rtnl_addr_cacheinfo *ci = &addr->a_cacheinfo;
+
+		nl_dump_line(p, "   valid-lifetime %s",
+			     ci->aci_valid == 0xFFFFFFFFU ? "forever" :
+			     nl_msec2str(ci->aci_valid * 1000,
+					   buf, sizeof(buf)));
+
+		nl_dump(p, " preferred-lifetime %s\n",
+			ci->aci_prefered == 0xFFFFFFFFU ? "forever" :
+			nl_msec2str(ci->aci_prefered * 1000,
+				      buf, sizeof(buf)));
+
+		nl_dump_line(p, "   created boot-time+%s ",
+			     nl_msec2str(addr->a_cacheinfo.aci_cstamp * 10,
+					   buf, sizeof(buf)));
+		    
+		nl_dump(p, "last-updated boot-time+%s\n",
+			nl_msec2str(addr->a_cacheinfo.aci_tstamp * 10,
+				      buf, sizeof(buf)));
+	}
+}
+
+static void addr_dump_stats(struct nl_object *obj, struct nl_dump_params *p)
+{
+	addr_dump_details(obj, p);
+}
+
+static void addr_dump_env(struct nl_object *obj, struct nl_dump_params *p)
+{
+	struct rtnl_addr *addr = (struct rtnl_addr *) obj;
+	struct nl_cache *link_cache;
+	char buf[128];
+
+	nl_dump_line(p, "ADDR_FAMILY=%s\n",
+		     nl_af2str(addr->a_family, buf, sizeof(buf)));
+
+	if (addr->ce_mask & ADDR_ATTR_LOCAL)
+		nl_dump_line(p, "ADDR_LOCAL=%s\n",
+			     nl_addr2str(addr->a_local, buf, sizeof(buf)));
+
+	if (addr->ce_mask & ADDR_ATTR_PEER)
+		nl_dump_line(p, "ADDR_PEER=%s\n",
+			     nl_addr2str(addr->a_peer, buf, sizeof(buf)));
+
+	if (addr->ce_mask & ADDR_ATTR_BROADCAST)
+		nl_dump_line(p, "ADDR_BROADCAST=%s\n",
+			     nl_addr2str(addr->a_bcast, buf, sizeof(buf)));
+
+	if (addr->ce_mask & ADDR_ATTR_ANYCAST)
+		nl_dump_line(p, "ADDR_ANYCAST=%s\n",
+			     nl_addr2str(addr->a_anycast, buf, sizeof(buf)));
+
+	if (addr->ce_mask & ADDR_ATTR_MULTICAST)
+		nl_dump_line(p, "ADDR_MULTICAST=%s\n",
+			     nl_addr2str(addr->a_multicast, buf,
+					   sizeof(buf)));
+
+	if (addr->ce_mask & ADDR_ATTR_PREFIXLEN)
+		nl_dump_line(p, "ADDR_PREFIXLEN=%u\n",
+			     addr->a_prefixlen);
+	link_cache = nl_cache_mngt_require("route/link");
+
+	nl_dump_line(p, "ADDR_IFINDEX=%u\n", addr->a_ifindex);
+	if (link_cache)
+		nl_dump_line(p, "ADDR_IFNAME=%s\n",
+			     rtnl_link_i2name(link_cache, addr->a_ifindex,
+					      buf, sizeof(buf)));
+
+	if (addr->ce_mask & ADDR_ATTR_SCOPE)
+		nl_dump_line(p, "ADDR_SCOPE=%s\n",
+			     rtnl_scope2str(addr->a_scope, buf, sizeof(buf)));
+
+	if (addr->ce_mask & ADDR_ATTR_LABEL)
+		nl_dump_line(p, "ADDR_LABEL=%s\n", addr->a_label);
+
+	rtnl_addr_flags2str(addr->a_flags, buf, sizeof(buf));
+	if (buf[0])
+		nl_dump_line(p, "ADDR_FLAGS=%s\n", buf);
+
+	if (addr->ce_mask & ADDR_ATTR_CACHEINFO) {
+		struct rtnl_addr_cacheinfo *ci = &addr->a_cacheinfo;
+
+		nl_dump_line(p, "ADDR_CACHEINFO_VALID=%s\n",
+			     ci->aci_valid == 0xFFFFFFFFU ? "forever" :
+			     nl_msec2str(ci->aci_valid * 1000,
+					   buf, sizeof(buf)));
+
+		nl_dump_line(p, "ADDR_CACHEINFO_PREFERED=%s\n",
+			     ci->aci_prefered == 0xFFFFFFFFU ? "forever" :
+			     nl_msec2str(ci->aci_prefered * 1000,
+					 buf, sizeof(buf)));
+
+		nl_dump_line(p, "ADDR_CACHEINFO_CREATED=%s\n",
+			     nl_msec2str(addr->a_cacheinfo.aci_cstamp * 10,
+					 buf, sizeof(buf)));
+
+		nl_dump_line(p, "ADDR_CACHEINFO_LASTUPDATE=%s\n",
+			     nl_msec2str(addr->a_cacheinfo.aci_tstamp * 10,
+					 buf, sizeof(buf)));
+	}
+}
+
+static int addr_compare(struct nl_object *_a, struct nl_object *_b,
+			uint32_t attrs, int flags)
+{
+	struct rtnl_addr *a = (struct rtnl_addr *) _a;
+	struct rtnl_addr *b = (struct rtnl_addr *) _b;
+	int diff = 0;
+
+#define ADDR_DIFF(ATTR, EXPR) ATTR_DIFF(attrs, ADDR_ATTR_##ATTR, a, b, EXPR)
+
+	diff |= ADDR_DIFF(IFINDEX,	a->a_ifindex != b->a_ifindex);
+	diff |= ADDR_DIFF(FAMILY,	a->a_family != b->a_family);
+	diff |= ADDR_DIFF(SCOPE,	a->a_scope != b->a_scope);
+	diff |= ADDR_DIFF(LABEL,	strcmp(a->a_label, b->a_label));
+	diff |= ADDR_DIFF(PEER,		nl_addr_cmp(a->a_peer, b->a_peer));
+	diff |= ADDR_DIFF(LOCAL,	nl_addr_cmp(a->a_local, b->a_local));
+	diff |= ADDR_DIFF(MULTICAST,	nl_addr_cmp(a->a_multicast,
+						    b->a_multicast));
+	diff |= ADDR_DIFF(BROADCAST,	nl_addr_cmp(a->a_bcast, b->a_bcast));
+	diff |= ADDR_DIFF(ANYCAST,	nl_addr_cmp(a->a_anycast, b->a_anycast));
+
+	if (flags & LOOSE_COMPARISON)
+		diff |= ADDR_DIFF(FLAGS,
+				  (a->a_flags ^ b->a_flags) & b->a_flag_mask);
+	else
+		diff |= ADDR_DIFF(FLAGS, a->a_flags != b->a_flags);
+
+#undef ADDR_DIFF
+
+	return diff;
+}
+
+static struct trans_tbl addr_attrs[] = {
+	__ADD(ADDR_ATTR_FAMILY, family)
+	__ADD(ADDR_ATTR_PREFIXLEN, prefixlen)
+	__ADD(ADDR_ATTR_FLAGS, flags)
+	__ADD(ADDR_ATTR_SCOPE, scope)
+	__ADD(ADDR_ATTR_IFINDEX, ifindex)
+	__ADD(ADDR_ATTR_LABEL, label)
+	__ADD(ADDR_ATTR_CACHEINFO, cacheinfo)
+	__ADD(ADDR_ATTR_PEER, peer)
+	__ADD(ADDR_ATTR_LOCAL, local)
+	__ADD(ADDR_ATTR_BROADCAST, broadcast)
+	__ADD(ADDR_ATTR_MULTICAST, multicast)
+};
+
+static char *addr_attrs2str(int attrs, char *buf, size_t len)
+{
+	return __flags2str(attrs, buf, len, addr_attrs,
+			   ARRAY_SIZE(addr_attrs));
+}
+
+/**
+ * @name Allocation/Freeing
+ * @{
+ */
+
+struct rtnl_addr *rtnl_addr_alloc(void)
+{
+	return (struct rtnl_addr *) nl_object_alloc(&addr_obj_ops);
+}
+
+void rtnl_addr_put(struct rtnl_addr *addr)
+{
+	nl_object_put((struct nl_object *) addr);
+}
+
+/** @} */
+
+/**
+ * @name Cache Management
+ * @{
+ */
+
+int rtnl_addr_alloc_cache(struct nl_sock *sk, struct nl_cache **result)
+{
+	return nl_cache_alloc_and_fill(&rtnl_addr_ops, sk, result);
+}
+
+/** @} */
+
+static int build_addr_msg(struct rtnl_addr *tmpl, int cmd, int flags,
+			  struct nl_msg **result)
+{
+	struct nl_msg *msg;
+	struct ifaddrmsg am = {
+		.ifa_family = tmpl->a_family,
+		.ifa_index = tmpl->a_ifindex,
+		.ifa_prefixlen = tmpl->a_prefixlen,
+	};
+
+	if (tmpl->ce_mask & ADDR_ATTR_SCOPE)
+		am.ifa_scope = tmpl->a_scope;
+	else {
+		/* compatibility hack */
+		if (tmpl->a_family == AF_INET &&
+		    tmpl->ce_mask & ADDR_ATTR_LOCAL &&
+		    *((char *) nl_addr_get_binary_addr(tmpl->a_local)) == 127)
+			am.ifa_scope = RT_SCOPE_HOST;
+		else
+			am.ifa_scope = RT_SCOPE_UNIVERSE;
+	}
+
+	msg = nlmsg_alloc_simple(cmd, flags);
+	if (!msg)
+		return -NLE_NOMEM;
+
+	if (nlmsg_append(msg, &am, sizeof(am), NLMSG_ALIGNTO) < 0)
+		goto nla_put_failure;
+
+	if (tmpl->ce_mask & ADDR_ATTR_LOCAL)
+		NLA_PUT_ADDR(msg, IFA_LOCAL, tmpl->a_local);
+
+	if (tmpl->ce_mask & ADDR_ATTR_PEER)
+		NLA_PUT_ADDR(msg, IFA_ADDRESS, tmpl->a_peer);
+	else if (tmpl->ce_mask & ADDR_ATTR_LOCAL)
+		NLA_PUT_ADDR(msg, IFA_ADDRESS, tmpl->a_local);
+
+	if (tmpl->ce_mask & ADDR_ATTR_LABEL)
+		NLA_PUT_STRING(msg, IFA_LABEL, tmpl->a_label);
+
+	if (tmpl->ce_mask & ADDR_ATTR_BROADCAST)
+		NLA_PUT_ADDR(msg, IFA_BROADCAST, tmpl->a_bcast);
+
+	if (tmpl->ce_mask & ADDR_ATTR_CACHEINFO) {
+		struct ifa_cacheinfo ca = {
+			.ifa_valid = tmpl->a_cacheinfo.aci_valid,
+			.ifa_prefered = tmpl->a_cacheinfo.aci_prefered,
+		};
+
+		NLA_PUT(msg, IFA_CACHEINFO, sizeof(ca), &ca);
+	}
+
+
+	*result = msg;
+	return 0;
+
+nla_put_failure:
+	nlmsg_free(msg);
+	return -NLE_MSGSIZE;
+}
+
+/**
+ * @name Addition
+ * @{
+ */
+
+/**
+ * Build netlink request message to request addition of new address
+ * @arg addr		Address object representing the new address.
+ * @arg flags		Additional netlink message flags.
+ * @arg result		Pointer to store resulting message.
+ *
+ * Builds a new netlink message requesting the addition of a new
+ * address. The netlink message header isn't fully equipped with
+ * all relevant fields and must thus be sent out via nl_send_auto_complete()
+ * or supplemented as needed.
+ *
+ * Minimal required attributes:
+ *   - interface index (rtnl_addr_set_ifindex())
+ *   - local address (rtnl_addr_set_local())
+ *
+ * The scope will default to universe except for loopback addresses in
+ * which case a host scope is used if not specified otherwise.
+ *
+ * @note Free the memory after usage using nlmsg_free().
+ *
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_addr_build_add_request(struct rtnl_addr *addr, int flags,
+				struct nl_msg **result)
+{
+	int required = ADDR_ATTR_IFINDEX | ADDR_ATTR_FAMILY |
+		       ADDR_ATTR_PREFIXLEN | ADDR_ATTR_LOCAL;
+
+	if ((addr->ce_mask & required) != required)
+		return -NLE_MISSING_ATTR;
+	
+	return build_addr_msg(addr, RTM_NEWADDR, NLM_F_CREATE | flags, result);
+}
+
+/**
+ * Request addition of new address
+ * @arg sk		Netlink socket.
+ * @arg addr		Address object representing the new address.
+ * @arg flags		Additional netlink message flags.
+ *
+ * Builds a netlink message by calling rtnl_addr_build_add_request(),
+ * sends the request to the kernel and waits for the next ACK to be
+ * received and thus blocks until the request has been fullfilled.
+ *
+ * @see rtnl_addr_build_add_request()
+ *
+ * @return 0 on sucess or a negative error if an error occured.
+ */
+int rtnl_addr_add(struct nl_sock *sk, struct rtnl_addr *addr, int flags)
+{
+	struct nl_msg *msg;
+	int err;
+
+	if ((err = rtnl_addr_build_add_request(addr, flags, &msg)) < 0)
+		return err;
+
+	err = nl_send_auto_complete(sk, msg);
+	nlmsg_free(msg);
+	if (err < 0)
+		return err;
+
+	return wait_for_ack(sk);
+}
+
+/** @} */
+
+/**
+ * @name Deletion
+ * @{
+ */
+
+/**
+ * Build a netlink request message to request deletion of an address
+ * @arg addr		Address object to be deleteted.
+ * @arg flags		Additional netlink message flags.
+ * @arg result		Pointer to store resulting message.
+ *
+ * Builds a new netlink message requesting a deletion of an address.
+ * The netlink message header isn't fully equipped with all relevant
+ * fields and must thus be sent out via nl_send_auto_complete()
+ * or supplemented as needed.
+ *
+ * Minimal required attributes:
+ *   - interface index (rtnl_addr_set_ifindex())
+ *   - address family (rtnl_addr_set_family())
+ *
+ * Optional attributes:
+ *   - local address (rtnl_addr_set_local())
+ *   - label (rtnl_addr_set_label(), IPv4/DECnet only)
+ *   - peer address (rtnl_addr_set_peer(), IPv4 only)
+ *
+ * @note Free the memory after usage using nlmsg_free().
+ *
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_addr_build_delete_request(struct rtnl_addr *addr, int flags,
+				   struct nl_msg **result)
+{
+	int required = ADDR_ATTR_IFINDEX | ADDR_ATTR_FAMILY;
+
+	if ((addr->ce_mask & required) != required)
+		return -NLE_MISSING_ATTR;
+
+	return build_addr_msg(addr, RTM_DELADDR, flags, result);
+}
+
+/**
+ * Request deletion of an address
+ * @arg sk		Netlink socket.
+ * @arg addr		Address object to be deleted.
+ * @arg flags		Additional netlink message flags.
+ *
+ * Builds a netlink message by calling rtnl_addr_build_delete_request(),
+ * sends the request to the kernel and waits for the next ACK to be
+ * received and thus blocks until the request has been fullfilled.
+ *
+ * @see rtnl_addr_build_delete_request();
+ *
+ * @return 0 on sucess or a negative error if an error occured.
+ */
+int rtnl_addr_delete(struct nl_sock *sk, struct rtnl_addr *addr, int flags)
+{
+	struct nl_msg *msg;
+	int err;
+
+	if ((err = rtnl_addr_build_delete_request(addr, flags, &msg)) < 0)
+		return err;
+
+	err = nl_send_auto_complete(sk, msg);
+	nlmsg_free(msg);
+	if (err < 0)
+		return err;
+
+	return wait_for_ack(sk);
+}
+
+/** @} */
+
+/**
+ * @name Attributes
+ * @{
+ */
+
+int rtnl_addr_set_label(struct rtnl_addr *addr, const char *label)
+{
+	if (strlen(label) > sizeof(addr->a_label) - 1)
+		return -NLE_RANGE;
+
+	strcpy(addr->a_label, label);
+	addr->ce_mask |= ADDR_ATTR_LABEL;
+
+	return 0;
+}
+
+char *rtnl_addr_get_label(struct rtnl_addr *addr)
+{
+	if (addr->ce_mask & ADDR_ATTR_LABEL)
+		return addr->a_label;
+	else
+		return NULL;
+}
+
+void rtnl_addr_set_ifindex(struct rtnl_addr *addr, int ifindex)
+{
+	addr->a_ifindex = ifindex;
+	addr->ce_mask |= ADDR_ATTR_IFINDEX;
+}
+
+int rtnl_addr_get_ifindex(struct rtnl_addr *addr)
+{
+	return addr->a_ifindex;
+}
+
+void rtnl_addr_set_family(struct rtnl_addr *addr, int family)
+{
+	addr->a_family = family;
+	addr->ce_mask |= ADDR_ATTR_FAMILY;
+}
+
+int rtnl_addr_get_family(struct rtnl_addr *addr)
+{
+	return addr->a_family;
+}
+
+void rtnl_addr_set_prefixlen(struct rtnl_addr *addr, int prefix)
+{
+	addr->a_prefixlen = prefix;
+	addr->ce_mask |= ADDR_ATTR_PREFIXLEN;
+}
+
+int rtnl_addr_get_prefixlen(struct rtnl_addr *addr)
+{
+	return addr->a_prefixlen;
+}
+
+void rtnl_addr_set_scope(struct rtnl_addr *addr, int scope)
+{
+	addr->a_scope = scope;
+	addr->ce_mask |= ADDR_ATTR_SCOPE;
+}
+
+int rtnl_addr_get_scope(struct rtnl_addr *addr)
+{
+	return addr->a_scope;
+}
+
+void rtnl_addr_set_flags(struct rtnl_addr *addr, unsigned int flags)
+{
+	addr->a_flag_mask |= flags;
+	addr->a_flags |= flags;
+	addr->ce_mask |= ADDR_ATTR_FLAGS;
+}
+
+void rtnl_addr_unset_flags(struct rtnl_addr *addr, unsigned int flags)
+{
+	addr->a_flag_mask |= flags;
+	addr->a_flags &= ~flags;
+	addr->ce_mask |= ADDR_ATTR_FLAGS;
+}
+
+unsigned int rtnl_addr_get_flags(struct rtnl_addr *addr)
+{
+	return addr->a_flags;
+}
+
+static inline int __assign_addr(struct rtnl_addr *addr, struct nl_addr **pos,
+			        struct nl_addr *new, int flag)
+{
+	if (addr->ce_mask & ADDR_ATTR_FAMILY) {
+		if (new->a_family != addr->a_family)
+			return -NLE_AF_MISMATCH;
+	} else
+		addr->a_family = new->a_family;
+
+	if (*pos)
+		nl_addr_put(*pos);
+
+	*pos = nl_addr_get(new);
+	addr->ce_mask |= (flag | ADDR_ATTR_FAMILY);
+
+	return 0;
+}
+
+int rtnl_addr_set_local(struct rtnl_addr *addr, struct nl_addr *local)
+{
+	int err;
+
+	err = __assign_addr(addr, &addr->a_local, local, ADDR_ATTR_LOCAL);
+	if (err < 0)
+		return err;
+
+	if (!(addr->ce_mask & ADDR_ATTR_PEER)) {
+		addr->a_prefixlen = nl_addr_get_prefixlen(addr->a_local);
+		addr->ce_mask |= ADDR_ATTR_PREFIXLEN;
+	}
+
+	return 0;
+}
+
+struct nl_addr *rtnl_addr_get_local(struct rtnl_addr *addr)
+{
+	return addr->a_local;
+}
+
+int rtnl_addr_set_peer(struct rtnl_addr *addr, struct nl_addr *peer)
+{
+	return __assign_addr(addr, &addr->a_peer, peer, ADDR_ATTR_PEER);
+
+	addr->a_prefixlen = nl_addr_get_prefixlen(addr->a_peer);
+	addr->ce_mask |= ADDR_ATTR_PREFIXLEN;
+
+	return 0;
+}
+
+struct nl_addr *rtnl_addr_get_peer(struct rtnl_addr *addr)
+{
+	return addr->a_peer;
+}
+
+int rtnl_addr_set_broadcast(struct rtnl_addr *addr, struct nl_addr *bcast)
+{
+	return __assign_addr(addr, &addr->a_bcast, bcast, ADDR_ATTR_BROADCAST);
+}
+
+struct nl_addr *rtnl_addr_get_broadcast(struct rtnl_addr *addr)
+{
+	return addr->a_bcast;
+}
+
+int rtnl_addr_set_multicast(struct rtnl_addr *addr, struct nl_addr *multicast)
+{
+	return __assign_addr(addr, &addr->a_multicast, multicast,
+			     ADDR_ATTR_MULTICAST);
+}
+
+struct nl_addr *rtnl_addr_get_multicast(struct rtnl_addr *addr)
+{
+	return addr->a_multicast;
+}
+
+int rtnl_addr_set_anycast(struct rtnl_addr *addr, struct nl_addr *anycast)
+{
+	return __assign_addr(addr, &addr->a_anycast, anycast,
+			     ADDR_ATTR_ANYCAST);
+}
+
+struct nl_addr *rtnl_addr_get_anycast(struct rtnl_addr *addr)
+{
+	return addr->a_anycast;
+}
+
+uint32_t rtnl_addr_get_valid_lifetime(struct rtnl_addr *addr)
+{
+	if (addr->ce_mask & ADDR_ATTR_CACHEINFO)
+		return addr->a_cacheinfo.aci_valid;
+	else
+		return 0xFFFFFFFFU;
+}
+
+void rtnl_addr_set_valid_lifetime(struct rtnl_addr *addr, uint32_t lifetime)
+{
+	addr->a_cacheinfo.aci_valid = lifetime;
+	addr->ce_mask |= ADDR_ATTR_CACHEINFO;
+}
+
+uint32_t rtnl_addr_get_preferred_lifetime(struct rtnl_addr *addr)
+{
+	if (addr->ce_mask & ADDR_ATTR_CACHEINFO)
+		return addr->a_cacheinfo.aci_prefered;
+	else
+		return 0xFFFFFFFFU;
+}
+
+void rtnl_addr_set_preferred_lifetime(struct rtnl_addr *addr, uint32_t lifetime)
+{
+	addr->a_cacheinfo.aci_prefered = lifetime;
+	addr->ce_mask |= ADDR_ATTR_CACHEINFO;
+}
+
+uint32_t rtnl_addr_get_create_time(struct rtnl_addr *addr)
+{
+	return addr->a_cacheinfo.aci_cstamp;
+}
+
+uint32_t rtnl_addr_get_last_update_time(struct rtnl_addr *addr)
+{
+	return addr->a_cacheinfo.aci_tstamp;
+}
+
+/** @} */
+
+/**
+ * @name Flags Translations
+ * @{
+ */
+
+static struct trans_tbl addr_flags[] = {
+	__ADD(IFA_F_SECONDARY, secondary)
+	__ADD(IFA_F_NODAD, nodad)
+	__ADD(IFA_F_OPTIMISTIC, optimistic)
+	__ADD(IFA_F_HOMEADDRESS, homeaddress)
+	__ADD(IFA_F_DEPRECATED, deprecated)
+	__ADD(IFA_F_TENTATIVE, tentative)
+	__ADD(IFA_F_PERMANENT, permanent)
+};
+
+char *rtnl_addr_flags2str(int flags, char *buf, size_t size)
+{
+	return __flags2str(flags, buf, size, addr_flags,
+			   ARRAY_SIZE(addr_flags));
+}
+
+int rtnl_addr_str2flags(const char *name)
+{
+	return __str2flags(name, addr_flags, ARRAY_SIZE(addr_flags));
+}
+
+/** @} */
+
+static struct nl_object_ops addr_obj_ops = {
+	.oo_name		= "route/addr",
+	.oo_size		= sizeof(struct rtnl_addr),
+	.oo_constructor		= addr_constructor,
+	.oo_free_data		= addr_free_data,
+	.oo_clone		= addr_clone,
+	.oo_dump = {
+	    [NL_DUMP_LINE] 	= addr_dump_line,
+	    [NL_DUMP_DETAILS]	= addr_dump_details,
+	    [NL_DUMP_STATS]	= addr_dump_stats,
+	    [NL_DUMP_ENV]	= addr_dump_env,
+	},
+	.oo_compare		= addr_compare,
+	.oo_attrs2str		= addr_attrs2str,
+	.oo_id_attrs		= (ADDR_ATTR_FAMILY | ADDR_ATTR_IFINDEX |
+				   ADDR_ATTR_LOCAL | ADDR_ATTR_PREFIXLEN),
+};
+
+static struct nl_af_group addr_groups[] = {
+	{ AF_INET,	RTNLGRP_IPV4_IFADDR },
+	{ AF_INET6,	RTNLGRP_IPV6_IFADDR },
+	{ END_OF_GROUP_LIST },
+};
+
+static struct nl_cache_ops rtnl_addr_ops = {
+	.co_name		= "route/addr",
+	.co_hdrsize		= sizeof(struct ifaddrmsg),
+	.co_msgtypes		= {
+					{ RTM_NEWADDR, NL_ACT_NEW, "new" },
+					{ RTM_DELADDR, NL_ACT_DEL, "del" },
+					{ RTM_GETADDR, NL_ACT_GET, "get" },
+					END_OF_MSGTYPES_LIST,
+				  },
+	.co_protocol		= NETLINK_ROUTE,
+	.co_groups		= addr_groups,
+	.co_request_update      = addr_request_update,
+	.co_msg_parser          = addr_msg_parser,
+	.co_obj_ops		= &addr_obj_ops,
+};
+
+static void __init addr_init(void)
+{
+	nl_cache_mngt_register(&rtnl_addr_ops);
+}
+
+static void __exit addr_exit(void)
+{
+	nl_cache_mngt_unregister(&rtnl_addr_ops);
+}
+
+/** @} */
diff -uNr libnl_kk/lib/route/class_api.c libnl/lib/route/class_api.c
--- libnl_kk/lib/route/class_api.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/class_api.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,102 @@
+/*
+ * lib/route/class_api.c            Queueing Classes Module API
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup class
+ * @defgroup class_api Class Modules
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink-tc.h>
+#include <netlink/netlink.h>
+#include <netlink/route/tc.h>
+#include <netlink/route/class.h>
+#include <netlink/route/class-modules.h>
+#include <netlink/utils.h>
+
+static struct rtnl_class_ops *class_ops_list;
+
+/**
+ * @name Module API
+ * @{
+ */
+
+/**
+ * Register a class module
+ * @arg cops		class module operations
+ */
+int rtnl_class_register(struct rtnl_class_ops *cops)
+{
+	struct rtnl_class_ops *o, **op;
+
+	if (!cops->co_kind[0])
+		BUG();
+
+	for (op = &class_ops_list; (o = *op) != NULL; op = &o->co_next)
+		if (!strcasecmp(cops->co_kind, o->co_kind))
+			return -NLE_EXIST;
+
+	cops->co_next = NULL;
+	*op = cops;
+
+	return 0;
+}
+
+/**
+ * Unregister a class module
+ * @arg cops		class module operations
+ */
+int rtnl_class_unregister(struct rtnl_class_ops *cops)
+{
+	struct rtnl_class_ops *o, **op;
+
+	for (op = &class_ops_list; (o = *op) != NULL; op = &o->co_next)
+		if (!strcasecmp(cops->co_kind, o->co_kind))
+			break;
+
+	if (!o)
+		return -NLE_OBJ_NOTFOUND;
+
+	*op = cops->co_next;
+
+	return 0;
+}
+
+struct rtnl_class_ops *__rtnl_class_lookup_ops(const char *kind)
+{
+	struct rtnl_class_ops *cops;
+
+	for (cops = class_ops_list; cops; cops = cops->co_next)
+		if (!strcmp(kind, cops->co_kind))
+			return cops;
+
+	return NULL;
+}
+
+/**
+ * Lookup class operations for a class object
+ * @arg class		Class object.
+ *
+ * @return Class operations or NULL if not found.
+ */
+struct rtnl_class_ops *rtnl_class_lookup_ops(struct rtnl_class *class)
+{
+	if (!class->c_ops)
+		class->c_ops = __rtnl_class_lookup_ops(class->c_kind);
+
+	return class->c_ops;
+}
+
+
+/** @} */
+
+/** @} */
diff -uNr libnl_kk/lib/route/class.c libnl/lib/route/class.c
--- libnl_kk/lib/route/class.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/class.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,304 @@
+/*
+ * lib/route/class.c            Queueing Classes
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup tc
+ * @defgroup class Queueing Classes
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink-tc.h>
+#include <netlink/netlink.h>
+#include <netlink/route/tc.h>
+#include <netlink/route/class.h>
+#include <netlink/route/class-modules.h>
+#include <netlink/route/qdisc.h>
+#include <netlink/route/classifier.h>
+#include <netlink/utils.h>
+
+static struct nl_cache_ops rtnl_class_ops;
+
+static int class_msg_parser(struct nl_cache_ops *ops, struct sockaddr_nl *who,
+			    struct nlmsghdr *n, struct nl_parser_param *pp)
+{
+	int err;
+	struct rtnl_class *class;
+	struct rtnl_class_ops *cops;
+
+	class = rtnl_class_alloc();
+	if (!class) {
+		err = -NLE_NOMEM;
+		goto errout;
+	}
+	class->ce_msgtype = n->nlmsg_type;
+
+	err = tca_msg_parser(n, (struct rtnl_tca *) class);
+	if (err < 0)
+		goto errout_free;
+
+	cops = rtnl_class_lookup_ops(class);
+	if (cops && cops->co_msg_parser) {
+		err = cops->co_msg_parser(class);
+		if (err < 0)
+			goto errout_free;
+	}
+
+	err = pp->pp_cb((struct nl_object *) class, pp);
+errout_free:
+	rtnl_class_put(class);
+errout:
+	return err;
+}
+
+static int class_request_update(struct nl_cache *cache, struct nl_sock *sk)
+{
+	struct tcmsg tchdr = {
+		.tcm_family = AF_UNSPEC,
+		.tcm_ifindex = cache->c_iarg1,
+	};
+
+	return nl_send_simple(sk, RTM_GETTCLASS, NLM_F_DUMP, &tchdr,
+			      sizeof(tchdr));
+}
+
+/**
+ * @name Addition/Modification
+ * @{
+ */
+
+static int class_build(struct rtnl_class *class, int type, int flags,
+		       struct nl_msg **result)
+{
+	struct rtnl_class_ops *cops;
+	int err;
+
+	err = tca_build_msg((struct rtnl_tca *) class, type, flags, result);
+	if (err < 0)
+		return err;
+
+	cops = rtnl_class_lookup_ops(class);
+	if (cops && cops->co_get_opts) {
+		struct nl_msg *opts;
+		
+		opts = cops->co_get_opts(class);
+		if (opts) {
+			err = nla_put_nested(*result, TCA_OPTIONS, opts);
+			nlmsg_free(opts);
+			if (err < 0)
+				goto errout;
+		}
+	}
+
+	return 0;
+errout:
+	nlmsg_free(*result);
+	return err;
+}
+
+/**
+ * Build a netlink message to add a new class
+ * @arg class		class to add 
+ * @arg flags		additional netlink message flags
+ * @arg result		Pointer to store resulting message.
+ *
+ * Builds a new netlink message requesting an addition of a class.
+ * The netlink message header isn't fully equipped with all relevant
+ * fields and must be sent out via nl_send_auto_complete() or
+ * supplemented as needed. 
+ *
+ * Common message flags
+ *   - NLM_F_REPLACE - replace possibly existing classes
+ *
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_class_build_add_request(struct rtnl_class *class, int flags,
+				 struct nl_msg **result)
+{
+	return class_build(class, RTM_NEWTCLASS, NLM_F_CREATE | flags, result);
+}
+
+/**
+ * Add a new class
+ * @arg sk		Netlink socket.
+ * @arg class		class to delete
+ * @arg flags		additional netlink message flags
+ *
+ * Builds a netlink message by calling rtnl_qdisc_build_add_request(),
+ * sends the request to the kernel and waits for the next ACK to be
+ * received and thus blocks until the request has been processed.
+ *
+ * Common message flags
+ *   - NLM_F_REPLACE - replace possibly existing classes
+ *
+ * @return 0 on success or a negative error code
+ */
+int rtnl_class_add(struct nl_sock *sk, struct rtnl_class *class, int flags)
+{
+	struct nl_msg *msg;
+	int err;
+
+	if ((err = rtnl_class_build_add_request(class, flags, &msg)) < 0)
+		return err;
+
+	err = nl_send_auto_complete(sk, msg);
+	nlmsg_free(msg);
+	if (err < 0)
+		return err;
+
+	return wait_for_ack(sk);
+}
+
+int rtnl_class_build_delete_request(struct rtnl_class *class,
+									struct nl_msg **result)
+{
+	struct nl_msg *msg;
+	struct tcmsg tchdr;
+	int required = TCA_ATTR_IFINDEX | TCA_ATTR_PARENT;
+
+	if ((class->ce_mask & required) != required)
+		BUG();
+
+	msg = nlmsg_alloc_simple(RTM_DELTCLASS, 0);
+	if (!msg)
+		return -NLE_NOMEM;
+
+	tchdr.tcm_family = AF_UNSPEC;
+	tchdr.tcm_handle = class->c_handle;
+	tchdr.tcm_parent = class->c_parent;
+	tchdr.tcm_ifindex = class->c_ifindex;
+	if (nlmsg_append(msg, &tchdr, sizeof(tchdr), NLMSG_ALIGNTO) < 0) {
+		nlmsg_free(msg);
+		return -NLE_MSGSIZE;
+	}
+
+	*result = msg;
+	return 0;
+}
+
+/**
+ * Delete a class
+ * @arg sk		Netlink socket.
+ * @arg class		class to delete
+ *
+ * Builds a netlink message by calling rtnl_class_build_delete_request(),
+ * sends the request to the kernel and waits for the ACK to be
+ * received and thus blocks until the request has been processed.
+ *
+ * @return 0 on success or a negative error code
+ */
+int rtnl_class_delete(struct nl_sock *sk, struct rtnl_class *class)
+{
+	struct nl_msg *msg;
+	int err;
+
+	if ((err = rtnl_class_build_delete_request(class, &msg)) < 0)
+		return err;
+
+	err = nl_send_auto_complete(sk, msg);
+	nlmsg_free(msg);
+	if (err < 0)
+		return err;
+
+	return wait_for_ack(sk);
+}
+
+/** @} */
+
+/**
+ * @name Cache Management
+ * @{
+ */
+
+/**
+ * Build a class cache including all classes attached to the specified interface
+ * @arg sk		Netlink socket.
+ * @arg ifindex		interface index of the link the classes are
+ *                      attached to.
+ *
+ * Allocates a new cache, initializes it properly and updates it to
+ * include all classes attached to the specified interface.
+ *
+ * @return The cache or NULL if an error has occured.
+ */
+int rtnl_class_alloc_cache(struct nl_sock *sk, int ifindex,
+			   struct nl_cache **result)
+{
+	struct nl_cache * cache;
+	int err;
+	
+	cache = nl_cache_alloc(&rtnl_class_ops);
+	if (!cache)
+		return -NLE_NOMEM;
+
+	cache->c_iarg1 = ifindex;
+	
+	if (sk && (err = nl_cache_refill(sk, cache)) < 0) {
+		nl_cache_free(cache);
+		return err;
+	}
+
+	*result = cache;
+	return 0;
+}
+
+/**
+ * Look up class by its handle in the provided cache
+ * @arg cache		class cache
+ * @arg ifindex		interface the class is attached to
+ * @arg handle		class handle
+ * @return pointer to class inside the cache or NULL if no match was found.
+ */
+struct rtnl_class *rtnl_class_get(struct nl_cache *cache, int ifindex,
+								  uint32_t handle)
+{
+	struct rtnl_class *class;
+	
+	if (cache->c_ops != &rtnl_class_ops)
+		return NULL;
+
+	nl_list_for_each_entry(class, &cache->c_items, ce_list) {
+		if (class->c_handle == handle && class->c_ifindex == ifindex) {
+			nl_object_get((struct nl_object *) class);
+			return class;
+		}
+	}
+	return NULL;
+}
+
+/** @} */
+
+static struct nl_cache_ops rtnl_class_ops = {
+	.co_name		= "route/class",
+	.co_hdrsize		= sizeof(struct tcmsg),
+	.co_msgtypes		= {
+					{ RTM_NEWTCLASS, NL_ACT_NEW, "new" },
+					{ RTM_DELTCLASS, NL_ACT_DEL, "del" },
+					{ RTM_GETTCLASS, NL_ACT_GET, "get" },
+					END_OF_MSGTYPES_LIST,
+				  },
+	.co_protocol		= NETLINK_ROUTE,
+	.co_request_update	= &class_request_update,
+	.co_msg_parser		= &class_msg_parser,
+	.co_obj_ops		= &class_obj_ops,
+};
+
+static void __init class_init(void)
+{
+	nl_cache_mngt_register(&rtnl_class_ops);
+}
+
+static void __exit class_exit(void)
+{
+	nl_cache_mngt_unregister(&rtnl_class_ops);
+}
+
+/** @} */
diff -uNr libnl_kk/lib/route/class_obj.c libnl/lib/route/class_obj.c
--- libnl_kk/lib/route/class_obj.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/class_obj.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,281 @@
+/*
+ * lib/route/class.c            Queueing Classes
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2006 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup class
+ * @defgroup class_obj Class Object
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink-tc.h>
+#include <netlink/netlink.h>
+#include <netlink/route/tc.h>
+#include <netlink/route/class.h>
+#include <netlink/route/class-modules.h>
+#include <netlink/route/qdisc.h>
+#include <netlink/route/classifier.h>
+#include <netlink/utils.h>
+
+static void class_free_data(struct nl_object *obj)
+{
+	struct rtnl_class *class = (struct rtnl_class *) obj;
+	struct rtnl_class_ops *cops;
+	
+	tca_free_data((struct rtnl_tca *) class);
+
+	cops = rtnl_class_lookup_ops(class);
+	if (cops && cops->co_free_data)
+		cops->co_free_data(class);
+}
+
+static int class_clone(struct nl_object *_dst, struct nl_object *_src)
+{
+	struct rtnl_class *dst = nl_object_priv(_dst);
+	struct rtnl_class *src = nl_object_priv(_src);
+	struct rtnl_class_ops *cops;
+	int err;
+
+	err = tca_clone((struct rtnl_tca *) dst, (struct rtnl_tca *) src);
+	if (err < 0)
+		goto errout;
+
+	cops = rtnl_class_lookup_ops(src);
+	if (cops && cops->co_clone)
+		err = cops->co_clone(dst, src);
+errout:
+	return err;
+}
+
+static void class_dump_line(struct nl_object *obj, struct nl_dump_params *p)
+{
+	struct rtnl_class *class = (struct rtnl_class *) obj;
+	struct rtnl_class_ops *cops;
+
+	tca_dump_line((struct rtnl_tca *) class, "class", p);
+
+	cops = rtnl_class_lookup_ops(class);
+	if (cops && cops->co_dump[NL_DUMP_LINE])
+		cops->co_dump[NL_DUMP_LINE](class, p);
+	nl_dump(p, "\n");
+}
+
+static void class_dump_details(struct nl_object *obj, struct nl_dump_params *p)
+{
+	struct rtnl_class *class = (struct rtnl_class *) obj;
+	struct rtnl_class_ops *cops;
+
+	class_dump_line(obj, p);
+	tca_dump_details((struct rtnl_tca *) class, p);
+	
+	if (class->c_info) {
+		char buf[32];
+		nl_dump(p, "child-qdisc %s ",
+			rtnl_tc_handle2str(class->c_info, buf, sizeof(buf)));
+	}
+
+	cops = rtnl_class_lookup_ops(class);
+	if (cops && cops->co_dump[NL_DUMP_DETAILS])
+		cops->co_dump[NL_DUMP_DETAILS](class, p);
+	else if (!class->c_info)
+		nl_dump(p, "noop (no leaf qdisc)");
+
+	nl_dump(p, "\n");
+}
+
+static void class_dump_stats(struct nl_object *obj, struct nl_dump_params *p)
+{
+	struct rtnl_class *class = (struct rtnl_class *) obj;
+	struct rtnl_class_ops *cops;
+
+	class_dump_details(obj, p);
+	tca_dump_stats((struct rtnl_tca *) class, p);
+	nl_dump(p, "\n");
+
+	cops = rtnl_class_lookup_ops(class);
+	if (cops && cops->co_dump[NL_DUMP_STATS])
+		cops->co_dump[NL_DUMP_STATS](class, p);
+}
+
+/**
+ * @name Allocation/Freeing
+ * @{
+ */
+
+struct rtnl_class *rtnl_class_alloc(void)
+{
+	return (struct rtnl_class *) nl_object_alloc(&class_obj_ops);
+}
+
+void rtnl_class_put(struct rtnl_class *class)
+{
+	nl_object_put((struct nl_object *) class);
+}
+
+/** @} */
+
+/**
+ * @name Leaf Qdisc
+ * @{
+ */
+
+/**
+ * Lookup the leaf qdisc of a class
+ * @arg class		the parent class
+ * @arg cache		a qdisc cache including at laest all qdiscs of the
+ *                      interface the specified class is attached to
+ * @return The qdisc from the cache or NULL if the class has no leaf qdisc
+ */
+struct rtnl_qdisc *rtnl_class_leaf_qdisc(struct rtnl_class *class,
+					 struct nl_cache *cache)
+{
+	struct rtnl_qdisc *leaf;
+
+	if (!class->c_info)
+		return NULL;
+
+	leaf = rtnl_qdisc_get_by_parent(cache, class->c_ifindex,
+					class->c_handle);
+	if (!leaf || leaf->q_handle != class->c_info)
+		return NULL;
+
+	return leaf;
+}
+
+/** @} */
+
+
+/**
+ * @name Iterators
+ * @{
+ */
+
+/**
+ * Call a callback for each child of a class
+ * @arg class		the parent class
+ * @arg cache		a class cache including all classes of the interface
+ *                      the specified class is attached to
+ * @arg cb              callback function
+ * @arg arg             argument to be passed to callback function
+ */
+void rtnl_class_foreach_child(struct rtnl_class *class, struct nl_cache *cache,
+			      void (*cb)(struct nl_object *, void *), void *arg)
+{
+	struct rtnl_class *filter;
+	
+	filter = rtnl_class_alloc();
+	if (!filter)
+		return;
+
+	rtnl_class_set_parent(filter, class->c_handle);
+	rtnl_class_set_ifindex(filter, class->c_ifindex);
+	rtnl_class_set_kind(filter, class->c_kind);
+
+	nl_cache_foreach_filter(cache, (struct nl_object *) filter, cb, arg);
+	rtnl_class_put(filter);
+}
+
+/**
+ * Call a callback for each classifier attached to the class
+ * @arg class		the parent class
+ * @arg cache		a filter cache including at least all the filters
+ *                      attached to the specified class
+ * @arg cb              callback function
+ * @arg arg             argument to be passed to callback function
+ */
+void rtnl_class_foreach_cls(struct rtnl_class *class, struct nl_cache *cache,
+			    void (*cb)(struct nl_object *, void *), void *arg)
+{
+	struct rtnl_cls *filter;
+
+	filter = rtnl_cls_alloc();
+	if (!filter)
+		return;
+
+	rtnl_cls_set_ifindex(filter, class->c_ifindex);
+	rtnl_cls_set_parent(filter, class->c_parent);
+
+	nl_cache_foreach_filter(cache, (struct nl_object *) filter, cb, arg);
+	rtnl_cls_put(filter);
+}
+
+/** @} */
+
+
+/**
+ * @name Attributes
+ * @{
+ */
+
+void rtnl_class_set_ifindex(struct rtnl_class *class, int ifindex)
+{
+	tca_set_ifindex((struct rtnl_tca *) class, ifindex);
+}
+
+int rtnl_class_get_ifindex(struct rtnl_class *class)
+{
+	return tca_get_ifindex((struct rtnl_tca *) class);
+}
+
+void rtnl_class_set_handle(struct rtnl_class *class, uint32_t handle)
+{
+	tca_set_handle((struct rtnl_tca *) class, handle);
+}
+
+uint32_t rtnl_class_get_handle(struct rtnl_class *class)
+{
+	return tca_get_handle((struct rtnl_tca *) class);
+}
+
+void rtnl_class_set_parent(struct rtnl_class *class, uint32_t parent)
+{
+	tca_set_parent((struct rtnl_tca *) class, parent);
+}
+
+uint32_t rtnl_class_get_parent(struct rtnl_class *class)
+{
+	return tca_get_parent((struct rtnl_tca *) class);
+}
+
+void rtnl_class_set_kind(struct rtnl_class *class, const char *name)
+{
+	tca_set_kind((struct rtnl_tca *) class, name);
+	class->c_ops = __rtnl_class_lookup_ops(name);
+}
+
+char *rtnl_class_get_kind(struct rtnl_class *class)
+{
+	return tca_get_kind((struct rtnl_tca *) class);
+}
+
+uint64_t rtnl_class_get_stat(struct rtnl_class *class,
+			     enum rtnl_tc_stats_id id)
+{
+	return tca_get_stat((struct rtnl_tca *) class, id);
+}
+
+/** @} */
+
+struct nl_object_ops class_obj_ops = {
+	.oo_name		= "route/class",
+	.oo_size		= sizeof(struct rtnl_class),
+	.oo_free_data         	= class_free_data,
+	.oo_clone		= class_clone,
+	.oo_dump = {
+	    [NL_DUMP_LINE]	= class_dump_line,
+	    [NL_DUMP_DETAILS]	= class_dump_details,
+	    [NL_DUMP_STATS]	= class_dump_stats,
+	},
+	.oo_compare		= tca_compare,
+	.oo_id_attrs		= (TCA_ATTR_IFINDEX | TCA_ATTR_HANDLE),
+};
+
+/** @} */
diff -uNr libnl_kk/lib/route/cls/basic.c libnl/lib/route/cls/basic.c
--- libnl_kk/lib/route/cls/basic.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/cls/basic.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,211 @@
+/*
+ * lib/route/cls/basic.c	Basic Classifier
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2008-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup cls
+ * @defgroup basic Basic Classifier
+ *
+ * @par Introduction
+ * The basic classifier is the simplest form of a classifier. It does
+ * not have any special classification capabilities, instead it can be
+ * used to classify exclusively based on extended matches or to
+ * create a "catch-all" filter.
+ *
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink-tc.h>
+#include <netlink/netlink.h>
+#include <netlink/route/classifier.h>
+#include <netlink/route/classifier-modules.h>
+#include <netlink/route/cls/basic.h>
+#include <netlink/route/cls/ematch.h>
+
+struct rtnl_basic
+{
+	uint32_t			b_classid;
+	struct rtnl_ematch_tree *	b_ematch;
+	int				b_mask;
+};
+
+/** @cond SKIP */
+#define BASIC_ATTR_CLASSID	0x001
+#define BASIC_ATTR_EMATCH	0x002
+/** @endcond */
+
+static struct nla_policy basic_policy[TCA_FW_MAX+1] = {
+	[TCA_BASIC_CLASSID]	= { .type = NLA_U32 },
+	[TCA_BASIC_EMATCHES]	= { .type = NLA_NESTED },
+	[TCA_BASIC_ACT]		= { .type = NLA_NESTED },
+	[TCA_BASIC_POLICE]	= { .type = NLA_NESTED },
+};
+
+static int basic_clone(struct rtnl_cls *_dst, struct rtnl_cls *_src)
+{
+	return -NLE_OPNOTSUPP;
+}
+
+static void basic_free_data(struct rtnl_cls *cls)
+{
+	struct rtnl_basic *basic = rtnl_cls_data(cls);
+
+	rtnl_ematch_tree_free(basic->b_ematch);
+}
+
+static int basic_msg_parser(struct rtnl_cls *cls)
+{
+	struct nlattr *tb[TCA_BASIC_MAX + 1];
+	struct rtnl_basic *basic = rtnl_cls_data(cls);
+	int err;
+
+	err = tca_parse(tb, TCA_BASIC_MAX, (struct rtnl_tca *) cls, basic_policy);
+	if (err < 0)
+		return err;
+
+	if (tb[TCA_BASIC_CLASSID]) {
+		basic->b_classid = nla_get_u32(tb[TCA_BASIC_CLASSID]);
+		basic->b_mask |= BASIC_ATTR_CLASSID;
+	}
+
+	if (tb[TCA_BASIC_EMATCHES]) {
+		if ((err = rtnl_ematch_parse(tb[TCA_BASIC_EMATCHES],
+					     &basic->b_ematch)) < 0)
+			return err;
+
+		if (basic->b_ematch)
+			basic->b_mask |= BASIC_ATTR_EMATCH;
+	}
+
+	if (tb[TCA_BASIC_ACT]) {
+		/* XXX */
+	}
+
+	if (tb[TCA_BASIC_POLICE]) {
+		/* XXX */
+	}
+
+	return 0;
+}
+
+static void basic_dump_line(struct rtnl_cls *cls, struct nl_dump_params *p)
+{
+	struct rtnl_basic *b = rtnl_cls_data(cls);
+	char buf[32];
+
+	if (b->b_mask & BASIC_ATTR_EMATCH)
+		nl_dump(p, " ematch");
+	else
+		nl_dump(p, " match-all");
+
+	if (b->b_mask & BASIC_ATTR_CLASSID)
+		nl_dump(p, " classify-to %s",
+			rtnl_tc_handle2str(b->b_classid, buf, sizeof(buf)));
+}
+
+static void basic_dump_details(struct rtnl_cls *cls, struct nl_dump_params *p)
+{
+	struct rtnl_basic *b = rtnl_cls_data(cls);
+
+	if (b->b_mask & BASIC_ATTR_EMATCH) {
+		nl_dump(p, "\n");
+		nl_dump_line(p, "    ematch ");
+		rtnl_ematch_tree_dump(b->b_ematch, p);
+	} else
+		nl_dump(p, "no options.\n");
+}
+
+static int basic_get_opts(struct rtnl_cls *cls, struct nl_msg *msg)
+{
+	struct rtnl_basic *b = rtnl_cls_data(cls);
+
+	if (!(b->b_mask & BASIC_ATTR_CLASSID))
+		return -NLE_MISSING_ATTR;
+
+	NLA_PUT_U32(msg, TCA_BASIC_CLASSID, b->b_classid);
+
+	return 0;
+
+nla_put_failure:
+	return -NLE_NOMEM;
+}
+
+/**
+ * @name Attribute Modifications
+ * @{
+ */
+
+int rtnl_basic_set_classid(struct rtnl_cls *cls, uint32_t classid)
+{
+	struct rtnl_basic *b = rtnl_cls_data(cls);
+
+	b->b_classid = classid;
+	b->b_mask |= BASIC_ATTR_CLASSID;
+
+	return 0;
+}
+
+uint32_t rtnl_basic_get_classid(struct rtnl_cls *cls)
+{
+	struct rtnl_basic *b = rtnl_cls_data(cls);
+
+	return b->b_classid;
+}
+
+int rtnl_basic_set_ematch(struct rtnl_cls *cls, struct rtnl_ematch_tree *tree)
+{
+	struct rtnl_basic *b = rtnl_cls_data(cls);
+
+	if (b->b_ematch) {
+		rtnl_ematch_tree_free(b->b_ematch);
+		b->b_mask &= ~BASIC_ATTR_EMATCH;
+	}
+
+	b->b_ematch = tree;
+
+	if (tree)
+		b->b_mask |= BASIC_ATTR_EMATCH;
+
+	return 0;
+}
+
+struct rtnl_ematch_tree *rtnl_basic_get_ematch(struct rtnl_cls *cls)
+{
+	struct rtnl_basic *b = rtnl_cls_data(cls);
+	return b->b_ematch;
+}
+
+/** @} */
+
+static struct rtnl_cls_ops basic_ops = {
+	.co_kind		= "basic",
+	.co_size		= sizeof(struct rtnl_basic),
+	.co_msg_parser		= basic_msg_parser,
+	.co_clone		= basic_clone,
+	.co_free_data		= basic_free_data,
+	.co_get_opts		= basic_get_opts,
+	.co_dump = {
+	    [NL_DUMP_LINE]	= basic_dump_line,
+	    [NL_DUMP_DETAILS]	= basic_dump_details,
+	},
+};
+
+static void __init basic_init(void)
+{
+	rtnl_cls_register(&basic_ops);
+}
+
+static void __exit basic_exit(void)
+{
+	rtnl_cls_unregister(&basic_ops);
+}
+
+/** @} */
diff -uNr libnl_kk/lib/route/cls/cgroup.c libnl/lib/route/cls/cgroup.c
--- libnl_kk/lib/route/cls/cgroup.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/cls/cgroup.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,141 @@
+/*
+ * lib/route/cls/cgroup.c	Control Groups Classifier
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup cls_api
+ * @defgroup cgroup Control Groups Classifier
+ *
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink-tc.h>
+#include <netlink/netlink.h>
+#include <netlink/attr.h>
+#include <netlink/utils.h>
+#include <netlink/route/classifier.h>
+#include <netlink/route/classifier-modules.h>
+#include <netlink/route/cls/cgroup.h>
+#include <netlink/route/cls/ematch.h>
+
+/** @cond SKIP */
+#define CGROUP_ATTR_EMATCH      0x001
+/** @endcond */
+
+static struct nla_policy cgroup_policy[TCA_CGROUP_MAX+1] = {
+	[TCA_CGROUP_EMATCHES]	= { .type = NLA_NESTED },
+};
+
+static void cgroup_free_data(struct rtnl_cls *cls)
+{
+	struct rtnl_cgroup *cg = rtnl_cls_data(cls);
+
+	rtnl_ematch_tree_free(cg->cg_ematch);
+}
+
+static int cgroup_msg_parser(struct rtnl_cls *cls)
+{
+	struct rtnl_cgroup *cg = rtnl_cls_data(cls);
+	struct nlattr *tb[TCA_CGROUP_MAX + 1];
+	int err;
+
+	err = tca_parse(tb, TCA_CGROUP_MAX, (struct rtnl_tca *) cls,
+			cgroup_policy);
+	if (err < 0)
+		return err;
+
+	if (tb[TCA_CGROUP_EMATCHES]) {
+		if ((err = rtnl_ematch_parse(tb[TCA_CGROUP_EMATCHES],
+					     &cg->cg_ematch)) < 0)
+			return err;
+		cg->cg_mask |= CGROUP_ATTR_EMATCH;
+	}
+
+#if 0
+	TODO:
+	TCA_CGROUP_ACT,
+	TCA_CGROUP_POLICE,
+#endif
+
+	return 0;
+}
+
+static void cgroup_dump_line(struct rtnl_cls *cls, struct nl_dump_params *p)
+{
+	struct rtnl_cgroup *cg = rtnl_cls_data(cls);
+
+	if (cg->cg_mask & CGROUP_ATTR_EMATCH)
+		nl_dump(p, " ematch");
+	else
+		nl_dump(p, " match-all");
+}
+
+static void cgroup_dump_details(struct rtnl_cls *cls, struct nl_dump_params *p)
+{
+	struct rtnl_cgroup *cg = rtnl_cls_data(cls);
+
+	if (cg->cg_mask & CGROUP_ATTR_EMATCH) {
+		nl_dump(p, "\n");
+		nl_dump_line(p, "    ematch ");
+		rtnl_ematch_tree_dump(cg->cg_ematch, p);
+	}
+}
+
+/**
+ * @name Attribute Modifications
+ * @{
+ */
+
+int rtnl_cgroup_set_ematch(struct rtnl_cls *cls, struct rtnl_ematch_tree *tree)
+{
+	struct rtnl_cgroup *cg = rtnl_cls_data(cls);
+
+	if (cg->cg_ematch) {
+		rtnl_ematch_tree_free(cg->cg_ematch);
+		cg->cg_mask &= ~CGROUP_ATTR_EMATCH;
+	}
+
+	cg->cg_ematch = tree;
+
+	if (tree)
+		cg->cg_mask |= CGROUP_ATTR_EMATCH;
+
+	return 0;
+}
+
+struct rtnl_ematch_tree *rtnl_cgroup_get_ematch(struct rtnl_cls *cls)
+{
+	struct rtnl_cgroup *cg = rtnl_cls_data(cls);
+	return cg->cg_ematch;
+}
+
+static struct rtnl_cls_ops cgroup_ops = {
+	.co_kind		= "cgroup",
+	.co_size		= sizeof(struct rtnl_cgroup),
+	.co_msg_parser		= cgroup_msg_parser,
+	.co_free_data		= cgroup_free_data,
+	.co_dump = {
+	    [NL_DUMP_LINE]	= cgroup_dump_line,
+	    [NL_DUMP_DETAILS]	= cgroup_dump_details,
+	},
+};
+
+static void __init cgroup_init(void)
+{
+	rtnl_cls_register(&cgroup_ops);
+}
+
+static void __exit cgroup_exit(void)
+{
+	rtnl_cls_unregister(&cgroup_ops);
+}
+
+/** @} */
diff -uNr libnl_kk/lib/route/cls/ematch/cmp.c libnl/lib/route/cls/ematch/cmp.c
--- libnl_kk/lib/route/cls/ematch/cmp.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/cls/ematch/cmp.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,116 @@
+/*
+ * lib/route/cls/ematch/cmp.c	Simple packet data comparison ematch
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2008-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup ematch
+ * @defgroup em_cmp Simple packet data comparison
+ *
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink-tc.h>
+#include <netlink/netlink.h>
+#include <netlink/route/cls/ematch.h>
+#include <linux/tc_ematch/tc_em_cmp.h>
+
+void rtnl_ematch_cmp_set(struct rtnl_ematch *ematch,
+			 struct tcf_em_cmp *cfg)
+{
+	memcpy(rtnl_ematch_data(ematch), cfg, sizeof(*cfg));
+}
+
+struct tcf_em_cmp *rtnl_ematch_cmp_get(struct rtnl_ematch *ematch)
+{
+	return rtnl_ematch_data(ematch);
+}
+
+static const char *align_txt(struct tcf_em_cmp *cmp)
+{
+	switch (cmp->align) {
+	case TCF_EM_ALIGN_U8:
+		return "u8";
+	case TCF_EM_ALIGN_U16:
+		return (cmp->flags & TCF_EM_CMP_TRANS) ? "h16" : "u16";
+	case TCF_EM_ALIGN_U32:
+		return (cmp->flags & TCF_EM_CMP_TRANS) ? "h32" : "u32";
+	default:
+		return (cmp->flags & TCF_EM_CMP_TRANS) ? "h?" : "u?";
+	}
+}
+
+static const char *layer_txt(struct tcf_em_cmp *cmp)
+{
+	switch (cmp->layer) {
+	case TCF_LAYER_LINK:
+		return "link";
+	case TCF_LAYER_NETWORK:
+		return "network";
+	case TCF_LAYER_TRANSPORT:
+		return "transport";
+	default:
+		return "?";
+	}
+}
+
+static const char *relation_txt(struct tcf_em_cmp *cmp)
+{
+	switch (cmp->opnd) {
+	case TCF_EM_OPND_EQ:
+		return "eq";
+	case TCF_EM_OPND_LT:
+		return "lt";
+	case TCF_EM_OPND_GT:
+		return "gt";
+	default:
+		return "?";
+	}
+}
+
+static int cmp_parse(struct rtnl_ematch *m, void *data, size_t len)
+{
+	memcpy(rtnl_ematch_data(m), data, len);
+
+	return 0;
+}
+
+static void cmp_dump(struct rtnl_ematch *m, struct nl_dump_params *p)
+{
+	struct tcf_em_cmp *cmp = rtnl_ematch_data(m);
+
+	nl_dump(p, "%s at %s+%u ",
+		align_txt(cmp), layer_txt(cmp), cmp->off);
+
+	if (cmp->mask)
+		nl_dump(p, "& 0x%x ", cmp->mask);
+
+	nl_dump(p, "%s %u", relation_txt(cmp), cmp->val);
+}
+
+static struct rtnl_ematch_ops cmp_ops = {
+	.eo_kind	= TCF_EM_CMP,
+	.eo_name	= "cmp",
+	.eo_datalen	= sizeof(struct tcf_em_cmp),
+	.eo_parse	= cmp_parse,
+	.eo_dump	= cmp_dump,
+};
+
+static void __init cmp_init(void)
+{
+	rtnl_ematch_register(&cmp_ops);
+}
+
+static void __exit cmp_exit(void)
+{
+	rtnl_ematch_unregister(&cmp_ops);
+}
+
+/** @} */
diff -uNr libnl_kk/lib/route/cls/ematch/container.c libnl/lib/route/cls/ematch/container.c
--- libnl_kk/lib/route/cls/ematch/container.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/cls/ematch/container.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,39 @@
+/*
+ * lib/route/cls/ematch/container.c	Container Ematch
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2008-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#include <netlink-local.h>
+#include <netlink-tc.h>
+#include <netlink/netlink.h>
+#include <netlink/route/cls/ematch.h>
+
+static int container_parse(struct rtnl_ematch *m, void *data, size_t len)
+{
+	memcpy(m->e_data, data, sizeof(uint32_t));
+
+	return 0;
+}
+
+static struct rtnl_ematch_ops container_ops = {
+	.eo_kind	= TCF_EM_CONTAINER,
+	.eo_name	= "container",
+	.eo_datalen	= sizeof(uint32_t),
+	.eo_parse	= container_parse,
+};
+
+static void __init container_init(void)
+{
+	rtnl_ematch_register(&container_ops);
+}
+
+static void __exit container_exit(void)
+{
+	rtnl_ematch_unregister(&container_ops);
+}
diff -uNr libnl_kk/lib/route/cls/ematch.c libnl/lib/route/cls/ematch.c
--- libnl_kk/lib/route/cls/ematch.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/cls/ematch.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,410 @@
+/*
+ * lib/route/cls/ematch.c	Extended Matches
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2008-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup cls
+ * @defgroup ematch Extended Match
+ *
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink-tc.h>
+#include <netlink/netlink.h>
+#include <netlink/route/classifier.h>
+#include <netlink/route/classifier-modules.h>
+#include <netlink/route/cls/ematch.h>
+
+/**
+ * @name Module Registration
+ * @{
+ */
+
+static NL_LIST_HEAD(ematch_ops_list);
+
+/**
+ * Register ematch module
+ * @arg ops		Module operations.
+ *
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_ematch_register(struct rtnl_ematch_ops *ops)
+{
+	if (rtnl_ematch_lookup_ops(ops->eo_kind))
+		return -NLE_EXIST;
+
+	nl_list_add_tail(&ops->eo_list, &ematch_ops_list);
+
+	return 0;
+}
+
+/**
+ * Unregister ematch module
+ * @arg ops		Module operations.
+ *
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_ematch_unregister(struct rtnl_ematch_ops *ops)
+{
+	struct rtnl_ematch_ops *o;
+
+	nl_list_for_each_entry(o, &ematch_ops_list, eo_list) {
+		if (ops->eo_kind == o->eo_kind) {
+			nl_list_del(&o->eo_list);
+			return 0;
+		}
+	}
+
+	return -NLE_OBJ_NOTFOUND;
+}
+
+/**
+ * Lookup ematch module by kind
+ * @arg kind		Module kind.
+ *
+ * @return Module operations or NULL if not found.
+ */
+struct rtnl_ematch_ops *rtnl_ematch_lookup_ops(int kind)
+{
+	struct rtnl_ematch_ops *ops;
+
+	nl_list_for_each_entry(ops, &ematch_ops_list, eo_list)
+		if (ops->eo_kind == kind)
+			return ops;
+
+	return NULL;
+}
+
+/**
+ * Lookup ematch module by name
+ * @arg name		Name of ematch module.
+ *
+ * @return Module operations or NULL if not fuond.
+ */
+struct rtnl_ematch_ops *rtnl_ematch_lookup_ops_name(const char *name)
+{
+	struct rtnl_ematch_ops *ops;
+
+	nl_list_for_each_entry(ops, &ematch_ops_list, eo_list)
+		if (!strcasecmp(ops->eo_name, name))
+			return ops;
+
+	return NULL;
+}
+
+/** @} */
+
+/**
+ * @name Match
+ */
+
+struct rtnl_ematch *rtnl_ematch_alloc(struct rtnl_ematch_ops *ops)
+{
+	struct rtnl_ematch *e;
+	size_t len = sizeof(*e) + (ops ? ops->eo_datalen : 0);
+
+	if (!(e = calloc(1, len)))
+		return NULL;
+
+	NL_INIT_LIST_HEAD(&e->e_list);
+	NL_INIT_LIST_HEAD(&e->e_childs);
+
+	if (ops) {
+		e->e_ops = ops;
+		e->e_kind = ops->eo_kind;
+	}
+
+	return e;
+}
+
+/**
+ * Add ematch to the end of the parent's list of children.
+ * @arg parent		Parent ematch.
+ * @arg child		Ematch to be added as new child of parent.
+ */
+void rtnl_ematch_add_child(struct rtnl_ematch *parent,
+			   struct rtnl_ematch *child)
+{
+	nl_list_add_tail(&child->e_list, &parent->e_childs);
+}
+
+/**
+ * Remove ematch from the list it is linked to.
+ * @arg ematch		Ematch to be unlinked.
+ */
+void rtnl_ematch_unlink(struct rtnl_ematch *ematch)
+{
+	nl_list_del(&ematch->e_list);
+}
+
+void rtnl_ematch_free(struct rtnl_ematch *ematch)
+{
+	if (!ematch)
+		return;
+
+	free(ematch);
+}
+
+void rtnl_ematch_set_flags(struct rtnl_ematch *ematch, uint16_t flags)
+{
+	ematch->e_flags |= flags;
+}
+
+void rtnl_ematch_unset_flags(struct rtnl_ematch *ematch, uint16_t flags)
+{
+	ematch->e_flags &= ~flags;
+}
+
+uint16_t rtnl_ematch_get_flags(struct rtnl_ematch *ematch)
+{
+	return ematch->e_flags;
+}
+
+void *rtnl_ematch_data(struct rtnl_ematch *ematch)
+{
+	return ematch->e_data;
+}
+
+/** @} */
+
+/**
+ * @name Tree
+ */
+
+struct rtnl_ematch_tree *rtnl_ematch_tree_alloc(uint16_t progid)
+{
+	struct rtnl_ematch_tree *tree;
+
+	if (!(tree = calloc(1, sizeof(*tree))))
+		return NULL;
+
+	NL_INIT_LIST_HEAD(&tree->et_list);
+	tree->et_progid = progid;
+
+	return tree;
+}
+
+static void free_ematch_list(struct nl_list_head *head)
+{
+	struct rtnl_ematch *pos, *next;
+
+	nl_list_for_each_entry_safe(pos, next, head, e_list) {
+		if (!nl_list_empty(&pos->e_childs))
+			free_ematch_list(&pos->e_childs);
+		rtnl_ematch_free(pos);
+	}
+}
+
+void rtnl_ematch_tree_free(struct rtnl_ematch_tree *tree)
+{
+	if (!tree)
+		return;
+
+	free_ematch_list(&tree->et_list);
+	free(tree);
+}
+
+void rtnl_ematch_tree_add_tail(struct rtnl_ematch_tree *tree,
+			       struct rtnl_ematch *ematch)
+{
+	nl_list_add_tail(&ematch->e_list, &tree->et_list);
+}
+
+static inline uint32_t container_ref(struct rtnl_ematch *ematch)
+{
+	return *((uint32_t *) rtnl_ematch_data(ematch));
+}
+
+static int link_tree(struct rtnl_ematch *index[], int nmatches, int pos,
+		     struct nl_list_head *root)
+{
+	struct rtnl_ematch *ematch;
+	int i;
+
+	for (i = pos; i < nmatches; i++) {
+		ematch = index[i];
+
+		nl_list_add_tail(&ematch->e_list, root);
+
+		if (ematch->e_kind == TCF_EM_CONTAINER)
+			link_tree(index, nmatches, container_ref(ematch),
+				  &ematch->e_childs);
+
+		if (!(ematch->e_flags & TCF_EM_REL_MASK))
+			return 0;
+	}
+
+	/* Last entry in chain can't possibly have no relation */
+	return -NLE_INVAL;
+}
+
+static struct nla_policy tree_policy[TCA_EMATCH_TREE_MAX+1] = {
+	[TCA_EMATCH_TREE_HDR]  = { .minlen=sizeof(struct tcf_ematch_tree_hdr) },
+	[TCA_EMATCH_TREE_LIST] = { .type = NLA_NESTED },
+};
+
+/**
+ * Parse ematch netlink attributes
+ *
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_ematch_parse(struct nlattr *attr, struct rtnl_ematch_tree **result)
+{
+	struct nlattr *a, *tb[TCA_EMATCH_TREE_MAX+1];
+	struct tcf_ematch_tree_hdr *thdr;
+	struct rtnl_ematch_tree *tree;
+	struct rtnl_ematch **index;
+	int nmatches = 0, err, remaining;
+
+	err = nla_parse_nested(tb, TCA_EMATCH_TREE_MAX, attr, tree_policy);
+	if (err < 0)
+		return err;
+
+	if (!tb[TCA_EMATCH_TREE_HDR])
+		return -NLE_MISSING_ATTR;
+
+	thdr = nla_data(tb[TCA_EMATCH_TREE_HDR]);
+
+	/* Ignore empty trees */
+	if (thdr->nmatches == 0)
+		return 0;
+
+	if (!tb[TCA_EMATCH_TREE_LIST])
+		return -NLE_MISSING_ATTR;
+
+	if (thdr->nmatches > (nla_len(tb[TCA_EMATCH_TREE_LIST]) /
+			      nla_total_size(sizeof(struct tcf_ematch_hdr))))
+		return -NLE_INVAL;
+
+	if (!(index = calloc(thdr->nmatches, sizeof(struct rtnl_ematch *))))
+		return -NLE_NOMEM;
+
+	if (!(tree = rtnl_ematch_tree_alloc(thdr->progid))) {
+		err = -NLE_NOMEM;
+		goto errout;
+	}
+
+	nla_for_each_nested(a, tb[TCA_EMATCH_TREE_LIST], remaining) {
+		struct rtnl_ematch_ops *ops;
+		struct tcf_ematch_hdr *hdr;
+		struct rtnl_ematch *ematch;
+		void *data;
+		size_t len;
+
+		if (nla_len(a) < sizeof(*hdr)) {
+			err = -NLE_INVAL;
+			goto errout;
+		}
+
+		if (nmatches >= thdr->nmatches) {
+			err = -NLE_RANGE;
+			goto errout;
+		}
+
+		hdr = nla_data(a);
+		data = nla_data(a) + NLA_ALIGN(sizeof(*hdr));
+		len = nla_len(a) - NLA_ALIGN(sizeof(*hdr));
+
+		ops = rtnl_ematch_lookup_ops(hdr->kind);
+		if (ops && ops->eo_datalen && len < ops->eo_datalen) {
+			err = -NLE_INVAL;
+			goto errout;
+		}
+
+		if (!(ematch = rtnl_ematch_alloc(ops))) {
+			err = -NLE_NOMEM;
+			goto errout;
+		}
+
+		ematch->e_id = hdr->matchid;
+		ematch->e_kind = hdr->kind;
+		ematch->e_flags = hdr->flags;
+
+		if (ops && (err = ops->eo_parse(ematch, data, len)) < 0)
+			goto errout;
+
+		if (hdr->kind == TCF_EM_CONTAINER &&
+		    container_ref(ematch) >= thdr->nmatches) {
+			err = -NLE_INVAL;
+			goto errout;
+		}
+
+		index[nmatches++] = ematch;
+	}
+
+	if (nmatches != thdr->nmatches) {
+		err = -NLE_INVAL;
+		goto errout;
+	}
+
+	err = link_tree(index, nmatches, 0, &tree->et_list);
+	if (err < 0)
+		goto errout;
+
+	free(index);
+	*result = tree;
+
+	return 0;
+
+errout:
+	rtnl_ematch_tree_free(tree);
+	free(index);
+	return err;
+}
+
+static void dump_ematch_sequence(struct nl_list_head *head,
+				 struct nl_dump_params *p)
+{
+	struct rtnl_ematch *match;
+
+	nl_list_for_each_entry(match, head, e_list) {
+		if (match->e_flags & TCF_EM_INVERT)
+			nl_dump(p, "NOT ");
+
+		if (match->e_kind == TCF_EM_CONTAINER) {
+			nl_dump(p, "(");
+			dump_ematch_sequence(&match->e_childs, p);
+			nl_dump(p, ")");
+		} else if (!match->e_ops) {
+			nl_dump(p, "[unknown ematch %d]", match->e_kind);
+		} else {
+			nl_dump(p, "%s(", match->e_ops->eo_name);
+
+			if (match->e_ops->eo_dump)
+				match->e_ops->eo_dump(match, p);
+
+			nl_dump(p, ")");
+		}
+
+		switch (match->e_flags & TCF_EM_REL_MASK) {
+		case TCF_EM_REL_AND:
+			nl_dump(p, " AND ");
+			break;
+		case TCF_EM_REL_OR:
+			nl_dump(p, " OR ");
+			break;
+		default:
+			/* end of first level ematch sequence */
+			return;
+		}
+	}
+}
+
+void rtnl_ematch_tree_dump(struct rtnl_ematch_tree *tree,
+			   struct nl_dump_params *p)
+{
+	dump_ematch_sequence(&tree->et_list, p);
+	nl_dump(p, "\n");
+}
+
+/** @} */
+
+/** @} */
diff -uNr libnl_kk/lib/route/cls/fw.c libnl/lib/route/cls/fw.c
--- libnl_kk/lib/route/cls/fw.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/cls/fw.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,180 @@
+/*
+ * lib/route/cls/fw.c		fw classifier
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2009 Thomas Graf <tgraf@suug.ch>
+ * Copyright (c) 2006 Petr Gotthard <petr.gotthard@siemens.com>
+ * Copyright (c) 2006 Siemens AG Oesterreich
+ */
+
+/**
+ * @ingroup cls_api
+ * @defgroup fw Firewall Classifier
+ *
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink-tc.h>
+#include <netlink/netlink.h>
+#include <netlink/route/classifier.h>
+#include <netlink/route/classifier-modules.h>
+#include <netlink/route/cls/fw.h>
+
+/** @cond SKIP */
+#define FW_ATTR_CLASSID      0x001
+#define FW_ATTR_ACTION       0x002
+#define FW_ATTR_POLICE       0x004
+#define FW_ATTR_INDEV        0x008
+/** @endcond */
+
+static struct nla_policy fw_policy[TCA_FW_MAX+1] = {
+	[TCA_FW_CLASSID]	= { .type = NLA_U32 },
+	[TCA_FW_INDEV]		= { .type = NLA_STRING,
+				    .maxlen = IFNAMSIZ },
+};
+
+static int fw_msg_parser(struct rtnl_cls *cls)
+{
+	struct rtnl_fw *f = rtnl_cls_data(cls);
+	struct nlattr *tb[TCA_FW_MAX + 1];
+	int err;
+
+	err = tca_parse(tb, TCA_FW_MAX, (struct rtnl_tca *) cls, fw_policy);
+	if (err < 0)
+		return err;
+
+	if (tb[TCA_FW_CLASSID]) {
+		f->cf_classid = nla_get_u32(tb[TCA_FW_CLASSID]);
+		f->cf_mask |= FW_ATTR_CLASSID;
+	}
+
+	if (tb[TCA_FW_ACT]) {
+		f->cf_act = nl_data_alloc_attr(tb[TCA_FW_ACT]);
+		if (!f->cf_act)
+			return -NLE_NOMEM;
+		f->cf_mask |= FW_ATTR_ACTION;
+	}
+
+	if (tb[TCA_FW_POLICE]) {
+		f->cf_police = nl_data_alloc_attr(tb[TCA_FW_POLICE]);
+		if (!f->cf_police)
+			return -NLE_NOMEM;
+		f->cf_mask |= FW_ATTR_POLICE;
+	}
+
+	if (tb[TCA_FW_INDEV]) {
+		nla_strlcpy(f->cf_indev, tb[TCA_FW_INDEV], IFNAMSIZ);
+		f->cf_mask |= FW_ATTR_INDEV;
+	}
+
+	return 0;
+}
+
+static void fw_free_data(struct rtnl_cls *cls)
+{
+	struct rtnl_fw *f = rtnl_cls_data(cls);
+
+	nl_data_free(f->cf_act);
+	nl_data_free(f->cf_police);
+}
+
+static int fw_clone(struct rtnl_cls *_dst, struct rtnl_cls *_src)
+{
+	struct rtnl_fw *dst = rtnl_cls_data(_dst);
+	struct rtnl_fw *src = rtnl_cls_data(_src);
+
+	if (src->cf_act && !(dst->cf_act = nl_data_clone(src->cf_act)))
+		return -NLE_NOMEM;
+	
+	if (src->cf_police && !(dst->cf_police = nl_data_clone(src->cf_police)))
+		return -NLE_NOMEM;
+
+	return 0;
+}
+
+static void fw_dump_line(struct rtnl_cls *cls, struct nl_dump_params *p)
+{
+	struct rtnl_fw *f = rtnl_cls_data(cls);
+	char buf[32];
+
+	if (f->cf_mask & FW_ATTR_CLASSID)
+		nl_dump(p, " target %s",
+			rtnl_tc_handle2str(f->cf_classid, buf, sizeof(buf)));
+}
+
+static void fw_dump_details(struct rtnl_cls *cls, struct nl_dump_params *p)
+{
+	struct rtnl_fw *f = rtnl_cls_data(cls);
+
+	if (f->cf_mask & FW_ATTR_INDEV)
+		nl_dump(p, "indev %s ", f->cf_indev);
+}
+
+static int fw_get_opts(struct rtnl_cls *cls, struct nl_msg *msg)
+{
+	struct rtnl_fw *f = rtnl_cls_data(cls);
+	
+	if (f->cf_mask & FW_ATTR_CLASSID)
+		NLA_PUT_U32(msg, TCA_FW_CLASSID, f->cf_classid);
+
+	if (f->cf_mask & FW_ATTR_ACTION)
+		NLA_PUT_DATA(msg, TCA_FW_ACT, f->cf_act);
+
+	if (f->cf_mask & FW_ATTR_POLICE)
+		NLA_PUT_DATA(msg, TCA_FW_POLICE, f->cf_police);
+
+	if (f->cf_mask & FW_ATTR_INDEV)
+		NLA_PUT_STRING(msg, TCA_FW_INDEV, f->cf_indev);
+
+	return 0;
+
+nla_put_failure:
+	return -NLE_NOMEM;
+}
+
+/**
+ * @name Attribute Modifications
+ * @{
+ */
+
+int rtnl_fw_set_classid(struct rtnl_cls *cls, uint32_t classid)
+{
+	struct rtnl_fw *f = rtnl_cls_data(cls);
+	
+	f->cf_classid = classid;
+	f->cf_mask |= FW_ATTR_CLASSID;
+
+	return 0;
+}
+
+/** @} */
+
+static struct rtnl_cls_ops fw_ops = {
+	.co_kind		= "fw",
+	.co_size		= sizeof(struct rtnl_fw),
+	.co_msg_parser		= fw_msg_parser,
+	.co_free_data		= fw_free_data,
+	.co_clone		= fw_clone,
+	.co_get_opts		= fw_get_opts,
+	.co_dump = {
+	    [NL_DUMP_LINE]	= fw_dump_line,
+	    [NL_DUMP_DETAILS]	= fw_dump_details,
+	},
+};
+
+static void __init fw_init(void)
+{
+	rtnl_cls_register(&fw_ops);
+}
+
+static void __exit fw_exit(void)
+{
+	rtnl_cls_unregister(&fw_ops);
+}
+
+/** @} */
diff -uNr libnl_kk/lib/route/cls/police.c libnl/lib/route/cls/police.c
--- libnl_kk/lib/route/cls/police.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/cls/police.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,67 @@
+/*
+ * lib/route/cls/police.c	Policer
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2006 Thomas Graf <tgraf@suug.ch>
+ */
+
+#include <netlink-local.h>
+#include <netlink-tc.h>
+#include <netlink/netlink.h>
+#include <netlink/utils.h>
+#include <netlink/route/tc.h>
+#include <netlink/route/classifier.h>
+#include <netlink/route/classifier-modules.h>
+#include <netlink/route/cls/police.h>
+
+/**
+ * @name Policer Type
+ * @{
+ */
+
+static struct trans_tbl police_types[] = {
+	__ADD(TC_POLICE_UNSPEC,unspec)
+	__ADD(TC_POLICE_OK,ok)
+	__ADD(TC_POLICE_RECLASSIFY,reclassify)
+	__ADD(TC_POLICE_SHOT,shot)
+#ifdef TC_POLICE_PIPE
+	__ADD(TC_POLICE_PIPE,pipe)
+#endif
+};
+
+/**
+ * Transform a policer type number into a character string (Reentrant).
+ * @arg type		policer type
+ * @arg buf		destination buffer
+ * @arg len		buffer length
+ *
+ * Transforms a policer type number into a character string and stores
+ * it in the provided buffer.
+ *
+ * @return The destination buffer or the type encoded in hex if no match was found.
+ */
+char * nl_police2str(int type, char *buf, size_t len)
+{
+	return __type2str(type, buf, len, police_types,
+			  ARRAY_SIZE(police_types));
+}
+
+/**
+ * Transform a character string into a policer type number
+ * @arg name		policer type name
+ *
+ * Transform the provided character string specifying a policer
+ * type into the corresponding numeric value
+ *
+ * @return Policer type number or a negative value.
+ */
+int nl_str2police(const char *name)
+{
+	return __str2type(name, police_types, ARRAY_SIZE(police_types));
+}
+
+/** @} */
diff -uNr libnl_kk/lib/route/cls/u32.c libnl/lib/route/cls/u32.c
--- libnl_kk/lib/route/cls/u32.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/cls/u32.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,528 @@
+/*
+ * lib/route/cls/u32.c		u32 classifier
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2009 Thomas Graf <tgraf@suug.ch>
+ * Copyright (c) 2005-2006 Petr Gotthard <petr.gotthard@siemens.com>
+ * Copyright (c) 2005-2006 Siemens AG Oesterreich
+ */
+
+/**
+ * @ingroup cls_api
+ * @defgroup u32 Universal 32-bit Classifier
+ *
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink-tc.h>
+#include <netlink/netlink.h>
+#include <netlink/attr.h>
+#include <netlink/utils.h>
+#include <netlink/route/tc.h>
+#include <netlink/route/classifier.h>
+#include <netlink/route/classifier-modules.h>
+#include <netlink/route/cls/u32.h>
+
+/** @cond SKIP */
+#define U32_ATTR_DIVISOR      0x001
+#define U32_ATTR_HASH         0x002
+#define U32_ATTR_CLASSID      0x004
+#define U32_ATTR_LINK         0x008
+#define U32_ATTR_PCNT         0x010
+#define U32_ATTR_SELECTOR     0x020
+#define U32_ATTR_ACTION       0x040
+#define U32_ATTR_POLICE       0x080
+#define U32_ATTR_INDEV        0x100
+/** @endcond */
+
+static inline struct tc_u32_sel *u32_selector(struct rtnl_u32 *u)
+{
+	return (struct tc_u32_sel *) u->cu_selector->d_data;
+}
+
+static inline struct tc_u32_sel *u32_selector_alloc(struct rtnl_u32 *u)
+{
+	if (!u->cu_selector)
+		u->cu_selector = nl_data_alloc(NULL, sizeof(struct tc_u32_sel));
+
+	return u32_selector(u);
+}
+
+static struct nla_policy u32_policy[TCA_U32_MAX+1] = {
+	[TCA_U32_DIVISOR]	= { .type = NLA_U32 },
+	[TCA_U32_HASH]		= { .type = NLA_U32 },
+	[TCA_U32_CLASSID]	= { .type = NLA_U32 },
+	[TCA_U32_LINK]		= { .type = NLA_U32 },
+	[TCA_U32_INDEV]		= { .type = NLA_STRING,
+				    .maxlen = IFNAMSIZ },
+	[TCA_U32_SEL]		= { .minlen = sizeof(struct tc_u32_sel) },
+	[TCA_U32_PCNT]		= { .minlen = sizeof(struct tc_u32_pcnt) },
+};
+
+static int u32_msg_parser(struct rtnl_cls *cls)
+{
+	struct rtnl_u32 *u = rtnl_cls_data(cls);
+	struct nlattr *tb[TCA_U32_MAX + 1];
+	int err;
+
+	err = tca_parse(tb, TCA_U32_MAX, (struct rtnl_tca *) cls, u32_policy);
+	if (err < 0)
+		return err;
+
+	if (tb[TCA_U32_DIVISOR]) {
+		u->cu_divisor = nla_get_u32(tb[TCA_U32_DIVISOR]);
+		u->cu_mask |= U32_ATTR_DIVISOR;
+	}
+
+	if (tb[TCA_U32_SEL]) {
+		u->cu_selector = nl_data_alloc_attr(tb[TCA_U32_SEL]);
+		if (!u->cu_selector)
+			goto errout_nomem;
+		u->cu_mask |= U32_ATTR_SELECTOR;
+	}
+
+	if (tb[TCA_U32_HASH]) {
+		u->cu_hash = nla_get_u32(tb[TCA_U32_HASH]);
+		u->cu_mask |= U32_ATTR_HASH;
+	}
+
+	if (tb[TCA_U32_CLASSID]) {
+		u->cu_classid = nla_get_u32(tb[TCA_U32_CLASSID]);
+		u->cu_mask |= U32_ATTR_CLASSID;
+	}
+
+	if (tb[TCA_U32_LINK]) {
+		u->cu_link = nla_get_u32(tb[TCA_U32_LINK]);
+		u->cu_mask |= U32_ATTR_LINK;
+	}
+
+	if (tb[TCA_U32_ACT]) {
+		u->cu_act = nl_data_alloc_attr(tb[TCA_U32_ACT]);
+		if (!u->cu_act)
+			goto errout_nomem;
+		u->cu_mask |= U32_ATTR_ACTION;
+	}
+
+	if (tb[TCA_U32_POLICE]) {
+		u->cu_police = nl_data_alloc_attr(tb[TCA_U32_POLICE]);
+		if (!u->cu_police)
+			goto errout_nomem;
+		u->cu_mask |= U32_ATTR_POLICE;
+	}
+
+	if (tb[TCA_U32_PCNT]) {
+		struct tc_u32_sel *sel;
+		int pcnt_size;
+
+		if (!tb[TCA_U32_SEL]) {
+			err = -NLE_MISSING_ATTR;
+			goto errout;
+		}
+		
+		sel = u->cu_selector->d_data;
+		pcnt_size = sizeof(struct tc_u32_pcnt) +
+				(sel->nkeys * sizeof(uint64_t));
+		if (nla_len(tb[TCA_U32_PCNT]) < pcnt_size) {
+			err = -NLE_INVAL;
+			goto errout;
+		}
+
+		u->cu_pcnt = nl_data_alloc_attr(tb[TCA_U32_PCNT]);
+		if (!u->cu_pcnt)
+			goto errout_nomem;
+		u->cu_mask |= U32_ATTR_PCNT;
+	}
+
+	if (tb[TCA_U32_INDEV]) {
+		nla_strlcpy(u->cu_indev, tb[TCA_U32_INDEV], IFNAMSIZ);
+		u->cu_mask |= U32_ATTR_INDEV;
+	}
+
+	return 0;
+
+errout_nomem:
+	err = -NLE_NOMEM;
+errout:
+	return err;
+}
+
+static void u32_free_data(struct rtnl_cls *cls)
+{
+	struct rtnl_u32 *u = rtnl_cls_data(cls);
+
+	nl_data_free(u->cu_selector);
+	nl_data_free(u->cu_act);
+	nl_data_free(u->cu_police);
+	nl_data_free(u->cu_pcnt);
+}
+
+static int u32_clone(struct rtnl_cls *_dst, struct rtnl_cls *_src)
+{
+	struct rtnl_u32 *dst = rtnl_cls_data(_dst);
+	struct rtnl_u32 *src = rtnl_cls_data(_src);
+
+	if (src->cu_selector &&
+	    !(dst->cu_selector = nl_data_clone(src->cu_selector)))
+		return -NLE_NOMEM;
+
+	if (src->cu_act && !(dst->cu_act = nl_data_clone(src->cu_act)))
+		return -NLE_NOMEM;
+
+	if (src->cu_police && !(dst->cu_police = nl_data_clone(src->cu_police)))
+		return -NLE_NOMEM;
+
+	if (src->cu_pcnt && !(dst->cu_pcnt = nl_data_clone(src->cu_pcnt)))
+		return -NLE_NOMEM;
+
+	return 0;
+}
+
+static void u32_dump_line(struct rtnl_cls *cls, struct nl_dump_params *p)
+{
+	struct rtnl_u32 *u = rtnl_cls_data(cls);
+	char buf[32];
+
+	if (u->cu_mask & U32_ATTR_DIVISOR)
+		nl_dump(p, " divisor %u", u->cu_divisor);
+	else if (u->cu_mask & U32_ATTR_CLASSID)
+		nl_dump(p, " target %s",
+			rtnl_tc_handle2str(u->cu_classid, buf, sizeof(buf)));
+}
+
+static void print_selector(struct nl_dump_params *p, struct tc_u32_sel *sel,
+			   struct rtnl_cls *cls, struct rtnl_u32 *u)
+{
+	int i;
+	struct tc_u32_key *key;
+
+	if (sel->hmask || sel->hoff) {
+		/* I guess this will never be used since the kernel only
+		 * exports the selector if no divisor is set but hash offset
+		 * and hash mask make only sense in hash filters with divisor
+		 * set */
+		nl_dump(p, " hash at %u & 0x%x", sel->hoff, sel->hmask);
+	}
+
+	if (sel->flags & (TC_U32_OFFSET | TC_U32_VAROFFSET)) {
+		nl_dump(p, " offset at %u", sel->off);
+
+		if (sel->flags & TC_U32_VAROFFSET)
+			nl_dump(p, " variable (at %u & 0x%x) >> %u",
+				sel->offoff, ntohs(sel->offmask), sel->offshift);
+	}
+
+	if (sel->flags) {
+		int flags = sel->flags;
+		nl_dump(p, " <");
+
+#define PRINT_FLAG(f) if (flags & TC_U32_##f) { \
+	flags &= ~TC_U32_##f; nl_dump(p, #f "%s", flags ? "," : ""); }
+
+		PRINT_FLAG(TERMINAL);
+		PRINT_FLAG(OFFSET);
+		PRINT_FLAG(VAROFFSET);
+		PRINT_FLAG(EAT);
+#undef PRINT_FLAG
+
+		nl_dump(p, ">");
+	}
+		
+	
+	for (i = 0; i < sel->nkeys; i++) {
+		key = (struct tc_u32_key *) ((char *) sel + sizeof(*sel)) + i;
+
+		nl_dump(p, "\n");
+		nl_dump_line(p, "      match key at %s%u ",
+			key->offmask ? "nexthdr+" : "", key->off);
+
+		if (key->offmask)
+			nl_dump(p, "[0x%u] ", key->offmask);
+
+		nl_dump(p, "& 0x%08x == 0x%08x", ntohl(key->mask), ntohl(key->val));
+
+		if (p->dp_type == NL_DUMP_STATS &&
+		    (u->cu_mask & U32_ATTR_PCNT)) {
+			struct tc_u32_pcnt *pcnt = u->cu_pcnt->d_data;
+			nl_dump(p, " successful %" PRIu64, pcnt->kcnts[i]);
+		}
+	}
+}
+
+static void u32_dump_details(struct rtnl_cls *cls, struct nl_dump_params *p)
+{
+	struct rtnl_u32 *u = rtnl_cls_data(cls);
+	struct tc_u32_sel *s;
+
+	if (!(u->cu_mask & U32_ATTR_SELECTOR)) {
+		nl_dump(p, "no-selector\n");
+		return;
+	}
+	
+	s = u->cu_selector->d_data;
+
+	nl_dump(p, "nkeys %u ", s->nkeys);
+
+	if (u->cu_mask & U32_ATTR_HASH)
+		nl_dump(p, "ht key 0x%x hash 0x%u",
+			TC_U32_USERHTID(u->cu_hash), TC_U32_HASH(u->cu_hash));
+
+	if (u->cu_mask & U32_ATTR_LINK)
+		nl_dump(p, "link %u ", u->cu_link);
+
+	if (u->cu_mask & U32_ATTR_INDEV)
+		nl_dump(p, "indev %s ", u->cu_indev);
+
+	print_selector(p, s, cls, u);
+	nl_dump(p, "\n");
+
+#if 0	
+#define U32_ATTR_ACTION       0x040
+#define U32_ATTR_POLICE       0x080
+
+	struct nl_data   act;
+	struct nl_data   police;
+#endif
+}
+
+static void u32_dump_stats(struct rtnl_cls *cls, struct nl_dump_params *p)
+{
+	struct rtnl_u32 *u = rtnl_cls_data(cls);
+
+	if (u->cu_mask & U32_ATTR_PCNT) {
+		struct tc_u32_pcnt *pc = u->cu_pcnt->d_data;
+		nl_dump(p, "\n");
+		nl_dump_line(p, "    hit %8llu count %8llu\n",
+			     pc->rhit, pc->rcnt);
+	}
+}
+
+static int u32_get_opts(struct rtnl_cls *cls, struct nl_msg *msg)
+{
+	struct rtnl_u32 *u = rtnl_cls_data(cls);
+	
+	if (u->cu_mask & U32_ATTR_DIVISOR)
+		NLA_PUT_U32(msg, TCA_U32_DIVISOR, u->cu_divisor);
+
+	if (u->cu_mask & U32_ATTR_HASH)
+		NLA_PUT_U32(msg, TCA_U32_HASH, u->cu_hash);
+
+	if (u->cu_mask & U32_ATTR_CLASSID)
+		NLA_PUT_U32(msg, TCA_U32_CLASSID, u->cu_classid);
+
+	if (u->cu_mask & U32_ATTR_LINK)
+		NLA_PUT_U32(msg, TCA_U32_LINK, u->cu_link);
+
+	if (u->cu_mask & U32_ATTR_SELECTOR)
+		NLA_PUT_DATA(msg, TCA_U32_SEL, u->cu_selector);
+
+	if (u->cu_mask & U32_ATTR_ACTION)
+		NLA_PUT_DATA(msg, TCA_U32_ACT, u->cu_act);
+
+	if (u->cu_mask & U32_ATTR_POLICE)
+		NLA_PUT_DATA(msg, TCA_U32_POLICE, u->cu_police);
+
+	if (u->cu_mask & U32_ATTR_INDEV)
+		NLA_PUT_STRING(msg, TCA_U32_INDEV, u->cu_indev);
+
+	return 0;
+
+nla_put_failure:
+	return -NLE_NOMEM;
+}
+
+/**
+ * @name Attribute Modifications
+ * @{
+ */
+
+void rtnl_u32_set_handle(struct rtnl_cls *cls, int htid, int hash,
+			 int nodeid)
+{
+	uint32_t handle = (htid << 20) | (hash << 12) | nodeid;
+
+	tca_set_handle((struct rtnl_tca *) cls, handle );
+}
+ 
+int rtnl_u32_set_classid(struct rtnl_cls *cls, uint32_t classid)
+{
+	struct rtnl_u32 *u = rtnl_cls_data(cls);
+	
+	u->cu_classid = classid;
+	u->cu_mask |= U32_ATTR_CLASSID;
+
+	return 0;
+}
+
+/** @} */
+
+/**
+ * @name Selector Modifications
+ * @{
+ */
+
+int rtnl_u32_set_flags(struct rtnl_cls *cls, int flags)
+{
+	struct tc_u32_sel *sel;
+	struct rtnl_u32 *u = rtnl_cls_data(cls);
+
+	sel = u32_selector_alloc(u);
+	if (!sel)
+		return -NLE_NOMEM;
+
+	sel->flags |= flags;
+	u->cu_mask |= U32_ATTR_SELECTOR;
+
+	return 0;
+}
+
+/**
+ * Append new 32-bit key to the selector
+ *
+ * @arg cls	classifier to be modifier
+ * @arg val	value to be matched (network byte-order)
+ * @arg mask	mask to be applied before matching (network byte-order)
+ * @arg off	offset, in bytes, to start matching
+ * @arg offmask	offset mask
+ *
+ * General selectors define the pattern, mask and offset the pattern will be
+ * matched to the packet contents. Using the general selectors you can match
+ * virtually any single bit in the IP (or upper layer) header.
+ *
+*/
+int rtnl_u32_add_key(struct rtnl_cls *cls, uint32_t val, uint32_t mask,
+		     int off, int offmask)
+{
+	struct tc_u32_sel *sel;
+	struct rtnl_u32 *u = rtnl_cls_data(cls);
+	int err;
+
+	sel = u32_selector_alloc(u);
+	if (!sel)
+		return -NLE_NOMEM;
+
+	err = nl_data_append(u->cu_selector, NULL, sizeof(struct tc_u32_key));
+	if (err < 0)
+		return err;
+
+	/* the selector might have been moved by realloc */
+	sel = u32_selector(u);
+
+	sel->keys[sel->nkeys].mask = mask;
+	sel->keys[sel->nkeys].val = val & mask;
+	sel->keys[sel->nkeys].off = off;
+	sel->keys[sel->nkeys].offmask = offmask;
+	sel->nkeys++;
+	u->cu_mask |= U32_ATTR_SELECTOR;
+
+	return 0;
+}
+
+int rtnl_u32_add_key_uint8(struct rtnl_cls *cls, uint8_t val, uint8_t mask,
+			   int off, int offmask)
+{
+	int shift = 24 - 8 * (off & 3);
+
+	return rtnl_u32_add_key(cls, htonl((uint32_t)val << shift),
+				htonl((uint32_t)mask << shift),
+				off & ~3, offmask);
+}
+
+/**
+ * Append new selector key to match a 16-bit number
+ *
+ * @arg cls	classifier to be modified
+ * @arg val	value to be matched (host byte-order)
+ * @arg mask	mask to be applied before matching (host byte-order)
+ * @arg off	offset, in bytes, to start matching
+ * @arg offmask	offset mask
+*/
+int rtnl_u32_add_key_uint16(struct rtnl_cls *cls, uint16_t val, uint16_t mask,
+			    int off, int offmask)
+{
+	int shift = ((off & 3) == 0 ? 16 : 0);
+	if (off % 2)
+		return -NLE_INVAL;
+
+	return rtnl_u32_add_key(cls, htonl((uint32_t)val << shift),
+				htonl((uint32_t)mask << shift),
+				off & ~3, offmask);
+}
+
+/**
+ * Append new selector key to match a 32-bit number
+ *
+ * @arg cls	classifier to be modified
+ * @arg val	value to be matched (host byte-order)
+ * @arg mask	mask to be applied before matching (host byte-order)
+ * @arg off	offset, in bytes, to start matching
+ * @arg offmask	offset mask
+*/
+int rtnl_u32_add_key_uint32(struct rtnl_cls *cls, uint32_t val, uint32_t mask,
+			    int off, int offmask)
+{
+	return rtnl_u32_add_key(cls, htonl(val), htonl(mask),
+				off & ~3, offmask);
+}
+
+int rtnl_u32_add_key_in_addr(struct rtnl_cls *cls, struct in_addr *addr,
+			     uint8_t bitmask, int off, int offmask)
+{
+	uint32_t mask = 0xFFFFFFFF << (32 - bitmask);
+	return rtnl_u32_add_key(cls, addr->s_addr, htonl(mask), off, offmask);
+}
+
+int rtnl_u32_add_key_in6_addr(struct rtnl_cls *cls, struct in6_addr *addr,
+			      uint8_t bitmask, int off, int offmask)
+{
+	int i, err;
+
+	for (i = 1; i <= 4; i++) {
+		if (32 * i - bitmask <= 0) {
+			if ((err = rtnl_u32_add_key(cls, addr->s6_addr32[i-1],
+						0xFFFFFFFF, off+4*(i-1), offmask)) < 0)
+				return err;
+		}
+		else if (32 * i - bitmask < 32) {
+			uint32_t mask = 0xFFFFFFFF << (32 * i - bitmask);
+			if ((err = rtnl_u32_add_key(cls, addr->s6_addr32[i-1],
+						htonl(mask), off+4*(i-1), offmask)) < 0)
+				return err;
+		}
+		/* otherwise, if (32*i - bitmask >= 32) no key is generated */
+	}
+
+	return 0;
+}
+
+/** @} */
+
+static struct rtnl_cls_ops u32_ops = {
+	.co_kind		= "u32",
+	.co_size		= sizeof(struct rtnl_u32),
+	.co_msg_parser		= u32_msg_parser,
+	.co_free_data		= u32_free_data,
+	.co_clone		= u32_clone,
+	.co_get_opts		= u32_get_opts,
+	.co_dump = {
+	    [NL_DUMP_LINE]	= u32_dump_line,
+	    [NL_DUMP_DETAILS]	= u32_dump_details,
+	    [NL_DUMP_STATS]	= u32_dump_stats,
+	},
+};
+
+static void __init u32_init(void)
+{
+	rtnl_cls_register(&u32_ops);
+}
+
+static void __exit u32_exit(void)
+{
+	rtnl_cls_unregister(&u32_ops);
+}
+
+/** @} */
diff -uNr libnl_kk/lib/route/cls_api.c libnl/lib/route/cls_api.c
--- libnl_kk/lib/route/cls_api.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/cls_api.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,103 @@
+/*
+ * lib/route/cls_api.c       Classifier Module API
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup cls
+ * @defgroup cls_api Classifier Modules
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink-tc.h>
+#include <netlink/netlink.h>
+#include <netlink/utils.h>
+#include <netlink/route/tc.h>
+#include <netlink/route/classifier.h>
+#include <netlink/route/classifier-modules.h>
+#include <netlink/route/link.h>
+
+static struct rtnl_cls_ops *cls_ops_list;
+
+/**
+ * @name Classifier Module API
+ * @{
+ */
+
+/**
+ * Register a classifier module
+ * @arg cops		classifier module operations
+ */
+int rtnl_cls_register(struct rtnl_cls_ops *cops)
+{
+	struct rtnl_cls_ops *o, **op;
+
+	if (!cops->co_kind)
+		BUG();
+
+	for (op = &cls_ops_list; (o = *op) != NULL; op = &o->co_next)
+		if (!strcasecmp(cops->co_kind, o->co_kind))
+			return -NLE_EXIST;
+
+	cops->co_next = NULL;
+	*op = cops;
+
+	return 0;
+}
+
+/**
+ * Unregister a classifier module
+ * @arg cops		classifier module operations
+ */
+int rtnl_cls_unregister(struct rtnl_cls_ops *cops)
+{
+	struct rtnl_cls_ops *o, **op;
+
+	for (op = &cls_ops_list; (o = *op) != NULL; op = &o->co_next)
+		if (!strcasecmp(cops->co_kind, o->co_kind))
+			break;
+
+	if (!o)
+		return -NLE_OBJ_NOTFOUND;
+
+	*op = cops->co_next;
+
+	return 0;
+}
+
+struct rtnl_cls_ops *__rtnl_cls_lookup_ops(const char *kind)
+{
+	struct rtnl_cls_ops *cops;
+
+	for (cops = cls_ops_list; cops; cops = cops->co_next)
+		if (!strcmp(kind, cops->co_kind))
+			return cops;
+
+	return NULL;
+}
+
+/**
+ * Lookup classifier operations for a classifier object
+ * @arg cls		Classifier object.
+ *
+ * @return Classifier operations or NULL if not found.
+ */
+struct rtnl_cls_ops *rtnl_cls_lookup_ops(struct rtnl_cls *cls)
+{
+	if (!cls->c_ops)
+		cls->c_ops = __rtnl_cls_lookup_ops(cls->c_kind);
+
+	return cls->c_ops;
+}
+
+
+/** @} */
+
+/** @} */
diff -uNr libnl_kk/lib/route/cls.c libnl/lib/route/cls.c
--- libnl_kk/lib/route/cls.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/cls.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,341 @@
+/*
+ * lib/route/classifier.c       Classifier
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup tc
+ * @defgroup cls Classifiers
+ *
+ * @par Classifier Identification
+ * - protocol
+ * - priority
+ * - parent
+ * - interface
+ * - kind
+ * - handle
+ * 
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink-tc.h>
+#include <netlink/netlink.h>
+#include <netlink/utils.h>
+#include <netlink/route/tc.h>
+#include <netlink/route/classifier.h>
+#include <netlink/route/classifier-modules.h>
+#include <netlink/route/link.h>
+
+static struct nl_cache_ops rtnl_cls_ops;
+
+static int cls_msg_parser(struct nl_cache_ops *ops, struct sockaddr_nl *who,
+			  struct nlmsghdr *nlh, struct nl_parser_param *pp)
+{
+	struct rtnl_cls_ops *cops;
+	struct rtnl_cls *cls;
+	int err;
+
+	cls = rtnl_cls_alloc();
+	if (!cls) {
+		err = -NLE_NOMEM;
+		goto errout;
+	}
+	cls->ce_msgtype = nlh->nlmsg_type;
+
+	err = tca_msg_parser(nlh, (struct rtnl_tca *) cls);
+	if (err < 0)
+		goto errout_free;
+
+	cls->c_prio = TC_H_MAJ(cls->c_info) >> 16;
+	cls->c_protocol = ntohs(TC_H_MIN(cls->c_info));
+
+	cops = rtnl_cls_lookup_ops(cls);
+	if (cops && cops->co_msg_parser && (err = cops->co_msg_parser(cls)) < 0)
+		goto errout_free;
+
+	err = pp->pp_cb((struct nl_object *) cls, pp);
+errout_free:
+	rtnl_cls_put(cls);
+errout:
+	return err;
+}
+
+static int cls_request_update(struct nl_cache *cache, struct nl_sock *sk)
+{
+	struct tcmsg tchdr = {
+		.tcm_family = AF_UNSPEC,
+		.tcm_ifindex = cache->c_iarg1,
+		.tcm_parent = cache->c_iarg2,
+	};
+
+	return nl_send_simple(sk, RTM_GETTFILTER, NLM_F_DUMP, &tchdr,
+			      sizeof(tchdr));
+}
+
+
+static int cls_build(struct rtnl_cls *cls, int type, int flags,
+		     struct nl_msg **result)
+{
+	struct rtnl_cls_ops *cops;
+	int err, prio, proto;
+	struct tcmsg *tchdr;
+
+	err = tca_build_msg((struct rtnl_tca *) cls, type, flags, result);
+	if (err < 0)
+		return err;
+
+	tchdr = nlmsg_data(nlmsg_hdr(*result));
+	prio = rtnl_cls_get_prio(cls);
+	proto = rtnl_cls_get_protocol(cls);
+	tchdr->tcm_info = TC_H_MAKE(prio << 16, htons(proto));
+
+	cops = rtnl_cls_lookup_ops(cls);
+	if (cops && cops->co_get_opts) {
+		struct nl_msg *opts;
+
+		if (!(opts = nlmsg_alloc())) {
+			err = -NLE_NOMEM;
+			goto errout;
+		}
+
+		if (!(err = cops->co_get_opts(cls, opts)))
+			err = nla_put_nested(*result, TCA_OPTIONS, opts);
+
+		nlmsg_free(opts);
+		if (err < 0)
+			goto errout;
+	}
+
+	return 0;
+errout:
+	nlmsg_free(*result);
+	return err;
+}
+
+/**
+ * @name Classifier Addition/Modification/Deletion
+ * @{
+ */
+
+/**
+ * Build a netlink message to add a new classifier
+ * @arg cls		classifier to add
+ * @arg flags		additional netlink message flags
+ * @arg result		Pointer to store resulting message.
+ *
+ * Builds a new netlink message requesting an addition of a classifier
+ * The netlink message header isn't fully equipped with all relevant
+ * fields and must be sent out via nl_send_auto_complete() or
+ * supplemented as needed. \a classifier must contain the attributes of
+ * the new classifier set via \c rtnl_cls_set_* functions. \a opts
+ * may point to the clsasifier specific options.
+ *
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_cls_build_add_request(struct rtnl_cls *cls, int flags,
+			       struct nl_msg **result)
+{
+	return cls_build(cls, RTM_NEWTFILTER, NLM_F_CREATE | flags, result);
+}
+
+/**
+ * Add a new classifier
+ * @arg sk		Netlink socket.
+ * @arg cls 		classifier to add
+ * @arg flags		additional netlink message flags
+ *
+ * Builds a netlink message by calling rtnl_cls_build_add_request(),
+ * sends the request to the kernel and waits for the next ACK to be
+ * received and thus blocks until the request has been processed.
+ *
+ * @return 0 on sucess or a negative error if an error occured.
+ */
+int rtnl_cls_add(struct nl_sock *sk, struct rtnl_cls *cls, int flags)
+{
+	struct nl_msg *msg;
+	int err;
+	
+	if ((err = rtnl_cls_build_add_request(cls, flags, &msg)) < 0)
+		return err;
+	
+	err = nl_send_auto_complete(sk, msg);
+	nlmsg_free(msg);
+	if (err < 0)
+		return err;
+
+	return nl_wait_for_ack(sk);
+}
+
+/**
+ * Build a netlink message to change classifier attributes
+ * @arg cls		classifier to change
+ * @arg flags		additional netlink message flags
+ * @arg result		Pointer to store resulting message.
+ *
+ * Builds a new netlink message requesting a change of a neigh
+ * attributes. The netlink message header isn't fully equipped with
+ * all relevant fields and must thus be sent out via nl_send_auto_complete()
+ * or supplemented as needed.
+ *
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_cls_build_change_request(struct rtnl_cls *cls, int flags,
+				  struct nl_msg **result)
+{
+	return cls_build(cls, RTM_NEWTFILTER, NLM_F_REPLACE | flags, result);
+}
+
+/**
+ * Change a classifier
+ * @arg sk		Netlink socket.
+ * @arg cls		classifier to change
+ * @arg flags		additional netlink message flags
+ *
+ * Builds a netlink message by calling rtnl_cls_build_change_request(),
+ * sends the request to the kernel and waits for the next ACK to be
+ * received and thus blocks until the request has been processed.
+ *
+ * @return 0 on sucess or a negative error if an error occured.
+ */
+int rtnl_cls_change(struct nl_sock *sk, struct rtnl_cls *cls, int flags)
+{
+	struct nl_msg *msg;
+	int err;
+	
+	if ((err = rtnl_cls_build_change_request(cls, flags, &msg)) < 0)
+		return err;
+	
+	err = nl_send_auto_complete(sk, msg);
+	nlmsg_free(msg);
+	if (err < 0)
+		return err;
+
+	return nl_wait_for_ack(sk);
+}
+
+/**
+ * Build a netlink request message to delete a classifier
+ * @arg cls		classifier to delete
+ * @arg flags		additional netlink message flags
+ * @arg result		Pointer to store resulting message.
+ *
+ * Builds a new netlink message requesting a deletion of a classifier.
+ * The netlink message header isn't fully equipped with all relevant
+ * fields and must thus be sent out via nl_send_auto_complete()
+ * or supplemented as needed.
+ *
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_cls_build_delete_request(struct rtnl_cls *cls, int flags,
+				  struct nl_msg **result)
+{
+	return cls_build(cls, RTM_DELTFILTER, flags, result);
+}
+
+
+/**
+ * Delete a classifier
+ * @arg sk		Netlink socket.
+ * @arg cls		classifier to delete
+ * @arg flags		additional netlink message flags
+ *
+ * Builds a netlink message by calling rtnl_cls_build_delete_request(),
+ * sends the request to the kernel and waits for the next ACK to be
+ * received and thus blocks until the request has been processed.
+ *
+ * @return 0 on sucess or a negative error if an error occured.
+ */
+int rtnl_cls_delete(struct nl_sock *sk, struct rtnl_cls *cls, int flags)
+{
+	struct nl_msg *msg;
+	int err;
+	
+	if ((err = rtnl_cls_build_delete_request(cls, flags, &msg)) < 0)
+		return err;
+	
+	err = nl_send_auto_complete(sk, msg);
+	nlmsg_free(msg);
+	if (err < 0)
+		return err;
+
+	return nl_wait_for_ack(sk);
+}
+
+/** @} */
+
+/**
+ * @name Cache Management
+ * @{
+ */
+
+/**
+ * Build a classifier cache including all classifiers attached to the
+ * specified class/qdisc on eht specified interface.
+ * @arg sk		Netlink socket.
+ * @arg ifindex		interface index of the link the classes are
+ *                      attached to.
+ * @arg parent          parent qdisc/class
+ * @arg result		Pointer to store resulting cache.
+ *
+ * Allocates a new cache, initializes it properly and updates it to
+ * include all classes attached to the specified interface.
+ *
+ * @note The caller is responsible for destroying and freeing the
+ *       cache after using it.
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_cls_alloc_cache(struct nl_sock *sk, int ifindex, uint32_t parent,			 struct nl_cache **result)
+{
+	struct nl_cache * cache;
+	int err;
+	
+	if (!(cache = nl_cache_alloc(&rtnl_cls_ops)))
+		return -NLE_NOMEM;
+
+	cache->c_iarg1 = ifindex;
+	cache->c_iarg2 = parent;
+	
+	if (sk && (err = nl_cache_refill(sk, cache)) < 0) {
+		nl_cache_free(cache);
+		return err;
+	}
+
+	*result = cache;
+	return 0;
+}
+
+/** @} */
+
+static struct nl_cache_ops rtnl_cls_ops = {
+	.co_name		= "route/cls",
+	.co_hdrsize		= sizeof(struct tcmsg),
+	.co_msgtypes		= {
+					{ RTM_NEWTFILTER, NL_ACT_NEW, "new" },
+					{ RTM_DELTFILTER, NL_ACT_DEL, "del" },
+					{ RTM_GETTFILTER, NL_ACT_GET, "get" },
+					END_OF_MSGTYPES_LIST,
+				  },
+	.co_protocol		= NETLINK_ROUTE,
+	.co_request_update	= cls_request_update,
+	.co_msg_parser		= cls_msg_parser,
+	.co_obj_ops		= &cls_obj_ops,
+};
+
+static void __init cls_init(void)
+{
+	nl_cache_mngt_register(&rtnl_cls_ops);
+}
+
+static void __exit cls_exit(void)
+{
+	nl_cache_mngt_unregister(&rtnl_cls_ops);
+}
+
+/** @} */
diff -uNr libnl_kk/lib/route/cls_obj.c libnl/lib/route/cls_obj.c
--- libnl_kk/lib/route/cls_obj.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/cls_obj.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,253 @@
+/*
+ * lib/route/cls_api.c       Classifier Object
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2006 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup cls
+ * @defgroup cls_obj Classifier Object
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink-tc.h>
+#include <netlink/netlink.h>
+#include <netlink/utils.h>
+#include <netlink/route/tc.h>
+#include <netlink/route/classifier.h>
+#include <netlink/route/classifier-modules.h>
+#include <netlink/route/link.h>
+
+/** @cond SKIP */
+#define CLS_ATTR_PRIO		(TCA_ATTR_MAX << 1)
+#define CLS_ATTR_PROTOCOL	(TCA_ATTR_MAX << 2)
+/** @endcond */
+
+static void cls_free_data(struct nl_object *obj)
+{
+	struct rtnl_cls *cls = (struct rtnl_cls *) obj;
+	struct rtnl_cls_ops *cops;
+	
+	tca_free_data((struct rtnl_tca *) cls);
+
+	cops = rtnl_cls_lookup_ops(cls);
+	if (cops && cops->co_free_data)
+		cops->co_free_data(cls);
+
+	nl_data_free(cls->c_subdata);
+}
+
+static int cls_clone(struct nl_object *_dst, struct nl_object *_src)
+{
+	struct rtnl_cls *dst = nl_object_priv(_dst);
+	struct rtnl_cls *src = nl_object_priv(_src);
+	struct rtnl_cls_ops *cops;
+	int err;
+	
+	err = tca_clone((struct rtnl_tca *) dst, (struct rtnl_tca *) src);
+	if (err < 0)
+		goto errout;
+
+	if (src->c_subdata) {
+		if (!(dst->c_subdata = nl_data_clone(src->c_subdata))) {
+			err = -NLE_NOMEM;
+			goto errout;
+		}
+	}
+
+	cops = rtnl_cls_lookup_ops(src);
+	if (cops && cops->co_clone)
+		err = cops->co_clone(dst, src);
+errout:
+	return err;
+}
+
+static void cls_dump_line(struct nl_object *obj, struct nl_dump_params *p)
+{
+	char buf[32];
+	struct rtnl_cls *cls = (struct rtnl_cls *) obj;
+	struct rtnl_cls_ops *cops;
+
+	tca_dump_line((struct rtnl_tca *) cls, "cls", p);
+
+	nl_dump(p, " prio %u protocol %s", cls->c_prio,
+		nl_ether_proto2str(cls->c_protocol, buf, sizeof(buf)));
+
+	cops = rtnl_cls_lookup_ops(cls);
+	if (cops && cops->co_dump[NL_DUMP_LINE])
+		cops->co_dump[NL_DUMP_LINE](cls, p);
+	nl_dump(p, "\n");
+}
+
+static void cls_dump_details(struct nl_object *obj, struct nl_dump_params *p)
+{
+	struct rtnl_cls *cls = (struct rtnl_cls *) obj;
+	struct rtnl_cls_ops *cops;
+
+	cls_dump_line(obj, p);
+	tca_dump_details((struct rtnl_tca *) cls, p);
+
+	cops = rtnl_cls_lookup_ops(cls);
+	if (cops && cops->co_dump[NL_DUMP_DETAILS])
+		cops->co_dump[NL_DUMP_DETAILS](cls, p);
+	else
+		nl_dump(p, "no options\n");
+}
+
+static void cls_dump_stats(struct nl_object *obj, struct nl_dump_params *p)
+{
+	struct rtnl_cls *cls = (struct rtnl_cls *) obj;
+	struct rtnl_cls_ops *cops;
+
+	cls_dump_details(obj, p);
+	tca_dump_stats((struct rtnl_tca *) cls, p);
+	nl_dump(p, "\n");
+
+	cops = rtnl_cls_lookup_ops(cls);
+	if (cops && cops->co_dump[NL_DUMP_STATS])
+		cops->co_dump[NL_DUMP_STATS](cls, p);
+}
+
+/**
+ * @name Allocation/Freeing
+ * @{
+ */
+
+struct rtnl_cls *rtnl_cls_alloc(void)
+{
+	return (struct rtnl_cls *) nl_object_alloc(&cls_obj_ops);
+}
+
+void rtnl_cls_put(struct rtnl_cls *cls)
+{
+	nl_object_put((struct nl_object *) cls);
+}
+
+/** @} */
+
+
+/**
+ * @name Attributes
+ * @{
+ */
+
+void rtnl_cls_set_ifindex(struct rtnl_cls *f, int ifindex)
+{
+	tca_set_ifindex((struct rtnl_tca *) f, ifindex);
+}
+
+int rtnl_cls_get_ifindex(struct rtnl_cls *cls)
+{
+	return cls->c_ifindex;
+}
+
+void rtnl_cls_set_handle(struct rtnl_cls *f, uint32_t handle)
+{
+	tca_set_handle((struct rtnl_tca *) f, handle);
+}
+
+void rtnl_cls_set_parent(struct rtnl_cls *f, uint32_t parent)
+{
+	tca_set_parent((struct rtnl_tca *) f, parent);
+}
+
+uint32_t rtnl_cls_get_parent(struct rtnl_cls *cls)
+{
+	return cls->c_parent;
+}
+
+int rtnl_cls_set_kind(struct rtnl_cls *cls, const char *kind)
+{
+	if (cls->ce_mask & TCA_ATTR_KIND)
+		return -NLE_EXIST;
+
+	tca_set_kind((struct rtnl_tca *) cls, kind);
+
+	/* Force allocation of data */
+	rtnl_cls_data(cls);
+
+	return 0;
+}
+
+struct rtnl_cls_ops *rtnl_cls_get_ops(struct rtnl_cls *cls)
+{
+	return cls->c_ops;
+}
+
+void rtnl_cls_set_prio(struct rtnl_cls *cls, uint16_t prio)
+{
+	cls->c_prio = prio;
+	cls->ce_mask |= CLS_ATTR_PRIO;
+}
+
+uint16_t rtnl_cls_get_prio(struct rtnl_cls *cls)
+{
+	if (cls->ce_mask & CLS_ATTR_PRIO)
+		return cls->c_prio;
+	else
+		return 0;
+}
+
+void rtnl_cls_set_protocol(struct rtnl_cls *cls, uint16_t protocol)
+{
+	cls->c_protocol = protocol;
+	cls->ce_mask |= CLS_ATTR_PROTOCOL;
+}
+
+uint16_t rtnl_cls_get_protocol(struct rtnl_cls *cls)
+{
+	if (cls->ce_mask & CLS_ATTR_PROTOCOL)
+		return cls->c_protocol;
+	else
+		return ETH_P_ALL;
+}
+
+void *rtnl_cls_data(struct rtnl_cls *cls)
+{
+	if (!cls->c_subdata) {
+		struct rtnl_cls_ops *ops = cls->c_ops;
+
+		if (!ops) {
+			if (!cls->c_kind[0])
+				BUG();
+
+			ops = __rtnl_cls_lookup_ops(cls->c_kind);
+			if (ops == NULL)
+				return NULL;
+
+			cls->c_ops = ops;
+		}
+
+		if (!ops->co_size)
+			BUG();
+
+		if (!(cls->c_subdata = nl_data_alloc(NULL, ops->co_size)))
+			return NULL;
+	}
+
+	return nl_data_get(cls->c_subdata);
+}
+
+/** @} */
+
+struct nl_object_ops cls_obj_ops = {
+	.oo_name		= "route/cls",
+	.oo_size		= sizeof(struct rtnl_cls),
+	.oo_free_data		= cls_free_data,
+	.oo_clone		= cls_clone,
+	.oo_dump = {
+	    [NL_DUMP_LINE]	= cls_dump_line,
+	    [NL_DUMP_DETAILS]	= cls_dump_details,
+	    [NL_DUMP_STATS]	= cls_dump_stats,
+	},
+	.oo_compare		= tca_compare,
+	.oo_id_attrs		= (TCA_ATTR_IFINDEX | TCA_ATTR_HANDLE),
+};
+
+/** @} */
diff -uNr libnl_kk/lib/route/.gitignore libnl/lib/route/.gitignore
--- libnl_kk/lib/route/.gitignore	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/.gitignore	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,4 @@
+pktloc_grammar.h
+pktloc_grammar.c
+pktloc_syntax.h
+pktloc_syntax.c
diff -uNr libnl_kk/lib/route/link/api.c libnl/lib/route/link/api.c
--- libnl_kk/lib/route/link/api.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/link/api.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,98 @@
+/*
+ * lib/route/link/api.c		Link Info API
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup link
+ * @defgroup link_info Link Info API
+ * @brief
+ *
+ * @par 1) Registering/Unregistering a new link info type
+ * @code
+ * static struct rtnl_link_info_ops vlan_info_ops = {
+ * 	.io_name		= "vlan",
+ * 	.io_alloc		= vlan_alloc,
+ * 	.io_parse		= vlan_parse,
+ * 	.io_dump[NL_DUMP_BRIEF]	= vlan_dump_brief,
+ * 	.io_dump[NL_DUMP_FULL]	= vlan_dump_full,
+ * 	.io_free		= vlan_free,
+ * };
+ *
+ * static void __init vlan_init(void)
+ * {
+ * 	rtnl_link_register_info(&vlan_info_ops);
+ * }
+ *
+ * static void __exit vlan_exit(void)
+ * {
+ * 	rtnl_link_unregister_info(&vlan_info_ops);
+ * }
+ * @endcode
+ *
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink/netlink.h>
+#include <netlink/utils.h>
+#include <netlink/route/link.h>
+#include <netlink/route/link/info-api.h>
+
+static struct rtnl_link_info_ops *info_ops;
+
+struct rtnl_link_info_ops *rtnl_link_info_ops_lookup(const char *name)
+{
+	struct rtnl_link_info_ops *ops;
+
+	for (ops = info_ops; ops; ops = ops->io_next)
+		if (!strcmp(ops->io_name, name))
+			return ops;
+
+	return NULL;
+}
+
+int rtnl_link_register_info(struct rtnl_link_info_ops *ops)
+{
+	if (ops->io_name == NULL)
+		return -NLE_INVAL;
+
+	if (rtnl_link_info_ops_lookup(ops->io_name))
+		return -NLE_EXIST;
+
+	NL_DBG(1, "Registered link info operations %s\n", ops->io_name);
+
+	ops->io_next = info_ops;
+	info_ops = ops;
+
+	return 0;
+}
+
+int rtnl_link_unregister_info(struct rtnl_link_info_ops *ops)
+{
+	struct rtnl_link_info_ops *t, **tp;
+
+	for (tp = &info_ops; (t=*tp) != NULL; tp = &t->io_next)
+		if (t == ops)
+			break;
+
+	if (!t)
+		return -NLE_OPNOTSUPP;
+
+	if (t->io_refcnt > 0)
+		return -NLE_BUSY;
+
+	NL_DBG(1, "Unregistered link info perations %s\n", ops->io_name);
+
+	*tp = t->io_next;
+	return 0;
+}
+
+/** @} */
+
diff -uNr libnl_kk/lib/route/link/vlan.c libnl/lib/route/link/vlan.c
--- libnl_kk/lib/route/link/vlan.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/link/vlan.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,491 @@
+/*
+ * lib/route/link/vlan.c	VLAN Link Info
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup link_info
+ * @defgroup vlan VLAN
+ * @brief
+ *
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink/netlink.h>
+#include <netlink/attr.h>
+#include <netlink/utils.h>
+#include <netlink/object.h>
+#include <netlink/route/rtnl.h>
+#include <netlink/route/link/info-api.h>
+#include <netlink/route/link/vlan.h>
+
+#include <linux/if_vlan.h>
+
+/** @cond SKIP */
+#define VLAN_HAS_ID		(1<<0)
+#define VLAN_HAS_FLAGS		(1<<1)
+#define VLAN_HAS_INGRESS_QOS	(1<<2)
+#define VLAN_HAS_EGRESS_QOS	(1<<3)
+
+struct vlan_info
+{
+	uint16_t		vi_vlan_id;
+	uint32_t		vi_flags;
+	uint32_t		vi_flags_mask;
+	uint32_t		vi_ingress_qos[VLAN_PRIO_MAX+1];
+	uint32_t		vi_negress;
+	uint32_t		vi_egress_size;
+	struct vlan_map * 	vi_egress_qos;
+	uint32_t		vi_mask;
+};
+/** @endcond */
+
+static struct trans_tbl vlan_flags[] = {
+	__ADD(VLAN_FLAG_REORDER_HDR, reorder_hdr)
+};
+
+char *rtnl_link_vlan_flags2str(int flags, char *buf, size_t len)
+{
+	return __flags2str(flags, buf, len, vlan_flags, ARRAY_SIZE(vlan_flags));
+}
+
+int rtnl_link_vlan_str2flags(const char *name)
+{
+	return __str2flags(name, vlan_flags, ARRAY_SIZE(vlan_flags));
+}
+
+static struct nla_policy vlan_policy[IFLA_VLAN_MAX+1] = {
+	[IFLA_VLAN_ID]		= { .type = NLA_U16 },
+	[IFLA_VLAN_FLAGS]	= { .minlen = sizeof(struct ifla_vlan_flags) },
+	[IFLA_VLAN_INGRESS_QOS]	= { .type = NLA_NESTED },
+	[IFLA_VLAN_EGRESS_QOS]	= { .type = NLA_NESTED },
+};
+
+static int vlan_alloc(struct rtnl_link *link)
+{
+	struct vlan_info *vi;
+
+	if ((vi = calloc(1, sizeof(*vi))) == NULL)
+		return -NLE_NOMEM;
+
+	link->l_info = vi;
+
+	return 0;
+}
+
+static int vlan_parse(struct rtnl_link *link, struct nlattr *data,
+		      struct nlattr *xstats)
+{
+	struct nlattr *tb[IFLA_VLAN_MAX+1];
+	struct vlan_info *vi;
+	int err;
+
+	NL_DBG(3, "Parsing VLAN link info");
+
+	if ((err = nla_parse_nested(tb, IFLA_VLAN_MAX, data, vlan_policy)) < 0)
+		goto errout;
+
+	if ((err = vlan_alloc(link)) < 0)
+		goto errout;
+
+	vi = link->l_info;
+
+	if (tb[IFLA_VLAN_ID]) {
+		vi->vi_vlan_id = nla_get_u16(tb[IFLA_VLAN_ID]);
+		vi->vi_mask |= VLAN_HAS_ID;
+	}
+
+	if (tb[IFLA_VLAN_FLAGS]) {
+		struct ifla_vlan_flags flags;
+		nla_memcpy(&flags, tb[IFLA_VLAN_FLAGS], sizeof(flags));
+
+		vi->vi_flags = flags.flags;
+		vi->vi_mask |= VLAN_HAS_FLAGS;
+	}
+
+	if (tb[IFLA_VLAN_INGRESS_QOS]) {
+		struct ifla_vlan_qos_mapping *map;
+		struct nlattr *nla;
+		int remaining;
+
+		memset(vi->vi_ingress_qos, 0, sizeof(vi->vi_ingress_qos));
+
+		nla_for_each_nested(nla, tb[IFLA_VLAN_INGRESS_QOS], remaining) {
+			if (nla_len(nla) < sizeof(*map))
+				return -NLE_INVAL;
+
+			map = nla_data(nla);
+			if (map->from < 0 || map->from > VLAN_PRIO_MAX) {
+				return -NLE_INVAL;
+			}
+
+			vi->vi_ingress_qos[map->from] = map->to;
+		}
+
+		vi->vi_mask |= VLAN_HAS_INGRESS_QOS;
+	}
+
+	if (tb[IFLA_VLAN_EGRESS_QOS]) {
+		struct ifla_vlan_qos_mapping *map;
+		struct nlattr *nla;
+		int remaining, i = 0;
+
+		nla_for_each_nested(nla, tb[IFLA_VLAN_EGRESS_QOS], remaining) {
+			if (nla_len(nla) < sizeof(*map))
+				return -NLE_INVAL;
+			i++;
+		}
+
+		/* align to have a little reserve */
+		vi->vi_egress_size = (i + 32) & ~31;
+		vi->vi_egress_qos = calloc(vi->vi_egress_size, sizeof(*map));
+		if (vi->vi_egress_qos == NULL)
+			return -NLE_NOMEM;
+
+		i = 0;
+		nla_for_each_nested(nla, tb[IFLA_VLAN_EGRESS_QOS], remaining) {
+			map = nla_data(nla);
+			NL_DBG(4, "Assigning egress qos mapping %d\n", i);
+			vi->vi_egress_qos[i].vm_from = map->from;
+			vi->vi_egress_qos[i++].vm_to = map->to;
+		}
+
+		vi->vi_negress = i;
+		vi->vi_mask |= VLAN_HAS_EGRESS_QOS;
+	}
+
+	err = 0;
+errout:
+	return err;
+}
+
+static void vlan_free(struct rtnl_link *link)
+{
+	struct vlan_info *vi = link->l_info;
+
+	if (vi) {
+		free(vi->vi_egress_qos);
+		vi->vi_egress_qos = NULL;
+	}
+
+	free(vi);
+	link->l_info = NULL;
+}
+
+static void vlan_dump_line(struct rtnl_link *link, struct nl_dump_params *p)
+{
+	struct vlan_info *vi = link->l_info;
+
+	nl_dump(p, "vlan-id %d", vi->vi_vlan_id);
+}
+
+static void vlan_dump_details(struct rtnl_link *link, struct nl_dump_params *p)
+{
+	struct vlan_info *vi = link->l_info;
+	int i, printed;
+	char buf[64];
+
+	rtnl_link_vlan_flags2str(vi->vi_flags, buf, sizeof(buf));
+	nl_dump_line(p, "    vlan-info id %d <%s>\n", vi->vi_vlan_id, buf);
+
+	if (vi->vi_mask & VLAN_HAS_INGRESS_QOS) {
+		nl_dump_line(p, 
+		"      ingress vlan prio -> qos/socket prio mapping:\n");
+		for (i = 0, printed = 0; i <= VLAN_PRIO_MAX; i++) {
+			if (vi->vi_ingress_qos[i]) {
+				if (printed == 0)
+					nl_dump_line(p, "      ");
+				nl_dump(p, "%x -> %#08x, ",
+					i, vi->vi_ingress_qos[i]);
+				if (printed++ == 3) {
+					nl_dump(p, "\n");
+					printed = 0;
+				}
+			}
+		}
+
+		if (printed > 0 && printed != 4)
+			nl_dump(p, "\n");
+	}
+
+	if (vi->vi_mask & VLAN_HAS_EGRESS_QOS) {
+		nl_dump_line(p, 
+		"      egress qos/socket prio -> vlan prio mapping:\n");
+		for (i = 0, printed = 0; i < vi->vi_negress; i++) {
+			if (printed == 0)
+				nl_dump_line(p, "      ");
+			nl_dump(p, "%#08x -> %x, ",
+				vi->vi_egress_qos[i].vm_from,
+				vi->vi_egress_qos[i].vm_to);
+			if (printed++ == 3) {
+				nl_dump(p, "\n");
+				printed = 0;
+			}
+		}
+
+		if (printed > 0 && printed != 4)
+			nl_dump(p, "\n");
+	}
+}
+
+static int vlan_clone(struct rtnl_link *dst, struct rtnl_link *src)
+{
+	struct vlan_info *vdst, *vsrc = src->l_info;
+	int err;
+
+	dst->l_info = NULL;
+	if ((err = rtnl_link_set_info_type(dst, "vlan")) < 0)
+		return err;
+	vdst = dst->l_info;
+
+	vdst->vi_egress_qos = calloc(vsrc->vi_egress_size,
+				     sizeof(struct vlan_map));
+	if (!vdst->vi_egress_qos)
+		return -NLE_NOMEM;
+
+	memcpy(vdst->vi_egress_qos, vsrc->vi_egress_qos,
+	       vsrc->vi_egress_size * sizeof(struct vlan_map));
+
+	return 0;
+}
+
+static int vlan_put_attrs(struct nl_msg *msg, struct rtnl_link *link)
+{
+	struct vlan_info *vi = link->l_info;
+	struct nlattr *data;
+
+	if (!(data = nla_nest_start(msg, IFLA_INFO_DATA)))
+		return -NLE_MSGSIZE;
+
+	if (vi->vi_mask & VLAN_HAS_ID)
+		NLA_PUT_U16(msg, IFLA_VLAN_ID, vi->vi_vlan_id);
+
+	if (vi->vi_mask & VLAN_HAS_FLAGS) {
+		struct ifla_vlan_flags flags = {
+			.flags = vi->vi_flags,
+			.mask = vi->vi_flags_mask,
+		};
+
+		NLA_PUT(msg, IFLA_VLAN_FLAGS, sizeof(flags), &flags);
+	}
+
+	if (vi->vi_mask & VLAN_HAS_INGRESS_QOS) {
+		struct ifla_vlan_qos_mapping map;
+		struct nlattr *qos;
+		int i;
+
+		if (!(qos = nla_nest_start(msg, IFLA_VLAN_INGRESS_QOS)))
+			goto nla_put_failure;
+
+		for (i = 0; i <= VLAN_PRIO_MAX; i++) {
+			if (vi->vi_ingress_qos[i]) {
+				map.from = i;
+				map.to = vi->vi_ingress_qos[i];
+
+				NLA_PUT(msg, i, sizeof(map), &map);
+			}
+		}
+
+		nla_nest_end(msg, qos);
+	}
+
+	if (vi->vi_mask & VLAN_HAS_EGRESS_QOS) {
+		struct ifla_vlan_qos_mapping map;
+		struct nlattr *qos;
+		int i;
+
+		if (!(qos = nla_nest_start(msg, IFLA_VLAN_EGRESS_QOS)))
+			goto nla_put_failure;
+
+		for (i = 0; i < vi->vi_negress; i++) {
+			map.from = vi->vi_egress_qos[i].vm_from;
+			map.to = vi->vi_egress_qos[i].vm_to;
+
+			NLA_PUT(msg, i, sizeof(map), &map);
+		}
+
+		nla_nest_end(msg, qos);
+	}
+
+	nla_nest_end(msg, data);
+
+nla_put_failure:
+
+	return 0;
+}
+
+static struct rtnl_link_info_ops vlan_info_ops = {
+	.io_name		= "vlan",
+	.io_alloc		= vlan_alloc,
+	.io_parse		= vlan_parse,
+	.io_dump = {
+	    [NL_DUMP_LINE]	= vlan_dump_line,
+	    [NL_DUMP_DETAILS]	= vlan_dump_details,
+	},
+	.io_clone		= vlan_clone,
+	.io_put_attrs		= vlan_put_attrs,
+	.io_free		= vlan_free,
+};
+
+int rtnl_link_vlan_set_id(struct rtnl_link *link, int id)
+{
+	struct vlan_info *vi = link->l_info;
+
+	if (link->l_info_ops != &vlan_info_ops || !link->l_info_ops)
+		return -NLE_OPNOTSUPP;
+
+	vi->vi_vlan_id = id;
+	vi->vi_mask |= VLAN_HAS_ID;
+
+	return 0;
+}
+
+int rtnl_link_vlan_get_id(struct rtnl_link *link)
+{
+	struct vlan_info *vi = link->l_info;
+
+	if (link->l_info_ops != &vlan_info_ops || !link->l_info_ops)
+		return -NLE_OPNOTSUPP;
+
+	if (vi->vi_mask & VLAN_HAS_ID)
+		return vi->vi_vlan_id;
+	else
+		return 0;
+}
+
+int rtnl_link_vlan_set_flags(struct rtnl_link *link, unsigned int flags)
+{
+	struct vlan_info *vi = link->l_info;
+
+	if (link->l_info_ops != &vlan_info_ops || !link->l_info_ops)
+		return -NLE_OPNOTSUPP;
+
+	vi->vi_flags_mask |= flags;
+	vi->vi_flags |= flags;
+	vi->vi_mask |= VLAN_HAS_FLAGS;
+
+	return 0;
+}
+
+int rtnl_link_vlan_unset_flags(struct rtnl_link *link, unsigned int flags)
+{
+	struct vlan_info *vi = link->l_info;
+
+	if (link->l_info_ops != &vlan_info_ops || !link->l_info_ops)
+		return -NLE_OPNOTSUPP;
+
+	vi->vi_flags_mask |= flags;
+	vi->vi_flags &= ~flags;
+	vi->vi_mask |= VLAN_HAS_FLAGS;
+
+	return 0;
+}
+
+unsigned int rtnl_link_vlan_get_flags(struct rtnl_link *link)
+{
+	struct vlan_info *vi = link->l_info;
+
+	if (link->l_info_ops != &vlan_info_ops || !link->l_info_ops)
+		return -NLE_OPNOTSUPP;
+
+	return vi->vi_flags;
+}
+
+int rtnl_link_vlan_set_ingress_map(struct rtnl_link *link, int from,
+				   uint32_t to)
+{
+	struct vlan_info *vi = link->l_info;
+
+	if (link->l_info_ops != &vlan_info_ops || !link->l_info_ops)
+		return -NLE_OPNOTSUPP;
+
+	if (from < 0 || from > VLAN_PRIO_MAX)
+		return -NLE_INVAL;
+
+	vi->vi_ingress_qos[from] = to;
+	vi->vi_mask |= VLAN_HAS_INGRESS_QOS;
+
+	return 0;
+}
+
+uint32_t *rtnl_link_vlan_get_ingress_map(struct rtnl_link *link)
+{
+	struct vlan_info *vi = link->l_info;
+
+	if (link->l_info_ops != &vlan_info_ops || !link->l_info_ops)
+		return NULL;
+
+	if (vi->vi_mask & VLAN_HAS_INGRESS_QOS)
+		return vi->vi_ingress_qos;
+	else
+		return NULL;
+}
+
+int rtnl_link_vlan_set_egress_map(struct rtnl_link *link, uint32_t from, int to)
+{
+	struct vlan_info *vi = link->l_info;
+
+	if (link->l_info_ops != &vlan_info_ops || !link->l_info_ops)
+		return -NLE_OPNOTSUPP;
+
+	if (to < 0 || to > VLAN_PRIO_MAX)
+		return -NLE_INVAL;
+
+	if (vi->vi_negress >= vi->vi_egress_size) {
+		int new_size = vi->vi_egress_size + 32;
+		void *ptr;
+
+		ptr = realloc(vi->vi_egress_qos, new_size);
+		if (!ptr)
+			return -NLE_NOMEM;
+
+		vi->vi_egress_qos = ptr;
+		vi->vi_egress_size = new_size;
+	}
+
+	vi->vi_egress_qos[vi->vi_negress].vm_from = from;
+	vi->vi_egress_qos[vi->vi_negress].vm_to = to;
+	vi->vi_negress++;
+	vi->vi_mask |= VLAN_HAS_EGRESS_QOS;
+
+	return 0;
+}
+
+struct vlan_map *rtnl_link_vlan_get_egress_map(struct rtnl_link *link,
+					       int *negress)
+{
+	struct vlan_info *vi = link->l_info;
+
+	if (link->l_info_ops != &vlan_info_ops || !link->l_info_ops)
+		return NULL;
+
+	if (negress == NULL)
+		return NULL;
+
+	if (vi->vi_mask & VLAN_HAS_EGRESS_QOS) {
+		*negress = vi->vi_negress;
+		return vi->vi_egress_qos;
+	} else {
+		*negress = 0;
+		return NULL;
+	}
+}
+
+static void __init vlan_init(void)
+{
+	rtnl_link_register_info(&vlan_info_ops);
+}
+
+static void __exit vlan_exit(void)
+{
+	rtnl_link_unregister_info(&vlan_info_ops);
+}
+
+/** @} */
diff -uNr libnl_kk/lib/route/link.c libnl/lib/route/link.c
--- libnl_kk/lib/route/link.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/link.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,1471 @@
+/*
+ * lib/route/link.c	Links (Interfaces)
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup rtnl
+ * @defgroup link Links (Interfaces)
+ * @brief
+ *
+ * @par Link Identification
+ * A link can be identified by either its interface index or by its
+ * name. The kernel favours the interface index but falls back to the
+ * interface name if the interface index is lesser-than 0 for kernels
+ * >= 2.6.11. Therefore you can request changes without mapping a
+ * interface name to the corresponding index first.
+ *
+ * @par Changeable Attributes
+ * @anchor link_changeable
+ *  - Link layer address
+ *  - Link layer broadcast address
+ *  - device mapping (ifmap) (>= 2.6.9)
+ *  - MTU (>= 2.6.9)
+ *  - Transmission queue length (>= 2.6.9)
+ *  - Weight (>= 2.6.9)
+ *  - Link name (only via access through interface index) (>= 2.6.9)
+ *  - Flags (>= 2.6.9)
+ *    - IFF_DEBUG
+ *    - IFF_NOTRAILERS
+ *    - IFF_NOARP
+ *    - IFF_DYNAMIC
+ *    - IFF_MULTICAST
+ *    - IFF_PORTSEL
+ *    - IFF_AUTOMEDIA
+ *    - IFF_UP
+ *    - IFF_PROMISC
+ *    - IFF_ALLMULTI
+ *
+ * @par Link Flags (linux/if.h)
+ * @anchor link_flags
+ * @code
+ *   IFF_UP            Status of link (up|down)
+ *   IFF_BROADCAST     Indicates this link allows broadcasting
+ *   IFF_MULTICAST     Indicates this link allows multicasting
+ *   IFF_ALLMULTI      Indicates this link is doing multicast routing
+ *   IFF_DEBUG         Tell the driver to do debugging (currently unused)
+ *   IFF_LOOPBACK      This is the loopback link
+ *   IFF_POINTOPOINT   Point-to-point link
+ *   IFF_NOARP         Link is unable to perform ARP
+ *   IFF_PROMISC       Status of promiscious mode flag
+ *   IFF_MASTER        Used by teql
+ *   IFF_SLAVE         Used by teql
+ *   IFF_PORTSEL       Indicates this link allows port selection
+ *   IFF_AUTOMEDIA     Indicates this link selects port automatically
+ *   IFF_DYNAMIC       Indicates the address of this link is dynamic
+ *   IFF_RUNNING       Link is running and carrier is ok.
+ *   IFF_NOTRAILERS    Unused, BSD compat.
+ * @endcode
+ *
+ * @par Notes on IFF_PROMISC and IFF_ALLMULTI flags
+ * Although you can query the status of IFF_PROMISC and IFF_ALLMULTI
+ * they do not represent the actual state in the kernel but rather
+ * whether the flag has been enabled/disabled by userspace. The link
+ * may be in promiscious mode even if IFF_PROMISC is not set in a link
+ * dump request response because promiscity might be needed by the driver
+ * for a period of time.
+ *
+ * @note The unit of the transmission queue length depends on the
+ *       link type, a common unit is \a packets.
+ *
+ * @par 1) Retrieving information about available links
+ * @code
+ * // The first step is to retrieve a list of all available interfaces within
+ * // the kernel and put them into a cache.
+ * struct nl_cache *cache = rtnl_link_alloc_cache(sk);
+ *
+ * // In a second step, a specific link may be looked up by either interface
+ * // index or interface name.
+ * struct rtnl_link *link = rtnl_link_get_by_name(cache, "lo");
+ *
+ * // rtnl_link_get_by_name() is the short version for translating the
+ * // interface name to an interface index first like this:
+ * int ifindex = rtnl_link_name2i(cache, "lo");
+ * struct rtnl_link *link = rtnl_link_get(cache, ifindex);
+ *
+ * // After successful usage, the object must be given back to the cache
+ * rtnl_link_put(link);
+ * @endcode
+ *
+ * @par 2) Changing link attributes
+ * @code
+ * // In order to change any attributes of an existing link, we must allocate
+ * // a new link to hold the change requests:
+ * struct rtnl_link *request = rtnl_link_alloc();
+ *
+ * // Now we can go on and specify the attributes we want to change:
+ * rtnl_link_set_weight(request, 300);
+ * rtnl_link_set_mtu(request, 1360);
+ *
+ * // We can also shut an interface down administratively
+ * rtnl_link_unset_flags(request, rtnl_link_str2flags("up"));
+ *
+ * // Actually, we should know which link to change, so let's look it up
+ * struct rtnl_link *old = rtnl_link_get(cache, "eth0");
+ *
+ * // Two ways exist to commit this change request, the first one is to
+ * // build the required netlink message and send it out in one single
+ * // step:
+ * rtnl_link_change(sk, old, request);
+ *
+ * // An alternative way is to build the netlink message and send it
+ * // out yourself using nl_send_auto_complete()
+ * struct nl_msg *msg = rtnl_link_build_change_request(old, request);
+ * nl_send_auto_complete(sk, nlmsg_hdr(msg));
+ * nlmsg_free(msg);
+ *
+ * // Don't forget to give back the link object ;->
+ * rtnl_link_put(old);
+ * @endcode
+ *
+ * @par 3) Link Type Specific Attributes
+ * @code
+ * // Some link types offer additional parameters and statistics specific
+ * // to their type. F.e. a VLAN link can be configured like this:
+ * //
+ * // Allocate a new link and set the info type to "vlan". This is required
+ * // to prepare the link to hold vlan specific attributes.
+ * struct rtnl_link *request = rtnl_link_alloc();
+ * rtnl_link_set_info_type(request, "vlan");
+ *
+ * // Now vlan specific attributes can be set:
+ * rtnl_link_vlan_set_id(request, 10);
+ * rtnl_link_vlan_set_ingress_map(request, 2, 8);
+ *
+ * // Of course the attributes can also be read, check the info type
+ * // to make sure you are using the right access functions:
+ * char *type = rtnl_link_get_info_type(link);
+ * if (!strcmp(type, "vlan"))
+ * 	int id = rtnl_link_vlan_get_id(link);
+ * @endcode
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink/netlink.h>
+#include <netlink/attr.h>
+#include <netlink/utils.h>
+#include <netlink/object.h>
+#include <netlink/route/rtnl.h>
+#include <netlink/route/link.h>
+#include <netlink/route/link/info-api.h>
+
+/** @cond SKIP */
+#define LINK_ATTR_MTU     0x0001
+#define LINK_ATTR_LINK    0x0002
+#define LINK_ATTR_TXQLEN  0x0004
+#define LINK_ATTR_WEIGHT  0x0008
+#define LINK_ATTR_MASTER  0x0010
+#define LINK_ATTR_QDISC   0x0020
+#define LINK_ATTR_MAP     0x0040
+#define LINK_ATTR_ADDR    0x0080
+#define LINK_ATTR_BRD     0x0100
+#define LINK_ATTR_FLAGS   0x0200
+#define LINK_ATTR_IFNAME  0x0400
+#define LINK_ATTR_IFINDEX 0x0800
+#define LINK_ATTR_FAMILY  0x1000
+#define LINK_ATTR_ARPTYPE 0x2000
+#define LINK_ATTR_STATS   0x4000
+#define LINK_ATTR_CHANGE  0x8000
+#define LINK_ATTR_OPERSTATE 0x10000
+#define LINK_ATTR_LINKMODE  0x20000
+#define LINK_ATTR_LINKINFO  0x40000
+
+static struct nl_cache_ops rtnl_link_ops;
+static struct nl_object_ops link_obj_ops;
+/** @endcond */
+
+static void release_link_info(struct rtnl_link *link)
+{
+	struct rtnl_link_info_ops *io = link->l_info_ops;
+
+	if (io != NULL) {
+		io->io_refcnt--;
+		io->io_free(link);
+		link->l_info_ops = NULL;
+	}
+}
+
+static void link_free_data(struct nl_object *c)
+{
+	struct rtnl_link *link = nl_object_priv(c);
+
+	if (link) {
+		struct rtnl_link_info_ops *io;
+
+		if ((io = link->l_info_ops) != NULL)
+			release_link_info(link);
+
+		nl_addr_put(link->l_addr);
+		nl_addr_put(link->l_bcast);
+	}
+}
+
+static int link_clone(struct nl_object *_dst, struct nl_object *_src)
+{
+	struct rtnl_link *dst = nl_object_priv(_dst);
+	struct rtnl_link *src = nl_object_priv(_src);
+	int err;
+
+	if (src->l_addr)
+		if (!(dst->l_addr = nl_addr_clone(src->l_addr)))
+			return -NLE_NOMEM;
+
+	if (src->l_bcast)
+		if (!(dst->l_bcast = nl_addr_clone(src->l_bcast)))
+			return -NLE_NOMEM;
+
+	if (src->l_info_ops && src->l_info_ops->io_clone) {
+		err = src->l_info_ops->io_clone(dst, src);
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
+}
+
+static struct nla_policy link_policy[IFLA_MAX+1] = {
+	[IFLA_IFNAME]	= { .type = NLA_STRING,
+			    .maxlen = IFNAMSIZ },
+	[IFLA_MTU]	= { .type = NLA_U32 },
+	[IFLA_TXQLEN]	= { .type = NLA_U32 },
+	[IFLA_LINK]	= { .type = NLA_U32 },
+	[IFLA_WEIGHT]	= { .type = NLA_U32 },
+	[IFLA_MASTER]	= { .type = NLA_U32 },
+	[IFLA_OPERSTATE]= { .type = NLA_U8 },
+	[IFLA_LINKMODE] = { .type = NLA_U8 },
+	[IFLA_LINKINFO]	= { .type = NLA_NESTED },
+	[IFLA_QDISC]	= { .type = NLA_STRING,
+			    .maxlen = IFQDISCSIZ },
+	[IFLA_STATS]	= { .minlen = sizeof(struct rtnl_link_stats) },
+	[IFLA_MAP]	= { .minlen = sizeof(struct rtnl_link_ifmap) },
+};
+
+static struct nla_policy link_info_policy[IFLA_INFO_MAX+1] = {
+	[IFLA_INFO_KIND]	= { .type = NLA_STRING },
+	[IFLA_INFO_DATA]	= { .type = NLA_NESTED },
+	[IFLA_INFO_XSTATS]	= { .type = NLA_NESTED },
+};
+
+static int link_msg_parser(struct nl_cache_ops *ops, struct sockaddr_nl *who,
+			   struct nlmsghdr *n, struct nl_parser_param *pp)
+{
+	struct rtnl_link *link;
+	struct ifinfomsg *ifi;
+	struct nlattr *tb[IFLA_MAX+1];
+	int err;
+
+	link = rtnl_link_alloc();
+	if (link == NULL) {
+		err = -NLE_NOMEM;
+		goto errout;
+	}
+		
+	link->ce_msgtype = n->nlmsg_type;
+
+	err = nlmsg_parse(n, sizeof(*ifi), tb, IFLA_MAX, link_policy);
+	if (err < 0)
+		goto errout;
+
+	if (tb[IFLA_IFNAME] == NULL) {
+		err = -NLE_MISSING_ATTR;
+		goto errout;
+	}
+
+	nla_strlcpy(link->l_name, tb[IFLA_IFNAME], IFNAMSIZ);
+
+	ifi = nlmsg_data(n);
+	link->l_family = ifi->ifi_family;
+	link->l_arptype = ifi->ifi_type;
+	link->l_index = ifi->ifi_index;
+	link->l_flags = ifi->ifi_flags;
+	link->l_change = ifi->ifi_change;
+	link->ce_mask = (LINK_ATTR_IFNAME | LINK_ATTR_FAMILY |
+			  LINK_ATTR_ARPTYPE| LINK_ATTR_IFINDEX |
+			  LINK_ATTR_FLAGS | LINK_ATTR_CHANGE);
+
+	if (tb[IFLA_STATS]) {
+		struct rtnl_link_stats *st = nla_data(tb[IFLA_STATS]);
+		
+		link->l_stats[RTNL_LINK_RX_PACKETS]	= st->rx_packets;
+		link->l_stats[RTNL_LINK_RX_BYTES]	= st->rx_bytes;
+		link->l_stats[RTNL_LINK_RX_ERRORS]	= st->rx_errors;
+		link->l_stats[RTNL_LINK_RX_DROPPED]	= st->rx_dropped;
+		link->l_stats[RTNL_LINK_RX_COMPRESSED]	= st->rx_compressed;
+		link->l_stats[RTNL_LINK_RX_FIFO_ERR]	= st->rx_fifo_errors;
+		link->l_stats[RTNL_LINK_TX_PACKETS]	= st->tx_packets;
+		link->l_stats[RTNL_LINK_TX_BYTES]	= st->tx_bytes;
+		link->l_stats[RTNL_LINK_TX_ERRORS]	= st->tx_errors;
+		link->l_stats[RTNL_LINK_TX_DROPPED]	= st->tx_dropped;
+		link->l_stats[RTNL_LINK_TX_COMPRESSED]	= st->tx_compressed;
+		link->l_stats[RTNL_LINK_TX_FIFO_ERR]	= st->tx_fifo_errors;
+		link->l_stats[RTNL_LINK_RX_LEN_ERR]	= st->rx_length_errors;
+		link->l_stats[RTNL_LINK_RX_OVER_ERR]	= st->rx_over_errors;
+		link->l_stats[RTNL_LINK_RX_CRC_ERR]	= st->rx_crc_errors;
+		link->l_stats[RTNL_LINK_RX_FRAME_ERR]	= st->rx_frame_errors;
+		link->l_stats[RTNL_LINK_RX_MISSED_ERR]	= st->rx_missed_errors;
+		link->l_stats[RTNL_LINK_TX_ABORT_ERR]	= st->tx_aborted_errors;
+		link->l_stats[RTNL_LINK_TX_CARRIER_ERR]	= st->tx_carrier_errors;
+		link->l_stats[RTNL_LINK_TX_HBEAT_ERR]	= st->tx_heartbeat_errors;
+		link->l_stats[RTNL_LINK_TX_WIN_ERR]	= st->tx_window_errors;
+		link->l_stats[RTNL_LINK_MULTICAST]	= st->multicast;
+
+		link->ce_mask |= LINK_ATTR_STATS;
+	}
+
+	if (tb[IFLA_TXQLEN]) {
+		link->l_txqlen = nla_get_u32(tb[IFLA_TXQLEN]);
+		link->ce_mask |= LINK_ATTR_TXQLEN;
+	}
+
+	if (tb[IFLA_MTU]) {
+		link->l_mtu = nla_get_u32(tb[IFLA_MTU]);
+		link->ce_mask |= LINK_ATTR_MTU;
+	}
+
+	if (tb[IFLA_ADDRESS]) {
+		link->l_addr = nl_addr_alloc_attr(tb[IFLA_ADDRESS], AF_UNSPEC);
+		if (link->l_addr == NULL) {
+			err = -NLE_NOMEM;
+			goto errout;
+		}
+		nl_addr_set_family(link->l_addr,
+				   nl_addr_guess_family(link->l_addr));
+		link->ce_mask |= LINK_ATTR_ADDR;
+	}
+
+	if (tb[IFLA_BROADCAST]) {
+		link->l_bcast = nl_addr_alloc_attr(tb[IFLA_BROADCAST],
+						   AF_UNSPEC);
+		if (link->l_bcast == NULL) {
+			err = -NLE_NOMEM;
+			goto errout;
+		}
+		nl_addr_set_family(link->l_bcast,
+				   nl_addr_guess_family(link->l_bcast));
+		link->ce_mask |= LINK_ATTR_BRD;
+	}
+
+	if (tb[IFLA_LINK]) {
+		link->l_link = nla_get_u32(tb[IFLA_LINK]);
+		link->ce_mask |= LINK_ATTR_LINK;
+	}
+
+	if (tb[IFLA_WEIGHT]) {
+		link->l_weight = nla_get_u32(tb[IFLA_WEIGHT]);
+		link->ce_mask |= LINK_ATTR_WEIGHT;
+	}
+
+	if (tb[IFLA_QDISC]) {
+		nla_strlcpy(link->l_qdisc, tb[IFLA_QDISC], IFQDISCSIZ);
+		link->ce_mask |= LINK_ATTR_QDISC;
+	}
+
+	if (tb[IFLA_MAP]) {
+		nla_memcpy(&link->l_map, tb[IFLA_MAP], 
+			   sizeof(struct rtnl_link_ifmap));
+		link->ce_mask |= LINK_ATTR_MAP;
+	}
+
+	if (tb[IFLA_MASTER]) {
+		link->l_master = nla_get_u32(tb[IFLA_MASTER]);
+		link->ce_mask |= LINK_ATTR_MASTER;
+	}
+
+	if (tb[IFLA_OPERSTATE]) {
+		link->l_operstate = nla_get_u8(tb[IFLA_OPERSTATE]);
+		link->ce_mask |= LINK_ATTR_OPERSTATE;
+	}
+
+	if (tb[IFLA_LINKMODE]) {
+		link->l_linkmode = nla_get_u8(tb[IFLA_LINKMODE]);
+		link->ce_mask |= LINK_ATTR_LINKMODE;
+	}
+
+	if (tb[IFLA_LINKINFO]) {
+		struct nlattr *li[IFLA_INFO_MAX+1];
+
+		err = nla_parse_nested(li, IFLA_INFO_MAX, tb[IFLA_LINKINFO],
+				       link_info_policy);
+		if (err < 0)
+			goto errout;
+
+		if (li[IFLA_INFO_KIND] &&
+		    (li[IFLA_INFO_DATA] || li[IFLA_INFO_XSTATS])) {
+			struct rtnl_link_info_ops *ops;
+			char *kind;
+
+			kind = nla_get_string(li[IFLA_INFO_KIND]);
+			ops = rtnl_link_info_ops_lookup(kind);
+			if (ops != NULL) {
+				ops->io_refcnt++;
+				link->l_info_ops = ops;
+				err = ops->io_parse(link, li[IFLA_INFO_DATA],
+						    li[IFLA_INFO_XSTATS]);
+				if (err < 0)
+					goto errout;
+			} else {
+				/* XXX: Warn about unparsed info? */
+			}
+		}
+	}
+
+	err = pp->pp_cb((struct nl_object *) link, pp);
+errout:
+	rtnl_link_put(link);
+	return err;
+}
+
+static int link_request_update(struct nl_cache *cache, struct nl_sock *sk)
+{
+	return nl_rtgen_request(sk, RTM_GETLINK, AF_UNSPEC, NLM_F_DUMP);
+}
+
+static void link_dump_line(struct nl_object *obj, struct nl_dump_params *p)
+{
+	char buf[128];
+	struct nl_cache *cache = dp_cache(obj);
+	struct rtnl_link *link = (struct rtnl_link *) obj;
+
+	nl_dump_line(p, "%s %s ", link->l_name,
+		     nl_llproto2str(link->l_arptype, buf, sizeof(buf)));
+
+	if (link->l_addr && !nl_addr_iszero(link->l_addr))
+		nl_dump(p, "%s ", nl_addr2str(link->l_addr, buf, sizeof(buf)));
+
+	if (link->ce_mask & LINK_ATTR_MASTER) {
+		struct rtnl_link *master = rtnl_link_get(cache, link->l_master);
+		nl_dump(p, "master %s ", master ? master->l_name : "inv");
+		if (master)
+			rtnl_link_put(master);
+	}
+
+	rtnl_link_flags2str(link->l_flags, buf, sizeof(buf));
+	if (buf[0])
+		nl_dump(p, "<%s> ", buf);
+
+	if (link->ce_mask & LINK_ATTR_LINK) {
+		struct rtnl_link *ll = rtnl_link_get(cache, link->l_link);
+		nl_dump(p, "slave-of %s ", ll ? ll->l_name : "NONE");
+		if (ll)
+			rtnl_link_put(ll);
+	}
+
+	if (link->l_info_ops && link->l_info_ops->io_dump[NL_DUMP_LINE])
+		link->l_info_ops->io_dump[NL_DUMP_LINE](link, p);
+
+	nl_dump(p, "\n");
+}
+
+static void link_dump_details(struct nl_object *obj, struct nl_dump_params *p)
+{
+	struct rtnl_link *link = (struct rtnl_link *) obj;
+	char buf[64];
+
+	link_dump_line(obj, p);
+
+	nl_dump_line(p, "    mtu %u ", link->l_mtu);
+	nl_dump(p, "txqlen %u weight %u ", link->l_txqlen, link->l_weight);
+
+	if (link->ce_mask & LINK_ATTR_QDISC)
+		nl_dump(p, "qdisc %s ", link->l_qdisc);
+
+	if (link->ce_mask & LINK_ATTR_MAP && link->l_map.lm_irq)
+		nl_dump(p, "irq %u ", link->l_map.lm_irq);
+
+	if (link->ce_mask & LINK_ATTR_IFINDEX)
+		nl_dump(p, "index %u ", link->l_index);
+
+
+	nl_dump(p, "\n");
+	nl_dump_line(p, "    ");
+
+	if (link->ce_mask & LINK_ATTR_BRD)
+		nl_dump(p, "brd %s ", nl_addr2str(link->l_bcast, buf,
+						   sizeof(buf)));
+
+	if ((link->ce_mask & LINK_ATTR_OPERSTATE) &&
+	    link->l_operstate != IF_OPER_UNKNOWN) {
+		rtnl_link_operstate2str(link->l_operstate, buf, sizeof(buf));
+		nl_dump(p, "state %s ", buf);
+	}
+
+	nl_dump(p, "mode %s\n",
+		rtnl_link_mode2str(link->l_linkmode, buf, sizeof(buf)));
+
+	if (link->l_info_ops && link->l_info_ops->io_dump[NL_DUMP_DETAILS])
+		link->l_info_ops->io_dump[NL_DUMP_DETAILS](link, p);
+}
+
+static void link_dump_stats(struct nl_object *obj, struct nl_dump_params *p)
+{
+	struct rtnl_link *link = (struct rtnl_link *) obj;
+	char *unit, fmt[64];
+	float res;
+	
+	link_dump_details(obj, p);
+
+	nl_dump_line(p, "    Stats:    bytes    packets     errors "
+			"   dropped   fifo-err compressed\n");
+
+	res = nl_cancel_down_bytes(link->l_stats[RTNL_LINK_RX_BYTES], &unit);
+
+	strcpy(fmt, "     RX %X.2f %s %10llu %10llu %10llu %10llu %10llu\n");
+	fmt[9] = *unit == 'B' ? '9' : '7';
+	
+	nl_dump_line(p, fmt, res, unit,
+		link->l_stats[RTNL_LINK_RX_PACKETS],
+		link->l_stats[RTNL_LINK_RX_ERRORS],
+		link->l_stats[RTNL_LINK_RX_DROPPED],
+		link->l_stats[RTNL_LINK_RX_FIFO_ERR],
+		link->l_stats[RTNL_LINK_RX_COMPRESSED]);
+
+	res = nl_cancel_down_bytes(link->l_stats[RTNL_LINK_TX_BYTES], &unit);
+
+	strcpy(fmt, "     TX %X.2f %s %10llu %10llu %10llu %10llu %10llu\n");
+	fmt[9] = *unit == 'B' ? '9' : '7';
+	
+	nl_dump_line(p, fmt, res, unit,
+		link->l_stats[RTNL_LINK_TX_PACKETS],
+		link->l_stats[RTNL_LINK_TX_ERRORS],
+		link->l_stats[RTNL_LINK_TX_DROPPED],
+		link->l_stats[RTNL_LINK_TX_FIFO_ERR],
+		link->l_stats[RTNL_LINK_TX_COMPRESSED]);
+
+	nl_dump_line(p, "    Errors:  length       over        crc "
+			"     frame     missed  multicast\n");
+
+	nl_dump_line(p, "     RX  %10" PRIu64 " %10" PRIu64 " %10"
+				PRIu64 " %10" PRIu64 " %10" PRIu64 " %10"
+				PRIu64 "\n",
+		link->l_stats[RTNL_LINK_RX_LEN_ERR],
+		link->l_stats[RTNL_LINK_RX_OVER_ERR],
+		link->l_stats[RTNL_LINK_RX_CRC_ERR],
+		link->l_stats[RTNL_LINK_RX_FRAME_ERR],
+		link->l_stats[RTNL_LINK_RX_MISSED_ERR],
+		link->l_stats[RTNL_LINK_MULTICAST]);
+
+	nl_dump_line(p, "            aborted    carrier  heartbeat "
+			"    window  collision\n");
+	
+	nl_dump_line(p, "     TX  %10" PRIu64 " %10" PRIu64 " %10"
+			PRIu64 " %10" PRIu64 " %10" PRIu64 "\n",
+		link->l_stats[RTNL_LINK_TX_ABORT_ERR],
+		link->l_stats[RTNL_LINK_TX_CARRIER_ERR],
+		link->l_stats[RTNL_LINK_TX_HBEAT_ERR],
+		link->l_stats[RTNL_LINK_TX_WIN_ERR],
+		link->l_stats[RTNL_LINK_TX_COLLISIONS]);
+
+	if (link->l_info_ops && link->l_info_ops->io_dump[NL_DUMP_STATS])
+		link->l_info_ops->io_dump[NL_DUMP_STATS](link, p);
+}
+
+static void link_dump_env(struct nl_object *obj, struct nl_dump_params *p)
+{
+	struct rtnl_link *link = (struct rtnl_link *) obj;
+	struct nl_cache *cache = dp_cache(obj);
+	char buf[128];
+	int i;
+
+	nl_dump_line(p, "LINK_NAME=%s\n", link->l_name);
+	nl_dump_line(p, "LINK_IFINDEX=%u\n", link->l_index);
+	nl_dump_line(p, "LINK_FAMILY=%s\n",
+		     nl_af2str(link->l_family, buf, sizeof(buf)));
+	nl_dump_line(p, "LINK_TYPE=%s\n",
+		     nl_llproto2str(link->l_arptype, buf, sizeof(buf)));
+	if (link->ce_mask & LINK_ATTR_ADDR)
+		nl_dump_line(p, "LINK_ADDRESS=%s\n",
+			     nl_addr2str(link->l_addr, buf, sizeof(buf)));
+	nl_dump_line(p, "LINK_MTU=%u\n", link->l_mtu);
+	nl_dump_line(p, "LINK_TXQUEUELEN=%u\n", link->l_txqlen);
+	nl_dump_line(p, "LINK_WEIGHT=%u\n", link->l_weight);
+
+	rtnl_link_flags2str(link->l_flags & ~IFF_RUNNING, buf, sizeof(buf));
+	if (buf[0])
+		nl_dump_line(p, "LINK_FLAGS=%s\n", buf);
+
+	if (link->ce_mask & LINK_ATTR_QDISC)
+		nl_dump_line(p, "LINK_QDISC=%s\n", link->l_qdisc);
+
+	if (link->ce_mask & LINK_ATTR_LINK) {
+		struct rtnl_link *ll = rtnl_link_get(cache, link->l_link);
+
+		nl_dump_line(p, "LINK_LINK_IFINDEX=%d\n", link->l_link);
+		if (ll) {
+			nl_dump_line(p, "LINK_LINK_IFNAME=%s\n", ll->l_name);
+			rtnl_link_put(ll);
+		}
+	}
+
+	if (link->ce_mask & LINK_ATTR_MASTER) {
+		struct rtnl_link *master = rtnl_link_get(cache, link->l_master);
+		nl_dump_line(p, "LINK_MASTER=%s\n",
+			     master ? master->l_name : "none");
+		if (master)
+			rtnl_link_put(master);
+	}
+
+	if (link->ce_mask & LINK_ATTR_BRD)
+		nl_dump_line(p, "LINK_BROADCAST=%s\n",
+			     nl_addr2str(link->l_bcast, buf, sizeof(buf)));
+
+	if (link->ce_mask & LINK_ATTR_STATS) {
+		for (i = 0; i <= RTNL_LINK_STATS_MAX; i++) {
+			char *c = buf;
+
+			sprintf(buf, "LINK_");
+			rtnl_link_stat2str(i, buf + 5, sizeof(buf) - 5);
+			while (*c) {
+				*c = toupper(*c);
+				c++;
+			}
+			nl_dump_line(p, "%s=%" PRIu64 "\n", buf, link->l_stats[i]);
+		}
+	}
+
+	if (link->l_info_ops && link->l_info_ops->io_dump[NL_DUMP_ENV])
+		link->l_info_ops->io_dump[NL_DUMP_ENV](link, p);
+}
+
+#if 0
+static int link_handle_event(struct nl_object *a, struct rtnl_link_event_cb *cb)
+{
+	struct rtnl_link *l = (struct rtnl_link *) a;
+	struct nl_cache *c = dp_cache(a);
+	int nevents = 0;
+
+	if (l->l_change == ~0U) {
+		if (l->ce_msgtype == RTM_NEWLINK)
+			cb->le_register(l);
+		else
+			cb->le_unregister(l);
+
+		return 1;
+	}
+
+	if (l->l_change & IFF_SLAVE) {
+		if (l->l_flags & IFF_SLAVE) {
+			struct rtnl_link *m = rtnl_link_get(c, l->l_master);
+			cb->le_new_bonding(l, m);
+			if (m)
+				rtnl_link_put(m);
+		} else
+			cb->le_cancel_bonding(l);
+	}
+
+#if 0
+	if (l->l_change & IFF_UP && l->l_change & IFF_RUNNING)
+		dp_dump_line(p, line++, "link %s changed state to %s.\n",
+			l->l_name, l->l_flags & IFF_UP ? "up" : "down");
+
+	if (l->l_change & IFF_PROMISC) {
+		dp_new_line(p, line++);
+		dp_dump(p, "link %s %s promiscuous mode.\n",
+		    l->l_name, l->l_flags & IFF_PROMISC ? "entered" : "left");
+	}
+
+	if (line == 0)
+		dp_dump_line(p, line++, "link %s sent unknown event.\n",
+			     l->l_name);
+#endif
+
+	return nevents;
+}
+#endif
+
+static int link_compare(struct nl_object *_a, struct nl_object *_b,
+			uint32_t attrs, int flags)
+{
+	struct rtnl_link *a = (struct rtnl_link *) _a;
+	struct rtnl_link *b = (struct rtnl_link *) _b;
+	int diff = 0;
+
+#define LINK_DIFF(ATTR, EXPR) ATTR_DIFF(attrs, LINK_ATTR_##ATTR, a, b, EXPR)
+
+	diff |= LINK_DIFF(IFINDEX,	a->l_index != b->l_index);
+	diff |= LINK_DIFF(MTU,		a->l_mtu != b->l_mtu);
+	diff |= LINK_DIFF(LINK,		a->l_link != b->l_link);
+	diff |= LINK_DIFF(TXQLEN,	a->l_txqlen != b->l_txqlen);
+	diff |= LINK_DIFF(WEIGHT,	a->l_weight != b->l_weight);
+	diff |= LINK_DIFF(MASTER,	a->l_master != b->l_master);
+	diff |= LINK_DIFF(FAMILY,	a->l_family != b->l_family);
+	diff |= LINK_DIFF(OPERSTATE,	a->l_operstate != b->l_operstate);
+	diff |= LINK_DIFF(LINKMODE,	a->l_linkmode != b->l_linkmode);
+	diff |= LINK_DIFF(QDISC,	strcmp(a->l_qdisc, b->l_qdisc));
+	diff |= LINK_DIFF(IFNAME,	strcmp(a->l_name, b->l_name));
+	diff |= LINK_DIFF(ADDR,		nl_addr_cmp(a->l_addr, b->l_addr));
+	diff |= LINK_DIFF(BRD,		nl_addr_cmp(a->l_bcast, b->l_bcast));
+
+	if (flags & LOOSE_COMPARISON)
+		diff |= LINK_DIFF(FLAGS,
+				  (a->l_flags ^ b->l_flags) & b->l_flag_mask);
+	else
+		diff |= LINK_DIFF(FLAGS, a->l_flags != b->l_flags);
+
+#undef LINK_DIFF
+
+	return diff;
+}
+
+static struct trans_tbl link_attrs[] = {
+	__ADD(LINK_ATTR_MTU, mtu)
+	__ADD(LINK_ATTR_LINK, link)
+	__ADD(LINK_ATTR_TXQLEN, txqlen)
+	__ADD(LINK_ATTR_WEIGHT, weight)
+	__ADD(LINK_ATTR_MASTER, master)
+	__ADD(LINK_ATTR_QDISC, qdisc)
+	__ADD(LINK_ATTR_MAP, map)
+	__ADD(LINK_ATTR_ADDR, address)
+	__ADD(LINK_ATTR_BRD, broadcast)
+	__ADD(LINK_ATTR_FLAGS, flags)
+	__ADD(LINK_ATTR_IFNAME, name)
+	__ADD(LINK_ATTR_IFINDEX, ifindex)
+	__ADD(LINK_ATTR_FAMILY, family)
+	__ADD(LINK_ATTR_ARPTYPE, arptype)
+	__ADD(LINK_ATTR_STATS, stats)
+	__ADD(LINK_ATTR_CHANGE, change)
+	__ADD(LINK_ATTR_OPERSTATE, operstate)
+	__ADD(LINK_ATTR_LINKMODE, linkmode)
+};
+
+static char *link_attrs2str(int attrs, char *buf, size_t len)
+{
+	return __flags2str(attrs, buf, len, link_attrs,
+			   ARRAY_SIZE(link_attrs));
+}
+
+/**
+ * @name Allocation/Freeing
+ * @{
+ */
+
+struct rtnl_link *rtnl_link_alloc(void)
+{
+	return (struct rtnl_link *) nl_object_alloc(&link_obj_ops);
+}
+
+void rtnl_link_put(struct rtnl_link *link)
+{
+	nl_object_put((struct nl_object *) link);
+}
+
+/** @} */
+
+/**
+ * @name Cache Management
+ * @{
+ */
+
+
+/**
+ * Allocate link cache and fill in all configured links.
+ * @arg sk		Netlink socket.
+ * @arg result		Pointer to store resulting cache.
+ *
+ * Allocates a new link cache, initializes it properly and updates it
+ * to include all links currently configured in the kernel.
+ *
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_link_alloc_cache(struct nl_sock *sk, struct nl_cache **result)
+{
+	return nl_cache_alloc_and_fill(&rtnl_link_ops, sk, result);
+}
+
+/**
+ * Look up link by interface index in the provided cache
+ * @arg cache		link cache
+ * @arg ifindex		link interface index
+ *
+ * The caller owns a reference on the returned object and
+ * must give the object back via rtnl_link_put().
+ *
+ * @return pointer to link inside the cache or NULL if no match was found.
+ */
+struct rtnl_link *rtnl_link_get(struct nl_cache *cache, int ifindex)
+{
+	struct rtnl_link *link;
+
+	if (cache->c_ops != &rtnl_link_ops)
+		return NULL;
+
+	nl_list_for_each_entry(link, &cache->c_items, ce_list) {
+		if (link->l_index == ifindex) {
+			nl_object_get((struct nl_object *) link);
+			return link;
+		}
+	}
+
+	return NULL;
+}
+
+/**
+ * Look up link by link name in the provided cache
+ * @arg cache		link cache
+ * @arg name		link name
+ *
+ * The caller owns a reference on the returned object and
+ * must give the object back via rtnl_link_put().
+ *
+ * @return pointer to link inside the cache or NULL if no match was found.
+ */
+struct rtnl_link *rtnl_link_get_by_name(struct nl_cache *cache,
+					 const char *name)
+{
+	struct rtnl_link *link;
+
+	if (cache->c_ops != &rtnl_link_ops)
+		return NULL;
+
+	nl_list_for_each_entry(link, &cache->c_items, ce_list) {
+		if (!strcmp(name, link->l_name)) {
+			nl_object_get((struct nl_object *) link);
+			return link;
+		}
+	}
+
+	return NULL;
+}
+
+/** @} */
+
+/**
+ * @name Link Modifications
+ * @{
+ */
+
+/**
+ * Builds a netlink change request message to change link attributes
+ * @arg old		link to be changed
+ * @arg tmpl		template with requested changes
+ * @arg flags		additional netlink message flags
+ *
+ * Builds a new netlink message requesting a change of link attributes.
+ * The netlink message header isn't fully equipped with all relevant
+ * fields and must be sent out via nl_send_auto_complete() or
+ * supplemented as needed.
+ * \a old must point to a link currently configured in the kernel
+ * and \a tmpl must contain the attributes to be changed set via
+ * \c rtnl_link_set_* functions.
+ *
+ * @return New netlink message
+ * @note Not all attributes can be changed, see
+ *       \ref link_changeable "Changeable Attributes" for more details.
+ */
+int rtnl_link_build_change_request(struct rtnl_link *old,
+				   struct rtnl_link *tmpl, int flags,
+				   struct nl_msg **result)
+{
+	struct nl_msg *msg;
+	struct ifinfomsg ifi = {
+		.ifi_family = old->l_family,
+		.ifi_index = old->l_index,
+	};
+
+	if (tmpl->ce_mask & LINK_ATTR_FLAGS) {
+		ifi.ifi_flags = old->l_flags & ~tmpl->l_flag_mask;
+		ifi.ifi_flags |= tmpl->l_flags;
+	}
+
+	msg = nlmsg_alloc_simple(RTM_SETLINK, flags);
+	if (!msg)
+		return -NLE_NOMEM;
+
+	if (nlmsg_append(msg, &ifi, sizeof(ifi), NLMSG_ALIGNTO) < 0)
+		goto nla_put_failure;
+
+	if (tmpl->ce_mask & LINK_ATTR_ADDR)
+		NLA_PUT_ADDR(msg, IFLA_ADDRESS, tmpl->l_addr);
+
+	if (tmpl->ce_mask & LINK_ATTR_BRD)
+		NLA_PUT_ADDR(msg, IFLA_BROADCAST, tmpl->l_bcast);
+
+	if (tmpl->ce_mask & LINK_ATTR_MTU)
+		NLA_PUT_U32(msg, IFLA_MTU, tmpl->l_mtu);
+
+	if (tmpl->ce_mask & LINK_ATTR_TXQLEN)
+		NLA_PUT_U32(msg, IFLA_TXQLEN, tmpl->l_txqlen);
+
+	if (tmpl->ce_mask & LINK_ATTR_WEIGHT)
+		NLA_PUT_U32(msg, IFLA_WEIGHT, tmpl->l_weight);
+
+	if (tmpl->ce_mask & LINK_ATTR_IFNAME)
+		NLA_PUT_STRING(msg, IFLA_IFNAME, tmpl->l_name);
+
+	if (tmpl->ce_mask & LINK_ATTR_OPERSTATE)
+		NLA_PUT_U8(msg, IFLA_OPERSTATE, tmpl->l_operstate);
+
+	if (tmpl->ce_mask & LINK_ATTR_LINKMODE)
+		NLA_PUT_U8(msg, IFLA_LINKMODE, tmpl->l_linkmode);
+
+	if ((tmpl->ce_mask & LINK_ATTR_LINKINFO) && tmpl->l_info_ops &&
+	    tmpl->l_info_ops->io_put_attrs) {
+		struct nlattr *info;
+
+		if (!(info = nla_nest_start(msg, IFLA_LINKINFO)))
+			goto nla_put_failure;
+
+		NLA_PUT_STRING(msg, IFLA_INFO_KIND, tmpl->l_info_ops->io_name);
+
+		if (tmpl->l_info_ops->io_put_attrs(msg, tmpl) < 0)
+			goto nla_put_failure;
+
+		nla_nest_end(msg, info);
+	}
+
+	*result = msg;
+	return 0;
+
+nla_put_failure:
+	nlmsg_free(msg);
+	return -NLE_MSGSIZE;
+}
+
+/**
+ * Change link attributes
+ * @arg sk		Netlink socket.
+ * @arg old		link to be changed
+ * @arg tmpl		template with requested changes
+ * @arg flags		additional netlink message flags
+ *
+ * Builds a new netlink message by calling rtnl_link_build_change_request(),
+ * sends the request to the kernel and waits for the next ACK to be
+ * received, i.e. blocks until the request has been processed.
+ *
+ * @return 0 on success or a negative error code
+ * @note Not all attributes can be changed, see
+ *       \ref link_changeable "Changeable Attributes" for more details.
+ */
+int rtnl_link_change(struct nl_sock *sk, struct rtnl_link *old,
+		     struct rtnl_link *tmpl, int flags)
+{
+	struct nl_msg *msg;
+	int err;
+	
+	if ((err = rtnl_link_build_change_request(old, tmpl, flags, &msg)) < 0)
+		return err;
+	
+	err = nl_send_auto_complete(sk, msg);
+	nlmsg_free(msg);
+	if (err < 0)
+		return err;
+
+	return wait_for_ack(sk);
+}
+
+/** @} */
+
+/**
+ * @name Name <-> Index Translations
+ * @{
+ */
+
+/**
+ * Translate an interface index to the corresponding link name
+ * @arg cache		link cache
+ * @arg ifindex		link interface index
+ * @arg dst		destination buffer
+ * @arg len		length of destination buffer
+ *
+ * Translates the specified interface index to the corresponding
+ * link name and stores the name in the destination buffer.
+ *
+ * @return link name or NULL if no match was found.
+ */
+char * rtnl_link_i2name(struct nl_cache *cache, int ifindex, char *dst,
+			size_t len)
+{
+	struct rtnl_link *link = rtnl_link_get(cache, ifindex);
+
+	if (link) {
+		strncpy(dst, link->l_name, len - 1);
+		rtnl_link_put(link);
+		return dst;
+	}
+
+	return NULL;
+}
+
+/**
+ * Translate a link name to the corresponding interface index
+ * @arg cache		link cache
+ * @arg name		link name
+ *
+ * @return interface index or 0 if no match was found.
+ */
+int rtnl_link_name2i(struct nl_cache *cache, const char *name)
+{
+	int ifindex = 0;
+	struct rtnl_link *link;
+	
+	link = rtnl_link_get_by_name(cache, name);
+	if (link) {
+		ifindex = link->l_index;
+		rtnl_link_put(link);
+	}
+
+	return ifindex;
+}
+
+/** @} */
+
+/**
+ * @name Link Flags Translations
+ * @{
+ */
+
+static struct trans_tbl link_flags[] = {
+	__ADD(IFF_LOOPBACK, loopback)
+	__ADD(IFF_BROADCAST, broadcast)
+	__ADD(IFF_POINTOPOINT, pointopoint)
+	__ADD(IFF_MULTICAST, multicast)
+	__ADD(IFF_NOARP, noarp)
+	__ADD(IFF_ALLMULTI, allmulti)
+	__ADD(IFF_PROMISC, promisc)
+	__ADD(IFF_MASTER, master)
+	__ADD(IFF_SLAVE, slave)
+	__ADD(IFF_DEBUG, debug)
+	__ADD(IFF_DYNAMIC, dynamic)
+	__ADD(IFF_AUTOMEDIA, automedia)
+	__ADD(IFF_PORTSEL, portsel)
+	__ADD(IFF_NOTRAILERS, notrailers)
+	__ADD(IFF_UP, up)
+	__ADD(IFF_RUNNING, running)
+	__ADD(IFF_LOWER_UP, lowerup)
+	__ADD(IFF_DORMANT, dormant)
+	__ADD(IFF_ECHO, echo)
+};
+
+char * rtnl_link_flags2str(int flags, char *buf, size_t len)
+{
+	return __flags2str(flags, buf, len, link_flags,
+			   ARRAY_SIZE(link_flags));
+}
+
+int rtnl_link_str2flags(const char *name)
+{
+	return __str2flags(name, link_flags, ARRAY_SIZE(link_flags));
+}
+
+/** @} */
+
+/**
+ * @name Link Statistics Translations
+ * @{
+ */
+
+static struct trans_tbl link_stats[] = {
+	__ADD(RTNL_LINK_RX_PACKETS, rx_packets)
+	__ADD(RTNL_LINK_TX_PACKETS, tx_packets)
+	__ADD(RTNL_LINK_RX_BYTES, rx_bytes)
+	__ADD(RTNL_LINK_TX_BYTES, tx_bytes)
+	__ADD(RTNL_LINK_RX_ERRORS, rx_errors)
+	__ADD(RTNL_LINK_TX_ERRORS, tx_errors)
+	__ADD(RTNL_LINK_RX_DROPPED, rx_dropped)
+	__ADD(RTNL_LINK_TX_DROPPED, tx_dropped)
+	__ADD(RTNL_LINK_RX_COMPRESSED, rx_compressed)
+	__ADD(RTNL_LINK_TX_COMPRESSED, tx_compressed)
+	__ADD(RTNL_LINK_RX_FIFO_ERR, rx_fifo_err)
+	__ADD(RTNL_LINK_TX_FIFO_ERR, tx_fifo_err)
+	__ADD(RTNL_LINK_RX_LEN_ERR, rx_len_err)
+	__ADD(RTNL_LINK_RX_OVER_ERR, rx_over_err)
+	__ADD(RTNL_LINK_RX_CRC_ERR, rx_crc_err)
+	__ADD(RTNL_LINK_RX_FRAME_ERR, rx_frame_err)
+	__ADD(RTNL_LINK_RX_MISSED_ERR, rx_missed_err)
+	__ADD(RTNL_LINK_TX_ABORT_ERR, tx_abort_err)
+	__ADD(RTNL_LINK_TX_CARRIER_ERR, tx_carrier_err)
+	__ADD(RTNL_LINK_TX_HBEAT_ERR, tx_hbeat_err)
+	__ADD(RTNL_LINK_TX_WIN_ERR, tx_win_err)
+	__ADD(RTNL_LINK_TX_COLLISIONS, tx_collision)
+	__ADD(RTNL_LINK_MULTICAST, multicast)
+};
+
+char *rtnl_link_stat2str(int st, char *buf, size_t len)
+{
+	return __type2str(st, buf, len, link_stats, ARRAY_SIZE(link_stats));
+}
+
+int rtnl_link_str2stat(const char *name)
+{
+	return __str2type(name, link_stats, ARRAY_SIZE(link_stats));
+}
+
+/** @} */
+
+/**
+ * @name Link Operstate Translations
+ * @{
+ */
+
+static struct trans_tbl link_operstates[] = {
+	__ADD(IF_OPER_UNKNOWN, unknown)
+	__ADD(IF_OPER_NOTPRESENT, notpresent)
+	__ADD(IF_OPER_DOWN, down)
+	__ADD(IF_OPER_LOWERLAYERDOWN, lowerlayerdown)
+	__ADD(IF_OPER_TESTING, testing)
+	__ADD(IF_OPER_DORMANT, dormant)
+	__ADD(IF_OPER_UP, up)
+};
+
+char *rtnl_link_operstate2str(int st, char *buf, size_t len)
+{
+	return __type2str(st, buf, len, link_operstates,
+			  ARRAY_SIZE(link_operstates));
+}
+
+int rtnl_link_str2operstate(const char *name)
+{
+	return __str2type(name, link_operstates,
+			  ARRAY_SIZE(link_operstates));
+}
+
+/** @} */
+
+/**
+ * @name Link Mode Translations
+ * @{
+ */
+
+static struct trans_tbl link_modes[] = {
+	__ADD(IF_LINK_MODE_DEFAULT, default)
+	__ADD(IF_LINK_MODE_DORMANT, dormant)
+};
+
+char *rtnl_link_mode2str(int st, char *buf, size_t len)
+{
+	return __type2str(st, buf, len, link_modes, ARRAY_SIZE(link_modes));
+}
+
+int rtnl_link_str2mode(const char *name)
+{
+	return __str2type(name, link_modes, ARRAY_SIZE(link_modes));
+}
+
+/** @} */
+
+/**
+ * @name Attributes
+ * @{
+ */
+
+void rtnl_link_set_qdisc(struct rtnl_link *link, const char *qdisc)
+{
+	strncpy(link->l_qdisc, qdisc, sizeof(link->l_qdisc) - 1);
+	link->ce_mask |= LINK_ATTR_QDISC;
+}
+
+char *rtnl_link_get_qdisc(struct rtnl_link *link)
+{
+	if (link->ce_mask & LINK_ATTR_QDISC)
+		return link->l_qdisc;
+	else
+		return NULL;
+}
+
+void rtnl_link_set_name(struct rtnl_link *link, const char *name)
+{
+	strncpy(link->l_name, name, sizeof(link->l_name) - 1);
+	link->ce_mask |= LINK_ATTR_IFNAME;
+}
+
+char *rtnl_link_get_name(struct rtnl_link *link)
+{
+	if (link->ce_mask & LINK_ATTR_IFNAME)
+		return link->l_name;
+	else
+		return NULL;
+}
+
+static inline void __assign_addr(struct rtnl_link *link, struct nl_addr **pos,
+				 struct nl_addr *new, int flag)
+{
+	if (*pos)
+		nl_addr_put(*pos);
+
+	nl_addr_get(new);
+	*pos = new;
+
+	link->ce_mask |= flag;
+}
+
+void rtnl_link_set_addr(struct rtnl_link *link, struct nl_addr *addr)
+{
+	__assign_addr(link, &link->l_addr, addr, LINK_ATTR_ADDR);
+}
+
+struct nl_addr *rtnl_link_get_addr(struct rtnl_link *link)
+{
+	if (link->ce_mask & LINK_ATTR_ADDR)
+		return link->l_addr;
+	else
+		return NULL;
+}
+
+void rtnl_link_set_broadcast(struct rtnl_link *link, struct nl_addr *brd)
+{
+	__assign_addr(link, &link->l_bcast, brd, LINK_ATTR_BRD);
+}
+
+struct nl_addr *rtnl_link_get_broadcast(struct rtnl_link *link)
+{
+	if (link->ce_mask & LINK_ATTR_BRD)
+		return link->l_bcast;
+	else
+		return NULL;
+}
+
+void rtnl_link_set_flags(struct rtnl_link *link, unsigned int flags)
+{
+	link->l_flag_mask |= flags;
+	link->l_flags |= flags;
+	link->ce_mask |= LINK_ATTR_FLAGS;
+}
+
+void rtnl_link_unset_flags(struct rtnl_link *link, unsigned int flags)
+{
+	link->l_flag_mask |= flags;
+	link->l_flags &= ~flags;
+	link->ce_mask |= LINK_ATTR_FLAGS;
+}
+
+unsigned int rtnl_link_get_flags(struct rtnl_link *link)
+{
+	return link->l_flags;
+}
+
+void rtnl_link_set_family(struct rtnl_link *link, int family)
+{
+	link->l_family = family;
+	link->ce_mask |= LINK_ATTR_FAMILY;
+}
+
+int rtnl_link_get_family(struct rtnl_link *link)
+{
+	if (link->l_family & LINK_ATTR_FAMILY)
+		return link->l_family;
+	else
+		return AF_UNSPEC;
+}
+
+void rtnl_link_set_arptype(struct rtnl_link *link, unsigned int arptype)
+{
+	link->l_arptype = arptype;
+}
+
+unsigned int rtnl_link_get_arptype(struct rtnl_link *link)
+{
+	return link->l_arptype;
+}
+
+void rtnl_link_set_ifindex(struct rtnl_link *link, int ifindex)
+{
+	link->l_index = ifindex;
+	link->ce_mask |= LINK_ATTR_IFINDEX;
+}
+
+int rtnl_link_get_ifindex(struct rtnl_link *link)
+{
+	return link->l_index;
+}
+
+void rtnl_link_set_mtu(struct rtnl_link *link, unsigned int mtu)
+{
+	link->l_mtu = mtu;
+	link->ce_mask |= LINK_ATTR_MTU;
+}
+
+unsigned int rtnl_link_get_mtu(struct rtnl_link *link)
+{
+	if (link->ce_mask & LINK_ATTR_MTU)
+		return link->l_mtu;
+	else
+		return 0;
+}
+
+void rtnl_link_set_txqlen(struct rtnl_link *link, unsigned int txqlen)
+{
+	link->l_txqlen = txqlen;
+	link->ce_mask |= LINK_ATTR_TXQLEN;
+}
+
+unsigned int rtnl_link_get_txqlen(struct rtnl_link *link)
+{
+	if (link->ce_mask & LINK_ATTR_TXQLEN)
+		return link->l_txqlen;
+	else
+		return UINT_MAX;
+}
+
+void rtnl_link_set_weight(struct rtnl_link *link, unsigned int weight)
+{
+	link->l_weight = weight;
+	link->ce_mask |= LINK_ATTR_WEIGHT;
+}
+
+unsigned int rtnl_link_get_weight(struct rtnl_link *link)
+{
+	if (link->ce_mask & LINK_ATTR_WEIGHT)
+		return link->l_weight;
+	else
+		return UINT_MAX;
+}
+
+void rtnl_link_set_link(struct rtnl_link *link, int ifindex)
+{
+	link->l_link = ifindex;
+	link->ce_mask |= LINK_ATTR_LINK;
+}
+
+int rtnl_link_get_link(struct rtnl_link *link)
+{
+	return link->l_link;
+}
+
+void rtnl_link_set_master(struct rtnl_link *link, int ifindex)
+{
+	link->l_master = ifindex;
+	link->ce_mask |= LINK_ATTR_MASTER;
+}
+
+int rtnl_link_get_master(struct rtnl_link *link)
+{
+	return link->l_master;
+}
+
+void rtnl_link_set_operstate(struct rtnl_link *link, uint8_t operstate)
+{
+	link->l_operstate = operstate;
+	link->ce_mask |= LINK_ATTR_OPERSTATE;
+}
+
+uint8_t rtnl_link_get_operstate(struct rtnl_link *link)
+{
+	if (link->ce_mask & LINK_ATTR_OPERSTATE)
+		return link->l_operstate;
+	else
+		return IF_OPER_UNKNOWN;
+}
+
+void rtnl_link_set_linkmode(struct rtnl_link *link, uint8_t linkmode)
+{
+	link->l_linkmode = linkmode;
+	link->ce_mask |= LINK_ATTR_LINKMODE;
+}
+
+uint8_t rtnl_link_get_linkmode(struct rtnl_link *link)
+{
+	if (link->ce_mask & LINK_ATTR_LINKMODE)
+		return link->l_linkmode;
+	else
+		return IF_LINK_MODE_DEFAULT;
+}
+
+uint64_t rtnl_link_get_stat(struct rtnl_link *link, int id)
+{
+	if (id < 0 || id > RTNL_LINK_STATS_MAX)
+		return 0;
+
+	return link->l_stats[id];
+}
+
+/**
+ * Specify the info type of a link
+ * @arg link	link object
+ * @arg type	info type
+ *
+ * Looks up the info type and prepares the link to store info type
+ * specific attributes. If an info type has been assigned already
+ * it will be released with all changes lost.
+ *
+ * @return 0 on success or a negative errror code.
+ */
+int rtnl_link_set_info_type(struct rtnl_link *link, const char *type)
+{
+	struct rtnl_link_info_ops *io;
+	int err;
+
+	if ((io = rtnl_link_info_ops_lookup(type)) == NULL)
+		return -NLE_OPNOTSUPP;
+
+	if (link->l_info_ops)
+		release_link_info(link);
+
+	if ((err = io->io_alloc(link)) < 0)
+		return err;
+
+	link->l_info_ops = io;
+
+	return 0;
+}
+
+/**
+ * Return info type of a link
+ * @arg link	link object
+ *
+ * @note The returned pointer is only valid as long as the link exists
+ * @return Info type name or NULL if unknown.
+ */
+char *rtnl_link_get_info_type(struct rtnl_link *link)
+{
+	if (link->l_info_ops)
+		return link->l_info_ops->io_name;
+	else
+		return NULL;
+}
+
+/** @} */
+
+static struct nl_object_ops link_obj_ops = {
+	.oo_name		= "route/link",
+	.oo_size		= sizeof(struct rtnl_link),
+	.oo_free_data		= link_free_data,
+	.oo_clone		= link_clone,
+	.oo_dump = {
+	    [NL_DUMP_LINE]	= link_dump_line,
+	    [NL_DUMP_DETAILS]	= link_dump_details,
+	    [NL_DUMP_STATS]	= link_dump_stats,
+	    [NL_DUMP_ENV]	= link_dump_env,
+	},
+	.oo_compare		= link_compare,
+	.oo_attrs2str		= link_attrs2str,
+	.oo_id_attrs		= LINK_ATTR_IFINDEX,
+};
+
+static struct nl_af_group link_groups[] = {
+	{ AF_UNSPEC,	RTNLGRP_LINK },
+	{ END_OF_GROUP_LIST },
+};
+
+static struct nl_cache_ops rtnl_link_ops = {
+	.co_name		= "route/link",
+	.co_hdrsize		= sizeof(struct ifinfomsg),
+	.co_msgtypes		= {
+					{ RTM_NEWLINK, NL_ACT_NEW, "new" },
+					{ RTM_DELLINK, NL_ACT_DEL, "del" },
+					{ RTM_GETLINK, NL_ACT_GET, "get" },
+					END_OF_MSGTYPES_LIST,
+				  },
+	.co_protocol		= NETLINK_ROUTE,
+	.co_groups		= link_groups,
+	.co_request_update	= link_request_update,
+	.co_msg_parser		= link_msg_parser,
+	.co_obj_ops		= &link_obj_ops,
+};
+
+static void __init link_init(void)
+{
+	nl_cache_mngt_register(&rtnl_link_ops);
+}
+
+static void __exit link_exit(void)
+{
+	nl_cache_mngt_unregister(&rtnl_link_ops);
+}
+
+/** @} */
diff -uNr libnl_kk/lib/route/neigh.c libnl/lib/route/neigh.c
--- libnl_kk/lib/route/neigh.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/neigh.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,887 @@
+/*
+ * lib/route/neigh.c	Neighbours
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup rtnl
+ * @defgroup neigh Neighbours
+ * @brief
+ *
+ * The neighbour table establishes bindings between protocol addresses and
+ * link layer addresses for hosts sharing the same physical link. This
+ * module allows you to access and manipulate the content of these tables.
+ *
+ * @par Neighbour States
+ * @code
+ * NUD_INCOMPLETE
+ * NUD_REACHABLE
+ * NUD_STALE
+ * NUD_DELAY
+ * NUD_PROBE
+ * NUD_FAILED
+ * NUD_NOARP
+ * NUD_PERMANENT
+ * @endcode
+ *
+ * @par Neighbour Flags
+ * @code
+ * NTF_PROXY
+ * NTF_ROUTER
+ * @endcode
+ *
+ * @par Neighbour Identification
+ * A neighbour is uniquely identified by the attributes listed below, whenever
+ * you refer to an existing neighbour all of the attributes must be set.
+ * Neighbours from caches automatically have all required attributes set.
+ *   - interface index (rtnl_neigh_set_ifindex())
+ *   - destination address (rtnl_neigh_set_dst())
+ *
+ * @par Changeable Attributes
+ * \anchor neigh_changeable
+ *  - state (rtnl_neigh_set_state())
+ *  - link layer address (rtnl_neigh_set_lladdr())
+ *
+ * @par Required Caches for Dumping
+ * In order to dump neighbour attributes you must provide the following
+ * caches via nl_cache_provide()
+ *  - link cache holding all links
+ *
+ * @par TODO
+ *   - Document proxy settings
+ *   - Document states and their influence
+ *
+ * @par 1) Retrieving information about configured neighbours
+ * @code
+ * // The first step is to retrieve a list of all available neighbour within
+ * // the kernel and put them into a cache.
+ * struct nl_cache *cache = rtnl_neigh_alloc_cache(sk);
+ *
+ * // Neighbours can then be looked up by the interface and destination
+ * // address:
+ * struct rtnl_neigh *neigh = rtnl_neigh_get(cache, ifindex, dst_addr);
+ * 
+ * // After successful usage, the object must be given back to the cache
+ * rtnl_neigh_put(neigh);
+ * @endcode
+ *
+ * @par 2) Adding new neighbours
+ * @code
+ * // Allocate an empty neighbour handle to be filled out with the attributes
+ * // of the new neighbour.
+ * struct rtnl_neigh *neigh = rtnl_neigh_alloc();
+ *
+ * // Fill out the attributes of the new neighbour
+ * rtnl_neigh_set_ifindex(neigh, ifindex);
+ * rtnl_neigh_set_dst(neigh, dst_addr);
+ * rtnl_neigh_set_state(neigh, rtnl_neigh_str2state("permanent"));
+ *
+ * // Build the netlink message and send it to the kernel, the operation will
+ * // block until the operation has been completed. Alternatively the required
+ * // netlink message can be built using rtnl_neigh_build_add_request()
+ * // to be sent out using nl_send_auto_complete().
+ * rtnl_neigh_add(sk, neigh, NLM_F_CREATE);
+ *
+ * // Free the memory
+ * rtnl_neigh_put(neigh);
+ * @endcode
+ *
+ * @par 3) Deleting an existing neighbour
+ * @code
+ * // Allocate an empty neighbour object to be filled out with the attributes
+ * // matching the neighbour to be deleted. Alternatively a fully equipped
+ * // neighbour object out of a cache can be used instead.
+ * struct rtnl_neigh *neigh = rtnl_neigh_alloc();
+ *
+ * // Neighbours are uniquely identified by their interface index and
+ * // destination address, you may fill out other attributes but they
+ * // will have no influence.
+ * rtnl_neigh_set_ifindex(neigh, ifindex);
+ * rtnl_neigh_set_dst(neigh, dst_addr);
+ *
+ * // Build the netlink message and send it to the kernel, the operation will
+ * // block until the operation has been completed. Alternatively the required
+ * // netlink message can be built using rtnl_neigh_build_delete_request()
+ * // to be sent out using nl_send_auto_complete().
+ * rtnl_neigh_delete(sk, neigh, 0);
+ *
+ * // Free the memory
+ * rtnl_neigh_put(neigh);
+ * @endcode
+ *
+ * @par 4) Changing neighbour attributes
+ * @code
+ * // Allocate an empty neighbour object to be filled out with the attributes
+ * // matching the neighbour to be changed and the new parameters. Alternatively
+ * // a fully equipped modified neighbour object out of a cache can be used.
+ * struct rtnl_neigh *neigh = rtnl_neigh_alloc();
+ *
+ * // Identify the neighbour to be changed by its interface index and
+ * // destination address
+ * rtnl_neigh_set_ifindex(neigh, ifindex);
+ * rtnl_neigh_set_dst(neigh, dst_addr);
+ *
+ * // The link layer address may be modified, if so it is wise to change
+ * // its state to "permanent" in order to avoid having it overwritten.
+ * rtnl_neigh_set_lladdr(neigh, lladdr);
+ *
+ * // Secondly the state can be modified allowing normal neighbours to be
+ * // converted into permanent entries or to manually confirm a neighbour.
+ * rtnl_neigh_set_state(neigh, state);
+ *
+ * // Build the netlink message and send it to the kernel, the operation will
+ * // block until the operation has been completed. Alternatively the required
+ * // netlink message can be built using rtnl_neigh_build_change_request()
+ * // to be sent out using nl_send_auto_complete().
+ * rtnl_neigh_add(sk, neigh, NLM_F_REPLACE);
+ *
+ * // Free the memory
+ * rtnl_neigh_put(neigh);
+ * @endcode
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink/netlink.h>
+#include <netlink/utils.h>
+#include <netlink/route/rtnl.h>
+#include <netlink/route/neighbour.h>
+#include <netlink/route/link.h>
+
+/** @cond SKIP */
+#define NEIGH_ATTR_FLAGS        0x01
+#define NEIGH_ATTR_STATE        0x02
+#define NEIGH_ATTR_LLADDR       0x04
+#define NEIGH_ATTR_DST          0x08
+#define NEIGH_ATTR_CACHEINFO    0x10
+#define NEIGH_ATTR_IFINDEX      0x20
+#define NEIGH_ATTR_FAMILY       0x40
+#define NEIGH_ATTR_TYPE         0x80
+#define NEIGH_ATTR_PROBES       0x100
+
+static struct nl_cache_ops rtnl_neigh_ops;
+static struct nl_object_ops neigh_obj_ops;
+/** @endcond */
+
+static void neigh_free_data(struct nl_object *c)
+{
+	struct rtnl_neigh *neigh = nl_object_priv(c);
+
+	if (!neigh)
+		return;
+
+	nl_addr_put(neigh->n_lladdr);
+	nl_addr_put(neigh->n_dst);
+}
+
+static int neigh_clone(struct nl_object *_dst, struct nl_object *_src)
+{
+	struct rtnl_neigh *dst = nl_object_priv(_dst);
+	struct rtnl_neigh *src = nl_object_priv(_src);
+
+	if (src->n_lladdr)
+		if (!(dst->n_lladdr = nl_addr_clone(src->n_lladdr)))
+			return -NLE_NOMEM;
+
+	if (src->n_dst)
+		if (!(dst->n_dst = nl_addr_clone(src->n_dst)))
+			return -NLE_NOMEM;
+
+	return 0;
+}
+
+static int neigh_compare(struct nl_object *_a, struct nl_object *_b,
+			uint32_t attrs, int flags)
+{
+	struct rtnl_neigh *a = (struct rtnl_neigh *) _a;
+	struct rtnl_neigh *b = (struct rtnl_neigh *) _b;
+	int diff = 0;
+
+#define NEIGH_DIFF(ATTR, EXPR) ATTR_DIFF(attrs, NEIGH_ATTR_##ATTR, a, b, EXPR)
+
+	diff |= NEIGH_DIFF(IFINDEX,	a->n_ifindex != b->n_ifindex);
+	diff |= NEIGH_DIFF(FAMILY,	a->n_family != b->n_family);
+	diff |= NEIGH_DIFF(TYPE,	a->n_type != b->n_type);
+	diff |= NEIGH_DIFF(LLADDR,	nl_addr_cmp(a->n_lladdr, b->n_lladdr));
+	diff |= NEIGH_DIFF(DST,		nl_addr_cmp(a->n_dst, b->n_dst));
+
+	if (flags & LOOSE_COMPARISON) {
+		diff |= NEIGH_DIFF(STATE,
+				  (a->n_state ^ b->n_state) & b->n_state_mask);
+		diff |= NEIGH_DIFF(FLAGS,
+				  (a->n_flags ^ b->n_flags) & b->n_flag_mask);
+	} else {
+		diff |= NEIGH_DIFF(STATE, a->n_state != b->n_state);
+		diff |= NEIGH_DIFF(FLAGS, a->n_flags != b->n_flags);
+	}
+
+#undef NEIGH_DIFF
+
+	return diff;
+}
+
+static struct trans_tbl neigh_attrs[] = {
+	__ADD(NEIGH_ATTR_FLAGS, flags)
+	__ADD(NEIGH_ATTR_STATE, state)
+	__ADD(NEIGH_ATTR_LLADDR, lladdr)
+	__ADD(NEIGH_ATTR_DST, dst)
+	__ADD(NEIGH_ATTR_CACHEINFO, cacheinfo)
+	__ADD(NEIGH_ATTR_IFINDEX, ifindex)
+	__ADD(NEIGH_ATTR_FAMILY, family)
+	__ADD(NEIGH_ATTR_TYPE, type)
+	__ADD(NEIGH_ATTR_PROBES, probes)
+};
+
+static char *neigh_attrs2str(int attrs, char *buf, size_t len)
+{
+	return __flags2str(attrs, buf, len, neigh_attrs,
+			   ARRAY_SIZE(neigh_attrs));
+}
+
+static struct nla_policy neigh_policy[NDA_MAX+1] = {
+	[NDA_CACHEINFO]	= { .minlen = sizeof(struct nda_cacheinfo) },
+	[NDA_PROBES]	= { .type = NLA_U32 },
+};
+
+static int neigh_msg_parser(struct nl_cache_ops *ops, struct sockaddr_nl *who,
+			    struct nlmsghdr *n, struct nl_parser_param *pp)
+{
+	struct rtnl_neigh *neigh;
+	struct nlattr *tb[NDA_MAX + 1];
+	struct ndmsg *nm;
+	int err;
+
+	neigh = rtnl_neigh_alloc();
+	if (!neigh) {
+		err = -NLE_NOMEM;
+		goto errout;
+	}
+
+	neigh->ce_msgtype = n->nlmsg_type;
+	nm = nlmsg_data(n);
+
+	err = nlmsg_parse(n, sizeof(*nm), tb, NDA_MAX, neigh_policy);
+	if (err < 0)
+		goto errout;
+
+	neigh->n_family  = nm->ndm_family;
+	neigh->n_ifindex = nm->ndm_ifindex;
+	neigh->n_state   = nm->ndm_state;
+	neigh->n_flags   = nm->ndm_flags;
+	neigh->n_type    = nm->ndm_type;
+
+	neigh->ce_mask |= (NEIGH_ATTR_FAMILY | NEIGH_ATTR_IFINDEX |
+			   NEIGH_ATTR_STATE | NEIGH_ATTR_FLAGS |
+			   NEIGH_ATTR_TYPE);
+
+	if (tb[NDA_LLADDR]) {
+		neigh->n_lladdr = nl_addr_alloc_attr(tb[NDA_LLADDR], AF_UNSPEC);
+		if (!neigh->n_lladdr) {
+			err = -NLE_NOMEM;
+			goto errout;
+		}
+		nl_addr_set_family(neigh->n_lladdr,
+				   nl_addr_guess_family(neigh->n_lladdr));
+		neigh->ce_mask |= NEIGH_ATTR_LLADDR;
+	}
+
+	if (tb[NDA_DST]) {
+		neigh->n_dst = nl_addr_alloc_attr(tb[NDA_DST], neigh->n_family);
+		if (!neigh->n_dst) {
+			err = -NLE_NOMEM;
+			goto errout;
+		}
+		neigh->ce_mask |= NEIGH_ATTR_DST;
+	}
+
+	if (tb[NDA_CACHEINFO]) {
+		struct nda_cacheinfo *ci = nla_data(tb[NDA_CACHEINFO]);
+
+		neigh->n_cacheinfo.nci_confirmed = ci->ndm_confirmed;
+		neigh->n_cacheinfo.nci_used = ci->ndm_used;
+		neigh->n_cacheinfo.nci_updated = ci->ndm_updated;
+		neigh->n_cacheinfo.nci_refcnt = ci->ndm_refcnt;
+		
+		neigh->ce_mask |= NEIGH_ATTR_CACHEINFO;
+	}
+
+	if (tb[NDA_PROBES]) {
+		neigh->n_probes = nla_get_u32(tb[NDA_PROBES]);
+		neigh->ce_mask |= NEIGH_ATTR_PROBES;
+	}
+
+	err = pp->pp_cb((struct nl_object *) neigh, pp);
+errout:
+	rtnl_neigh_put(neigh);
+	return err;
+}
+
+static int neigh_request_update(struct nl_cache *c, struct nl_sock *h)
+{
+	return nl_rtgen_request(h, RTM_GETNEIGH, AF_UNSPEC, NLM_F_DUMP);
+}
+
+
+static void neigh_dump_line(struct nl_object *a, struct nl_dump_params *p)
+{
+	char dst[INET6_ADDRSTRLEN+5], lladdr[INET6_ADDRSTRLEN+5];
+	struct rtnl_neigh *n = (struct rtnl_neigh *) a;
+	struct nl_cache *link_cache;
+	char state[128], flags[64];
+
+	link_cache = nl_cache_mngt_require("route/link");
+
+	nl_dump_line(p, "%s ", nl_addr2str(n->n_dst, dst, sizeof(dst)));
+
+	if (link_cache)
+		nl_dump(p, "dev %s ",
+			rtnl_link_i2name(link_cache, n->n_ifindex,
+					 state, sizeof(state)));
+	else
+		nl_dump(p, "dev %d ", n->n_ifindex);
+
+	if (n->ce_mask & NEIGH_ATTR_LLADDR)
+		nl_dump(p, "lladdr %s ",
+			nl_addr2str(n->n_lladdr, lladdr, sizeof(lladdr)));
+
+	rtnl_neigh_state2str(n->n_state, state, sizeof(state));
+	rtnl_neigh_flags2str(n->n_flags, flags, sizeof(flags));
+
+	if (state[0])
+		nl_dump(p, "<%s", state);
+	if (flags[0])
+		nl_dump(p, "%s%s", state[0] ? "," : "<", flags);
+	if (state[0] || flags[0])
+		nl_dump(p, ">");
+	nl_dump(p, "\n");
+}
+
+static void neigh_dump_details(struct nl_object *a, struct nl_dump_params *p)
+{
+	char rtn_type[32];
+	struct rtnl_neigh *n = (struct rtnl_neigh *) a;
+	int hz = nl_get_hz();
+
+	neigh_dump_line(a, p);
+
+	nl_dump_line(p, "    refcnt %u type %s confirmed %u used "
+				"%u updated %u\n",
+		n->n_cacheinfo.nci_refcnt,
+		nl_rtntype2str(n->n_type, rtn_type, sizeof(rtn_type)),
+		n->n_cacheinfo.nci_confirmed/hz,
+		n->n_cacheinfo.nci_used/hz, n->n_cacheinfo.nci_updated/hz);
+}
+
+static void neigh_dump_stats(struct nl_object *a, struct nl_dump_params *p)
+{
+	neigh_dump_details(a, p);
+}
+
+static void neigh_dump_env(struct nl_object *obj, struct nl_dump_params *p)
+{
+	struct rtnl_neigh *neigh = (struct rtnl_neigh *) obj;
+	char buf[128];
+
+	nl_dump_line(p, "NEIGH_FAMILY=%s\n",
+		     nl_af2str(neigh->n_family, buf, sizeof(buf)));
+
+	if (neigh->ce_mask & NEIGH_ATTR_LLADDR)
+		nl_dump_line(p, "NEIGHT_LLADDR=%s\n",
+			     nl_addr2str(neigh->n_lladdr, buf, sizeof(buf)));
+
+	if (neigh->ce_mask & NEIGH_ATTR_DST)
+		nl_dump_line(p, "NEIGH_DST=%s\n",
+			     nl_addr2str(neigh->n_dst, buf, sizeof(buf)));
+
+	if (neigh->ce_mask & NEIGH_ATTR_IFINDEX) {
+		struct nl_cache *link_cache;
+
+		nl_dump_line(p, "NEIGH_IFINDEX=%u\n", neigh->n_ifindex);
+
+		link_cache = nl_cache_mngt_require("route/link");
+		if (link_cache)
+			nl_dump_line(p, "NEIGH_IFNAME=%s\n",
+				     rtnl_link_i2name(link_cache,
+						      neigh->n_ifindex,
+						      buf, sizeof(buf)));
+	}
+
+	if (neigh->ce_mask & NEIGH_ATTR_PROBES)
+		nl_dump_line(p, "NEIGH_PROBES=%u\n", neigh->n_probes);
+
+	if (neigh->ce_mask & NEIGH_ATTR_TYPE)
+		nl_dump_line(p, "NEIGH_TYPE=%s\n",
+			     nl_rtntype2str(neigh->n_type, buf, sizeof(buf)));
+
+	rtnl_neigh_flags2str(neigh->n_flags, buf, sizeof(buf));
+	if (buf[0])
+		nl_dump_line(p, "NEIGH_FLAGS=%s\n", buf);
+
+	rtnl_neigh_state2str(neigh->n_state, buf, sizeof(buf));
+	if (buf[0])
+		nl_dump_line(p, "NEIGH_STATE=%s\n", buf);
+}
+
+/**
+ * @name Neighbour Object Allocation/Freeage
+ * @{
+ */
+
+struct rtnl_neigh *rtnl_neigh_alloc(void)
+{
+	return (struct rtnl_neigh *) nl_object_alloc(&neigh_obj_ops);
+}
+
+void rtnl_neigh_put(struct rtnl_neigh *neigh)
+{
+	nl_object_put((struct nl_object *) neigh);
+}
+
+/** @} */
+
+/**
+ * @name Neighbour Cache Managament
+ * @{
+ */
+
+/**
+ * Build a neighbour cache including all neighbours currently configured in the kernel.
+ * @arg sk		Netlink socket.
+ * @arg result		Pointer to store resulting cache.
+ *
+ * Allocates a new neighbour cache, initializes it properly and updates it
+ * to include all neighbours currently configured in the kernel.
+ *
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_neigh_alloc_cache(struct nl_sock *sock, struct nl_cache **result)
+{
+	return nl_cache_alloc_and_fill(&rtnl_neigh_ops, sock, result);
+}
+
+/**
+ * Look up a neighbour by interface index and destination address
+ * @arg cache		neighbour cache
+ * @arg ifindex		interface index the neighbour is on
+ * @arg dst		destination address of the neighbour
+ * @return neighbour handle or NULL if no match was found.
+ */
+struct rtnl_neigh * rtnl_neigh_get(struct nl_cache *cache, int ifindex,
+				   struct nl_addr *dst)
+{
+	struct rtnl_neigh *neigh;
+
+	nl_list_for_each_entry(neigh, &cache->c_items, ce_list) {
+		if (neigh->n_ifindex == ifindex &&
+		    !nl_addr_cmp(neigh->n_dst, dst)) {
+			nl_object_get((struct nl_object *) neigh);
+			return neigh;
+		}
+	}
+
+	return NULL;
+}
+
+/** @} */
+
+/**
+ * @name Neighbour Addition
+ * @{
+ */
+
+static int build_neigh_msg(struct rtnl_neigh *tmpl, int cmd, int flags,
+			   struct nl_msg **result)
+{
+	struct nl_msg *msg;
+	struct ndmsg nhdr = {
+		.ndm_ifindex = tmpl->n_ifindex,
+		.ndm_state = NUD_PERMANENT,
+	};
+
+	if (!(tmpl->ce_mask & NEIGH_ATTR_DST))
+		return -NLE_MISSING_ATTR;
+
+	nhdr.ndm_family = nl_addr_get_family(tmpl->n_dst);
+
+	if (tmpl->ce_mask & NEIGH_ATTR_STATE)
+		nhdr.ndm_state = tmpl->n_state;
+
+	msg = nlmsg_alloc_simple(cmd, flags);
+	if (!msg)
+		return -NLE_NOMEM;
+
+	if (nlmsg_append(msg, &nhdr, sizeof(nhdr), NLMSG_ALIGNTO) < 0)
+		goto nla_put_failure;
+
+	NLA_PUT_ADDR(msg, NDA_DST, tmpl->n_dst);
+
+	if (tmpl->ce_mask & NEIGH_ATTR_LLADDR)
+		NLA_PUT_ADDR(msg, NDA_LLADDR, tmpl->n_lladdr);
+
+	*result = msg;
+	return 0;
+
+nla_put_failure:
+	nlmsg_free(msg);
+	return -NLE_MSGSIZE;
+}
+
+/**
+ * Build netlink request message to add a new neighbour
+ * @arg tmpl		template with data of new neighbour
+ * @arg flags		additional netlink message flags
+ * @arg result		Pointer to store resulting message.
+ *
+ * Builds a new netlink message requesting a addition of a new
+ * neighbour. The netlink message header isn't fully equipped with
+ * all relevant fields and must thus be sent out via nl_send_auto_complete()
+ * or supplemented as needed. \a tmpl must contain the attributes of the new
+ * neighbour set via \c rtnl_neigh_set_* functions.
+ * 
+ * The following attributes must be set in the template:
+ *  - Interface index (rtnl_neigh_set_ifindex())
+ *  - State (rtnl_neigh_set_state())
+ *  - Destination address (rtnl_neigh_set_dst())
+ *  - Link layer address (rtnl_neigh_set_lladdr())
+ *
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_neigh_build_add_request(struct rtnl_neigh *tmpl, int flags,
+				 struct nl_msg **result)
+{
+	return build_neigh_msg(tmpl, RTM_NEWNEIGH, flags, result);
+}
+
+/**
+ * Add a new neighbour
+ * @arg sk		Netlink socket.
+ * @arg tmpl		template with requested changes
+ * @arg flags		additional netlink message flags
+ *
+ * Builds a netlink message by calling rtnl_neigh_build_add_request(),
+ * sends the request to the kernel and waits for the next ACK to be
+ * received and thus blocks until the request has been fullfilled.
+ *
+ * The following attributes must be set in the template:
+ *  - Interface index (rtnl_neigh_set_ifindex())
+ *  - State (rtnl_neigh_set_state())
+ *  - Destination address (rtnl_neigh_set_dst())
+ *  - Link layer address (rtnl_neigh_set_lladdr())
+ *
+ * @return 0 on sucess or a negative error if an error occured.
+ */
+int rtnl_neigh_add(struct nl_sock *sk, struct rtnl_neigh *tmpl, int flags)
+{
+	int err;
+	struct nl_msg *msg;
+	
+	if ((err = rtnl_neigh_build_add_request(tmpl, flags, &msg)) < 0)
+		return err;
+
+	err = nl_send_auto_complete(sk, msg);
+	nlmsg_free(msg);
+	if (err < 0)
+		return err;
+
+	return wait_for_ack(sk);
+}
+
+/** @} */
+
+/**
+ * @name Neighbour Deletion
+ * @{
+ */
+
+/**
+ * Build a netlink request message to delete a neighbour
+ * @arg neigh		neighbour to delete
+ * @arg flags		additional netlink message flags
+ * @arg result		Pointer to store resulting message.
+ *
+ * Builds a new netlink message requesting a deletion of a neighbour.
+ * The netlink message header isn't fully equipped with all relevant
+ * fields and must thus be sent out via nl_send_auto_complete()
+ * or supplemented as needed. \a neigh must point to an existing
+ * neighbour.
+ *
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_neigh_build_delete_request(struct rtnl_neigh *neigh, int flags,
+				    struct nl_msg **result)
+{
+	return build_neigh_msg(neigh, RTM_DELNEIGH, flags, result);
+}
+
+/**
+ * Delete a neighbour
+ * @arg sk		Netlink socket.
+ * @arg neigh		neighbour to delete
+ * @arg flags		additional netlink message flags
+ *
+ * Builds a netlink message by calling rtnl_neigh_build_delete_request(),
+ * sends the request to the kernel and waits for the next ACK to be
+ * received and thus blocks until the request has been fullfilled.
+ *
+ * @return 0 on sucess or a negative error if an error occured.
+ */
+int rtnl_neigh_delete(struct nl_sock *sk, struct rtnl_neigh *neigh,
+		      int flags)
+{
+	struct nl_msg *msg;
+	int err;
+	
+	if ((err = rtnl_neigh_build_delete_request(neigh, flags, &msg)) < 0)
+		return err;
+
+	err = nl_send_auto_complete(sk, msg);
+	nlmsg_free(msg);
+	if (err < 0)
+		return err;
+
+	return wait_for_ack(sk);
+}
+
+/** @} */
+
+/**
+ * @name Neighbour States Translations
+ * @{
+ */
+
+static struct trans_tbl neigh_states[] = {
+	__ADD(NUD_INCOMPLETE, incomplete)
+	__ADD(NUD_REACHABLE, reachable)
+	__ADD(NUD_STALE, stale)
+	__ADD(NUD_DELAY, delay)
+	__ADD(NUD_PROBE, probe)
+	__ADD(NUD_FAILED, failed)
+	__ADD(NUD_NOARP, norarp)
+	__ADD(NUD_PERMANENT, permanent)
+};
+
+char * rtnl_neigh_state2str(int state, char *buf, size_t len)
+{
+	return __flags2str(state, buf, len, neigh_states,
+	    ARRAY_SIZE(neigh_states));
+}
+
+int rtnl_neigh_str2state(const char *name)
+{
+	return __str2type(name, neigh_states, ARRAY_SIZE(neigh_states));
+}
+
+/** @} */
+
+/**
+ * @name Neighbour Flags Translations
+ * @{
+ */
+
+static struct trans_tbl neigh_flags[] = {
+	__ADD(NTF_PROXY, proxy)
+	__ADD(NTF_ROUTER, router)
+};
+
+char * rtnl_neigh_flags2str(int flags, char *buf, size_t len)
+{
+	return __flags2str(flags, buf, len, neigh_flags,
+	    ARRAY_SIZE(neigh_flags));
+}
+
+int rtnl_neigh_str2flag(const char *name)
+{
+	return __str2type(name, neigh_flags, ARRAY_SIZE(neigh_flags));
+}
+
+/** @} */
+
+/**
+ * @name Attributes
+ * @{
+ */
+
+void rtnl_neigh_set_state(struct rtnl_neigh *neigh, int state)
+{
+	neigh->n_state_mask |= state;
+	neigh->n_state |= state;
+	neigh->ce_mask |= NEIGH_ATTR_STATE;
+}
+
+int rtnl_neigh_get_state(struct rtnl_neigh *neigh)
+{
+	if (neigh->ce_mask & NEIGH_ATTR_STATE)
+		return neigh->n_state;
+	else
+		return -1;
+}
+
+void rtnl_neigh_unset_state(struct rtnl_neigh *neigh, int state)
+{
+	neigh->n_state_mask |= state;
+	neigh->n_state &= ~state;
+	neigh->ce_mask |= NEIGH_ATTR_STATE;
+}
+
+void rtnl_neigh_set_flags(struct rtnl_neigh *neigh, unsigned int flags)
+{
+	neigh->n_flag_mask |= flags;
+	neigh->n_flags |= flags;
+	neigh->ce_mask |= NEIGH_ATTR_FLAGS;
+}
+
+unsigned int rtnl_neigh_get_flags(struct rtnl_neigh *neigh)
+{
+	return neigh->n_flags;
+}
+
+void rtnl_neigh_unset_flags(struct rtnl_neigh *neigh, unsigned int flags)
+{
+	neigh->n_flag_mask |= flags;
+	neigh->n_flags &= ~flags;
+	neigh->ce_mask |= NEIGH_ATTR_FLAGS;
+}
+
+void rtnl_neigh_set_ifindex(struct rtnl_neigh *neigh, int ifindex)
+{
+	neigh->n_ifindex = ifindex;
+	neigh->ce_mask |= NEIGH_ATTR_IFINDEX;
+}
+
+int rtnl_neigh_get_ifindex(struct rtnl_neigh *neigh)
+{
+	return neigh->n_ifindex;
+}
+
+static inline int __assign_addr(struct rtnl_neigh *neigh, struct nl_addr **pos,
+			        struct nl_addr *new, int flag, int nocheck)
+{
+	if (!nocheck) {
+		if (neigh->ce_mask & NEIGH_ATTR_FAMILY) {
+			if (new->a_family != neigh->n_family)
+				return -NLE_AF_MISMATCH;
+		} else {
+			neigh->n_family = new->a_family;
+			neigh->ce_mask |= NEIGH_ATTR_FAMILY;
+		}
+	}
+
+	if (*pos)
+		nl_addr_put(*pos);
+
+	nl_addr_get(new);
+	*pos = new;
+
+	neigh->ce_mask |= flag;
+
+	return 0;
+}
+
+void rtnl_neigh_set_lladdr(struct rtnl_neigh *neigh, struct nl_addr *addr)
+{
+	__assign_addr(neigh, &neigh->n_lladdr, addr, NEIGH_ATTR_LLADDR, 1);
+}
+
+struct nl_addr *rtnl_neigh_get_lladdr(struct rtnl_neigh *neigh)
+{
+	if (neigh->ce_mask & NEIGH_ATTR_LLADDR)
+		return neigh->n_lladdr;
+	else
+		return NULL;
+}
+
+int rtnl_neigh_set_dst(struct rtnl_neigh *neigh, struct nl_addr *addr)
+{
+	return __assign_addr(neigh, &neigh->n_dst, addr,
+			     NEIGH_ATTR_DST, 0);
+}
+
+struct nl_addr *rtnl_neigh_get_dst(struct rtnl_neigh *neigh)
+{
+	if (neigh->ce_mask & NEIGH_ATTR_DST)
+		return neigh->n_dst;
+	else
+		return NULL;
+}
+
+void rtnl_neigh_set_family(struct rtnl_neigh *neigh, int family)
+{
+	neigh->n_family = family;
+	neigh->ce_mask |= NEIGH_ATTR_FAMILY;
+}
+
+int rtnl_neigh_get_family(struct rtnl_neigh *neigh)
+{
+	return neigh->n_family;
+}
+
+void rtnl_neigh_set_type(struct rtnl_neigh *neigh, int type)
+{
+	neigh->n_type = type;
+	neigh->ce_mask = NEIGH_ATTR_TYPE;
+}
+
+int rtnl_neigh_get_type(struct rtnl_neigh *neigh)
+{
+	if (neigh->ce_mask & NEIGH_ATTR_TYPE)
+		return neigh->n_type;
+	else
+		return -1;
+}
+
+/** @} */
+
+static struct nl_object_ops neigh_obj_ops = {
+	.oo_name		= "route/neigh",
+	.oo_size		= sizeof(struct rtnl_neigh),
+	.oo_free_data		= neigh_free_data,
+	.oo_clone		= neigh_clone,
+	.oo_dump = {
+	    [NL_DUMP_LINE]	= neigh_dump_line,
+	    [NL_DUMP_DETAILS]	= neigh_dump_details,
+	    [NL_DUMP_STATS]	= neigh_dump_stats,
+	    [NL_DUMP_ENV]	= neigh_dump_env,
+	},
+	.oo_compare		= neigh_compare,
+	.oo_attrs2str		= neigh_attrs2str,
+	.oo_id_attrs		= (NEIGH_ATTR_IFINDEX | NEIGH_ATTR_DST | NEIGH_ATTR_FAMILY),
+};
+
+static struct nl_af_group neigh_groups[] = {
+	{ AF_UNSPEC, RTNLGRP_NEIGH },
+	{ END_OF_GROUP_LIST },
+};
+
+static struct nl_cache_ops rtnl_neigh_ops = {
+	.co_name		= "route/neigh",
+	.co_hdrsize		= sizeof(struct ndmsg),
+	.co_msgtypes		= {
+					{ RTM_NEWNEIGH, NL_ACT_NEW, "new" },
+					{ RTM_DELNEIGH, NL_ACT_DEL, "del" },
+					{ RTM_GETNEIGH, NL_ACT_GET, "get" },
+					END_OF_MSGTYPES_LIST,
+				  },
+	.co_protocol		= NETLINK_ROUTE,
+	.co_groups		= neigh_groups,
+	.co_request_update	= neigh_request_update,
+	.co_msg_parser		= neigh_msg_parser,
+	.co_obj_ops		= &neigh_obj_ops,
+};
+
+static void __init neigh_init(void)
+{
+	nl_cache_mngt_register(&rtnl_neigh_ops);
+}
+
+static void __exit neigh_exit(void)
+{
+	nl_cache_mngt_unregister(&rtnl_neigh_ops);
+}
+
+/** @} */
diff -uNr libnl_kk/lib/route/neightbl.c libnl/lib/route/neightbl.c
--- libnl_kk/lib/route/neightbl.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/neightbl.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,815 @@
+/*
+ * lib/route/neightbl.c         neighbour tables
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup rtnl
+ * @defgroup neightbl Neighbour Tables
+ * @brief
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink/netlink.h>
+#include <netlink/utils.h>
+#include <netlink/route/rtnl.h>
+#include <netlink/route/neightbl.h>
+#include <netlink/route/link.h>
+
+/** @cond SKIP */
+#define NEIGHTBL_ATTR_FAMILY       0x001
+#define NEIGHTBL_ATTR_STATS        0x002
+#define NEIGHTBL_ATTR_NAME	  0x004
+#define NEIGHTBL_ATTR_THRESH1	  0x008
+#define NEIGHTBL_ATTR_THRESH2	  0x010
+#define NEIGHTBL_ATTR_THRESH3	  0x020
+#define NEIGHTBL_ATTR_CONFIG	  0x040
+#define NEIGHTBL_ATTR_PARMS	  0x080
+#define NEIGHTBL_ATTR_GC_INTERVAL  0x100
+
+#define NEIGHTBLPARM_ATTR_IFINDEX	0x0001
+#define NEIGHTBLPARM_ATTR_REFCNT		0x0002
+#define NEIGHTBLPARM_ATTR_QUEUE_LEN	0x0004
+#define NEIGHTBLPARM_ATTR_APP_PROBES	0x0008
+#define NEIGHTBLPARM_ATTR_UCAST_PROBES	0x0010
+#define NEIGHTBLPARM_ATTR_MCAST_PROBES	0x0020
+#define NEIGHTBLPARM_ATTR_PROXY_QLEN	0x0040
+#define NEIGHTBLPARM_ATTR_REACHABLE_TIME	0x0080
+#define NEIGHTBLPARM_ATTR_BASE_REACHABLE_TIME 0x0100
+#define NEIGHTBLPARM_ATTR_RETRANS_TIME	0x0200
+#define NEIGHTBLPARM_ATTR_GC_STALETIME	0x0400
+#define NEIGHTBLPARM_ATTR_DELAY_PROBE_TIME 0x0800
+#define NEIGHTBLPARM_ATTR_ANYCAST_DELAY	0x1000
+#define NEIGHTBLPARM_ATTR_PROXY_DELAY	0x2000
+#define NEIGHTBLPARM_ATTR_LOCKTIME	0x4000
+
+static struct nl_cache_ops rtnl_neightbl_ops;
+static struct nl_object_ops neightbl_obj_ops;
+/** @endcond */
+
+static int neightbl_compare(struct nl_object *_a, struct nl_object *_b,
+			uint32_t attrs, int flags)
+{
+	struct rtnl_neightbl *a = (struct rtnl_neightbl *) _a;
+	struct rtnl_neightbl *b = (struct rtnl_neightbl *) _b;
+	int diff = 0;
+
+#define NT_DIFF(ATTR, EXPR) ATTR_DIFF(attrs, NEIGHTBL_ATTR_##ATTR, a, b, EXPR)
+
+	diff |= NT_DIFF(FAMILY,		a->nt_family != b->nt_family);
+	diff |= NT_DIFF(NAME,		strcmp(a->nt_name, b->nt_name));
+	diff |= NT_DIFF(THRESH1,	a->nt_gc_thresh1 != b->nt_gc_thresh1);
+	diff |= NT_DIFF(THRESH2,	a->nt_gc_thresh2 != b->nt_gc_thresh2);
+	diff |= NT_DIFF(THRESH3,	a->nt_gc_thresh3 != b->nt_gc_thresh3);
+	diff |= NT_DIFF(GC_INTERVAL,	a->nt_gc_interval != b->nt_gc_interval);
+
+#undef NT_DIFF
+
+	if (!(a->ce_mask & NEIGHTBL_ATTR_PARMS) &&
+	    !(b->ce_mask & NEIGHTBL_ATTR_PARMS))
+		return diff;
+
+	/* XXX: FIXME: Compare parameter table */
+
+
+#if 0
+#define REQ(F) (fp->ntp_mask & NEIGHTBLPARM_ATTR_##F)
+#define AVAIL(F) (op->ntp_mask & NEIGHTBLPARM_ATTR_##F)
+#define _C(F, N) (REQ(F) && (!AVAIL(F) || (op->N != fp->N)))
+	if (_C(IFINDEX,			ntp_ifindex)			||
+	    _C(QUEUE_LEN,		ntp_queue_len)			||
+	    _C(APP_PROBES,		ntp_app_probes)			||
+	    _C(UCAST_PROBES,		ntp_ucast_probes)		||
+	    _C(MCAST_PROBES,		ntp_mcast_probes)		||
+	    _C(PROXY_QLEN,		ntp_proxy_qlen)			||
+	    _C(LOCKTIME,		ntp_locktime)			||
+	    _C(RETRANS_TIME,		ntp_retrans_time)		||
+	    _C(BASE_REACHABLE_TIME,	ntp_base_reachable_time)	||
+	    _C(GC_STALETIME,		ntp_gc_stale_time)		||
+	    _C(DELAY_PROBE_TIME,	ntp_probe_delay)		||
+	    _C(ANYCAST_DELAY,		ntp_anycast_delay)		||
+	    _C(PROXY_DELAY,		ntp_proxy_delay))
+		return 0;
+#undef REQ
+#undef AVAIL
+#undef _C
+#endif
+
+	return diff;
+}
+
+
+static struct nla_policy neightbl_policy[NDTA_MAX+1] = {
+	[NDTA_NAME]		= { .type = NLA_STRING,
+				    .maxlen = NTBLNAMSIZ },
+	[NDTA_THRESH1]		= { .type = NLA_U32 },
+	[NDTA_THRESH2]		= { .type = NLA_U32 },
+	[NDTA_THRESH3]		= { .type = NLA_U32 },
+	[NDTA_GC_INTERVAL]	= { .type = NLA_U32 },
+	[NDTA_CONFIG]		= { .minlen = sizeof(struct ndt_config) },
+	[NDTA_STATS]		= { .minlen = sizeof(struct ndt_stats) },
+	[NDTA_PARMS]		= { .type = NLA_NESTED },
+};
+
+static int neightbl_msg_parser(struct nl_cache_ops *ops,
+			       struct sockaddr_nl *who, struct nlmsghdr *n,
+			       struct nl_parser_param *pp)
+{
+	struct rtnl_neightbl *ntbl;
+	struct nlattr *tb[NDTA_MAX + 1];
+	struct rtgenmsg *rtmsg;
+	int err;
+
+	ntbl = rtnl_neightbl_alloc();
+	if (!ntbl) {
+		err = -NLE_NOMEM;
+		goto errout;
+	}
+
+	ntbl->ce_msgtype = n->nlmsg_type;
+	rtmsg = nlmsg_data(n);
+	
+	err = nlmsg_parse(n, sizeof(*rtmsg), tb, NDTA_MAX, neightbl_policy);
+	if (err < 0)
+		goto errout;
+
+	ntbl->nt_family = rtmsg->rtgen_family;
+
+	if (tb[NDTA_NAME] == NULL) {
+		return -NLE_MISSING_ATTR;
+		goto errout;
+	}
+
+	nla_strlcpy(ntbl->nt_name, tb[NDTA_NAME], NTBLNAMSIZ);
+	ntbl->ce_mask |= NEIGHTBL_ATTR_NAME;
+
+	if (tb[NDTA_THRESH1]) {
+		ntbl->nt_gc_thresh1 = nla_get_u32(tb[NDTA_THRESH1]);
+		ntbl->ce_mask |= NEIGHTBL_ATTR_THRESH1;
+	}
+
+	if (tb[NDTA_THRESH2]) {
+		ntbl->nt_gc_thresh2 = nla_get_u32(tb[NDTA_THRESH2]);
+		ntbl->ce_mask |= NEIGHTBL_ATTR_THRESH2;
+	}
+
+	if (tb[NDTA_THRESH3]) {
+		ntbl->nt_gc_thresh3 = nla_get_u32(tb[NDTA_THRESH3]);
+		ntbl->ce_mask |= NEIGHTBL_ATTR_THRESH3;
+	}
+
+	if (tb[NDTA_GC_INTERVAL]) {
+		ntbl->nt_gc_interval = nla_get_u32(tb[NDTA_GC_INTERVAL]);
+		ntbl->ce_mask |= NEIGHTBL_ATTR_GC_INTERVAL;
+	}
+
+	if (tb[NDTA_CONFIG]) {
+		nla_memcpy(&ntbl->nt_config, tb[NDTA_CONFIG],
+			   sizeof(ntbl->nt_config));
+		ntbl->ce_mask |= NEIGHTBL_ATTR_CONFIG;
+	}
+
+	if (tb[NDTA_STATS]) {
+		nla_memcpy(&ntbl->nt_stats, tb[NDTA_STATS],
+			   sizeof(ntbl->nt_stats));
+		ntbl->ce_mask |= NEIGHTBL_ATTR_STATS;
+	}
+
+	if (tb[NDTA_PARMS]) {
+		struct nlattr *tbp[NDTPA_MAX + 1];
+		struct rtnl_neightbl_parms *p = &ntbl->nt_parms;
+
+		err = nla_parse_nested(tbp, NDTPA_MAX, tb[NDTA_PARMS], NULL);
+		if (err < 0)
+			goto errout;
+
+#define COPY_ENTRY(name, var) \
+		if (tbp[NDTPA_ ##name]) { \
+			p->ntp_ ##var = nla_get_u32(tbp[NDTPA_ ##name]); \
+			p->ntp_mask |= NEIGHTBLPARM_ATTR_ ##name; \
+		}
+
+		COPY_ENTRY(IFINDEX, ifindex);
+		COPY_ENTRY(REFCNT, refcnt);
+		COPY_ENTRY(QUEUE_LEN, queue_len);
+		COPY_ENTRY(APP_PROBES, app_probes);
+		COPY_ENTRY(UCAST_PROBES, ucast_probes);
+		COPY_ENTRY(MCAST_PROBES, mcast_probes);
+		COPY_ENTRY(PROXY_QLEN, proxy_qlen);
+		COPY_ENTRY(PROXY_DELAY, proxy_delay);
+		COPY_ENTRY(ANYCAST_DELAY, anycast_delay);
+		COPY_ENTRY(LOCKTIME, locktime);
+		COPY_ENTRY(REACHABLE_TIME, reachable_time);
+		COPY_ENTRY(BASE_REACHABLE_TIME, base_reachable_time);
+		COPY_ENTRY(RETRANS_TIME, retrans_time);
+		COPY_ENTRY(GC_STALETIME, gc_stale_time);
+		COPY_ENTRY(DELAY_PROBE_TIME, probe_delay);
+#undef COPY_ENTRY
+
+		ntbl->ce_mask |= NEIGHTBL_ATTR_PARMS;
+	}
+
+	err = pp->pp_cb((struct nl_object *) ntbl, pp);
+errout:
+	rtnl_neightbl_put(ntbl);
+	return err;
+}
+
+static int neightbl_request_update(struct nl_cache *c, struct nl_sock *h)
+{
+	return nl_rtgen_request(h, RTM_GETNEIGHTBL, AF_UNSPEC, NLM_F_DUMP);
+}
+
+
+static void neightbl_dump_line(struct nl_object *arg, struct nl_dump_params *p)
+{
+	struct rtnl_neightbl *ntbl = (struct rtnl_neightbl *) arg;
+
+	nl_dump_line(p, "%s", ntbl->nt_name);
+
+	if (ntbl->nt_parms.ntp_mask & NEIGHTBLPARM_ATTR_IFINDEX) {
+		struct nl_cache *link_cache;
+		
+		link_cache = nl_cache_mngt_require("route/link");
+
+		if (link_cache) {
+			char buf[32];
+			nl_dump(p, "<%s> ",
+				rtnl_link_i2name(link_cache,
+						 ntbl->nt_parms.ntp_ifindex,
+						 buf, sizeof(buf)));
+		} else
+			nl_dump(p, "<%u> ", ntbl->nt_parms.ntp_ifindex);
+	} else
+		nl_dump(p, " ");
+
+	if (ntbl->ce_mask & NEIGHTBL_ATTR_CONFIG)
+		nl_dump(p, "entries %u ", ntbl->nt_config.ndtc_entries);
+
+	if (ntbl->ce_mask & NEIGHTBL_ATTR_PARMS) {
+		char rt[32], rt2[32];
+		struct rtnl_neightbl_parms *pa = &ntbl->nt_parms;
+
+		nl_dump(p, "reachable-time %s retransmit-time %s",
+			nl_msec2str(pa->ntp_reachable_time, rt, sizeof(rt)),
+			nl_msec2str(pa->ntp_retrans_time, rt2, sizeof(rt2)));
+	}
+
+	nl_dump(p, "\n");
+}
+
+static void neightbl_dump_details(struct nl_object *arg, struct nl_dump_params *p)
+{
+	char x[32], y[32], z[32];
+	struct rtnl_neightbl *ntbl = (struct rtnl_neightbl *) arg;
+
+	neightbl_dump_line(arg, p);
+
+	if (ntbl->ce_mask & NEIGHTBL_ATTR_CONFIG) {
+		nl_dump_line(p, "    key-len %u entry-size %u last-flush %s\n",
+			ntbl->nt_config.ndtc_key_len,
+			ntbl->nt_config.ndtc_entry_size,
+			nl_msec2str(ntbl->nt_config.ndtc_last_flush,
+				      x, sizeof(x)));
+
+		nl_dump_line(p, "    gc threshold %u/%u/%u interval %s " \
+			    "chain-position %u\n",
+			ntbl->nt_gc_thresh1, ntbl->nt_gc_thresh2,
+			ntbl->nt_gc_thresh3,
+			nl_msec2str(ntbl->nt_gc_interval, x, sizeof(x)),
+			ntbl->nt_config.ndtc_hash_chain_gc);
+
+		nl_dump_line(p, "    hash-rand 0x%08X/0x%08X last-rand %s\n",
+			ntbl->nt_config.ndtc_hash_rnd,
+			ntbl->nt_config.ndtc_hash_mask,
+			nl_msec2str(ntbl->nt_config.ndtc_last_rand,
+				      x, sizeof(x)));
+	}
+
+	if (ntbl->ce_mask & NEIGHTBL_ATTR_PARMS) {
+		struct rtnl_neightbl_parms *pa = &ntbl->nt_parms;
+
+		nl_dump_line(p, "    refcnt %u pending-queue-limit %u " \
+			    "proxy-delayed-queue-limit %u\n",
+			pa->ntp_refcnt,
+			pa->ntp_queue_len,
+			pa->ntp_proxy_qlen);
+
+		nl_dump_line(p, "    num-userspace-probes %u num-unicast-probes " \
+			    "%u num-multicast-probes %u\n",
+			pa->ntp_app_probes,
+			pa->ntp_ucast_probes,
+			pa->ntp_mcast_probes);
+
+		nl_dump_line(p, "    min-age %s base-reachable-time %s " \
+			    "stale-check-interval %s\n",
+			nl_msec2str(pa->ntp_locktime, x, sizeof(x)),
+			nl_msec2str(pa->ntp_base_reachable_time,
+				      y, sizeof(y)),
+			nl_msec2str(pa->ntp_gc_stale_time, z, sizeof(z)));
+
+		nl_dump_line(p, "    initial-probe-delay %s answer-delay %s " \
+			    "proxy-answer-delay %s\n",
+			nl_msec2str(pa->ntp_probe_delay, x, sizeof(x)),
+			nl_msec2str(pa->ntp_anycast_delay, y, sizeof(y)),
+			nl_msec2str(pa->ntp_proxy_delay, z, sizeof(z)));
+	}
+}
+
+static void neightbl_dump_stats(struct nl_object *arg, struct nl_dump_params *p)
+{
+	struct rtnl_neightbl *ntbl = (struct rtnl_neightbl *) arg;
+
+	neightbl_dump_details(arg, p);
+
+	if (!(ntbl->ce_mask & NEIGHTBL_ATTR_STATS))
+		return;
+
+	nl_dump_line(p, "    lookups %lld hits %lld failed %lld " \
+		    "allocations %lld destroys %lld\n",
+		ntbl->nt_stats.ndts_lookups,
+		ntbl->nt_stats.ndts_hits,
+		ntbl->nt_stats.ndts_res_failed,
+		ntbl->nt_stats.ndts_allocs,
+		ntbl->nt_stats.ndts_destroys);
+
+	nl_dump_line(p, "    hash-grows %lld forced-gc-runs %lld " \
+		    "periodic-gc-runs %lld\n",
+		ntbl->nt_stats.ndts_hash_grows,
+		ntbl->nt_stats.ndts_forced_gc_runs,
+		ntbl->nt_stats.ndts_periodic_gc_runs);
+
+	nl_dump_line(p, "    rcv-unicast-probes %lld rcv-multicast-probes %lld\n",
+		ntbl->nt_stats.ndts_rcv_probes_ucast,
+		ntbl->nt_stats.ndts_rcv_probes_mcast);
+}
+
+/**
+ * @name Allocation/Freeing
+ * @{
+ */
+
+struct rtnl_neightbl *rtnl_neightbl_alloc(void)
+{
+	return (struct rtnl_neightbl *) nl_object_alloc(&neightbl_obj_ops);
+}
+
+void rtnl_neightbl_put(struct rtnl_neightbl *neightbl)
+{
+	nl_object_put((struct nl_object *) neightbl);
+}
+
+/** @} */
+
+/**
+ * @name Neighbour Table Cache Management
+ * @{
+ */
+
+/**
+ * Build a neighbour table cache including all neighbour tables currently configured in the kernel.
+ * @arg sk		Netlink socket.
+ * @arg result		Pointer to store resulting cache.
+ *
+ * Allocates a new neighbour table cache, initializes it properly and
+ * updates it to include all neighbour tables currently configured in
+ * the kernel.
+ *
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_neightbl_alloc_cache(struct nl_sock *sk, struct nl_cache **result)
+{
+	return nl_cache_alloc_and_fill(&rtnl_neightbl_ops, sk, result);
+}
+
+/**
+ * Lookup neighbour table by name and optional interface index
+ * @arg cache		neighbour table cache
+ * @arg name		name of table
+ * @arg ifindex		optional interface index
+ *
+ * Looks up the neighbour table matching the specified name and
+ * optionally the specified ifindex to retrieve device specific
+ * parameter sets.
+ *
+ * @return ptr to neighbour table inside the cache or NULL if no
+ *         match was found.
+ */
+struct rtnl_neightbl *rtnl_neightbl_get(struct nl_cache *cache,
+					const char *name, int ifindex)
+{
+	struct rtnl_neightbl *nt;
+
+	if (cache->c_ops != &rtnl_neightbl_ops)
+		return NULL;
+
+	nl_list_for_each_entry(nt, &cache->c_items, ce_list) {
+		if (!strcasecmp(nt->nt_name, name) &&
+		    ((!ifindex && !nt->nt_parms.ntp_ifindex) ||
+		     (ifindex && ifindex == nt->nt_parms.ntp_ifindex))) {
+			nl_object_get((struct nl_object *) nt);
+			return nt;
+		}
+	}
+
+	return NULL;
+}
+
+/** @} */
+
+/**
+ * @name Neighbour Table Modifications
+ * @{
+ */
+
+/**
+ * Builds a netlink change request message to change neighbour table attributes
+ * @arg old		neighbour table to change
+ * @arg tmpl		template with requested changes
+ * @arg result		Pointer to store resulting message.
+ *
+ * Builds a new netlink message requesting a change of neighbour table
+ * attributes. The netlink message header isn't fully equipped with all
+ * relevant fields and must be sent out via nl_send_auto_complete() or
+ * supplemented as needed.
+ * \a old must point to a neighbour table currently configured in the
+ * kernel and \a tmpl must contain the attributes to be changed set via
+ * \c rtnl_neightbl_set_* functions.
+ *
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_neightbl_build_change_request(struct rtnl_neightbl *old,
+				       struct rtnl_neightbl *tmpl,
+				       struct nl_msg **result)
+{
+	struct nl_msg *m, *parms = NULL;
+	struct ndtmsg ndt = {
+		.ndtm_family = old->nt_family,
+	};
+
+	m = nlmsg_alloc_simple(RTM_SETNEIGHTBL, 0);
+	if (!m)
+		return -NLE_NOMEM;
+
+	if (nlmsg_append(m, &ndt, sizeof(ndt), NLMSG_ALIGNTO) < 0)
+		goto nla_put_failure;
+
+	NLA_PUT_STRING(m, NDTA_NAME, old->nt_name);
+
+	if (tmpl->ce_mask & NEIGHTBL_ATTR_THRESH1)
+		NLA_PUT_U32(m, NDTA_THRESH1, tmpl->nt_gc_thresh1);
+
+	if (tmpl->ce_mask & NEIGHTBL_ATTR_THRESH2)
+		NLA_PUT_U32(m, NDTA_THRESH2, tmpl->nt_gc_thresh2);
+
+	if (tmpl->ce_mask & NEIGHTBL_ATTR_THRESH2)
+		NLA_PUT_U32(m, NDTA_THRESH2, tmpl->nt_gc_thresh2);
+
+	if (tmpl->ce_mask & NEIGHTBL_ATTR_GC_INTERVAL)
+		NLA_PUT_U64(m, NDTA_GC_INTERVAL,
+				      tmpl->nt_gc_interval);
+
+	if (tmpl->ce_mask & NEIGHTBL_ATTR_PARMS) {
+		struct rtnl_neightbl_parms *p = &tmpl->nt_parms;
+
+		parms = nlmsg_alloc();
+		if (!parms)
+			goto nla_put_failure;
+
+		if (old->nt_parms.ntp_mask & NEIGHTBLPARM_ATTR_IFINDEX)
+			NLA_PUT_U32(parms, NDTPA_IFINDEX,
+					      old->nt_parms.ntp_ifindex);
+
+
+		if (p->ntp_mask & NEIGHTBLPARM_ATTR_QUEUE_LEN)
+			NLA_PUT_U32(parms, NDTPA_QUEUE_LEN, p->ntp_queue_len);
+
+		if (p->ntp_mask & NEIGHTBLPARM_ATTR_APP_PROBES)
+			NLA_PUT_U32(parms, NDTPA_APP_PROBES, p->ntp_app_probes);
+
+		if (p->ntp_mask & NEIGHTBLPARM_ATTR_UCAST_PROBES)
+			NLA_PUT_U32(parms, NDTPA_UCAST_PROBES,
+				    p->ntp_ucast_probes);
+
+		if (p->ntp_mask & NEIGHTBLPARM_ATTR_MCAST_PROBES)
+			NLA_PUT_U32(parms, NDTPA_MCAST_PROBES,
+				    p->ntp_mcast_probes);
+
+		if (p->ntp_mask & NEIGHTBLPARM_ATTR_PROXY_QLEN)
+			NLA_PUT_U32(parms, NDTPA_PROXY_QLEN,
+				    p->ntp_proxy_qlen);
+
+		if (p->ntp_mask & NEIGHTBLPARM_ATTR_BASE_REACHABLE_TIME)
+			NLA_PUT_U64(parms, NDTPA_BASE_REACHABLE_TIME,
+				    p->ntp_base_reachable_time);
+
+		if (p->ntp_mask & NEIGHTBLPARM_ATTR_RETRANS_TIME)
+			NLA_PUT_U64(parms, NDTPA_RETRANS_TIME,
+				    p->ntp_retrans_time);
+
+		if (p->ntp_mask & NEIGHTBLPARM_ATTR_GC_STALETIME)
+			NLA_PUT_U64(parms, NDTPA_GC_STALETIME,
+				    p->ntp_gc_stale_time);
+
+		if (p->ntp_mask & NEIGHTBLPARM_ATTR_DELAY_PROBE_TIME)
+			NLA_PUT_U64(parms, NDTPA_DELAY_PROBE_TIME,
+				    p->ntp_proxy_delay);
+
+		if (p->ntp_mask & NEIGHTBLPARM_ATTR_ANYCAST_DELAY)
+			NLA_PUT_U64(parms, NDTPA_ANYCAST_DELAY,
+				    p->ntp_anycast_delay);
+
+		if (p->ntp_mask & NEIGHTBLPARM_ATTR_PROXY_DELAY)
+			NLA_PUT_U64(parms, NDTPA_PROXY_DELAY,
+					      p->ntp_proxy_delay);
+
+		if (p->ntp_mask & NEIGHTBLPARM_ATTR_LOCKTIME)
+			NLA_PUT_U64(parms, NDTPA_LOCKTIME, p->ntp_locktime);
+
+		if (nla_put_nested(m, NDTA_PARMS, parms) < 0)
+			goto nla_put_failure;
+
+		nlmsg_free(parms);
+	}
+
+	*result = m;
+	return 0;
+
+nla_put_failure:
+	if (parms)
+		nlmsg_free(parms);
+	nlmsg_free(m);
+	return -NLE_MSGSIZE;
+}
+
+/**
+ * Change neighbour table attributes
+ * @arg sk		Netlink socket.
+ * @arg old		neighbour table to be changed
+ * @arg tmpl		template with requested changes
+ *
+ * Builds a new netlink message by calling
+ * rtnl_neightbl_build_change_request(), sends the request to the
+ * kernel and waits for the next ACK to be received, i.e. blocks
+ * until the request has been processed.
+ *
+ * @return 0 on success or a negative error code
+ */
+int rtnl_neightbl_change(struct nl_sock *sk, struct rtnl_neightbl *old,
+			 struct rtnl_neightbl *tmpl)
+{
+	struct nl_msg *msg;
+	int err;
+	
+	if ((err = rtnl_neightbl_build_change_request(old, tmpl, &msg)) < 0)
+		return err;
+
+	err = nl_send_auto_complete(sk, msg);
+	nlmsg_free(msg);
+	if (err < 0)
+		return err;
+
+	return wait_for_ack(sk);
+}
+
+/** @} */
+
+/**
+ * @name Attribute Modification
+ * @{
+ */
+
+void rtnl_neightbl_set_family(struct rtnl_neightbl *ntbl, int family)
+{
+	ntbl->nt_family = family;
+	ntbl->ce_mask |= NEIGHTBL_ATTR_FAMILY;
+}
+
+void rtnl_neightbl_set_gc_interval(struct rtnl_neightbl *ntbl, uint64_t ms)
+{
+	ntbl->nt_gc_interval = ms;
+	ntbl->ce_mask |= NEIGHTBL_ATTR_GC_INTERVAL;
+}
+
+void rtnl_neightbl_set_gc_tresh1(struct rtnl_neightbl *ntbl, int thresh)
+{
+	ntbl->nt_gc_thresh1 = thresh;
+	ntbl->ce_mask |= NEIGHTBL_ATTR_THRESH1;
+}
+
+void rtnl_neightbl_set_gc_tresh2(struct rtnl_neightbl *ntbl, int thresh)
+{
+	ntbl->nt_gc_thresh2 = thresh;
+	ntbl->ce_mask |= NEIGHTBL_ATTR_THRESH2;
+}
+
+void rtnl_neightbl_set_gc_tresh3(struct rtnl_neightbl *ntbl, int thresh)
+{
+	ntbl->nt_gc_thresh3 = thresh;
+	ntbl->ce_mask |= NEIGHTBL_ATTR_THRESH3;
+}
+
+void rtnl_neightbl_set_name(struct rtnl_neightbl *ntbl, const char *name)
+{
+	strncpy(ntbl->nt_name, name, sizeof(ntbl->nt_name) - 1);
+	ntbl->ce_mask |= NEIGHTBL_ATTR_NAME;
+}
+
+void rtnl_neightbl_set_dev(struct rtnl_neightbl *ntbl, int ifindex)
+{
+	ntbl->nt_parms.ntp_ifindex = ifindex;
+	ntbl->nt_parms.ntp_mask |= NEIGHTBLPARM_ATTR_IFINDEX;
+	ntbl->ce_mask |= NEIGHTBL_ATTR_PARMS;
+}
+
+/**
+ * Set the queue length for pending requests of a neighbour table to the specified value
+ * @arg ntbl		neighbour table to change
+ * @arg len		new queue len
+ */
+void rtnl_neightbl_set_queue_len(struct rtnl_neightbl *ntbl, int len)
+{
+	ntbl->nt_parms.ntp_queue_len = len;
+	ntbl->nt_parms.ntp_mask |= NEIGHTBLPARM_ATTR_QUEUE_LEN;
+	ntbl->ce_mask |= NEIGHTBL_ATTR_PARMS;
+}
+
+/**
+ * Set the queue length for delay proxy arp requests of a neighbour table to the specified value
+ * @arg ntbl		neighbour table to change
+ * @arg len		new queue len
+ */
+void rtnl_neightbl_set_proxy_queue_len(struct rtnl_neightbl *ntbl, int len)
+{
+	ntbl->nt_parms.ntp_proxy_qlen = len;
+	ntbl->nt_parms.ntp_mask |= NEIGHTBLPARM_ATTR_PROXY_QLEN;
+	ntbl->ce_mask |= NEIGHTBL_ATTR_PARMS;
+}
+
+/**
+ * Set the number of application probes of a neighbour table to the specified value
+ * @arg ntbl		neighbour table to change
+ * @arg probes		new probes value
+ */
+void rtnl_neightbl_set_app_probes(struct rtnl_neightbl *ntbl, int probes)
+{
+	ntbl->nt_parms.ntp_app_probes = probes;
+	ntbl->nt_parms.ntp_mask |= NEIGHTBLPARM_ATTR_APP_PROBES;
+	ntbl->ce_mask |= NEIGHTBL_ATTR_PARMS;
+}
+
+/**
+ * Set the number of unicast probes of a neighbour table to the specified value
+ * @arg ntbl		neighbour table to change
+ * @arg probes		new probes value
+ */
+void rtnl_neightbl_set_ucast_probes(struct rtnl_neightbl *ntbl, int probes)
+{
+	ntbl->nt_parms.ntp_ucast_probes = probes;
+	ntbl->nt_parms.ntp_mask |= NEIGHTBLPARM_ATTR_UCAST_PROBES;
+	ntbl->ce_mask |= NEIGHTBL_ATTR_PARMS;
+}
+
+/**
+ * Set the number of multicast probes of a neighbour table to the specified value
+ * @arg ntbl		neighbour table to change
+ * @arg probes		new probes value
+ */
+void rtnl_neightbl_set_mcast_probes(struct rtnl_neightbl *ntbl, int probes)
+{
+	ntbl->nt_parms.ntp_mcast_probes = probes;
+	ntbl->nt_parms.ntp_mask |= NEIGHTBLPARM_ATTR_MCAST_PROBES;
+	ntbl->ce_mask |= NEIGHTBL_ATTR_PARMS;
+}
+
+/**
+ * Set the base reachable time of a neighbour table to the specified value
+ * @arg ntbl		neighbour table to change
+ * @arg ms		new base reachable time in milliseconds
+ */
+void rtnl_neightbl_set_base_reachable_time(struct rtnl_neightbl *ntbl,
+					   uint64_t ms)
+{
+	ntbl->nt_parms.ntp_base_reachable_time = ms;
+	ntbl->nt_parms.ntp_mask |= NEIGHTBLPARM_ATTR_BASE_REACHABLE_TIME;
+	ntbl->ce_mask |= NEIGHTBL_ATTR_PARMS;
+}
+
+/**
+ * Set the retransmit time of a neighbour table to the specified value
+ * @arg ntbl		neighbour table to change
+ * @arg ms		new retransmit time
+ */
+void rtnl_neightbl_set_retrans_time(struct rtnl_neightbl *ntbl, uint64_t ms)
+{
+	ntbl->nt_parms.ntp_retrans_time = ms;
+	ntbl->nt_parms.ntp_mask |= NEIGHTBLPARM_ATTR_RETRANS_TIME;
+	ntbl->ce_mask |= NEIGHTBL_ATTR_PARMS;
+}
+
+/**
+ * Set the gc stale time of a neighbour table to the specified value
+ * @arg ntbl		neighbour table to change
+ * @arg ms		new gc stale time in milliseconds
+ */
+void rtnl_neightbl_set_gc_stale_time(struct rtnl_neightbl *ntbl, uint64_t ms)
+{
+	ntbl->nt_parms.ntp_gc_stale_time = ms;
+	ntbl->nt_parms.ntp_mask |= NEIGHTBLPARM_ATTR_GC_STALETIME;
+	ntbl->ce_mask |= NEIGHTBL_ATTR_PARMS;
+}
+
+/**
+ * Set the first probe delay time of a neighbour table to the specified value
+ * @arg ntbl		neighbour table to change
+ * @arg ms		new first probe delay time in milliseconds
+ */
+void rtnl_neightbl_set_delay_probe_time(struct rtnl_neightbl *ntbl, uint64_t ms)
+{
+	ntbl->nt_parms.ntp_probe_delay = ms;
+	ntbl->nt_parms.ntp_mask |= NEIGHTBLPARM_ATTR_DELAY_PROBE_TIME;
+	ntbl->ce_mask |= NEIGHTBL_ATTR_PARMS;
+}
+
+/**
+ * Set the anycast delay of a neighbour table to the specified value
+ * @arg ntbl		neighbour table to change
+ * @arg ms		new anycast delay in milliseconds
+ */
+void rtnl_neightbl_set_anycast_delay(struct rtnl_neightbl *ntbl, uint64_t ms)
+{
+	ntbl->nt_parms.ntp_anycast_delay = ms;
+	ntbl->nt_parms.ntp_mask |= NEIGHTBLPARM_ATTR_ANYCAST_DELAY;
+	ntbl->ce_mask |= NEIGHTBL_ATTR_PARMS;
+}
+
+/**
+ * Set the proxy delay of a neighbour table to the specified value
+ * @arg ntbl		neighbour table to change
+ * @arg ms		new proxy delay in milliseconds
+ */
+void rtnl_neightbl_set_proxy_delay(struct rtnl_neightbl *ntbl, uint64_t ms)
+{
+	ntbl->nt_parms.ntp_proxy_delay = ms;
+	ntbl->nt_parms.ntp_mask |= NEIGHTBLPARM_ATTR_PROXY_DELAY;
+	ntbl->ce_mask |= NEIGHTBL_ATTR_PARMS;
+}
+
+/**
+ * Set the locktime of a neighbour table to the specified value
+ * @arg ntbl		neighbour table to change
+ * @arg ms		new locktime in milliseconds
+ */
+void rtnl_neightbl_set_locktime(struct rtnl_neightbl *ntbl, uint64_t ms)
+{
+	ntbl->nt_parms.ntp_locktime = ms;
+	ntbl->nt_parms.ntp_mask |= NEIGHTBLPARM_ATTR_LOCKTIME;
+	ntbl->ce_mask |= NEIGHTBL_ATTR_PARMS;
+}
+
+/** @} */
+
+static struct nl_object_ops neightbl_obj_ops = {
+	.oo_name		= "route/neightbl",
+	.oo_size		= sizeof(struct rtnl_neightbl),
+	.oo_dump = {
+	    [NL_DUMP_LINE]	= neightbl_dump_line,
+	    [NL_DUMP_DETAILS]	= neightbl_dump_details,
+	    [NL_DUMP_STATS]	= neightbl_dump_stats,
+	},
+	.oo_compare		= neightbl_compare,
+};
+
+static struct nl_cache_ops rtnl_neightbl_ops = {
+	.co_name		= "route/neightbl",
+	.co_hdrsize		= sizeof(struct rtgenmsg),
+	.co_msgtypes		= {
+					{ RTM_NEWNEIGHTBL, NL_ACT_NEW, "new" },
+					{ RTM_SETNEIGHTBL, NL_ACT_SET, "set" },
+					{ RTM_GETNEIGHTBL, NL_ACT_GET, "get" },
+					END_OF_MSGTYPES_LIST,
+				  },
+	.co_protocol		= NETLINK_ROUTE,
+	.co_request_update	= neightbl_request_update,
+	.co_msg_parser		= neightbl_msg_parser,
+	.co_obj_ops		= &neightbl_obj_ops,
+};
+
+static void __init neightbl_init(void)
+{
+	nl_cache_mngt_register(&rtnl_neightbl_ops);
+}
+
+static void __exit neightbl_exit(void)
+{
+	nl_cache_mngt_unregister(&rtnl_neightbl_ops);
+}
+
+/** @} */
diff -uNr libnl_kk/lib/route/nexthop.c libnl/lib/route/nexthop.c
--- libnl_kk/lib/route/nexthop.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/nexthop.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,330 @@
+/*
+ * lib/route/nexthop.c	Routing Nexthop
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup route_obj
+ * @defgroup nexthop Nexthop
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink/netlink.h>
+#include <netlink/utils.h>
+#include <netlink/route/rtnl.h>
+#include <netlink/route/route.h>
+
+/** @cond SKIP */
+#define NH_ATTR_FLAGS   0x000001
+#define NH_ATTR_WEIGHT  0x000002
+#define NH_ATTR_IFINDEX 0x000004
+#define NH_ATTR_GATEWAY 0x000008
+#define NH_ATTR_REALMS  0x000010
+/** @endcond */
+
+/**
+ * @name Allocation/Freeing
+ * @{
+ */
+
+struct rtnl_nexthop *rtnl_route_nh_alloc(void)
+{
+	struct rtnl_nexthop *nh;
+
+	nh = calloc(1, sizeof(*nh));
+	if (!nh)
+		return NULL;
+
+	nl_init_list_head(&nh->rtnh_list);
+
+	return nh;
+}
+
+struct rtnl_nexthop *rtnl_route_nh_clone(struct rtnl_nexthop *src)
+{
+	struct rtnl_nexthop *nh;
+
+	nh = rtnl_route_nh_alloc();
+	if (!nh)
+		return NULL;
+
+	nh->rtnh_flags = src->rtnh_flags;
+	nh->rtnh_flag_mask = src->rtnh_flag_mask;
+	nh->rtnh_weight = src->rtnh_weight;
+	nh->rtnh_ifindex = src->rtnh_ifindex;
+	nh->ce_mask = src->ce_mask;
+
+	if (src->rtnh_gateway) {
+		nh->rtnh_gateway = nl_addr_clone(src->rtnh_gateway);
+		if (!nh->rtnh_gateway) {
+			free(nh);
+			return NULL;
+		}
+	}
+
+	return nh;
+}
+
+void rtnl_route_nh_free(struct rtnl_nexthop *nh)
+{
+	nl_addr_put(nh->rtnh_gateway);
+	free(nh);
+}
+
+/** @} */
+
+int rtnl_route_nh_compare(struct rtnl_nexthop *a, struct rtnl_nexthop *b,
+			  uint32_t attrs, int loose)
+{
+	int diff = 0;
+
+#define NH_DIFF(ATTR, EXPR) ATTR_DIFF(attrs, NH_ATTR_##ATTR, a, b, EXPR)
+
+	diff |= NH_DIFF(IFINDEX,	a->rtnh_ifindex != b->rtnh_ifindex);
+	diff |= NH_DIFF(WEIGHT,		a->rtnh_weight != b->rtnh_weight);
+	diff |= NH_DIFF(REALMS,		a->rtnh_realms != b->rtnh_realms);
+	diff |= NH_DIFF(GATEWAY,	nl_addr_cmp(a->rtnh_gateway,
+						    b->rtnh_gateway));
+
+	if (loose)
+		diff |= NH_DIFF(FLAGS,
+			  (a->rtnh_flags ^ b->rtnh_flags) & b->rtnh_flag_mask);
+	else
+		diff |= NH_DIFF(FLAGS, a->rtnh_flags != b->rtnh_flags);
+	
+#undef NH_DIFF
+
+	return diff;
+}
+
+static void nh_dump_line(struct rtnl_nexthop *nh, struct nl_dump_params *dp)
+{
+	struct nl_cache *link_cache;
+	char buf[128];
+
+	link_cache = nl_cache_mngt_require("route/link");
+
+	nl_dump(dp, "via");
+
+	if (nh->ce_mask & NH_ATTR_GATEWAY)
+		nl_dump(dp, " %s", nl_addr2str(nh->rtnh_gateway,
+						   buf, sizeof(buf)));
+
+	if(nh->ce_mask & NH_ATTR_IFINDEX) {
+		if (link_cache) {
+			nl_dump(dp, " dev %s",
+				rtnl_link_i2name(link_cache,
+						 nh->rtnh_ifindex,
+						 buf, sizeof(buf)));
+		} else
+			nl_dump(dp, " dev %d", nh->rtnh_ifindex);
+	}
+
+	nl_dump(dp, " ");
+}
+
+static void nh_dump_details(struct rtnl_nexthop *nh, struct nl_dump_params *dp)
+{
+	struct nl_cache *link_cache;
+	char buf[128];
+
+	link_cache = nl_cache_mngt_require("route/link");
+
+	nl_dump(dp, "nexthop");
+
+	if (nh->ce_mask & NH_ATTR_GATEWAY)
+		nl_dump(dp, " via %s", nl_addr2str(nh->rtnh_gateway,
+						   buf, sizeof(buf)));
+
+	if(nh->ce_mask & NH_ATTR_IFINDEX) {
+		if (link_cache) {
+			nl_dump(dp, " dev %s",
+				rtnl_link_i2name(link_cache,
+						 nh->rtnh_ifindex,
+						 buf, sizeof(buf)));
+		} else
+			nl_dump(dp, " dev %d", nh->rtnh_ifindex);
+	}
+
+	if (nh->ce_mask & NH_ATTR_WEIGHT)
+		nl_dump(dp, " weight %u", nh->rtnh_weight);
+
+	if (nh->ce_mask & NH_ATTR_REALMS)
+		nl_dump(dp, " realm %04x:%04x",
+			RTNL_REALM_FROM(nh->rtnh_realms),
+			RTNL_REALM_TO(nh->rtnh_realms));
+
+	if (nh->ce_mask & NH_ATTR_FLAGS)
+		nl_dump(dp, " <%s>", rtnl_route_nh_flags2str(nh->rtnh_flags,
+							buf, sizeof(buf)));
+}
+
+static void nh_dump_env(struct rtnl_nexthop *nh, struct nl_dump_params *dp)
+{
+	struct nl_cache *link_cache;
+	char buf[128];
+
+	link_cache = nl_cache_mngt_require("route/link");
+
+	if (nh->ce_mask & NH_ATTR_GATEWAY)
+		nl_dump_line(dp, "ROUTE_NH%d_VIA=%s\n", dp->dp_ivar,
+			nl_addr2str(nh->rtnh_gateway, buf, sizeof(buf)));
+
+	if(nh->ce_mask & NH_ATTR_IFINDEX) {
+		if (link_cache) {
+			nl_dump_line(dp, "ROUTE_NH%d_DEV=%s\n", dp->dp_ivar,
+					rtnl_link_i2name(link_cache,
+						 nh->rtnh_ifindex,
+						 buf, sizeof(buf)));
+		} else
+			nl_dump_line(dp, "ROUTE_NH%d_DEV=%d\n", dp->dp_ivar,
+					nh->rtnh_ifindex);
+	}
+
+	if (nh->ce_mask & NH_ATTR_WEIGHT)
+		nl_dump_line(dp, "ROUTE_NH%d_WEIGHT=%u\n", dp->dp_ivar,
+				nh->rtnh_weight);
+
+	if (nh->ce_mask & NH_ATTR_REALMS)
+		nl_dump_line(dp, "ROUTE_NH%d_REALM=%04x:%04x\n", dp->dp_ivar,
+			RTNL_REALM_FROM(nh->rtnh_realms),
+			RTNL_REALM_TO(nh->rtnh_realms));
+
+	if (nh->ce_mask & NH_ATTR_FLAGS)
+		nl_dump_line(dp, "ROUTE_NH%d_FLAGS=<%s>\n", dp->dp_ivar,
+			rtnl_route_nh_flags2str(nh->rtnh_flags,
+							buf, sizeof(buf)));
+}
+void rtnl_route_nh_dump(struct rtnl_nexthop *nh, struct nl_dump_params *dp)
+{
+	switch (dp->dp_type) {
+	case NL_DUMP_LINE:
+		nh_dump_line(nh, dp);
+		break;
+
+	case NL_DUMP_DETAILS:
+	case NL_DUMP_STATS:
+		if (dp->dp_ivar == NH_DUMP_FROM_DETAILS)
+			nh_dump_details(nh, dp);
+		break;
+
+	case NL_DUMP_ENV:
+		nh_dump_env(nh, dp);
+		break;
+	
+	default:
+		break;
+	}
+}
+
+/**
+ * @name Attributes
+ * @{
+ */
+
+void rtnl_route_nh_set_weight(struct rtnl_nexthop *nh, uint8_t weight)
+{
+	nh->rtnh_weight = weight;
+	nh->ce_mask |= NH_ATTR_WEIGHT;
+}
+
+uint8_t rtnl_route_nh_get_weight(struct rtnl_nexthop *nh)
+{
+	return nh->rtnh_weight;
+}
+
+void rtnl_route_nh_set_ifindex(struct rtnl_nexthop *nh, int ifindex)
+{
+	nh->rtnh_ifindex = ifindex;
+	nh->ce_mask |= NH_ATTR_IFINDEX;
+}
+
+int rtnl_route_nh_get_ifindex(struct rtnl_nexthop *nh)
+{
+	return nh->rtnh_ifindex;
+}	
+
+void rtnl_route_nh_set_gateway(struct rtnl_nexthop *nh, struct nl_addr *addr)
+{
+	struct nl_addr *old = nh->rtnh_gateway;
+
+	if (addr) {
+		nh->rtnh_gateway = nl_addr_get(addr);
+		nh->ce_mask |= NH_ATTR_GATEWAY;
+	} else {
+		nh->ce_mask &= ~NH_ATTR_GATEWAY;
+		nh->rtnh_gateway = NULL;
+	}
+
+	if (old)
+		nl_addr_put(old);
+}
+
+struct nl_addr *rtnl_route_nh_get_gateway(struct rtnl_nexthop *nh)
+{
+	return nh->rtnh_gateway;
+}
+
+void rtnl_route_nh_set_flags(struct rtnl_nexthop *nh, unsigned int flags)
+{
+	nh->rtnh_flag_mask |= flags;
+	nh->rtnh_flags |= flags;
+	nh->ce_mask |= NH_ATTR_FLAGS;
+}
+
+void rtnl_route_nh_unset_flags(struct rtnl_nexthop *nh, unsigned int flags)
+{
+	nh->rtnh_flag_mask |= flags;
+	nh->rtnh_flags &= ~flags;
+	nh->ce_mask |= NH_ATTR_FLAGS;
+}
+
+unsigned int rtnl_route_nh_get_flags(struct rtnl_nexthop *nh)
+{
+	return nh->rtnh_flags;
+}
+
+void rtnl_route_nh_set_realms(struct rtnl_nexthop *nh, uint32_t realms)
+{
+	nh->rtnh_realms = realms;
+	nh->ce_mask |= NH_ATTR_REALMS;
+}
+
+uint32_t rtnl_route_nh_get_realms(struct rtnl_nexthop *nh)
+{
+	return nh->rtnh_realms;
+}
+
+/** @} */
+
+/**
+ * @name Nexthop Flags Translations
+ * @{
+ */
+
+static struct trans_tbl nh_flags[] = {
+	__ADD(RTNH_F_DEAD, dead)
+	__ADD(RTNH_F_PERVASIVE, pervasive)
+	__ADD(RTNH_F_ONLINK, onlink)
+};
+
+char *rtnl_route_nh_flags2str(int flags, char *buf, size_t len)
+{
+	return __flags2str(flags, buf, len, nh_flags, ARRAY_SIZE(nh_flags));
+}
+
+int rtnl_route_nh_str2flags(const char *name)
+{
+	return __str2flags(name, nh_flags, ARRAY_SIZE(nh_flags));
+}
+
+/** @} */
+
+/** @} */
diff -uNr libnl_kk/lib/route/pktloc.c libnl/lib/route/pktloc.c
--- libnl_kk/lib/route/pktloc.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/pktloc.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,168 @@
+/*
+ * lib/route/pktloc.c     Packet Location Aliasing
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation version 2 of the License.
+ *
+ * Copyright (c) 2008-2010 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup tc
+ * @defgroup pktloc Packet Location Aliasing
+ * Packet Location Aliasing
+ *
+ * The packet location aliasing interface eases the use of offset definitions
+ * inside packets by allowing them to be referenced by name. Known positions
+ * of protocol fields are stored in a configuration file and associated with
+ * a name for later reference. The configuration file is distributed with the
+ * library and provides a well defined set of definitions for most common
+ * protocol fields.
+ *
+ * @subsection pktloc_examples Examples
+ * @par Example 1.1 Looking up a packet location
+ * @code
+ * struct rtnl_pktloc *loc;
+ *
+ * rtnl_pktloc_lookup("ip.src", &loc);
+ * @endcode
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink-tc.h>
+#include <netlink/netlink.h>
+#include <netlink/utils.h>
+#include <netlink/route/pktloc.h>
+
+#include "pktloc_syntax.h"
+#include "pktloc_grammar.h"
+
+/** @cond */
+#define PKTLOC_NAME_HT_SIZ 256
+
+static struct nl_list_head pktloc_name_ht[PKTLOC_NAME_HT_SIZ];
+
+/* djb2 */
+unsigned int pktloc_hash(const char *str)
+{
+	unsigned long hash = 5381;
+	int c;
+
+	while ((c = *str++))
+		hash = ((hash << 5) + hash) + c; /* hash * 33 + c */
+
+	return hash % PKTLOC_NAME_HT_SIZ;
+}
+
+
+void rtnl_pktloc_add(struct rtnl_pktloc *loc)
+{
+	nl_list_add_tail(&loc->list, &pktloc_name_ht[pktloc_hash(loc->name)]);
+}
+
+extern int pktloc_parse(void *scanner);
+
+/** @endcond */
+
+static void rtnl_pktloc_free(struct rtnl_pktloc *loc)
+{
+	if (!loc)
+		return;
+
+	free(loc->name);
+	free(loc);
+}
+
+static int read_pktlocs(void)
+{
+	YY_BUFFER_STATE buf;
+	yyscan_t scanner = NULL;
+	static time_t last_read;
+	struct stat st = {0};
+	char *path;
+	int i, err;
+	FILE *fd;
+
+	asprintf(&path, "%s/pktloc", SYSCONFDIR);
+
+	/* if stat fails, just try to read the file */
+	if (stat(path, &st) == 0) {
+		/* Don't re-read file if file is unchanged */
+		if (last_read == st.st_mtime)
+			return 0;
+	}
+
+	if (!(fd = fopen(path, "r")))
+		return -NLE_PKTLOC_FILE;
+
+	for (i = 0; i < PKTLOC_NAME_HT_SIZ; i++) {
+		struct rtnl_pktloc *loc, *n;
+
+		nl_list_for_each_entry_safe(loc, n, &pktloc_name_ht[i], list)
+			rtnl_pktloc_free(loc);
+
+		nl_init_list_head(&pktloc_name_ht[i]);
+	}
+
+	if ((err = pktloc_lex_init(&scanner)) < 0)
+		return -NLE_FAILURE;
+
+	buf = pktloc__create_buffer(fd, YY_BUF_SIZE, scanner);
+	pktloc__switch_to_buffer(buf, scanner);
+
+	if ((err = pktloc_parse(scanner)) < 0)
+		return -NLE_FAILURE;
+
+	if (scanner)
+		pktloc_lex_destroy(scanner);
+
+	free(path);
+	last_read = st.st_mtime;
+
+	return 0;
+}
+
+/**
+ * Lookup packet location alias
+ * @arg name		Name of packet location.
+ *
+ * Tries to find a matching packet location alias for the supplied
+ * packet location name.
+ *
+ * The file containing the packet location definitions is automatically
+ * re-read if its modification time has changed since the last call.
+ *
+ * @return 0 on success or a negative error code.
+ * @retval NLE_PKTLOC_FILE Unable to open packet location file.
+ * @retval NLE_OBJ_NOTFOUND No matching packet location alias found.
+ */
+int rtnl_pktloc_lookup(const char *name, struct rtnl_pktloc **result)
+{
+	struct rtnl_pktloc *loc;
+	int hash, err;
+
+	if ((err = read_pktlocs()) < 0)
+		return err;
+
+	hash = pktloc_hash(name);
+	nl_list_for_each_entry(loc, &pktloc_name_ht[hash], list) {
+		if (!strcasecmp(loc->name, name)) {
+			*result = loc;
+			return 0;
+		}
+	}
+
+	return -NLE_OBJ_NOTFOUND;
+}
+
+static int __init pktloc_init(void)
+{
+	int i;
+
+	for (i = 0; i < PKTLOC_NAME_HT_SIZ; i++)
+		nl_init_list_head(&pktloc_name_ht[i]);
+	
+	return 0;
+}
diff -uNr libnl_kk/lib/route/pktloc_grammar.l libnl/lib/route/pktloc_grammar.l
--- libnl_kk/lib/route/pktloc_grammar.l	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/pktloc_grammar.l	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,42 @@
+%{
+ #include <netlink-local.h>
+ #include <netlink-tc.h>
+ #include <netlink/netlink.h>
+ #include <netlink/utils.h>
+ #include <netlink/route/pktloc.h>
+ #include "pktloc_syntax.h"
+%}
+
+%option 8bit
+%option reentrant
+%option warn
+%option noyywrap
+%option nounput
+%option bison-bridge
+%option bison-locations
+%option prefix="pktloc_"
+
+%%
+
+[ \t\r\n]+
+
+"#".*
+
+[[:digit:]]+		|
+0[xX][[:xdigit:]]+	{
+				yylval->i = strtoul(yytext, NULL, 0);
+				return NUMBER;
+			}
+
+"+"			{ return yylval->i = yytext[0]; }
+
+[lL][iI][nN][kK]	{ yylval->i = TCF_LAYER_LINK; return LAYER; }
+[nN][eE][tT]		{ yylval->i = TCF_LAYER_NETWORK; return LAYER; }
+[tT][cC][pP]		{ yylval->i = TCF_LAYER_TRANSPORT; return LAYER; }
+
+[^ \t\r\n+]+		{
+				yylval->s = strdup(yytext);
+				if (yylval->s == NULL)
+					return ERROR;
+				return NAME;
+			}
diff -uNr libnl_kk/lib/route/pktloc_syntax.y libnl/lib/route/pktloc_syntax.y
--- libnl_kk/lib/route/pktloc_syntax.y	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/pktloc_syntax.y	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,108 @@
+%{
+#include <netlink-local.h>
+#include <netlink-tc.h>
+#include <netlink/netlink.h>
+#include <netlink/utils.h>
+#include <netlink/route/pktloc.h>
+%}
+
+%locations
+%error-verbose
+%define api.pure
+%name-prefix "pktloc_"
+
+%parse-param {void *scanner}
+%lex-param {void *scanner}
+
+%union {
+	struct rtnl_pktloc *l;
+	uint32_t i;
+	char *s;
+}
+
+%{
+extern int pktloc_lex(YYSTYPE *, YYLTYPE *, void *);
+extern void rtnl_pktloc_add(struct rtnl_pktloc *);
+
+static void yyerror(YYLTYPE *locp, void *scanner, const char *msg)
+{
+	/* FIXME */
+}
+%}
+
+%token <i> ERROR NUMBER LAYER
+%token <s> NAME
+
+%type <i> mask layer
+%type <l> location
+
+%destructor { free($$); } NAME
+
+%start input
+
+%%
+
+input:
+	def
+		{ }
+	;
+
+def:
+	/* empty */
+		{ }
+	| location def
+		{ }
+	;
+
+location:
+	NAME NAME layer NUMBER mask
+		{
+			struct rtnl_pktloc *loc;
+
+			if (!(loc = calloc(1, sizeof(*loc)))) {
+				/* FIXME */
+			}
+
+			if (!strcasecmp($2, "u8"))
+				loc->align = TCF_EM_ALIGN_U8;
+			else if (!strcasecmp($2, "h8")) {
+				loc->align = TCF_EM_ALIGN_U8;
+				loc->flags = TCF_EM_CMP_TRANS;
+			} else if (!strcasecmp($2, "u16"))
+				loc->align = TCF_EM_ALIGN_U16;
+			else if (!strcasecmp($2, "h16")) {
+				loc->align = TCF_EM_ALIGN_U16;
+				loc->flags = TCF_EM_CMP_TRANS;
+			} else if (!strcasecmp($2, "u32"))
+				loc->align = TCF_EM_ALIGN_U32;
+			else if (!strcasecmp($2, "h32")) {
+				loc->align = TCF_EM_ALIGN_U32;
+				loc->flags = TCF_EM_CMP_TRANS;
+			}
+			
+			free($2);
+
+			loc->name = $1;
+			loc->layer = $3;
+			loc->offset = $4;
+			loc->mask = $5;
+
+			rtnl_pktloc_add(loc);
+
+			$$ = loc;
+		}
+	;
+
+layer:
+	/* empty */
+		{ $$ = TCF_LAYER_NETWORK; }
+	| LAYER '+' 
+		{ $$ = $1; }
+	;
+
+mask:
+	/* empty */
+		{ $$ = 0; }
+	| NUMBER
+		{ $$ = $1; }
+	;
diff -uNr libnl_kk/lib/route/qdisc_api.c libnl/lib/route/qdisc_api.c
--- libnl_kk/lib/route/qdisc_api.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/qdisc_api.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,98 @@
+/*
+ * lib/route/qdisc_api.c            Queueing Discipline Module API
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2006 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup qdisc
+ * @defgroup qdisc_api Queueing Discipline Modules
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink-tc.h>
+#include <netlink/netlink.h>
+#include <netlink/utils.h>
+#include <netlink/route/link.h>
+#include <netlink/route/tc.h>
+#include <netlink/route/qdisc.h>
+#include <netlink/route/class.h>
+#include <netlink/route/classifier.h>
+#include <netlink/route/qdisc-modules.h>
+
+static struct rtnl_qdisc_ops *qdisc_ops_list;
+
+/**
+ * @name Module API
+ * @{
+ */
+
+/**
+ * Register a qdisc module
+ * @arg qops		qdisc module operations
+ */
+int rtnl_qdisc_register(struct rtnl_qdisc_ops *qops)
+{
+	struct rtnl_qdisc_ops *o, **op;
+
+	if (!qops->qo_kind[0])
+		BUG();
+
+	for (op = &qdisc_ops_list; (o = *op) != NULL; op = &o->qo_next)
+		if (!strcasecmp(qops->qo_kind, o->qo_kind))
+			return -NLE_EXIST;
+
+	qops->qo_next = NULL;
+	*op = qops;
+
+	return 0;
+}
+
+/**
+ * Unregister a qdisc module
+ * @arg qops		qdisc module operations
+ */
+int rtnl_qdisc_unregister(struct rtnl_qdisc_ops *qops)
+{
+	struct rtnl_qdisc_ops *o, **op;
+
+	for (op = &qdisc_ops_list; (o = *op) != NULL; op = &o->qo_next)
+		if (!strcasecmp(qops->qo_kind, o->qo_kind))
+			break;
+
+	if (!o)
+		return -NLE_OBJ_NOTFOUND;
+
+	*op = qops->qo_next;
+
+	return 0;
+}
+
+struct rtnl_qdisc_ops *__rtnl_qdisc_lookup_ops(const char *kind)
+{
+	struct rtnl_qdisc_ops *qops;
+
+	for (qops = qdisc_ops_list; qops; qops = qops->qo_next)
+		if (!strcmp(kind, qops->qo_kind))
+			return qops;
+
+	return NULL;
+}
+
+struct rtnl_qdisc_ops *rtnl_qdisc_lookup_ops(struct rtnl_qdisc *qdisc)
+{
+	if (!qdisc->q_ops)
+		qdisc->q_ops = __rtnl_qdisc_lookup_ops(qdisc->q_kind);
+
+	return qdisc->q_ops;
+}
+
+/** @} */
+
+/** @} */
diff -uNr libnl_kk/lib/route/qdisc.c libnl/lib/route/qdisc.c
--- libnl_kk/lib/route/qdisc.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/qdisc.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,468 @@
+/*
+ * lib/route/qdisc.c            Queueing Disciplines
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup tc
+ * @defgroup qdisc Queueing Disciplines
+ *
+ * @par Qdisc Handles
+ * In general, qdiscs are identified by the major part of a traffic control
+ * handle (the upper 16 bits). A few special values exist though:
+ *  - \c TC_H_ROOT: root qdisc (directly attached to the device)
+ *  - \c TC_H_INGRESS: ingress qdisc (directly attached to the device)
+ *  - \c TC_H_UNSPEC: unspecified qdisc (no reference)
+ *
+ * @par 1) Adding a Qdisc
+ * @code
+ * // Allocate a new empty qdisc to be filled out
+ * struct rtnl_qdisc *qdisc = rtnl_qdisc_alloc();
+ *
+ * // ... specify the kind of the Qdisc
+ * rtnl_qdisc_set_kind(qdisc, "pfifo");
+ *
+ * // Specify the device the qdisc should be attached to
+ * rtnl_qdisc_set_ifindex(qdisc, ifindex);
+ *
+ * // ... specify the parent qdisc
+ * rtnl_qdisc_set_parent(qdisc, TC_H_ROOT);
+ *
+ * // Specifying the handle is not required but makes reidentifying easier
+ * // and may help to avoid adding a qdisc twice.
+ * rtnl_qdisc_set_handle(qdisc, 0x000A0000);
+ *
+ * // Now on to specify the qdisc specific options, see the relevant qdisc
+ * // modules for documentation, in this example we set the upper limit of
+ * // the packet fifo qdisc to 64
+ * rtnl_qdisc_fifo_set_limit(qdisc, 64);
+ *
+ * rtnl_qdisc_add(handle, qdisc, NLM_R_REPLACE);
+ *
+ * // Free up the memory
+ * rtnl_qdisc_put(qdisc);
+ * @endcode
+ *
+ * @par 2) Deleting a Qdisc
+ * @code
+ * // Allocate a new empty qdisc to be filled out with the parameters
+ * // specifying the qdisc to be deleted. Alternatively a fully equiped
+ * // Qdisc object from a cache can be used.
+ * struct rtnl_qdisc *qdisc = rtnl_qdisc_alloc();
+ *
+ * // The interface index of the device the qdisc is on and the parent handle
+ * // are the least required fields to be filled out.
+ * // Note: Specify TC_H_ROOT or TC_H_INGRESS as parent handle to delete the
+ * //       root respectively root ingress qdisc.
+ * rtnl_qdisc_set_ifindex(qdisc, ifindex);
+ * rtnl_qdisc_set_parent(qdisc, parent_handle);
+ *
+ * // If required for identification, the handle can be specified as well.
+ * rtnl_qdisc_set_handle(qdisc, qdisc_handle);
+ *
+ * // Not required but maybe helpful as sanity check, the kind of the qdisc
+ * // can be specified to avoid mistakes.
+ * rtnl_qdisc_set_kind(qdisc, "pfifo");
+ *
+ * // Finally delete the qdisc with rtnl_qdisc_delete(), alternatively
+ * // rtnl_qdisc_build_delete_request() can be invoked to generate an
+ * // appropritate netlink message to send out.
+ * rtnl_qdisc_delete(handle, qdisc);
+ *
+ * // Free up the memory
+ * rtnl_qdisc_put(qdisc);
+ * @endcode
+ *
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink-tc.h>
+#include <netlink/netlink.h>
+#include <netlink/utils.h>
+#include <netlink/route/link.h>
+#include <netlink/route/tc.h>
+#include <netlink/route/qdisc.h>
+#include <netlink/route/class.h>
+#include <netlink/route/classifier.h>
+#include <netlink/route/qdisc-modules.h>
+
+static struct nl_cache_ops rtnl_qdisc_ops;
+
+static int qdisc_msg_parser(struct nl_cache_ops *ops, struct sockaddr_nl *who,
+			    struct nlmsghdr *n, struct nl_parser_param *pp)
+{
+	int err;
+	struct rtnl_qdisc *qdisc;
+	struct rtnl_qdisc_ops *qops;
+
+	qdisc = rtnl_qdisc_alloc();
+	if (!qdisc) {
+		err = -NLE_NOMEM;
+		goto errout;
+	}
+
+	qdisc->ce_msgtype = n->nlmsg_type;
+
+	err = tca_msg_parser(n, (struct rtnl_tca *) qdisc);
+	if (err < 0)
+		goto errout_free;
+
+	qops = rtnl_qdisc_lookup_ops(qdisc);
+	if (qops && qops->qo_msg_parser) {
+		err = qops->qo_msg_parser(qdisc);
+		if (err < 0)
+			goto errout_free;
+	}
+
+	err = pp->pp_cb((struct nl_object *) qdisc, pp);
+errout_free:
+	rtnl_qdisc_put(qdisc);
+errout:
+	return err;
+}
+
+static int qdisc_request_update(struct nl_cache *c, struct nl_sock *sk)
+{
+	struct tcmsg tchdr = {
+		.tcm_family = AF_UNSPEC,
+		.tcm_ifindex = c->c_iarg1,
+	};
+
+	return nl_send_simple(sk, RTM_GETQDISC, NLM_F_DUMP, &tchdr,
+			      sizeof(tchdr));
+}
+
+/**
+ * @name QDisc Addition
+ * @{
+ */
+
+static int qdisc_build(struct rtnl_qdisc *qdisc, int type, int flags,
+		       struct nl_msg **result)
+{
+	struct rtnl_qdisc_ops *qops;
+	int err;
+
+	err = tca_build_msg((struct rtnl_tca *) qdisc, type, flags, result);
+	if (err < 0)
+		return err;
+
+	qops = rtnl_qdisc_lookup_ops(qdisc);
+	if (qops && qops->qo_get_opts) {
+		struct nl_msg *opts;
+		
+		opts = qops->qo_get_opts(qdisc);
+		if (opts) {
+			err = nla_put_nested(*result, TCA_OPTIONS, opts);
+			nlmsg_free(opts);
+			if (err < 0)
+				goto errout;
+		}
+	}
+	/* Some qdiscs don't accept properly nested messages (e.g. netem). To
+	 * accomodate for this, they can complete the message themselves.
+	 */		
+	else if (qops && qops->qo_build_msg) {
+		err = qops->qo_build_msg(qdisc, *result);
+		if (err < 0)
+			goto errout;
+	}
+
+	return 0;
+errout:
+	nlmsg_free(*result);
+
+	return err;
+}
+
+/**
+ * Build a netlink message to add a new qdisc
+ * @arg qdisc		qdisc to add 
+ * @arg flags		additional netlink message flags
+ * @arg result		Pointer to store resulting message.
+ *
+ * Builds a new netlink message requesting an addition of a qdisc.
+ * The netlink message header isn't fully equipped with all relevant
+ * fields and must be sent out via nl_send_auto_complete() or
+ * supplemented as needed. 
+ *
+ * Common message flags used:
+ *  - NLM_F_REPLACE - replace a potential existing qdisc
+ *
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_qdisc_build_add_request(struct rtnl_qdisc *qdisc, int flags,
+				 struct nl_msg **result)
+{
+	return qdisc_build(qdisc, RTM_NEWQDISC, NLM_F_CREATE | flags, result);
+}
+
+/**
+ * Add a new qdisc
+ * @arg sk		Netlink socket.
+ * @arg qdisc		qdisc to delete
+ * @arg flags		additional netlink message flags
+ *
+ * Builds a netlink message by calling rtnl_qdisc_build_add_request(),
+ * sends the request to the kernel and waits for the ACK to be
+ * received and thus blocks until the request has been processed.
+ *
+ * Common message flags used:
+ *  - NLM_F_REPLACE - replace a potential existing qdisc
+ *
+ * @return 0 on success or a negative error code
+ */
+int rtnl_qdisc_add(struct nl_sock *sk, struct rtnl_qdisc *qdisc,
+		   int flags)
+{
+	struct nl_msg *msg;
+	int err;
+
+	if ((err = rtnl_qdisc_build_add_request(qdisc, flags, &msg)) < 0)
+		return err;
+
+	err = nl_send_auto_complete(sk, msg);
+	nlmsg_free(msg);
+	if (err < 0)
+		return err;
+
+	return wait_for_ack(sk);
+}
+
+/** @} */
+
+/**
+ * @name QDisc Modification
+ * @{
+ */
+
+/**
+ * Build a netlink message to change attributes of a existing qdisc
+ * @arg qdisc		qdisc to change
+ * @arg new		new qdisc attributes
+ * @arg result		Pointer to store resulting message.
+ *
+ * Builds a new netlink message requesting an change of qdisc
+ * attributes. The netlink message header isn't fully equipped
+ * with all relevant fields and must be sent out via
+ * nl_send_auto_complete() or supplemented as needed. 
+ *
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_qdisc_build_change_request(struct rtnl_qdisc *qdisc,
+				    struct rtnl_qdisc *new,
+				    struct nl_msg **result)
+{
+	return qdisc_build(qdisc, RTM_NEWQDISC, NLM_F_REPLACE, result);
+}
+
+/**
+ * Change attributes of a qdisc
+ * @arg sk		Netlink socket.
+ * @arg qdisc		qdisc to change
+ * @arg new		new qdisc attributes
+ *
+ * Builds a netlink message by calling rtnl_qdisc_build_change_request(),
+ * sends the request to the kernel and waits for the ACK to be
+ * received and thus blocks until the request has been processed.
+ *
+ * @return 0 on success or a negative error code
+ */
+int rtnl_qdisc_change(struct nl_sock *sk, struct rtnl_qdisc *qdisc,
+		      struct rtnl_qdisc *new)
+{
+	struct nl_msg *msg;
+	int err;
+
+	if ((err = rtnl_qdisc_build_change_request(qdisc, new, &msg)) < 0)
+		return err;
+
+	err = nl_send_auto_complete(sk, msg);
+	nlmsg_free(msg);
+	if (err < 0)
+		return err;
+
+	return wait_for_ack(sk);
+}
+
+/** @} */
+
+/**
+ * @name QDisc Deletion
+ * @{
+ */
+
+/**
+ * Build a netlink request message to delete a qdisc
+ * @arg qdisc		qdisc to delete
+ * @arg result		Pointer to store resulting message.
+ *
+ * Builds a new netlink message requesting a deletion of a qdisc.
+ * The netlink message header isn't fully equipped with all relevant
+ * fields and must thus be sent out via nl_send_auto_complete()
+ * or supplemented as needed.
+ *
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_qdisc_build_delete_request(struct rtnl_qdisc *qdisc,
+				    struct nl_msg **result)
+{
+	struct nl_msg *msg;
+	struct tcmsg tchdr;
+	int required = TCA_ATTR_IFINDEX | TCA_ATTR_PARENT;
+
+	if ((qdisc->ce_mask & required) != required)
+		BUG();
+
+	msg = nlmsg_alloc_simple(RTM_DELQDISC, 0);
+	if (!msg)
+		return -NLE_NOMEM;
+
+	tchdr.tcm_family = AF_UNSPEC;
+	tchdr.tcm_handle = qdisc->q_handle;
+	tchdr.tcm_parent = qdisc->q_parent;
+	tchdr.tcm_ifindex = qdisc->q_ifindex;
+	if (nlmsg_append(msg, &tchdr, sizeof(tchdr), NLMSG_ALIGNTO) < 0) {
+		nlmsg_free(msg);
+		return -NLE_MSGSIZE;
+	}
+
+	*result = msg;
+	return 0;
+}
+
+/**
+ * Delete a qdisc
+ * @arg sk		Netlink socket.
+ * @arg qdisc		qdisc to delete
+ *
+ * Builds a netlink message by calling rtnl_qdisc_build_delete_request(),
+ * sends the request to the kernel and waits for the ACK to be
+ * received and thus blocks until the request has been processed.
+ *
+ * @return 0 on success or a negative error code
+ */
+int rtnl_qdisc_delete(struct nl_sock *sk, struct rtnl_qdisc *qdisc)
+{
+	struct nl_msg *msg;
+	int err;
+
+	if ((err = rtnl_qdisc_build_delete_request(qdisc, &msg)) < 0)
+		return err;
+
+	err = nl_send_auto_complete(sk, msg);
+	nlmsg_free(msg);
+	if (err < 0)
+		return err;
+
+	return wait_for_ack(sk);
+}
+
+/** @} */
+
+/**
+ * @name Qdisc Cache Management
+ * @{
+ */
+
+/**
+ * Build a qdisc cache including all qdiscs currently configured in
+ * the kernel
+ * @arg sk		Netlink socket.
+ * @arg result		Pointer to store resulting message.
+ *
+ * Allocates a new cache, initializes it properly and updates it to
+ * include all qdiscs currently configured in the kernel.
+ *
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_qdisc_alloc_cache(struct nl_sock *sk, struct nl_cache **result)
+{
+	return nl_cache_alloc_and_fill(&rtnl_qdisc_ops, sk, result);
+}
+
+/**
+ * Look up qdisc by its parent in the provided cache
+ * @arg cache		qdisc cache
+ * @arg ifindex		interface the qdisc is attached to
+ * @arg parent		parent handle
+ * @return pointer to qdisc inside the cache or NULL if no match was found.
+ */
+struct rtnl_qdisc * rtnl_qdisc_get_by_parent(struct nl_cache *cache,
+					     int ifindex, uint32_t parent)
+{
+	struct rtnl_qdisc *q;
+
+	if (cache->c_ops != &rtnl_qdisc_ops)
+		return NULL;
+
+	nl_list_for_each_entry(q, &cache->c_items, ce_list) {
+		if (q->q_parent == parent && q->q_ifindex == ifindex) {
+			nl_object_get((struct nl_object *) q);
+			return q;
+		}
+	}
+
+	return NULL;
+}
+
+/**
+ * Look up qdisc by its handle in the provided cache
+ * @arg cache		qdisc cache
+ * @arg ifindex		interface the qdisc is attached to
+ * @arg handle		qdisc handle
+ * @return pointer to qdisc inside the cache or NULL if no match was found.
+ */
+struct rtnl_qdisc * rtnl_qdisc_get(struct nl_cache *cache,
+				   int ifindex, uint32_t handle)
+{
+	struct rtnl_qdisc *q;
+
+	if (cache->c_ops != &rtnl_qdisc_ops)
+		return NULL;
+
+	nl_list_for_each_entry(q, &cache->c_items, ce_list) {
+		if (q->q_handle == handle && q->q_ifindex == ifindex) {
+			nl_object_get((struct nl_object *) q);
+			return q;
+		}
+	}
+
+	return NULL;
+}
+
+/** @} */
+
+static struct nl_cache_ops rtnl_qdisc_ops = {
+	.co_name		= "route/qdisc",
+	.co_hdrsize		= sizeof(struct tcmsg),
+	.co_msgtypes		= {
+					{ RTM_NEWQDISC, NL_ACT_NEW, "new" },
+					{ RTM_DELQDISC, NL_ACT_DEL, "del" },
+					{ RTM_GETQDISC, NL_ACT_GET, "get" },
+					END_OF_MSGTYPES_LIST,
+				  },
+	.co_protocol		= NETLINK_ROUTE,
+	.co_request_update	= qdisc_request_update,
+	.co_msg_parser		= qdisc_msg_parser,
+	.co_obj_ops		= &qdisc_obj_ops,
+};
+
+static void __init qdisc_init(void)
+{
+	nl_cache_mngt_register(&rtnl_qdisc_ops);
+}
+
+static void __exit qdisc_exit(void)
+{
+	nl_cache_mngt_unregister(&rtnl_qdisc_ops);
+}
+
+/** @} */
diff -uNr libnl_kk/lib/route/qdisc_obj.c libnl/lib/route/qdisc_obj.c
--- libnl_kk/lib/route/qdisc_obj.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/qdisc_obj.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,270 @@
+/*
+ * lib/route/qdisc_obj.c            Queueing Discipline Object
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2006 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup qdisc
+ * @defgroup qdisc_obj Queueing Discipline Object
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink-tc.h>
+#include <netlink/netlink.h>
+#include <netlink/utils.h>
+#include <netlink/route/link.h>
+#include <netlink/route/tc.h>
+#include <netlink/route/qdisc.h>
+#include <netlink/route/class.h>
+#include <netlink/route/classifier.h>
+#include <netlink/route/qdisc-modules.h>
+
+static void qdisc_free_data(struct nl_object *obj)
+{
+	struct rtnl_qdisc *qdisc = (struct rtnl_qdisc *) obj;
+	struct rtnl_qdisc_ops *qops;
+
+	tca_free_data((struct rtnl_tca *) qdisc);
+
+	qops = rtnl_qdisc_lookup_ops(qdisc);
+	if (qops && qops->qo_free_data)
+		qops->qo_free_data(qdisc);
+}
+
+static int qdisc_clone(struct nl_object *_dst, struct nl_object *_src)
+{
+	struct rtnl_qdisc *dst = (struct rtnl_qdisc *) _dst;
+	struct rtnl_qdisc *src = (struct rtnl_qdisc *) _src;
+	struct rtnl_qdisc_ops *qops;
+	int err;
+
+	err = tca_clone((struct rtnl_tca *) dst, (struct rtnl_tca *) src);
+	if (err < 0)
+		goto errout;
+
+	qops = rtnl_qdisc_lookup_ops(src);
+	if (qops && qops->qo_clone)
+		err = qops->qo_clone(dst, src);
+errout:
+	return err;
+}
+
+static void qdisc_dump_line(struct nl_object *obj, struct nl_dump_params *p)
+{
+	struct rtnl_qdisc *qdisc = (struct rtnl_qdisc *) obj;
+	struct rtnl_qdisc_ops *qops;
+	
+	tca_dump_line((struct rtnl_tca *) qdisc, "qdisc", p);
+
+	qops = rtnl_qdisc_lookup_ops(qdisc);
+	if (qops && qops->qo_dump[NL_DUMP_LINE])
+		qops->qo_dump[NL_DUMP_LINE](qdisc, p);
+
+	nl_dump(p, "\n");
+}
+
+static void qdisc_dump_details(struct nl_object *arg, struct nl_dump_params *p)
+{
+	struct rtnl_qdisc *qdisc = (struct rtnl_qdisc *) arg;
+	struct rtnl_qdisc_ops *qops;
+
+	qdisc_dump_line(arg, p);
+
+	tca_dump_details((struct rtnl_tca *) qdisc, p);
+	nl_dump(p, "refcnt %u ", qdisc->q_info);
+
+	qops = rtnl_qdisc_lookup_ops(qdisc);
+	if (qops && qops->qo_dump[NL_DUMP_DETAILS])
+		qops->qo_dump[NL_DUMP_DETAILS](qdisc, p);
+
+	nl_dump(p, "\n");
+}
+
+static void qdisc_dump_stats(struct nl_object *arg, struct nl_dump_params *p)
+{
+	struct rtnl_qdisc *qdisc = (struct rtnl_qdisc *) arg;
+	struct rtnl_qdisc_ops *qops;
+
+	qdisc_dump_details(arg, p);
+	tca_dump_stats((struct rtnl_tca *) qdisc, p);
+	nl_dump(p, "\n");
+
+	qops = rtnl_qdisc_lookup_ops(qdisc);
+	if (qops && qops->qo_dump[NL_DUMP_STATS])
+		qops->qo_dump[NL_DUMP_STATS](qdisc, p);
+}
+
+/**
+ * @name Allocation/Freeing
+ * @{
+ */
+
+struct rtnl_qdisc *rtnl_qdisc_alloc(void)
+{
+	return (struct rtnl_qdisc *) nl_object_alloc(&qdisc_obj_ops);
+}
+
+void rtnl_qdisc_put(struct rtnl_qdisc *qdisc)
+{
+	nl_object_put((struct nl_object *) qdisc);
+}
+
+/** @} */
+
+/**
+ * @name Iterators
+ * @{
+ */
+
+/**
+ * Call a callback for each child class of a qdisc
+ * @arg qdisc		the parent qdisc
+ * @arg cache		a class cache including all classes of the interface
+ *                      the specified qdisc is attached to
+ * @arg cb              callback function
+ * @arg arg             argument to be passed to callback function
+ */
+void rtnl_qdisc_foreach_child(struct rtnl_qdisc *qdisc, struct nl_cache *cache,
+			      void (*cb)(struct nl_object *, void *), void *arg)
+{
+	struct rtnl_class *filter;
+	
+	filter = rtnl_class_alloc();
+	if (!filter)
+		return;
+
+	rtnl_class_set_parent(filter, qdisc->q_handle);
+	rtnl_class_set_ifindex(filter, qdisc->q_ifindex);
+	rtnl_class_set_kind(filter, qdisc->q_kind);
+
+	nl_cache_foreach_filter(cache, (struct nl_object *) filter, cb, arg);
+
+	rtnl_class_put(filter);
+}
+
+/**
+ * Call a callback for each filter attached to the qdisc
+ * @arg qdisc		the parent qdisc
+ * @arg cache		a filter cache including at least all the filters
+ *                      attached to the specified qdisc
+ * @arg cb              callback function
+ * @arg arg             argument to be passed to callback function
+ */
+void rtnl_qdisc_foreach_cls(struct rtnl_qdisc *qdisc, struct nl_cache *cache,
+			    void (*cb)(struct nl_object *, void *), void *arg)
+{
+	struct rtnl_cls *filter;
+
+	filter = rtnl_cls_alloc();
+	if (!filter)
+		return;
+
+	rtnl_cls_set_ifindex(filter, qdisc->q_ifindex);
+	rtnl_cls_set_parent(filter, qdisc->q_parent);
+
+	nl_cache_foreach_filter(cache, (struct nl_object *) filter, cb, arg);
+	rtnl_cls_put(filter);
+}
+
+/** @} */
+
+/**
+ * @name Attributes
+ * @{
+ */
+
+void rtnl_qdisc_set_ifindex(struct rtnl_qdisc *qdisc, int ifindex)
+{
+	tca_set_ifindex((struct rtnl_tca *) qdisc, ifindex);
+}
+
+int rtnl_qdisc_get_ifindex(struct rtnl_qdisc *qdisc)
+{
+	return tca_get_ifindex((struct rtnl_tca *) qdisc);
+}
+
+void rtnl_qdisc_set_handle(struct rtnl_qdisc *qdisc, uint32_t handle)
+{
+	tca_set_handle((struct rtnl_tca *) qdisc, handle);
+}
+
+uint32_t rtnl_qdisc_get_handle(struct rtnl_qdisc *qdisc)
+{
+	return tca_get_handle((struct rtnl_tca *) qdisc);
+}
+
+void rtnl_qdisc_set_parent(struct rtnl_qdisc *qdisc, uint32_t parent)
+{
+	tca_set_parent((struct rtnl_tca *) qdisc, parent);
+}
+
+uint32_t rtnl_qdisc_get_parent(struct rtnl_qdisc *qdisc)
+{
+	return tca_get_parent((struct rtnl_tca *) qdisc);
+}
+
+void rtnl_qdisc_set_kind(struct rtnl_qdisc *qdisc, const char *name)
+{
+	tca_set_kind((struct rtnl_tca *) qdisc, name);
+	qdisc->q_ops = __rtnl_qdisc_lookup_ops(name);
+}
+
+char *rtnl_qdisc_get_kind(struct rtnl_qdisc *qdisc)
+{
+	return tca_get_kind((struct rtnl_tca *) qdisc);
+}
+
+uint64_t rtnl_qdisc_get_stat(struct rtnl_qdisc *qdisc,
+			     enum rtnl_tc_stats_id id)
+{
+	return tca_get_stat((struct rtnl_tca *) qdisc, id);
+}
+
+/** @} */
+
+/**
+ * @name Qdisc Specific Options
+ * @{
+ */
+
+/**
+ * Return qdisc specific options for use in TCA_OPTIONS
+ * @arg qdisc		qdisc carrying the optiosn
+ * 
+ * @return new headerless netlink message carrying the options as payload
+ */
+struct nl_msg *rtnl_qdisc_get_opts(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_qdisc_ops *ops;
+
+	ops = rtnl_qdisc_lookup_ops(qdisc);
+	if (ops && ops->qo_get_opts)
+		return ops->qo_get_opts(qdisc);
+
+	return NULL;
+}
+
+/** @} */
+
+struct nl_object_ops qdisc_obj_ops = {
+	.oo_name		= "route/qdisc",
+	.oo_size		= sizeof(struct rtnl_qdisc),
+	.oo_free_data		= qdisc_free_data,
+	.oo_clone		= qdisc_clone,
+	.oo_dump = {
+	    [NL_DUMP_LINE]	= qdisc_dump_line,
+	    [NL_DUMP_DETAILS]	= qdisc_dump_details,
+	    [NL_DUMP_STATS]	= qdisc_dump_stats,
+	},
+	.oo_compare		= tca_compare,
+	.oo_id_attrs		= (TCA_ATTR_IFINDEX | TCA_ATTR_HANDLE),
+};
+
+/** @} */
diff -uNr libnl_kk/lib/route/route.c libnl/lib/route/route.c
--- libnl_kk/lib/route/route.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/route.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,201 @@
+/*
+ * lib/route/route.c	Routes
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup rtnl
+ * @defgroup route Routing
+ * @brief
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink/netlink.h>
+#include <netlink/cache.h>
+#include <netlink/utils.h>
+#include <netlink/data.h>
+#include <netlink/route/rtnl.h>
+#include <netlink/route/route.h>
+#include <netlink/route/link.h>
+
+static struct nl_cache_ops rtnl_route_ops;
+
+static int route_msg_parser(struct nl_cache_ops *ops, struct sockaddr_nl *who,
+			    struct nlmsghdr *nlh, struct nl_parser_param *pp)
+{
+	struct rtnl_route *route;
+	int err;
+
+	if ((err = rtnl_route_parse(nlh, &route)) < 0)
+		return err;
+
+	err = pp->pp_cb((struct nl_object *) route, pp);
+
+	rtnl_route_put(route);
+	return err;
+}
+
+static int route_request_update(struct nl_cache *c, struct nl_sock *h)
+{
+	struct rtmsg rhdr = {
+		.rtm_family = c->c_iarg1,
+	};
+
+	if (c->c_iarg2 & ROUTE_CACHE_CONTENT)
+		rhdr.rtm_flags |= RTM_F_CLONED;
+
+	return nl_send_simple(h, RTM_GETROUTE, NLM_F_DUMP, &rhdr, sizeof(rhdr));
+}
+
+/**
+ * @name Cache Management
+ * @{
+ */
+
+/**
+ * Build a route cache holding all routes currently configured in the kernel
+ * @arg sk		Netlink socket.
+ * @arg family		Address family of routes to cover or AF_UNSPEC
+ * @arg flags		Flags
+ *
+ * Allocates a new cache, initializes it properly and updates it to
+ * contain all routes currently configured in the kernel.
+ *
+ * @note The caller is responsible for destroying and freeing the
+ *       cache after using it.
+ * @return The cache or NULL if an error has occured.
+ */
+int rtnl_route_alloc_cache(struct nl_sock *sk, int family, int flags,
+			   struct nl_cache **result)
+{
+	struct nl_cache *cache;
+	int err;
+
+	if (!(cache = nl_cache_alloc(&rtnl_route_ops)))
+		return -NLE_NOMEM;
+
+	cache->c_iarg1 = family;
+	cache->c_iarg2 = flags;
+
+	if (sk && (err = nl_cache_refill(sk, cache)) < 0) {
+		free(cache);
+		return err;
+	}
+
+	*result = cache;
+	return 0;
+}
+
+/** @} */
+
+/**
+ * @name Route Addition
+ * @{
+ */
+
+static int build_route_msg(struct rtnl_route *tmpl, int cmd, int flags,
+			   struct nl_msg **result)
+{
+	struct nl_msg *msg;
+	int err;
+
+	if (!(msg = nlmsg_alloc_simple(cmd, flags)))
+		return -NLE_NOMEM;
+
+	if ((err = rtnl_route_build_msg(msg, tmpl)) < 0) {
+		nlmsg_free(msg);
+		return err;
+	}
+
+	*result = msg;
+	return 0;
+}
+
+int rtnl_route_build_add_request(struct rtnl_route *tmpl, int flags,
+				 struct nl_msg **result)
+{
+	return build_route_msg(tmpl, RTM_NEWROUTE, NLM_F_CREATE | flags,
+			       result);
+}
+
+int rtnl_route_add(struct nl_sock *sk, struct rtnl_route *route, int flags)
+{
+	struct nl_msg *msg;
+	int err;
+
+	if ((err = rtnl_route_build_add_request(route, flags, &msg)) < 0)
+		return err;
+
+	err = nl_send_auto_complete(sk, msg);
+	nlmsg_free(msg);
+	if (err < 0)
+		return err;
+
+	return wait_for_ack(sk);
+}
+
+int rtnl_route_build_del_request(struct rtnl_route *tmpl, int flags,
+				 struct nl_msg **result)
+{
+	return build_route_msg(tmpl, RTM_DELROUTE, flags, result);
+}
+
+int rtnl_route_delete(struct nl_sock *sk, struct rtnl_route *route, int flags)
+{
+	struct nl_msg *msg;
+	int err;
+
+	if ((err = rtnl_route_build_del_request(route, flags, &msg)) < 0)
+		return err;
+
+	err = nl_send_auto_complete(sk, msg);
+	nlmsg_free(msg);
+	if (err < 0)
+		return err;
+
+	return wait_for_ack(sk);
+}
+
+/** @} */
+
+static struct nl_af_group route_groups[] = {
+	{ AF_INET,	RTNLGRP_IPV4_ROUTE },
+	{ AF_INET6,	RTNLGRP_IPV6_ROUTE },
+	{ AF_DECnet,	RTNLGRP_DECnet_ROUTE },
+	{ END_OF_GROUP_LIST },
+};
+
+static struct nl_cache_ops rtnl_route_ops = {
+	.co_name		= "route/route",
+	.co_hdrsize		= sizeof(struct rtmsg),
+	.co_msgtypes		= {
+					{ RTM_NEWROUTE, NL_ACT_NEW, "new" },
+					{ RTM_DELROUTE, NL_ACT_DEL, "del" },
+					{ RTM_GETROUTE, NL_ACT_GET, "get" },
+					END_OF_MSGTYPES_LIST,
+				  },
+	.co_protocol		= NETLINK_ROUTE,
+	.co_groups		= route_groups,
+	.co_request_update	= route_request_update,
+	.co_msg_parser		= route_msg_parser,
+	.co_obj_ops		= &route_obj_ops,
+};
+
+static void __init route_init(void)
+{
+	nl_cache_mngt_register(&rtnl_route_ops);
+}
+
+static void __exit route_exit(void)
+{
+	nl_cache_mngt_unregister(&rtnl_route_ops);
+}
+
+/** @} */
diff -uNr libnl_kk/lib/route/route_obj.c libnl/lib/route/route_obj.c
--- libnl_kk/lib/route/route_obj.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/route_obj.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,1197 @@
+/*
+ * lib/route/route_obj.c	Route Object
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup route
+ * @defgroup route_obj Route Object
+ *
+ * @par Attributes
+ * @code
+ * Name                                           Default
+ * -------------------------------------------------------------
+ * routing table                                  RT_TABLE_MAIN
+ * scope                                          RT_SCOPE_NOWHERE
+ * tos                                            0
+ * protocol                                       RTPROT_STATIC
+ * prio                                           0
+ * family                                         AF_UNSPEC
+ * type                                           RTN_UNICAST
+ * iif                                            NULL
+ * @endcode
+ *
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink/netlink.h>
+#include <netlink/cache.h>
+#include <netlink/utils.h>
+#include <netlink/data.h>
+#include <netlink/route/rtnl.h>
+#include <netlink/route/route.h>
+#include <netlink/route/link.h>
+#include <netlink/route/nexthop.h>
+
+/** @cond SKIP */
+#define ROUTE_ATTR_FAMILY    0x000001
+#define ROUTE_ATTR_TOS       0x000002
+#define ROUTE_ATTR_TABLE     0x000004
+#define ROUTE_ATTR_PROTOCOL  0x000008
+#define ROUTE_ATTR_SCOPE     0x000010
+#define ROUTE_ATTR_TYPE      0x000020
+#define ROUTE_ATTR_FLAGS     0x000040
+#define ROUTE_ATTR_DST       0x000080
+#define ROUTE_ATTR_SRC       0x000100
+#define ROUTE_ATTR_IIF       0x000200
+#define ROUTE_ATTR_OIF       0x000400
+#define ROUTE_ATTR_GATEWAY   0x000800
+#define ROUTE_ATTR_PRIO      0x001000
+#define ROUTE_ATTR_PREF_SRC  0x002000
+#define ROUTE_ATTR_METRICS   0x004000
+#define ROUTE_ATTR_MULTIPATH 0x008000
+#define ROUTE_ATTR_REALMS    0x010000
+#define ROUTE_ATTR_CACHEINFO 0x020000
+/** @endcond */
+
+static void route_constructor(struct nl_object *c)
+{
+	struct rtnl_route *r = (struct rtnl_route *) c;
+
+	r->rt_family = AF_UNSPEC;
+	r->rt_scope = RT_SCOPE_NOWHERE;
+	r->rt_table = RT_TABLE_MAIN;
+	r->rt_protocol = RTPROT_STATIC;
+	r->rt_type = RTN_UNICAST;
+
+	nl_init_list_head(&r->rt_nexthops);
+}
+
+static void route_free_data(struct nl_object *c)
+{
+	struct rtnl_route *r = (struct rtnl_route *) c;
+	struct rtnl_nexthop *nh, *tmp;
+
+	if (r == NULL)
+		return;
+
+	nl_addr_put(r->rt_dst);
+	nl_addr_put(r->rt_src);
+	nl_addr_put(r->rt_pref_src);
+
+	nl_list_for_each_entry_safe(nh, tmp, &r->rt_nexthops, rtnh_list) {
+		rtnl_route_remove_nexthop(r, nh);
+		rtnl_route_nh_free(nh);
+	}
+}
+
+static int route_clone(struct nl_object *_dst, struct nl_object *_src)
+{
+	struct rtnl_route *dst = (struct rtnl_route *) _dst;
+	struct rtnl_route *src = (struct rtnl_route *) _src;
+	struct rtnl_nexthop *nh, *new;
+
+	if (src->rt_dst)
+		if (!(dst->rt_dst = nl_addr_clone(src->rt_dst)))
+			return -NLE_NOMEM;
+
+	if (src->rt_src)
+		if (!(dst->rt_src = nl_addr_clone(src->rt_src)))
+			return -NLE_NOMEM;
+
+	if (src->rt_pref_src)
+		if (!(dst->rt_pref_src = nl_addr_clone(src->rt_pref_src)))
+			return -NLE_NOMEM;
+
+	nl_init_list_head(&dst->rt_nexthops);
+	nl_list_for_each_entry(nh, &src->rt_nexthops, rtnh_list) {
+		new = rtnl_route_nh_clone(nh);
+		if (!new)
+			return -NLE_NOMEM;
+
+		rtnl_route_add_nexthop(dst, new);
+	}
+
+	return 0;
+}
+
+static void route_dump_line(struct nl_object *a, struct nl_dump_params *p)
+{
+	struct rtnl_route *r = (struct rtnl_route *) a;
+	struct nl_cache *link_cache;
+	int cache = 0, flags;
+	char buf[64];
+
+	link_cache = nl_cache_mngt_require("route/link");
+
+	if (r->rt_flags & RTM_F_CLONED)
+		cache = 1;
+
+	nl_dump_line(p, "%s ", nl_af2str(r->rt_family, buf, sizeof(buf)));
+
+	if (cache)
+		nl_dump(p, "cache ");
+
+	if (!(r->ce_mask & ROUTE_ATTR_DST) ||
+	    nl_addr_get_len(r->rt_dst) == 0)
+		nl_dump(p, "default ");
+	else
+		nl_dump(p, "%s ", nl_addr2str(r->rt_dst, buf, sizeof(buf)));
+
+	if (r->ce_mask & ROUTE_ATTR_TABLE && !cache)
+		nl_dump(p, "table %s ",
+			rtnl_route_table2str(r->rt_table, buf, sizeof(buf)));
+
+	if (r->ce_mask & ROUTE_ATTR_TYPE)
+		nl_dump(p, "type %s ",
+			nl_rtntype2str(r->rt_type, buf, sizeof(buf)));
+
+	if (r->ce_mask & ROUTE_ATTR_TOS && r->rt_tos != 0)
+		nl_dump(p, "tos %#x ", r->rt_tos);
+
+	if (r->ce_mask & ROUTE_ATTR_MULTIPATH) {
+		struct rtnl_nexthop *nh;
+
+		nl_list_for_each_entry(nh, &r->rt_nexthops, rtnh_list) {
+			p->dp_ivar = NH_DUMP_FROM_ONELINE;
+			rtnl_route_nh_dump(nh, p);
+		}
+	}
+
+	flags = r->rt_flags & ~(RTM_F_CLONED);
+	if (r->ce_mask & ROUTE_ATTR_FLAGS && flags) {
+
+		nl_dump(p, "<");
+
+#define PRINT_FLAG(f) if (flags & RTNH_F_##f) { \
+		flags &= ~RTNH_F_##f; nl_dump(p, #f "%s", flags ? "," : ""); }
+		PRINT_FLAG(DEAD);
+		PRINT_FLAG(ONLINK);
+		PRINT_FLAG(PERVASIVE);
+#undef PRINT_FLAG
+
+#define PRINT_FLAG(f) if (flags & RTM_F_##f) { \
+		flags &= ~RTM_F_##f; nl_dump(p, #f "%s", flags ? "," : ""); }
+		PRINT_FLAG(NOTIFY);
+		PRINT_FLAG(EQUALIZE);
+		PRINT_FLAG(PREFIX);
+#undef PRINT_FLAG
+
+#define PRINT_FLAG(f) if (flags & RTCF_##f) { \
+		flags &= ~RTCF_##f; nl_dump(p, #f "%s", flags ? "," : ""); }
+		PRINT_FLAG(NOTIFY);
+		PRINT_FLAG(REDIRECTED);
+		PRINT_FLAG(DOREDIRECT);
+		PRINT_FLAG(DIRECTSRC);
+		PRINT_FLAG(DNAT);
+		PRINT_FLAG(BROADCAST);
+		PRINT_FLAG(MULTICAST);
+		PRINT_FLAG(LOCAL);
+#undef PRINT_FLAG
+
+		nl_dump(p, ">");
+	}
+
+	nl_dump(p, "\n");
+}
+
+static void route_dump_details(struct nl_object *a, struct nl_dump_params *p)
+{
+	struct rtnl_route *r = (struct rtnl_route *) a;
+	struct nl_cache *link_cache;
+	char buf[128];
+	int i;
+
+	link_cache = nl_cache_mngt_require("route/link");
+
+	route_dump_line(a, p);
+	nl_dump_line(p, "    ");
+
+	if (r->ce_mask & ROUTE_ATTR_PREF_SRC)
+		nl_dump(p, "preferred-src %s ",
+			nl_addr2str(r->rt_pref_src, buf, sizeof(buf)));
+
+	if (r->ce_mask & ROUTE_ATTR_SCOPE && r->rt_scope != RT_SCOPE_NOWHERE)
+		nl_dump(p, "scope %s ",
+			rtnl_scope2str(r->rt_scope, buf, sizeof(buf)));
+
+	if (r->ce_mask & ROUTE_ATTR_PRIO)
+		nl_dump(p, "priority %#x ", r->rt_prio);
+
+	if (r->ce_mask & ROUTE_ATTR_PROTOCOL)
+		nl_dump(p, "protocol %s ",
+			rtnl_route_proto2str(r->rt_protocol, buf, sizeof(buf)));
+
+	if (r->ce_mask & ROUTE_ATTR_IIF) {
+		if (link_cache) {
+			nl_dump(p, "iif %s ",
+				rtnl_link_i2name(link_cache, r->rt_iif,
+						 buf, sizeof(buf)));
+		} else
+			nl_dump(p, "iif %d ", r->rt_iif);
+	}
+
+	if (r->ce_mask & ROUTE_ATTR_SRC)
+		nl_dump(p, "src %s ", nl_addr2str(r->rt_src, buf, sizeof(buf)));
+
+	nl_dump(p, "\n");
+
+	if (r->ce_mask & ROUTE_ATTR_MULTIPATH) {
+		struct rtnl_nexthop *nh;
+
+		nl_list_for_each_entry(nh, &r->rt_nexthops, rtnh_list) {
+			nl_dump_line(p, "    ");
+			p->dp_ivar = NH_DUMP_FROM_DETAILS;
+			rtnl_route_nh_dump(nh, p);
+			nl_dump(p, "\n");
+		}
+	}
+
+	if ((r->ce_mask & ROUTE_ATTR_CACHEINFO) && r->rt_cacheinfo.rtci_error) {
+		nl_dump_line(p, "    cacheinfo error %d (%s)\n",
+			r->rt_cacheinfo.rtci_error,
+			strerror(-r->rt_cacheinfo.rtci_error));
+	}
+
+	if (r->ce_mask & ROUTE_ATTR_METRICS) {
+		nl_dump_line(p, "    metrics [");
+		for (i = 0; i < RTAX_MAX; i++)
+			if (r->rt_metrics_mask & (1 << i))
+				nl_dump(p, "%s %u ",
+					rtnl_route_metric2str(i+1,
+							      buf, sizeof(buf)),
+					r->rt_metrics[i]);
+		nl_dump(p, "]\n");
+	}
+}
+
+static void route_dump_stats(struct nl_object *obj, struct nl_dump_params *p)
+{
+	struct rtnl_route *route = (struct rtnl_route *) obj;
+
+	route_dump_details(obj, p);
+
+	if (route->ce_mask & ROUTE_ATTR_CACHEINFO) {
+		struct rtnl_rtcacheinfo *ci = &route->rt_cacheinfo;
+
+		nl_dump_line(p, "    used %u refcnt %u last-use %us "
+				"expires %us\n",
+			     ci->rtci_used, ci->rtci_clntref,
+			     ci->rtci_last_use / nl_get_hz(),
+			     ci->rtci_expires / nl_get_hz());
+	}
+}
+
+static void route_dump_env(struct nl_object *obj, struct nl_dump_params *p)
+{
+	struct rtnl_route *route = (struct rtnl_route *) obj;
+	struct nl_cache *link_cache;
+	char buf[128];
+
+	link_cache = nl_cache_mngt_require("route/link");
+
+	nl_dump_line(p, "ROUTE_FAMILY=%s\n",
+		     nl_af2str(route->rt_family, buf, sizeof(buf)));
+
+	if (route->ce_mask & ROUTE_ATTR_DST)
+		nl_dump_line(p, "ROUTE_DST=%s\n",
+			     nl_addr2str(route->rt_dst, buf, sizeof(buf)));
+
+	if (route->ce_mask & ROUTE_ATTR_SRC)
+		nl_dump_line(p, "ROUTE_SRC=%s\n",
+			     nl_addr2str(route->rt_src, buf, sizeof(buf)));
+
+	if (route->ce_mask & ROUTE_ATTR_PREF_SRC)
+		nl_dump_line(p, "ROUTE_PREFSRC=%s\n",
+			     nl_addr2str(route->rt_pref_src, buf, sizeof(buf)));
+
+	if (route->ce_mask & ROUTE_ATTR_IIF) {
+		if (link_cache) {
+			nl_dump_line(p, "ROUTE_IIF=%s",
+				rtnl_link_i2name(link_cache, route->rt_iif,
+						 buf, sizeof(buf)));
+		} else
+			nl_dump_line(p, "ROUTE_IIF=%d", route->rt_iif);
+	}
+
+	if (route->ce_mask & ROUTE_ATTR_TOS)
+		nl_dump_line(p, "ROUTE_TOS=%u\n", route->rt_tos);
+
+	if (route->ce_mask & ROUTE_ATTR_TABLE)
+		nl_dump_line(p, "ROUTE_TABLE=%u\n",
+			     route->rt_table);
+
+	if (route->ce_mask & ROUTE_ATTR_SCOPE)
+		nl_dump_line(p, "ROUTE_SCOPE=%s\n",
+			     rtnl_scope2str(route->rt_scope, buf, sizeof(buf)));
+
+	if (route->ce_mask & ROUTE_ATTR_PRIO)
+		nl_dump_line(p, "ROUTE_PRIORITY=%u\n",
+			     route->rt_prio);
+
+	if (route->ce_mask & ROUTE_ATTR_TYPE)
+		nl_dump_line(p, "ROUTE_TYPE=%s\n",
+			     nl_rtntype2str(route->rt_type, buf, sizeof(buf)));
+
+	if (route->ce_mask & ROUTE_ATTR_MULTIPATH) {
+		struct rtnl_nexthop *nh;
+		int index = 1;
+
+		if (route->rt_nr_nh > 0)
+			nl_dump_line(p, "ROUTE_NR_NH=%u\n", route->rt_nr_nh);
+
+		nl_list_for_each_entry(nh, &route->rt_nexthops, rtnh_list) {
+			p->dp_ivar = index++;
+			rtnl_route_nh_dump(nh, p);
+		}
+	}
+}
+
+static int route_compare(struct nl_object *_a, struct nl_object *_b,
+			uint32_t attrs, int flags)
+{
+	struct rtnl_route *a = (struct rtnl_route *) _a;
+	struct rtnl_route *b = (struct rtnl_route *) _b;
+	struct rtnl_nexthop *nh_a, *nh_b;
+	int i, diff = 0, found;
+
+#define ROUTE_DIFF(ATTR, EXPR) ATTR_DIFF(attrs, ROUTE_ATTR_##ATTR, a, b, EXPR)
+
+	diff |= ROUTE_DIFF(FAMILY,	a->rt_family != b->rt_family);
+	diff |= ROUTE_DIFF(TOS,		a->rt_tos != b->rt_tos);
+	diff |= ROUTE_DIFF(TABLE,	a->rt_table != b->rt_table);
+	diff |= ROUTE_DIFF(PROTOCOL,	a->rt_protocol != b->rt_protocol);
+	diff |= ROUTE_DIFF(SCOPE,	a->rt_scope != b->rt_scope);
+	diff |= ROUTE_DIFF(TYPE,	a->rt_type != b->rt_type);
+	diff |= ROUTE_DIFF(PRIO,	a->rt_prio != b->rt_prio);
+	diff |= ROUTE_DIFF(DST,		nl_addr_cmp(a->rt_dst, b->rt_dst));
+	diff |= ROUTE_DIFF(SRC,		nl_addr_cmp(a->rt_src, b->rt_src));
+	diff |= ROUTE_DIFF(IIF,		a->rt_iif != b->rt_iif);
+	diff |= ROUTE_DIFF(PREF_SRC,	nl_addr_cmp(a->rt_pref_src,
+						    b->rt_pref_src));
+
+	if (flags & LOOSE_COMPARISON) {
+		nl_list_for_each_entry(nh_b, &b->rt_nexthops, rtnh_list) {
+			found = 0;
+			nl_list_for_each_entry(nh_a, &a->rt_nexthops,
+					       rtnh_list) {
+				if (!rtnl_route_nh_compare(nh_a, nh_b,
+							nh_b->ce_mask, 1)) {
+					found = 1;
+					break;
+				}
+			}
+
+			if (!found)
+				goto nh_mismatch;
+		}
+
+		for (i = 0; i < RTAX_MAX - 1; i++) {
+			if (a->rt_metrics_mask & (1 << i) &&
+			    (!(b->rt_metrics_mask & (1 << i)) ||
+			     a->rt_metrics[i] != b->rt_metrics[i]))
+				ROUTE_DIFF(METRICS, 1);
+		}
+
+		diff |= ROUTE_DIFF(FLAGS,
+			  (a->rt_flags ^ b->rt_flags) & b->rt_flag_mask);
+	} else {
+		if (a->rt_nr_nh != a->rt_nr_nh)
+			goto nh_mismatch;
+
+		/* search for a dup in each nh of a */
+		nl_list_for_each_entry(nh_a, &a->rt_nexthops, rtnh_list) {
+			found = 0;
+			nl_list_for_each_entry(nh_b, &b->rt_nexthops,
+					       rtnh_list) {
+				if (!rtnl_route_nh_compare(nh_a, nh_b, ~0, 0))
+					found = 1;
+					break;
+			}
+			if (!found)
+				goto nh_mismatch;
+		}
+
+		/* search for a dup in each nh of b, covers case where a has
+		 * dupes itself */
+		nl_list_for_each_entry(nh_b, &b->rt_nexthops, rtnh_list) {
+			found = 0;
+			nl_list_for_each_entry(nh_a, &a->rt_nexthops,
+					       rtnh_list) {
+				if (!rtnl_route_nh_compare(nh_a, nh_b, ~0, 0))
+					found = 1;
+					break;
+			}
+			if (!found)
+				goto nh_mismatch;
+		}
+
+		for (i = 0; i < RTAX_MAX - 1; i++) {
+			if ((a->rt_metrics_mask & (1 << i)) ^
+			    (b->rt_metrics_mask & (1 << i)))
+				diff |= ROUTE_DIFF(METRICS, 1);
+			else
+				diff |= ROUTE_DIFF(METRICS,
+					a->rt_metrics[i] != b->rt_metrics[i]);
+		}
+
+		diff |= ROUTE_DIFF(FLAGS, a->rt_flags != b->rt_flags);
+	}
+
+out:
+	return diff;
+
+nh_mismatch:
+	diff |= ROUTE_DIFF(MULTIPATH, 1);
+	goto out;
+
+#undef ROUTE_DIFF
+}
+
+static struct trans_tbl route_attrs[] = {
+	__ADD(ROUTE_ATTR_FAMILY, family)
+	__ADD(ROUTE_ATTR_TOS, tos)
+	__ADD(ROUTE_ATTR_TABLE, table)
+	__ADD(ROUTE_ATTR_PROTOCOL, protocol)
+	__ADD(ROUTE_ATTR_SCOPE, scope)
+	__ADD(ROUTE_ATTR_TYPE, type)
+	__ADD(ROUTE_ATTR_FLAGS, flags)
+	__ADD(ROUTE_ATTR_DST, dst)
+	__ADD(ROUTE_ATTR_SRC, src)
+	__ADD(ROUTE_ATTR_IIF, iif)
+	__ADD(ROUTE_ATTR_OIF, oif)
+	__ADD(ROUTE_ATTR_GATEWAY, gateway)
+	__ADD(ROUTE_ATTR_PRIO, prio)
+	__ADD(ROUTE_ATTR_PREF_SRC, pref_src)
+	__ADD(ROUTE_ATTR_METRICS, metrics)
+	__ADD(ROUTE_ATTR_MULTIPATH, multipath)
+	__ADD(ROUTE_ATTR_REALMS, realms)
+	__ADD(ROUTE_ATTR_CACHEINFO, cacheinfo)
+};
+
+static char *route_attrs2str(int attrs, char *buf, size_t len)
+{
+	return __flags2str(attrs, buf, len, route_attrs,
+			   ARRAY_SIZE(route_attrs));
+}
+
+/**
+ * @name Allocation/Freeing
+ * @{
+ */
+
+struct rtnl_route *rtnl_route_alloc(void)
+{
+	return (struct rtnl_route *) nl_object_alloc(&route_obj_ops);
+}
+
+void rtnl_route_get(struct rtnl_route *route)
+{
+	nl_object_get((struct nl_object *) route);
+}
+
+void rtnl_route_put(struct rtnl_route *route)
+{
+	nl_object_put((struct nl_object *) route);
+}
+
+/** @} */
+
+/**
+ * @name Attributes
+ * @{
+ */
+
+void rtnl_route_set_table(struct rtnl_route *route, uint32_t table)
+{
+	route->rt_table = table;
+	route->ce_mask |= ROUTE_ATTR_TABLE;
+}
+
+uint32_t rtnl_route_get_table(struct rtnl_route *route)
+{
+	return route->rt_table;
+}
+
+void rtnl_route_set_scope(struct rtnl_route *route, uint8_t scope)
+{
+	route->rt_scope = scope;
+	route->ce_mask |= ROUTE_ATTR_SCOPE;
+}
+
+uint8_t rtnl_route_get_scope(struct rtnl_route *route)
+{
+	return route->rt_scope;
+}
+
+void rtnl_route_set_tos(struct rtnl_route *route, uint8_t tos)
+{
+	route->rt_tos = tos;
+	route->ce_mask |= ROUTE_ATTR_TOS;
+}
+
+uint8_t rtnl_route_get_tos(struct rtnl_route *route)
+{
+	return route->rt_tos;
+}
+
+void rtnl_route_set_protocol(struct rtnl_route *route, uint8_t protocol)
+{
+	route->rt_protocol = protocol;
+	route->ce_mask |= ROUTE_ATTR_PROTOCOL;
+}
+
+uint8_t rtnl_route_get_protocol(struct rtnl_route *route)
+{
+	return route->rt_protocol;
+}
+
+void rtnl_route_set_priority(struct rtnl_route *route, uint32_t prio)
+{
+	route->rt_prio = prio;
+	route->ce_mask |= ROUTE_ATTR_PRIO;
+}
+
+uint32_t rtnl_route_get_priority(struct rtnl_route *route)
+{
+	return route->rt_prio;
+}
+
+int rtnl_route_set_family(struct rtnl_route *route, uint8_t family)
+{
+	if (family != AF_INET && family != AF_INET6 && family != AF_DECnet)
+		return -NLE_AF_NOSUPPORT;
+
+	route->rt_family = family;
+	route->ce_mask |= ROUTE_ATTR_FAMILY;
+
+	return 0;
+}
+
+uint8_t rtnl_route_get_family(struct rtnl_route *route)
+{
+	return route->rt_family;
+}
+
+int rtnl_route_set_dst(struct rtnl_route *route, struct nl_addr *addr)
+{
+	if (route->ce_mask & ROUTE_ATTR_FAMILY) {
+		if (addr->a_family != route->rt_family)
+			return -NLE_AF_MISMATCH;
+	} else
+		route->rt_family = addr->a_family;
+
+	if (route->rt_dst)
+		nl_addr_put(route->rt_dst);
+
+	nl_addr_get(addr);
+	route->rt_dst = addr;
+	
+	route->ce_mask |= (ROUTE_ATTR_DST | ROUTE_ATTR_FAMILY);
+
+	return 0;
+}
+
+struct nl_addr *rtnl_route_get_dst(struct rtnl_route *route)
+{
+	return route->rt_dst;
+}
+
+int rtnl_route_set_src(struct rtnl_route *route, struct nl_addr *addr)
+{
+	if (addr->a_family == AF_INET)
+		return -NLE_SRCRT_NOSUPPORT;
+
+	if (route->ce_mask & ROUTE_ATTR_FAMILY) {
+		if (addr->a_family != route->rt_family)
+			return -NLE_AF_MISMATCH;
+	} else
+		route->rt_family = addr->a_family;
+
+	if (route->rt_src)
+		nl_addr_put(route->rt_src);
+
+	nl_addr_get(addr);
+	route->rt_src = addr;
+	route->ce_mask |= (ROUTE_ATTR_SRC | ROUTE_ATTR_FAMILY);
+
+	return 0;
+}
+
+struct nl_addr *rtnl_route_get_src(struct rtnl_route *route)
+{
+	return route->rt_src;
+}
+
+int rtnl_route_set_type(struct rtnl_route *route, uint8_t type)
+{
+	if (type > RTN_MAX)
+		return -NLE_RANGE;
+
+	route->rt_type = type;
+	route->ce_mask |= ROUTE_ATTR_TYPE;
+
+	return 0;
+}
+
+uint8_t rtnl_route_get_type(struct rtnl_route *route)
+{
+	return route->rt_type;
+}
+
+void rtnl_route_set_flags(struct rtnl_route *route, uint32_t flags)
+{
+	route->rt_flag_mask |= flags;
+	route->rt_flags |= flags;
+	route->ce_mask |= ROUTE_ATTR_FLAGS;
+}
+
+void rtnl_route_unset_flags(struct rtnl_route *route, uint32_t flags)
+{
+	route->rt_flag_mask |= flags;
+	route->rt_flags &= ~flags;
+	route->ce_mask |= ROUTE_ATTR_FLAGS;
+}
+
+uint32_t rtnl_route_get_flags(struct rtnl_route *route)
+{
+	return route->rt_flags;
+}
+
+int rtnl_route_set_metric(struct rtnl_route *route, int metric, uint32_t value)
+{
+	if (metric > RTAX_MAX || metric < 1)
+		return -NLE_RANGE;
+
+	route->rt_metrics[metric - 1] = value;
+
+	if (!(route->rt_metrics_mask & (1 << (metric - 1)))) {
+		route->rt_nmetrics++;
+		route->rt_metrics_mask |= (1 << (metric - 1));
+	}
+
+	route->ce_mask |= ROUTE_ATTR_METRICS;
+
+	return 0;
+}
+
+int rtnl_route_unset_metric(struct rtnl_route *route, int metric)
+{
+	if (metric > RTAX_MAX || metric < 1)
+		return -NLE_RANGE;
+
+	if (route->rt_metrics_mask & (1 << (metric - 1))) {
+		route->rt_nmetrics--;
+		route->rt_metrics_mask &= ~(1 << (metric - 1));
+	}
+
+	return 0;
+}
+
+int rtnl_route_get_metric(struct rtnl_route *route, int metric, uint32_t *value)
+{
+	if (metric > RTAX_MAX || metric < 1)
+		return -NLE_RANGE;
+
+	if (!(route->rt_metrics_mask & (1 << (metric - 1))))
+		return -NLE_OBJ_NOTFOUND;
+
+	if (value)
+		*value = route->rt_metrics[metric - 1];
+
+	return 0;
+}
+
+int rtnl_route_set_pref_src(struct rtnl_route *route, struct nl_addr *addr)
+{
+	if (route->ce_mask & ROUTE_ATTR_FAMILY) {
+		if (addr->a_family != route->rt_family)
+			return -NLE_AF_MISMATCH;
+	} else
+		route->rt_family = addr->a_family;
+
+	if (route->rt_pref_src)
+		nl_addr_put(route->rt_pref_src);
+
+	nl_addr_get(addr);
+	route->rt_pref_src = addr;
+	route->ce_mask |= (ROUTE_ATTR_PREF_SRC | ROUTE_ATTR_FAMILY);
+
+	return 0;
+}
+
+struct nl_addr *rtnl_route_get_pref_src(struct rtnl_route *route)
+{
+	return route->rt_pref_src;
+}
+
+void rtnl_route_set_iif(struct rtnl_route *route, int ifindex)
+{
+	route->rt_iif = ifindex;
+	route->ce_mask |= ROUTE_ATTR_IIF;
+}
+
+int rtnl_route_get_iif(struct rtnl_route *route)
+{
+	return route->rt_iif;
+}
+
+void rtnl_route_add_nexthop(struct rtnl_route *route, struct rtnl_nexthop *nh)
+{
+	nl_list_add_tail(&nh->rtnh_list, &route->rt_nexthops);
+	route->rt_nr_nh++;
+	route->ce_mask |= ROUTE_ATTR_MULTIPATH;
+}
+
+void rtnl_route_remove_nexthop(struct rtnl_route *route, struct rtnl_nexthop *nh)
+{
+	route->rt_nr_nh--;
+	nl_list_del(&nh->rtnh_list);
+}
+
+struct nl_list_head *rtnl_route_get_nexthops(struct rtnl_route *route)
+{
+	return &route->rt_nexthops;
+}
+
+int rtnl_route_get_nnexthops(struct rtnl_route *route)
+{
+	return route->rt_nr_nh;
+}
+
+void rtnl_route_foreach_nexthop(struct rtnl_route *r,
+                                void (*cb)(struct rtnl_nexthop *, void *),
+                                void *arg)
+{
+	struct rtnl_nexthop *nh;
+    
+	if (r->ce_mask & ROUTE_ATTR_MULTIPATH) {
+		nl_list_for_each_entry(nh, &r->rt_nexthops, rtnh_list) {
+                        cb(nh, arg);
+		}
+	}
+}
+
+struct rtnl_nexthop *rtnl_route_nexthop_n(struct rtnl_route *r, int n)
+{
+	struct rtnl_nexthop *nh;
+	int i;
+    
+	if (r->ce_mask & ROUTE_ATTR_MULTIPATH && r->rt_nr_nh > n) {
+		i = 0;
+		nl_list_for_each_entry(nh, &r->rt_nexthops, rtnh_list) {
+                        if (i == n) return nh;
+			i++;
+		}
+	}
+        return NULL;
+}
+
+/** @} */
+
+/**
+ * @name Utilities
+ * @{
+ */
+
+/**
+ * Guess scope of a route object.
+ * @arg route		Route object.
+ *
+ * Guesses the scope of a route object, based on the following rules:
+ * @code
+ *   1) Local route -> local scope
+ *   2) At least one nexthop not directly connected -> universe scope
+ *   3) All others -> link scope
+ * @endcode
+ *
+ * @return Scope value.
+ */
+int rtnl_route_guess_scope(struct rtnl_route *route)
+{
+	if (route->rt_type == RTN_LOCAL)
+		return RT_SCOPE_HOST;
+
+	if (!nl_list_empty(&route->rt_nexthops)) {
+		struct rtnl_nexthop *nh;
+
+		/*
+		 * Use scope uiniverse if there is at least one nexthop which
+		 * is not directly connected
+		 */
+		nl_list_for_each_entry(nh, &route->rt_nexthops, rtnh_list) {
+			if (nh->rtnh_gateway)
+				return RT_SCOPE_UNIVERSE;
+		}
+	}
+
+	return RT_SCOPE_LINK;
+}
+
+/** @} */
+
+static struct nla_policy route_policy[RTA_MAX+1] = {
+	[RTA_IIF]	= { .type = NLA_U32 },
+	[RTA_OIF]	= { .type = NLA_U32 },
+	[RTA_PRIORITY]	= { .type = NLA_U32 },
+	[RTA_FLOW]	= { .type = NLA_U32 },
+	[RTA_CACHEINFO]	= { .minlen = sizeof(struct rta_cacheinfo) },
+	[RTA_METRICS]	= { .type = NLA_NESTED },
+	[RTA_MULTIPATH]	= { .type = NLA_NESTED },
+};
+
+static int parse_multipath(struct rtnl_route *route, struct nlattr *attr)
+{
+	struct rtnl_nexthop *nh = NULL;
+	struct rtnexthop *rtnh = nla_data(attr);
+	size_t tlen = nla_len(attr);
+	int err;
+
+	while (tlen >= sizeof(*rtnh) && tlen >= rtnh->rtnh_len) {
+		nh = rtnl_route_nh_alloc();
+		if (!nh)
+			return -NLE_NOMEM;
+
+		rtnl_route_nh_set_weight(nh, rtnh->rtnh_hops);
+		rtnl_route_nh_set_ifindex(nh, rtnh->rtnh_ifindex);
+		rtnl_route_nh_set_flags(nh, rtnh->rtnh_flags);
+
+		if (rtnh->rtnh_len > sizeof(*rtnh)) {
+			struct nlattr *ntb[RTA_MAX + 1];
+
+			err = nla_parse(ntb, RTA_MAX, (struct nlattr *)
+					RTNH_DATA(rtnh),
+					rtnh->rtnh_len - sizeof(*rtnh),
+					route_policy);
+			if (err < 0)
+				goto errout;
+
+			if (ntb[RTA_GATEWAY]) {
+				struct nl_addr *addr;
+
+				addr = nl_addr_alloc_attr(ntb[RTA_GATEWAY],
+							  route->rt_family);
+				if (!addr) {
+					err = -NLE_NOMEM;
+					goto errout;
+				}
+
+				rtnl_route_nh_set_gateway(nh, addr);
+				nl_addr_put(addr);
+			}
+
+			if (ntb[RTA_FLOW]) {
+				uint32_t realms;
+				
+				realms = nla_get_u32(ntb[RTA_FLOW]);
+				rtnl_route_nh_set_realms(nh, realms);
+			}
+		}
+
+		rtnl_route_add_nexthop(route, nh);
+		tlen -= RTNH_ALIGN(rtnh->rtnh_len);
+		rtnh = RTNH_NEXT(rtnh);
+	}
+
+	err = 0;
+errout:
+	if (err && nh)
+		rtnl_route_nh_free(nh);
+
+	return err;
+}
+
+int rtnl_route_parse(struct nlmsghdr *nlh, struct rtnl_route **result)
+{
+	struct rtmsg *rtm;
+	struct rtnl_route *route;
+	struct nlattr *tb[RTA_MAX + 1];
+	struct nl_addr *src = NULL, *dst = NULL, *addr;
+	struct rtnl_nexthop *old_nh = NULL;
+	int err, family;
+
+	route = rtnl_route_alloc();
+	if (!route) {
+		err = -NLE_NOMEM;
+		goto errout;
+	}
+
+	route->ce_msgtype = nlh->nlmsg_type;
+
+	err = nlmsg_parse(nlh, sizeof(struct rtmsg), tb, RTA_MAX, route_policy);
+	if (err < 0)
+		goto errout;
+
+	rtm = nlmsg_data(nlh);
+	route->rt_family = family = rtm->rtm_family;
+	route->rt_tos = rtm->rtm_tos;
+	route->rt_table = rtm->rtm_table;
+	route->rt_type = rtm->rtm_type;
+	route->rt_scope = rtm->rtm_scope;
+	route->rt_protocol = rtm->rtm_protocol;
+	route->rt_flags = rtm->rtm_flags;
+
+	route->ce_mask |= ROUTE_ATTR_FAMILY | ROUTE_ATTR_TOS |
+			  ROUTE_ATTR_TABLE | ROUTE_ATTR_TYPE |
+			  ROUTE_ATTR_SCOPE | ROUTE_ATTR_PROTOCOL |
+			  ROUTE_ATTR_FLAGS;
+
+	if (tb[RTA_DST]) {
+		if (!(dst = nl_addr_alloc_attr(tb[RTA_DST], family)))
+			goto errout_nomem;
+	} else {
+		if (!(dst = nl_addr_alloc(0)))
+			goto errout_nomem;
+		nl_addr_set_family(dst, rtm->rtm_family);
+	}
+
+	nl_addr_set_prefixlen(dst, rtm->rtm_dst_len);
+	err = rtnl_route_set_dst(route, dst);
+	if (err < 0)
+		goto errout;
+
+	nl_addr_put(dst);
+
+	if (tb[RTA_SRC]) {
+		if (!(src = nl_addr_alloc_attr(tb[RTA_SRC], family)))
+			goto errout_nomem;
+	} else if (rtm->rtm_src_len)
+		if (!(src = nl_addr_alloc(0)))
+			goto errout_nomem;
+
+	if (src) {
+		nl_addr_set_prefixlen(src, rtm->rtm_src_len);
+		rtnl_route_set_src(route, src);
+		nl_addr_put(src);
+	}
+
+	if (tb[RTA_IIF])
+		rtnl_route_set_iif(route, nla_get_u32(tb[RTA_IIF]));
+
+	if (tb[RTA_PRIORITY])
+		rtnl_route_set_priority(route, nla_get_u32(tb[RTA_PRIORITY]));
+
+	if (tb[RTA_PREFSRC]) {
+		if (!(addr = nl_addr_alloc_attr(tb[RTA_PREFSRC], family)))
+			goto errout_nomem;
+		rtnl_route_set_pref_src(route, addr);
+		nl_addr_put(addr);
+	}
+
+	if (tb[RTA_METRICS]) {
+		struct nlattr *mtb[RTAX_MAX + 1];
+		int i;
+
+		err = nla_parse_nested(mtb, RTAX_MAX, tb[RTA_METRICS], NULL);
+		if (err < 0)
+			goto errout;
+
+		for (i = 1; i <= RTAX_MAX; i++) {
+			if (mtb[i] && nla_len(mtb[i]) >= sizeof(uint32_t)) {
+				uint32_t m = nla_get_u32(mtb[i]);
+				if (rtnl_route_set_metric(route, i, m) < 0)
+					goto errout;
+			}
+		}
+	}
+
+	if (tb[RTA_MULTIPATH])
+		if ((err = parse_multipath(route, tb[RTA_MULTIPATH])) < 0)
+			goto errout;
+
+	if (tb[RTA_CACHEINFO]) {
+		nla_memcpy(&route->rt_cacheinfo, tb[RTA_CACHEINFO],
+			   sizeof(route->rt_cacheinfo));
+		route->ce_mask |= ROUTE_ATTR_CACHEINFO;
+	}
+
+	if (tb[RTA_OIF]) {
+		if (!old_nh && !(old_nh = rtnl_route_nh_alloc()))
+			goto errout;
+
+		rtnl_route_nh_set_ifindex(old_nh, nla_get_u32(tb[RTA_OIF]));
+	}
+
+	if (tb[RTA_GATEWAY]) {
+		if (!old_nh && !(old_nh = rtnl_route_nh_alloc()))
+			goto errout;
+
+		if (!(addr = nl_addr_alloc_attr(tb[RTA_GATEWAY], family)))
+			goto errout_nomem;
+
+		rtnl_route_nh_set_gateway(old_nh, addr);
+		nl_addr_put(addr);
+	}
+
+	if (tb[RTA_FLOW]) {
+		if (!old_nh && !(old_nh = rtnl_route_nh_alloc()))
+			goto errout;
+
+		rtnl_route_nh_set_realms(old_nh, nla_get_u32(tb[RTA_FLOW]));
+	}
+
+	if (old_nh) {
+		if (route->rt_nr_nh == 0) {
+			/* If no nexthops have been provided via RTA_MULTIPATH
+			 * we add it as regular nexthop to maintain backwards
+			 * compatibility */
+			rtnl_route_add_nexthop(route, old_nh);
+		} else {
+			/* Kernel supports new style nexthop configuration,
+			 * verify that it is a duplicate and discard nexthop. */
+			struct rtnl_nexthop *first;
+
+			first = nl_list_first_entry(&route->rt_nexthops,
+						    struct rtnl_nexthop,
+						    rtnh_list);
+			if (!first)
+				BUG();
+
+			if (rtnl_route_nh_compare(old_nh, first,
+						  old_nh->ce_mask, 0)) {
+				err = -NLE_INVAL;
+				goto errout;
+			}
+
+			rtnl_route_nh_free(old_nh);
+		}
+	}
+
+	*result = route;
+	return 0;
+
+errout:
+	rtnl_route_put(route);
+	return err;
+
+errout_nomem:
+	err = -NLE_NOMEM;
+	goto errout;
+}
+
+int rtnl_route_build_msg(struct nl_msg *msg, struct rtnl_route *route)
+{
+	int i;
+	struct nlattr *metrics;
+	struct rtmsg rtmsg = {
+		.rtm_family = route->rt_family,
+		.rtm_tos = route->rt_tos,
+		.rtm_table = route->rt_table,
+		.rtm_protocol = route->rt_protocol,
+		.rtm_scope = route->rt_scope,
+		.rtm_type = route->rt_type,
+		.rtm_flags = route->rt_flags,
+	};
+
+	if (route->rt_dst == NULL)
+		return -NLE_MISSING_ATTR;
+
+	rtmsg.rtm_dst_len = nl_addr_get_prefixlen(route->rt_dst);
+	if (route->rt_src)
+		rtmsg.rtm_src_len = nl_addr_get_prefixlen(route->rt_src);
+
+
+	if (rtmsg.rtm_scope == RT_SCOPE_NOWHERE)
+		rtmsg.rtm_scope = rtnl_route_guess_scope(route);
+
+	if (nlmsg_append(msg, &rtmsg, sizeof(rtmsg), NLMSG_ALIGNTO) < 0)
+		goto nla_put_failure;
+
+	/* Additional table attribute replacing the 8bit in the header, was
+	 * required to allow more than 256 tables. */
+	NLA_PUT_U32(msg, RTA_TABLE, route->rt_table);
+
+	if (nl_addr_get_len(route->rt_dst))
+		NLA_PUT_ADDR(msg, RTA_DST, route->rt_dst);
+	NLA_PUT_U32(msg, RTA_PRIORITY, route->rt_prio);
+
+	if (route->ce_mask & ROUTE_ATTR_SRC)
+		NLA_PUT_ADDR(msg, RTA_SRC, route->rt_src);
+
+	if (route->ce_mask & ROUTE_ATTR_PREF_SRC)
+		NLA_PUT_ADDR(msg, RTA_PREFSRC, route->rt_pref_src);
+
+	if (route->ce_mask & ROUTE_ATTR_IIF)
+		NLA_PUT_U32(msg, RTA_IIF, route->rt_iif);
+
+	if (route->rt_nmetrics > 0) {
+		uint32_t val;
+
+		metrics = nla_nest_start(msg, RTA_METRICS);
+		if (metrics == NULL)
+			goto nla_put_failure;
+
+		for (i = 1; i <= RTAX_MAX; i++) {
+			if (!rtnl_route_get_metric(route, i, &val))
+				NLA_PUT_U32(msg, i, val);
+		}
+
+		nla_nest_end(msg, metrics);
+	}
+
+	if (rtnl_route_get_nnexthops(route) > 0) {
+		struct nlattr *multipath;
+		struct rtnl_nexthop *nh;
+
+		if (!(multipath = nla_nest_start(msg, RTA_MULTIPATH)))
+			goto nla_put_failure;
+
+		nl_list_for_each_entry(nh, &route->rt_nexthops, rtnh_list) {
+			struct rtnexthop *rtnh;
+
+			rtnh = nlmsg_reserve(msg, sizeof(*rtnh), NLMSG_ALIGNTO);
+			if (!rtnh)
+				goto nla_put_failure;
+
+			rtnh->rtnh_flags = nh->rtnh_flags;
+			rtnh->rtnh_hops = nh->rtnh_weight;
+			rtnh->rtnh_ifindex = nh->rtnh_ifindex;
+
+			if (nh->rtnh_gateway)
+				NLA_PUT_ADDR(msg, RTA_GATEWAY,
+					     nh->rtnh_gateway);
+
+			if (nh->rtnh_realms)
+				NLA_PUT_U32(msg, RTA_FLOW, nh->rtnh_realms);
+
+			rtnh->rtnh_len = nlmsg_tail(msg->nm_nlh) -
+						(void *) rtnh;
+		}
+
+		nla_nest_end(msg, multipath);
+	}
+
+	return 0;
+
+nla_put_failure:
+	return -NLE_MSGSIZE;
+}
+
+/** @cond SKIP */
+struct nl_object_ops route_obj_ops = {
+	.oo_name		= "route/route",
+	.oo_size		= sizeof(struct rtnl_route),
+	.oo_constructor		= route_constructor,
+	.oo_free_data		= route_free_data,
+	.oo_clone		= route_clone,
+	.oo_dump = {
+	    [NL_DUMP_LINE]	= route_dump_line,
+	    [NL_DUMP_DETAILS]	= route_dump_details,
+	    [NL_DUMP_STATS]	= route_dump_stats,
+	    [NL_DUMP_ENV]	= route_dump_env,
+	},
+	.oo_compare		= route_compare,
+	.oo_attrs2str		= route_attrs2str,
+	.oo_id_attrs		= (ROUTE_ATTR_FAMILY | ROUTE_ATTR_TOS |
+				   ROUTE_ATTR_TABLE | ROUTE_ATTR_DST),
+};
+/** @endcond */
+
+/** @} */
diff -uNr libnl_kk/lib/route/route_utils.c libnl/lib/route/route_utils.c
--- libnl_kk/lib/route/route_utils.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/route_utils.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,170 @@
+/*
+ * lib/route/route_utils.c	Routing Utilities
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2006 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup route
+ * @defgroup route_utils Utilities
+ * @brief Routing Utility Functions
+ *
+ *
+ * @par 1) Translating Routing Table Names
+ * @code
+ * // libnl is only aware of the de facto standard routing table names.
+ * // Additional name <-> identifier associations have to be read in via
+ * // a configuration file, f.e. /etc/iproute2/rt_tables
+ * err = rtnl_route_read_table_names("/etc/iproute2/rt_tables");
+ *
+ * // Translating a table name to its idenfier
+ * int table = rtnl_route_str2table("main");
+ *
+ * // ... and the other way around.
+ * char buf[32];
+ * printf("Name: %s\n",
+ *        rtnl_route_table2str(table, buf, sizeof(buf)));
+ * @endcode
+ *
+ *
+ *
+ *
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink/netlink.h>
+#include <netlink/utils.h>
+#include <netlink/route/rtnl.h>
+#include <netlink/route/route.h>
+	
+/**
+ * @name Routing Table Identifier Translations
+ * @{
+ */
+
+static NL_LIST_HEAD(table_names);
+
+static int add_routing_table_name(long id, const char *name)
+{
+	return __trans_list_add(id, name, &table_names);
+}
+
+static void __init init_routing_table_names(void)
+{
+	add_routing_table_name(RT_TABLE_UNSPEC, "unspec");
+	add_routing_table_name(RT_TABLE_DEFAULT, "default");
+	add_routing_table_name(RT_TABLE_MAIN, "main");
+	add_routing_table_name(RT_TABLE_LOCAL, "local");
+};
+
+static void __exit release_routing_table_names(void)
+{
+	__trans_list_clear(&table_names);
+}
+
+int rtnl_route_read_table_names(const char *path)
+{
+	__trans_list_clear(&table_names);
+
+	return __nl_read_num_str_file(path, &add_routing_table_name);
+}
+
+char *rtnl_route_table2str(int table, char *buf, size_t size)
+{
+	return __list_type2str(table, buf, size, &table_names);
+}
+
+int rtnl_route_str2table(const char *name)
+{
+	return __list_str2type(name, &table_names);
+}
+
+
+/** @} */
+
+/**
+ * @name Routing Protocol Translations
+ * @{
+ */
+
+static NL_LIST_HEAD(proto_names);
+
+static int add_proto_name(long id, const char *name)
+{
+	return __trans_list_add(id, name, &proto_names);
+}
+
+static void __init init_proto_names(void)
+{
+	add_proto_name(RTPROT_UNSPEC, "unspec");
+	add_proto_name(RTPROT_REDIRECT, "redirect");
+	add_proto_name(RTPROT_KERNEL, "kernel");
+	add_proto_name(RTPROT_BOOT, "boot");
+	add_proto_name(RTPROT_STATIC, "static");
+};
+
+static void __exit release_proto_names(void)
+{
+	__trans_list_clear(&proto_names);
+}
+
+int rtnl_route_read_protocol_names(const char *path)
+{
+	__trans_list_clear(&proto_names);
+
+	return __nl_read_num_str_file(path, &add_proto_name);
+}
+
+char *rtnl_route_proto2str(int proto, char *buf, size_t size)
+{
+	return __list_type2str(proto, buf, size, &proto_names);
+}
+
+int rtnl_route_str2proto(const char *name)
+{
+	return __list_str2type(name, &proto_names);
+}
+
+/** @} */
+
+/**
+ * @name Routing Metrices Translations
+ * @{
+ */
+
+static struct trans_tbl route_metrices[] = {
+	__ADD(RTAX_UNSPEC, unspec)
+	__ADD(RTAX_LOCK, lock)
+	__ADD(RTAX_MTU, mtu)
+	__ADD(RTAX_WINDOW, window)
+	__ADD(RTAX_RTT, rtt)
+	__ADD(RTAX_RTTVAR, rttvar)
+	__ADD(RTAX_SSTHRESH, ssthresh)
+	__ADD(RTAX_CWND, cwnd)
+	__ADD(RTAX_ADVMSS, advmss)
+	__ADD(RTAX_REORDERING, reordering)
+	__ADD(RTAX_HOPLIMIT, hoplimit)
+	__ADD(RTAX_INITCWND, initcwnd)
+	__ADD(RTAX_FEATURES, features)
+};
+
+char *rtnl_route_metric2str(int metric, char *buf, size_t size)
+{
+	return __type2str(metric, buf, size, route_metrices,
+			  ARRAY_SIZE(route_metrices));
+}
+
+int rtnl_route_str2metric(const char *name)
+{
+	return __str2type(name, route_metrices, ARRAY_SIZE(route_metrices));
+}
+
+/** @} */
+
+/** @} */
diff -uNr libnl_kk/lib/route/rtnl.c libnl/lib/route/rtnl.c
--- libnl_kk/lib/route/rtnl.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/rtnl.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,124 @@
+/*
+ * lib/route/rtnl.c		Routing Netlink
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @defgroup rtnl Routing Family
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink/netlink.h>
+#include <netlink/utils.h>
+#include <netlink/route/rtnl.h>
+
+/**
+ * @name Sending
+ * @{
+ */
+
+/**
+ * Send routing netlink request message
+ * @arg sk		Netlink socket.
+ * @arg type		Netlink message type.
+ * @arg family		Address family.
+ * @arg flags		Additional netlink message flags.
+ *
+ * Fills out a routing netlink request message and sends it out
+ * using nl_send_simple().
+ *
+ * @return 0 on success or a negative error code.
+ */
+int nl_rtgen_request(struct nl_sock *sk, int type, int family, int flags)
+{
+	struct rtgenmsg gmsg = {
+		.rtgen_family = family,
+	};
+
+	return nl_send_simple(sk, type, flags, &gmsg, sizeof(gmsg));
+}
+
+/** @} */
+
+/**
+ * @name Routing Type Translations
+ * @{
+ */
+
+static struct trans_tbl rtntypes[] = {
+	__ADD(RTN_UNSPEC,unspec)
+	__ADD(RTN_UNICAST,unicast)
+	__ADD(RTN_LOCAL,local)
+	__ADD(RTN_BROADCAST,broadcast)
+	__ADD(RTN_ANYCAST,anycast)
+	__ADD(RTN_MULTICAST,multicast)
+	__ADD(RTN_BLACKHOLE,blackhole)
+	__ADD(RTN_UNREACHABLE,unreachable)
+	__ADD(RTN_PROHIBIT,prohibit)
+	__ADD(RTN_THROW,throw)
+	__ADD(RTN_NAT,nat)
+	__ADD(RTN_XRESOLVE,xresolve)
+};
+
+char *nl_rtntype2str(int type, char *buf, size_t size)
+{
+	return __type2str(type, buf, size, rtntypes, ARRAY_SIZE(rtntypes));
+}
+
+int nl_str2rtntype(const char *name)
+{
+	return __str2type(name, rtntypes, ARRAY_SIZE(rtntypes));
+}
+
+/** @} */
+
+/**
+ * @name Scope Translations
+ * @{
+ */
+
+static struct trans_tbl scopes[] = {
+	__ADD(255,nowhere)
+	__ADD(254,host)
+	__ADD(253,link)
+	__ADD(200,site)
+	__ADD(0,universe)
+};
+
+char *rtnl_scope2str(int scope, char *buf, size_t size)
+{
+	return __type2str(scope, buf, size, scopes, ARRAY_SIZE(scopes));
+}
+
+int rtnl_str2scope(const char *name)
+{
+	return __str2type(name, scopes, ARRAY_SIZE(scopes));
+}
+
+/** @} */
+
+/**
+ * @name Realms Translations
+ * @{
+ */
+
+char * rtnl_realms2str(uint32_t realms, char *buf, size_t len)
+{
+	int from = RTNL_REALM_FROM(realms);
+	int to = RTNL_REALM_TO(realms);
+
+	snprintf(buf, len, "%d/%d", from, to);
+
+	return buf;
+}
+
+/** @} */
+
+/** @} */
diff -uNr libnl_kk/lib/route/rule.c libnl/lib/route/rule.c
--- libnl_kk/lib/route/rule.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/rule.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,797 @@
+/*
+ * lib/route/rule.c          Routing Rules
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup rtnl
+ * @defgroup rule Routing Rules
+ * @brief
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink/netlink.h>
+#include <netlink/utils.h>
+#include <netlink/route/rtnl.h>
+#include <netlink/route/rule.h>
+#include <inttypes.h>
+
+/** @cond SKIP */
+#define RULE_ATTR_FAMILY	0x0001
+#define RULE_ATTR_PRIO		0x0002
+#define RULE_ATTR_MARK		0x0004
+#define RULE_ATTR_IIF		0x0008
+#define RULE_ATTR_REALMS	0x0010
+#define RULE_ATTR_SRC		0x0020
+#define RULE_ATTR_DST		0x0040
+#define RULE_ATTR_DSFIELD	0x0080
+#define RULE_ATTR_TABLE		0x0100
+#define RULE_ATTR_TYPE		0x0200
+#define RULE_ATTR_SRC_LEN	0x0400
+#define RULE_ATTR_DST_LEN	0x0800
+#define RULE_ATTR_SRCMAP	0x1000
+
+static struct nl_cache_ops rtnl_rule_ops;
+static struct nl_object_ops rule_obj_ops;
+/** @endcond */
+
+static void rule_free_data(struct nl_object *c)
+{
+	struct rtnl_rule *rule = nl_object_priv(c);
+
+	if (!rule)
+		return;
+
+	nl_addr_put(rule->r_src);
+	nl_addr_put(rule->r_dst);
+}
+
+static int rule_clone(struct nl_object *_dst, struct nl_object *_src)
+{
+	struct rtnl_rule *dst = nl_object_priv(_dst);
+	struct rtnl_rule *src = nl_object_priv(_src);
+
+	if (src->r_src)
+		if (!(dst->r_src = nl_addr_clone(src->r_src)))
+			return -NLE_NOMEM;
+
+	if (src->r_dst)
+		if (!(dst->r_dst = nl_addr_clone(src->r_dst)))
+			return -NLE_NOMEM;
+
+	return 0;
+}
+
+static struct nla_policy rule_policy[RTA_MAX+1] = {
+	[RTA_PRIORITY]	= { .type = NLA_U32 },
+	[RTA_FLOW]	= { .type = NLA_U32 },
+	[RTA_PROTOINFO]	= { .type = NLA_U32 },
+	[RTA_IIF]	= { .type = NLA_STRING,
+			    .maxlen = IFNAMSIZ, },
+};
+
+static int rule_msg_parser(struct nl_cache_ops *ops, struct sockaddr_nl *who,
+			   struct nlmsghdr *n, struct nl_parser_param *pp)
+{
+	struct rtnl_rule *rule;
+	struct rtmsg *r;
+	struct nlattr *tb[RTA_MAX+1];
+	int err = 1, family;
+
+	rule = rtnl_rule_alloc();
+	if (!rule) {
+		err = -NLE_NOMEM;
+		goto errout;
+	}
+
+	rule->ce_msgtype = n->nlmsg_type;
+	r = nlmsg_data(n);
+
+	err = nlmsg_parse(n, sizeof(*r), tb, RTA_MAX, rule_policy);
+	if (err < 0)
+		goto errout;
+
+	rule->r_family = family = r->rtm_family;
+	rule->r_type = r->rtm_type;
+	rule->r_dsfield = r->rtm_tos;
+	rule->r_src_len = r->rtm_src_len;
+	rule->r_dst_len = r->rtm_dst_len;
+	rule->r_table = r->rtm_table;
+	rule->ce_mask = (RULE_ATTR_FAMILY | RULE_ATTR_TYPE | RULE_ATTR_DSFIELD |
+			 RULE_ATTR_SRC_LEN | RULE_ATTR_DST_LEN |RULE_ATTR_TYPE |
+			 RULE_ATTR_TABLE);
+
+	if (tb[RTA_PRIORITY]) {
+		rule->r_prio = nla_get_u32(tb[RTA_PRIORITY]);
+		rule->ce_mask |= RULE_ATTR_PRIO;
+	}
+
+	if (tb[RTA_SRC]) {
+		if (!(rule->r_src = nl_addr_alloc_attr(tb[RTA_SRC], family)))
+			goto errout_enomem;
+		nl_addr_set_prefixlen(rule->r_src, r->rtm_src_len);
+		rule->ce_mask |= RULE_ATTR_SRC;
+	}
+
+	if (tb[RTA_DST]) {
+		if (!(rule->r_dst = nl_addr_alloc_attr(tb[RTA_DST], family)))
+			goto errout_enomem;
+		nl_addr_set_prefixlen(rule->r_dst, r->rtm_dst_len);
+		rule->ce_mask |= RULE_ATTR_DST;
+	}
+
+	if (tb[RTA_PROTOINFO]) {
+		rule->r_mark = nla_get_u32(tb[RTA_PROTOINFO]);
+		rule->ce_mask |= RULE_ATTR_MARK;
+	}
+
+	if (tb[RTA_IIF]) {
+		nla_strlcpy(rule->r_iif, tb[RTA_IIF], IFNAMSIZ);
+		rule->ce_mask |= RULE_ATTR_IIF;
+	}
+
+	if (tb[RTA_FLOW]) {
+		rule->r_realms = nla_get_u32(tb[RTA_FLOW]);
+		rule->ce_mask |= RULE_ATTR_REALMS;
+	}
+
+	if (tb[RTA_GATEWAY]) {
+		rule->r_srcmap = nl_addr_alloc_attr(tb[RTA_GATEWAY], family);
+		if (!rule->r_srcmap)
+			goto errout_enomem;
+		rule->ce_mask |= RULE_ATTR_SRCMAP;
+	}
+
+	if (tb[RTA_TABLE]) {
+            rule->r_table = nla_get_u32(tb[RTA_TABLE]);
+            rule->ce_mask |= RULE_ATTR_TABLE;
+        }
+
+	err = pp->pp_cb((struct nl_object *) rule, pp);
+errout:
+	rtnl_rule_put(rule);
+	return err;
+
+errout_enomem:
+	err = -NLE_NOMEM;
+	goto errout;
+}
+
+static int rule_request_update(struct nl_cache *c, struct nl_sock *h)
+{
+	return nl_rtgen_request(h, RTM_GETRULE, AF_UNSPEC, NLM_F_DUMP);
+}
+
+static void rule_dump_line(struct nl_object *o, struct nl_dump_params *p)
+{
+	struct rtnl_rule *r = (struct rtnl_rule *) o;
+	char buf[128];
+
+	nl_dump_line(p, "%8d ", (r->ce_mask & RULE_ATTR_PRIO) ? r->r_prio : 0);
+	nl_dump(p, "%s ", nl_af2str(r->r_family, buf, sizeof(buf)));
+
+	if (r->ce_mask & RULE_ATTR_SRC)
+		nl_dump(p, "from %s ",
+			nl_addr2str(r->r_src, buf, sizeof(buf)));
+	else if (r->ce_mask & RULE_ATTR_SRC_LEN && r->r_src_len)
+		nl_dump(p, "from 0/%d ", r->r_src_len);
+
+	if (r->ce_mask & RULE_ATTR_DST)
+		nl_dump(p, "to %s ",
+			nl_addr2str(r->r_dst, buf, sizeof(buf)));
+	else if (r->ce_mask & RULE_ATTR_DST_LEN && r->r_dst_len)
+		nl_dump(p, "to 0/%d ", r->r_dst_len);
+
+	if (r->ce_mask & RULE_ATTR_DSFIELD && r->r_dsfield)
+		nl_dump(p, "tos %d ", r->r_dsfield);
+
+	if (r->ce_mask & RULE_ATTR_MARK)
+		nl_dump(p, "mark %" PRIx64 , r->r_mark);
+
+	if (r->ce_mask & RULE_ATTR_IIF)
+		nl_dump(p, "iif %s ", r->r_iif);
+
+	if (r->ce_mask & RULE_ATTR_TABLE)
+		nl_dump(p, "lookup %s ",
+			rtnl_route_table2str(r->r_table, buf, sizeof(buf)));
+
+	if (r->ce_mask & RULE_ATTR_REALMS)
+		nl_dump(p, "realms %s ",
+			rtnl_realms2str(r->r_realms, buf, sizeof(buf)));
+
+	nl_dump(p, "action %s\n",
+		nl_rtntype2str(r->r_type, buf, sizeof(buf)));
+}
+
+static void rule_dump_details(struct nl_object *obj, struct nl_dump_params *p)
+{
+	struct rtnl_rule *rule = (struct rtnl_rule *) obj;
+	char buf[128];
+
+	rule_dump_line(obj, p);
+
+	if (rule->ce_mask & RULE_ATTR_SRCMAP)
+		nl_dump_line(p, "  srcmap %s\n",
+			nl_addr2str(rule->r_srcmap, buf, sizeof(buf)));
+}
+
+static void rule_dump_stats(struct nl_object *obj, struct nl_dump_params *p)
+{
+	rule_dump_details(obj, p);
+}
+
+static void rule_dump_env(struct nl_object *obj, struct nl_dump_params *p)
+{
+	struct rtnl_rule *rule = (struct rtnl_rule *) obj;
+	char buf[128];
+
+	nl_dump_line(p, "RULE_PRIORITY=%u\n", rule->r_prio);
+	nl_dump_line(p, "RULE_FAMILY=%s\n",
+		     nl_af2str(rule->r_family, buf, sizeof(buf)));
+
+	if (rule->ce_mask & RULE_ATTR_DST)
+		nl_dump_line(p, "RULE_DST=%s\n",
+			     nl_addr2str(rule->r_dst, buf, sizeof(buf)));
+
+	if (rule->ce_mask & RULE_ATTR_DST_LEN)
+		nl_dump_line(p, "RULE_DSTLEN=%u\n", rule->r_dst_len);
+
+	if (rule->ce_mask & RULE_ATTR_SRC)
+		nl_dump_line(p, "RULE_SRC=%s\n",
+			     nl_addr2str(rule->r_src, buf, sizeof(buf)));
+
+	if (rule->ce_mask & RULE_ATTR_SRC_LEN)
+		nl_dump_line(p, "RULE_SRCLEN=%u\n", rule->r_src_len);
+
+	if (rule->ce_mask & RULE_ATTR_IIF)
+		nl_dump_line(p, "RULE_IIF=%s\n", rule->r_iif);
+
+	if (rule->ce_mask & RULE_ATTR_TABLE)
+		nl_dump_line(p, "RULE_TABLE=%u\n", rule->r_table);
+
+	if (rule->ce_mask & RULE_ATTR_REALMS)
+		nl_dump_line(p, "RULE_REALM=%u\n", rule->r_realms);
+
+	if (rule->ce_mask & RULE_ATTR_MARK)
+		nl_dump_line(p, "RULE_MARK=0x%" PRIx64 "\n", rule->r_mark);
+
+	if (rule->ce_mask & RULE_ATTR_DSFIELD)
+		nl_dump_line(p, "RULE_DSFIELD=%u\n", rule->r_dsfield);
+
+	if (rule->ce_mask & RULE_ATTR_TYPE)
+		nl_dump_line(p, "RULE_TYPE=%s\n",
+			     nl_rtntype2str(rule->r_type, buf, sizeof(buf)));
+
+	if (rule->ce_mask & RULE_ATTR_SRCMAP)
+		nl_dump_line(p, "RULE_SRCMAP=%s\n",
+			     nl_addr2str(rule->r_srcmap, buf, sizeof(buf)));
+}
+
+static int rule_compare(struct nl_object *_a, struct nl_object *_b,
+			uint32_t attrs, int flags)
+{
+	struct rtnl_rule *a = (struct rtnl_rule *) _a;
+	struct rtnl_rule *b = (struct rtnl_rule *) _b;
+	int diff = 0;
+
+#define RULE_DIFF(ATTR, EXPR) ATTR_DIFF(attrs, RULE_ATTR_##ATTR, a, b, EXPR)
+
+	diff |= RULE_DIFF(FAMILY,	a->r_family != b->r_family);
+	diff |= RULE_DIFF(TABLE,	a->r_table != b->r_table);
+	diff |= RULE_DIFF(REALMS,	a->r_realms != b->r_realms);
+	diff |= RULE_DIFF(DSFIELD,	a->r_dsfield != b->r_dsfield);
+	diff |= RULE_DIFF(TYPE,		a->r_type != b->r_type);
+	diff |= RULE_DIFF(PRIO,		a->r_prio != b->r_prio);
+	diff |= RULE_DIFF(MARK,		a->r_mark != b->r_mark);
+	diff |= RULE_DIFF(SRC_LEN,	a->r_src_len != b->r_src_len);
+	diff |= RULE_DIFF(DST_LEN,	a->r_dst_len != b->r_dst_len);
+	diff |= RULE_DIFF(SRC,		nl_addr_cmp(a->r_src, b->r_src));
+	diff |= RULE_DIFF(DST,		nl_addr_cmp(a->r_dst, b->r_dst));
+	diff |= RULE_DIFF(IIF,		strcmp(a->r_iif, b->r_iif));
+	
+#undef RULE_DIFF
+
+	return diff;
+}
+
+static struct trans_tbl rule_attrs[] = {
+	__ADD(RULE_ATTR_FAMILY, family)
+	__ADD(RULE_ATTR_PRIO, prio)
+	__ADD(RULE_ATTR_MARK, mark)
+	__ADD(RULE_ATTR_IIF, iif)
+	__ADD(RULE_ATTR_REALMS, realms)
+	__ADD(RULE_ATTR_SRC, src)
+	__ADD(RULE_ATTR_DST, dst)
+	__ADD(RULE_ATTR_DSFIELD, dsfield)
+	__ADD(RULE_ATTR_TABLE, table)
+	__ADD(RULE_ATTR_TYPE, type)
+	__ADD(RULE_ATTR_SRC_LEN, src_len)
+	__ADD(RULE_ATTR_DST_LEN, dst_len)
+	__ADD(RULE_ATTR_SRCMAP, srcmap)
+};
+
+static char *rule_attrs2str(int attrs, char *buf, size_t len)
+{
+	return __flags2str(attrs, buf, len, rule_attrs,
+			   ARRAY_SIZE(rule_attrs));
+}
+
+/**
+ * @name Allocation/Freeing
+ * @{
+ */
+
+struct rtnl_rule *rtnl_rule_alloc(void)
+{
+	return (struct rtnl_rule *) nl_object_alloc(&rule_obj_ops);
+}
+
+void rtnl_rule_put(struct rtnl_rule *rule)
+{
+	nl_object_put((struct nl_object *) rule);
+}
+
+/** @} */
+
+/**
+ * @name Cache Management
+ * @{
+ */
+
+/**
+ * Build a rule cache including all rules currently configured in the kernel.
+ * @arg sk		Netlink socket.
+ * @arg family		Address family or AF_UNSPEC.
+ * @arg result		Pointer to store resulting cache.
+ *
+ * Allocates a new rule cache, initializes it properly and updates it
+ * to include all rules currently configured in the kernel.
+ *
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_rule_alloc_cache(struct nl_sock *sock, int family,
+			  struct nl_cache **result)
+{
+	struct nl_cache * cache;
+	int err;
+
+	if (!(cache = nl_cache_alloc(&rtnl_rule_ops)))
+		return -NLE_NOMEM;
+
+	cache->c_iarg1 = family;
+
+	if (sock && (err = nl_cache_refill(sock, cache)) < 0) {
+		free(cache);
+		return err;
+	}
+
+	*result = cache;
+	return 0;
+}
+
+/** @} */
+
+/**
+ * @name Rule Addition
+ * @{
+ */
+
+static int build_rule_msg(struct rtnl_rule *tmpl, int cmd, int flags,
+			  struct nl_msg **result)
+{
+	struct nl_msg *msg;
+	struct rtmsg rtm = {
+		.rtm_type = RTN_UNSPEC
+	};
+
+	if (cmd == RTM_NEWRULE)
+		rtm.rtm_type = RTN_UNICAST;
+		
+	if (tmpl->ce_mask & RULE_ATTR_FAMILY)
+		rtm.rtm_family = tmpl->r_family;
+
+	if (tmpl->ce_mask & RULE_ATTR_TABLE)
+		rtm.rtm_table = tmpl->r_table;
+
+	if (tmpl->ce_mask & RULE_ATTR_DSFIELD)
+		rtm.rtm_tos = tmpl->r_dsfield;
+
+	if (tmpl->ce_mask & RULE_ATTR_TYPE)
+		rtm.rtm_type = tmpl->r_type;
+
+	if (tmpl->ce_mask & RULE_ATTR_SRC_LEN)
+		rtm.rtm_src_len = tmpl->r_src_len;
+
+	if (tmpl->ce_mask & RULE_ATTR_DST_LEN)
+		rtm.rtm_dst_len = tmpl->r_dst_len;
+
+	msg = nlmsg_alloc_simple(cmd, flags);
+	if (!msg)
+		return -NLE_NOMEM;
+
+	if (nlmsg_append(msg, &rtm, sizeof(rtm), NLMSG_ALIGNTO) < 0)
+		goto nla_put_failure;
+
+	if (tmpl->ce_mask & RULE_ATTR_SRC)
+		NLA_PUT_ADDR(msg, RTA_SRC, tmpl->r_src);
+
+	if (tmpl->ce_mask & RULE_ATTR_DST)
+		NLA_PUT_ADDR(msg, RTA_DST, tmpl->r_dst);
+
+	if (tmpl->ce_mask & RULE_ATTR_PRIO)
+		NLA_PUT_U32(msg, RTA_PRIORITY, tmpl->r_prio);
+
+	if (tmpl->ce_mask & RULE_ATTR_MARK)
+		NLA_PUT_U32(msg, RTA_PROTOINFO, tmpl->r_mark);
+
+	if (tmpl->ce_mask & RULE_ATTR_REALMS)
+		NLA_PUT_U32(msg, RTA_FLOW, tmpl->r_realms);
+
+	if (tmpl->ce_mask & RULE_ATTR_IIF)
+		NLA_PUT_STRING(msg, RTA_IIF, tmpl->r_iif);
+
+	*result = msg;
+	return 0;
+
+nla_put_failure:
+	nlmsg_free(msg);
+	return -NLE_MSGSIZE;
+}
+
+/**
+ * Build netlink request message to add a new rule
+ * @arg tmpl		template with data of new rule
+ * @arg flags		additional netlink message flags
+ *
+ * Builds a new netlink message requesting a addition of a new
+ * rule. The netlink message header isn't fully equipped with
+ * all relevant fields and must thus be sent out via nl_send_auto_complete()
+ * or supplemented as needed. \a tmpl must contain the attributes of the new
+ * address set via \c rtnl_rule_set_* functions.
+ * 
+ * @return The netlink message
+ */
+int rtnl_rule_build_add_request(struct rtnl_rule *tmpl, int flags,
+				struct nl_msg **result)
+{
+	return build_rule_msg(tmpl, RTM_NEWRULE, NLM_F_CREATE | flags,
+			      result);
+}
+
+/**
+ * Add a new rule
+ * @arg sk		Netlink socket.
+ * @arg tmpl		template with requested changes
+ * @arg flags		additional netlink message flags
+ *
+ * Builds a netlink message by calling rtnl_rule_build_add_request(),
+ * sends the request to the kernel and waits for the next ACK to be
+ * received and thus blocks until the request has been fullfilled.
+ *
+ * @return 0 on sucess or a negative error if an error occured.
+ */
+int rtnl_rule_add(struct nl_sock *sk, struct rtnl_rule *tmpl, int flags)
+{
+	struct nl_msg *msg;
+	int err;
+	
+	if ((err = rtnl_rule_build_add_request(tmpl, flags, &msg)) < 0)
+		return err;
+
+	err = nl_send_auto_complete(sk, msg);
+	nlmsg_free(msg);
+	if (err < 0)
+		return err;
+
+	return wait_for_ack(sk);
+}
+
+/** @} */
+
+/**
+ * @name Rule Deletion
+ * @{
+ */
+
+/**
+ * Build a netlink request message to delete a rule
+ * @arg rule		rule to delete
+ * @arg flags		additional netlink message flags
+ *
+ * Builds a new netlink message requesting a deletion of a rule.
+ * The netlink message header isn't fully equipped with all relevant
+ * fields and must thus be sent out via nl_send_auto_complete()
+ * or supplemented as needed. \a rule must point to an existing
+ * address.
+ *
+ * @return The netlink message
+ */
+int rtnl_rule_build_delete_request(struct rtnl_rule *rule, int flags,
+				   struct nl_msg **result)
+{
+	return build_rule_msg(rule, RTM_DELRULE, flags, result);
+}
+
+/**
+ * Delete a rule
+ * @arg sk		Netlink socket.
+ * @arg rule		rule to delete
+ * @arg flags		additional netlink message flags
+ *
+ * Builds a netlink message by calling rtnl_rule_build_delete_request(),
+ * sends the request to the kernel and waits for the next ACK to be
+ * received and thus blocks until the request has been fullfilled.
+ *
+ * @return 0 on sucess or a negative error if an error occured.
+ */
+int rtnl_rule_delete(struct nl_sock *sk, struct rtnl_rule *rule, int flags)
+{
+	struct nl_msg *msg;
+	int err;
+	
+	if ((err = rtnl_rule_build_delete_request(rule, flags, &msg)) < 0)
+		return err;
+
+	err = nl_send_auto_complete(sk, msg);
+	nlmsg_free(msg);
+	if (err < 0)
+		return err;
+
+	return wait_for_ack(sk);
+}
+
+/** @} */
+
+/**
+ * @name Attribute Modification
+ * @{
+ */
+
+void rtnl_rule_set_family(struct rtnl_rule *rule, int family)
+{
+	rule->r_family = family;
+	rule->ce_mask |= RULE_ATTR_FAMILY;
+}
+
+int rtnl_rule_get_family(struct rtnl_rule *rule)
+{
+	if (rule->ce_mask & RULE_ATTR_FAMILY)
+		return rule->r_family;
+	else
+		return AF_UNSPEC;
+}
+
+void rtnl_rule_set_prio(struct rtnl_rule *rule, int prio)
+{
+	rule->r_prio = prio;
+	rule->ce_mask |= RULE_ATTR_PRIO;
+}
+
+int rtnl_rule_get_prio(struct rtnl_rule *rule)
+{
+	if (rule->ce_mask & RULE_ATTR_PRIO)
+		return rule->r_prio;
+	else
+		return -1;
+}
+
+void rtnl_rule_set_mark(struct rtnl_rule *rule, uint64_t mark)
+{
+	rule->r_mark = mark;
+	rule->ce_mask |= RULE_ATTR_MARK;
+}
+
+uint64_t rtnl_rule_get_mark(struct rtnl_rule *rule)
+{
+	if (rule->ce_mask & RULE_ATTR_MARK)
+		return rule->r_mark;
+	else
+		return UINT_LEAST64_MAX;
+}
+
+void rtnl_rule_set_table(struct rtnl_rule *rule, int table)
+{
+	rule->r_table = table;
+	rule->ce_mask |= RULE_ATTR_TABLE;
+}
+
+int rtnl_rule_get_table(struct rtnl_rule *rule)
+{
+	if (rule->ce_mask & RULE_ATTR_TABLE)
+		return rule->r_table;
+	else
+		return -1;
+}
+
+void rtnl_rule_set_dsfield(struct rtnl_rule *rule, int dsfield)
+{
+	rule->r_dsfield = dsfield;
+	rule->ce_mask |= RULE_ATTR_DSFIELD;
+}
+
+int rtnl_rule_get_dsfield(struct rtnl_rule *rule)
+{
+	if (rule->ce_mask & RULE_ATTR_DSFIELD)
+		return rule->r_dsfield;
+	else
+		return -1;
+}
+
+void rtnl_rule_set_src_len(struct rtnl_rule *rule, int len)
+{
+	rule->r_src_len = len;
+	if (rule->ce_mask & RULE_ATTR_SRC)
+		nl_addr_set_prefixlen(rule->r_src, len);
+	rule->ce_mask |= RULE_ATTR_SRC_LEN;
+}
+
+int rtnl_rule_get_src_len(struct rtnl_rule *rule)
+{
+	if (rule->ce_mask & RULE_ATTR_SRC_LEN)
+		return rule->r_src_len;
+	else
+		return -1;
+}
+
+void rtnl_rule_set_dst_len(struct rtnl_rule *rule, int len)
+{
+	rule->r_dst_len = len;
+	if (rule->ce_mask & RULE_ATTR_DST)
+		nl_addr_set_prefixlen(rule->r_dst, len);
+	rule->ce_mask |= RULE_ATTR_DST_LEN;
+}
+
+int rtnl_rule_get_dst_len(struct rtnl_rule *rule)
+{
+	if (rule->ce_mask & RULE_ATTR_DST_LEN)
+		return rule->r_dst_len;
+	else
+		return -1;
+}
+
+static inline int __assign_addr(struct rtnl_rule *rule, struct nl_addr **pos,
+			        struct nl_addr *new, uint8_t *len, int flag)
+{
+	if (rule->ce_mask & RULE_ATTR_FAMILY) {
+		if (new->a_family != rule->r_family)
+			return -NLE_AF_MISMATCH;
+	} else
+		rule->r_family = new->a_family;
+
+	if (*pos)
+		nl_addr_put(*pos);
+
+	nl_addr_get(new);
+	*pos = new;
+	*len = nl_addr_get_prefixlen(new);
+
+	rule->ce_mask |= (flag | RULE_ATTR_FAMILY);
+
+	return 0;
+}
+
+int rtnl_rule_set_src(struct rtnl_rule *rule, struct nl_addr *src)
+{
+	return __assign_addr(rule, &rule->r_src, src, &rule->r_src_len,
+			     RULE_ATTR_SRC | RULE_ATTR_SRC_LEN);
+}
+
+struct nl_addr *rtnl_rule_get_src(struct rtnl_rule *rule)
+{
+	if (rule->ce_mask & RULE_ATTR_SRC)
+		return rule->r_src;
+	else
+		return NULL;
+}
+
+int rtnl_rule_set_dst(struct rtnl_rule *rule, struct nl_addr *dst)
+{
+	return __assign_addr(rule, &rule->r_dst, dst, &rule->r_dst_len,
+			     RULE_ATTR_DST | RULE_ATTR_DST_LEN);
+}
+
+struct nl_addr *rtnl_rule_get_dst(struct rtnl_rule *rule)
+{
+	if (rule->ce_mask & RULE_ATTR_DST)
+		return rule->r_dst;
+	else
+		return NULL;
+}
+
+int rtnl_rule_set_iif(struct rtnl_rule *rule, const char *dev)
+{
+	if (strlen(dev) > IFNAMSIZ-1)
+		return -NLE_RANGE;
+
+	strcpy(rule->r_iif, dev);
+	rule->ce_mask |= RULE_ATTR_IIF;
+	return 0;
+}
+
+char *rtnl_rule_get_iif(struct rtnl_rule *rule)
+{
+	if (rule->ce_mask & RULE_ATTR_IIF)
+		return rule->r_iif;
+	else
+		return NULL;
+}
+
+void rtnl_rule_set_action(struct rtnl_rule *rule, int type)
+{
+	rule->r_type = type;
+	rule->ce_mask |= RULE_ATTR_TYPE;
+}
+
+int rtnl_rule_get_action(struct rtnl_rule *rule)
+{
+	if (rule->ce_mask & RULE_ATTR_TYPE)
+		return rule->r_type;
+	else
+		return -NLE_NOATTR;
+}
+
+void rtnl_rule_set_realms(struct rtnl_rule *rule, uint32_t realms)
+{
+	rule->r_realms = realms;
+	rule->ce_mask |= RULE_ATTR_REALMS;
+}
+
+uint32_t rtnl_rule_get_realms(struct rtnl_rule *rule)
+{
+	if (rule->ce_mask & RULE_ATTR_REALMS)
+		return rule->r_realms;
+	else
+		return 0;
+}
+
+/** @} */
+
+static struct nl_object_ops rule_obj_ops = {
+	.oo_name		= "route/rule",
+	.oo_size		= sizeof(struct rtnl_rule),
+	.oo_free_data		= rule_free_data,
+	.oo_clone		= rule_clone,
+	.oo_dump = {
+	    [NL_DUMP_LINE]	= rule_dump_line,
+	    [NL_DUMP_DETAILS]	= rule_dump_details,
+	    [NL_DUMP_STATS]	= rule_dump_stats,
+	    [NL_DUMP_ENV]	= rule_dump_env,
+	},
+	.oo_compare		= rule_compare,
+	.oo_attrs2str		= rule_attrs2str,
+	.oo_id_attrs		= ~0,
+};
+
+static struct nl_cache_ops rtnl_rule_ops = {
+	.co_name		= "route/rule",
+	.co_hdrsize		= sizeof(struct rtmsg),
+	.co_msgtypes		= {
+					{ RTM_NEWRULE, NL_ACT_NEW, "new" },
+					{ RTM_DELRULE, NL_ACT_DEL, "del" },
+					{ RTM_GETRULE, NL_ACT_GET, "get" },
+					END_OF_MSGTYPES_LIST,
+				  },
+	.co_protocol		= NETLINK_ROUTE,
+	.co_request_update	= rule_request_update,
+	.co_msg_parser		= rule_msg_parser,
+	.co_obj_ops		= &rule_obj_ops,
+};
+
+static void __init rule_init(void)
+{
+	nl_cache_mngt_register(&rtnl_rule_ops);
+}
+
+static void __exit rule_exit(void)
+{
+	nl_cache_mngt_unregister(&rtnl_rule_ops);
+}
+
+/** @} */
diff -uNr libnl_kk/lib/route/sch/blackhole.c libnl/lib/route/sch/blackhole.c
--- libnl_kk/lib/route/sch/blackhole.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/sch/blackhole.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,38 @@
+/*
+ * lib/route/sch/blackhole.c	Blackhole Qdisc
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2006 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup qdisc_api
+ * @defgroup blackhole Blackhole
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink-tc.h>
+#include <netlink/netlink.h>
+#include <netlink/route/qdisc.h>
+#include <netlink/route/qdisc-modules.h>
+
+static struct rtnl_qdisc_ops blackhole_ops = {
+	.qo_kind		= "blackhole",
+};
+
+static void __init blackhole_init(void)
+{
+	rtnl_qdisc_register(&blackhole_ops);
+}
+
+static void __exit blackhole_exit(void)
+{
+	rtnl_qdisc_unregister(&blackhole_ops);
+}
+
+/** @} */
diff -uNr libnl_kk/lib/route/sch/cbq.c libnl/lib/route/sch/cbq.c
--- libnl_kk/lib/route/sch/cbq.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/sch/cbq.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,298 @@
+/*
+ * lib/route/sch/cbq.c	Class Based Queueing
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+#include <netlink-local.h>
+#include <netlink-tc.h>
+#include <netlink/netlink.h>
+#include <netlink/utils.h>
+#include <netlink/route/qdisc.h>
+#include <netlink/route/qdisc-modules.h>
+#include <netlink/route/class.h>
+#include <netlink/route/class-modules.h>
+#include <netlink/route/link.h>
+#include <netlink/route/sch/cbq.h>
+#include <netlink/route/cls/police.h>
+
+/**
+ * @ingroup qdisc_api
+ * @ingroup class_api
+ * @defgroup cbq Class Based Queueing (CBQ)
+ * @{
+ */
+
+static struct trans_tbl ovl_strategies[] = {
+	__ADD(TC_CBQ_OVL_CLASSIC,classic)
+	__ADD(TC_CBQ_OVL_DELAY,delay)
+	__ADD(TC_CBQ_OVL_LOWPRIO,lowprio)
+	__ADD(TC_CBQ_OVL_DROP,drop)
+	__ADD(TC_CBQ_OVL_RCLASSIC,rclassic)
+};
+
+/**
+ * Convert a CBQ OVL strategy to a character string
+ * @arg type		CBQ OVL strategy
+ * @arg buf		destination buffer
+ * @arg len		length of destination buffer
+ *
+ * Converts a CBQ OVL strategy to a character string and stores in the
+ * provided buffer. Returns the destination buffer or the type
+ * encoded in hex if no match was found.
+ */
+char *nl_ovl_strategy2str(int type, char *buf, size_t len)
+{
+	return __type2str(type, buf, len, ovl_strategies,
+			    ARRAY_SIZE(ovl_strategies));
+}
+
+/**
+ * Convert a string to a CBQ OVL strategy
+ * @arg name		CBQ OVL stragegy name
+ *
+ * Converts a CBQ OVL stragegy name to it's corresponding CBQ OVL strategy
+ * type. Returns the type or -1 if none was found.
+ */
+int nl_str2ovl_strategy(const char *name)
+{
+	return __str2type(name, ovl_strategies, ARRAY_SIZE(ovl_strategies));
+}
+
+static struct nla_policy cbq_policy[TCA_CBQ_MAX+1] = {
+	[TCA_CBQ_LSSOPT]	= { .minlen = sizeof(struct tc_cbq_lssopt) },
+	[TCA_CBQ_RATE]		= { .minlen = sizeof(struct tc_ratespec) },
+	[TCA_CBQ_WRROPT]	= { .minlen = sizeof(struct tc_cbq_wrropt) },
+	[TCA_CBQ_OVL_STRATEGY]	= { .minlen = sizeof(struct tc_cbq_ovl) },
+	[TCA_CBQ_FOPT]		= { .minlen = sizeof(struct tc_cbq_fopt) },
+	[TCA_CBQ_POLICE]	= { .minlen = sizeof(struct tc_cbq_police) },
+};
+
+static inline struct rtnl_cbq *cbq_qdisc(struct rtnl_tca *tca)
+{
+	return (struct rtnl_cbq *) tca->tc_subdata;
+}
+
+static inline struct rtnl_cbq *cbq_alloc(struct rtnl_tca *tca)
+{
+	if (!tca->tc_subdata)
+		tca->tc_subdata = calloc(1, sizeof(struct rtnl_qdisc));
+
+	return cbq_qdisc(tca);
+}
+
+
+static int cbq_msg_parser(struct rtnl_tca *tca)
+{
+	struct nlattr *tb[TCA_CBQ_MAX + 1];
+	struct rtnl_cbq *cbq;
+	int err;
+
+	err = tca_parse(tb, TCA_CBQ_MAX, tca, cbq_policy);
+	if (err < 0)
+		return err;
+
+	cbq = cbq_alloc(tca);
+	if (!cbq)
+		return -NLE_NOMEM;
+
+	nla_memcpy(&cbq->cbq_lss, tb[TCA_CBQ_LSSOPT], sizeof(cbq->cbq_lss));
+	nla_memcpy(&cbq->cbq_rate, tb[TCA_CBQ_RATE], sizeof(cbq->cbq_rate));
+	nla_memcpy(&cbq->cbq_wrr, tb[TCA_CBQ_WRROPT], sizeof(cbq->cbq_wrr));
+	nla_memcpy(&cbq->cbq_fopt, tb[TCA_CBQ_FOPT], sizeof(cbq->cbq_fopt));
+	nla_memcpy(&cbq->cbq_ovl, tb[TCA_CBQ_OVL_STRATEGY],
+		   sizeof(cbq->cbq_ovl));
+	nla_memcpy(&cbq->cbq_police, tb[TCA_CBQ_POLICE],
+		    sizeof(cbq->cbq_police));
+	
+	return 0;
+}
+
+static int cbq_qdisc_msg_parser(struct rtnl_qdisc *qdisc)
+{
+	return cbq_msg_parser((struct rtnl_tca *) qdisc);
+}
+
+static int cbq_class_msg_parser(struct rtnl_class *class)
+{
+	return cbq_msg_parser((struct rtnl_tca *) class);
+}
+
+static void cbq_qdisc_free_data(struct rtnl_qdisc *qdisc)
+{
+	free(qdisc->q_subdata);
+}
+
+static int cbq_clone(struct rtnl_tca *_dst, struct rtnl_tca *_src)
+{
+	struct rtnl_cbq *src = cbq_qdisc(_src);
+
+	if (src && !cbq_alloc(_dst))
+		return -NLE_NOMEM;
+	else
+		return 0;
+}
+
+static int cbq_qdisc_clone(struct rtnl_qdisc *dst, struct rtnl_qdisc *src)
+{
+	return cbq_clone((struct rtnl_tca *) dst, (struct rtnl_tca *) src);
+}
+
+static void cbq_class_free_data(struct rtnl_class *class)
+{
+	free(class->c_subdata);
+}
+
+static int cbq_class_clone(struct rtnl_class *dst, struct rtnl_class *src)
+{
+	return cbq_clone((struct rtnl_tca *) dst, (struct rtnl_tca *) src);
+}
+
+static void cbq_dump_line(struct rtnl_tca *tca, struct nl_dump_params *p)
+{
+	struct rtnl_cbq *cbq;
+	double r, rbit;
+	char *ru, *rubit;
+
+	cbq = cbq_qdisc(tca);
+	if (!cbq)
+		return;
+
+	r = nl_cancel_down_bytes(cbq->cbq_rate.rate, &ru);
+	rbit = nl_cancel_down_bits(cbq->cbq_rate.rate * 8, &rubit);
+
+	nl_dump(p, " rate %.2f%s/s (%.0f%s) prio %u",
+		r, ru, rbit, rubit, cbq->cbq_wrr.priority);
+}
+
+static void cbq_qdisc_dump_line(struct rtnl_qdisc *qdisc,
+				struct nl_dump_params *p)
+{
+	cbq_dump_line((struct rtnl_tca *) qdisc, p);
+}
+
+static void cbq_class_dump_line(struct rtnl_class *class,
+				struct nl_dump_params *p)
+{
+	cbq_dump_line((struct rtnl_tca *) class, p);
+}
+
+static void cbq_dump_details(struct rtnl_tca *tca, struct nl_dump_params *p)
+{
+	struct rtnl_cbq *cbq;
+	char *unit, buf[32];
+	double w;
+	uint32_t el;
+
+	cbq = cbq_qdisc(tca);
+	if (!cbq)
+		return;
+
+	w = nl_cancel_down_bits(cbq->cbq_wrr.weight * 8, &unit);
+
+	nl_dump(p, "avgpkt %u mpu %u cell %u allot %u weight %.0f%s\n",
+		cbq->cbq_lss.avpkt,
+		cbq->cbq_rate.mpu,
+		1 << cbq->cbq_rate.cell_log,
+		cbq->cbq_wrr.allot, w, unit);
+
+	el = cbq->cbq_lss.ewma_log;
+	nl_dump_line(p, "  minidle %uus maxidle %uus offtime "
+				"%uus level %u ewma_log %u\n",
+		nl_ticks2us(cbq->cbq_lss.minidle >> el),
+		nl_ticks2us(cbq->cbq_lss.maxidle >> el),
+		nl_ticks2us(cbq->cbq_lss.offtime >> el),
+		cbq->cbq_lss.level,
+		cbq->cbq_lss.ewma_log);
+
+	nl_dump_line(p, "  penalty %uus strategy %s ",
+		nl_ticks2us(cbq->cbq_ovl.penalty),
+		nl_ovl_strategy2str(cbq->cbq_ovl.strategy, buf, sizeof(buf)));
+
+	nl_dump(p, "split %s defmap 0x%08x ",
+		rtnl_tc_handle2str(cbq->cbq_fopt.split, buf, sizeof(buf)),
+		cbq->cbq_fopt.defmap);
+	
+	nl_dump(p, "police %s",
+		nl_police2str(cbq->cbq_police.police, buf, sizeof(buf)));
+}
+
+static void cbq_qdisc_dump_details(struct rtnl_qdisc *qdisc,
+				   struct nl_dump_params *p)
+{
+	cbq_dump_details((struct rtnl_tca *) qdisc, p);
+}
+
+static void cbq_class_dump_details(struct rtnl_class *class,
+				   struct nl_dump_params *p)
+{
+	cbq_dump_details((struct rtnl_tca *) class, p);
+}
+
+static void cbq_dump_stats(struct rtnl_tca *tca, struct nl_dump_params *p)
+{
+	struct tc_cbq_xstats *x = tca_xstats(tca);
+
+	if (!x)
+		return;
+
+	nl_dump_line(p, "            borrows    overact  "
+			"  avgidle  undertime\n");
+	nl_dump_line(p, "         %10u %10u %10u %10u\n",
+		     x->borrows, x->overactions, x->avgidle, x->undertime);
+}
+
+static void cbq_qdisc_dump_stats(struct rtnl_qdisc *qdisc,
+				 struct nl_dump_params *p)
+{
+	cbq_dump_stats((struct rtnl_tca *) qdisc, p);
+}
+
+static void cbq_class_dump_stats(struct rtnl_class *class,
+				 struct nl_dump_params *p)
+{
+	cbq_dump_stats((struct rtnl_tca *) class, p);
+}
+
+static struct rtnl_qdisc_ops cbq_qdisc_ops = {
+	.qo_kind		= "cbq",
+	.qo_msg_parser		= cbq_qdisc_msg_parser,
+	.qo_free_data		= cbq_qdisc_free_data,
+	.qo_clone		= cbq_qdisc_clone,
+	.qo_dump = {
+	    [NL_DUMP_LINE]	= cbq_qdisc_dump_line,
+	    [NL_DUMP_DETAILS]	= cbq_qdisc_dump_details,
+	    [NL_DUMP_STATS]	= cbq_qdisc_dump_stats,
+	},
+};
+
+static struct rtnl_class_ops cbq_class_ops = {
+	.co_kind		= "cbq",
+	.co_msg_parser		= cbq_class_msg_parser,
+	.co_free_data		= cbq_class_free_data,
+	.co_clone		= cbq_class_clone,
+	.co_dump = {
+	    [NL_DUMP_LINE]	= cbq_class_dump_line,
+	    [NL_DUMP_DETAILS]	= cbq_class_dump_details,
+	    [NL_DUMP_STATS]	= cbq_class_dump_stats,
+	},
+};
+
+static void __init cbq_init(void)
+{
+	rtnl_qdisc_register(&cbq_qdisc_ops);
+	rtnl_class_register(&cbq_class_ops);
+}
+
+static void __exit cbq_exit(void)
+{
+	rtnl_qdisc_unregister(&cbq_qdisc_ops);
+	rtnl_class_unregister(&cbq_class_ops);
+}
+
+/** @} */
diff -uNr libnl_kk/lib/route/sch/dsmark.c libnl/lib/route/sch/dsmark.c
--- libnl_kk/lib/route/sch/dsmark.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/sch/dsmark.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,453 @@
+/*
+ * lib/route/sch/dsmark.c	DSMARK
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup qdisc_api
+ * @ingroup class_api
+ * @defgroup dsmark Differentiated Services Marker (DSMARK)
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink-tc.h>
+#include <netlink/netlink.h>
+#include <netlink/utils.h>
+#include <netlink/route/qdisc.h>
+#include <netlink/route/qdisc-modules.h>
+#include <netlink/route/class.h>
+#include <netlink/route/class-modules.h>
+#include <netlink/route/sch/dsmark.h>
+
+/** @cond SKIP */
+#define SCH_DSMARK_ATTR_INDICES		0x1
+#define SCH_DSMARK_ATTR_DEFAULT_INDEX	0x2
+#define SCH_DSMARK_ATTR_SET_TC_INDEX	0x4
+
+#define SCH_DSMARK_ATTR_MASK		0x1
+#define SCH_DSMARK_ATTR_VALUE		0x2
+/** @endcond */
+
+static inline struct rtnl_dsmark_qdisc *dsmark_qdisc(struct rtnl_qdisc *qdisc)
+{
+	return (struct rtnl_dsmark_qdisc *) qdisc->q_subdata;
+}
+
+static inline struct rtnl_dsmark_qdisc *
+dsmark_qdisc_alloc(struct rtnl_qdisc *qdisc)
+{
+	if (!qdisc->q_subdata)
+		qdisc->q_subdata = calloc(1, sizeof(struct rtnl_dsmark_qdisc));
+
+	return dsmark_qdisc(qdisc);
+}
+
+static struct nla_policy dsmark_policy[TCA_DSMARK_MAX+1] = {
+	[TCA_DSMARK_INDICES]		= { .type = NLA_U16 },
+	[TCA_DSMARK_DEFAULT_INDEX]	= { .type = NLA_U16 },
+	[TCA_DSMARK_SET_TC_INDEX]	= { .type = NLA_FLAG },
+	[TCA_DSMARK_VALUE]		= { .type = NLA_U8 },
+	[TCA_DSMARK_MASK]		= { .type = NLA_U8 },
+};
+
+static int dsmark_qdisc_msg_parser(struct rtnl_qdisc *qdisc)
+{
+	int err;
+	struct nlattr *tb[TCA_DSMARK_MAX + 1];
+	struct rtnl_dsmark_qdisc *dsmark;
+
+	err = tca_parse(tb, TCA_DSMARK_MAX, (struct rtnl_tca *) qdisc,
+			dsmark_policy);
+	if (err < 0)
+		return err;
+
+	dsmark = dsmark_qdisc_alloc(qdisc);
+	if (!dsmark)
+		return -NLE_NOMEM;
+
+	if (tb[TCA_DSMARK_INDICES]) {
+		dsmark->qdm_indices = nla_get_u16(tb[TCA_DSMARK_INDICES]);
+		dsmark->qdm_mask |= SCH_DSMARK_ATTR_INDICES;
+	}
+
+	if (tb[TCA_DSMARK_DEFAULT_INDEX]) {
+		dsmark->qdm_default_index =
+				nla_get_u16(tb[TCA_DSMARK_DEFAULT_INDEX]);
+		dsmark->qdm_mask |= SCH_DSMARK_ATTR_DEFAULT_INDEX;
+	}
+
+	if (tb[TCA_DSMARK_SET_TC_INDEX]) {
+		dsmark->qdm_set_tc_index = 1;
+		dsmark->qdm_mask |= SCH_DSMARK_ATTR_SET_TC_INDEX;
+	}
+
+	return 0;
+}
+
+static inline struct rtnl_dsmark_class *dsmark_class(struct rtnl_class *class)
+{
+	return (struct rtnl_dsmark_class *) class->c_subdata;
+}
+
+static inline struct rtnl_dsmark_class *
+dsmark_class_alloc(struct rtnl_class *class)
+{
+	if (!class->c_subdata)
+		class->c_subdata = calloc(1, sizeof(struct rtnl_dsmark_class));
+
+	return dsmark_class(class);
+}
+
+static int dsmark_class_msg_parser(struct rtnl_class *class)
+{
+	int err;
+	struct nlattr *tb[TCA_DSMARK_MAX + 1];
+	struct rtnl_dsmark_class *dsmark;
+
+	err = tca_parse(tb, TCA_DSMARK_MAX, (struct rtnl_tca *) class,
+			dsmark_policy);
+	if (err < 0)
+		return err;
+
+	dsmark = dsmark_class_alloc(class);
+	if (!dsmark)
+		return -NLE_NOMEM;
+
+	if (tb[TCA_DSMARK_MASK]) {
+		dsmark->cdm_bmask = nla_get_u8(tb[TCA_DSMARK_MASK]);
+		dsmark->cdm_mask |= SCH_DSMARK_ATTR_MASK;
+	}
+
+	if (tb[TCA_DSMARK_VALUE]) {
+		dsmark->cdm_value = nla_get_u8(tb[TCA_DSMARK_VALUE]);
+		dsmark->cdm_mask |= SCH_DSMARK_ATTR_VALUE;
+	}
+
+	return 0;
+}
+
+static void dsmark_qdisc_dump_line(struct rtnl_qdisc *qdisc,
+				   struct nl_dump_params *p)
+{
+	struct rtnl_dsmark_qdisc *dsmark = dsmark_qdisc(qdisc);
+
+	if (dsmark && (dsmark->qdm_mask & SCH_DSMARK_ATTR_INDICES))
+		nl_dump(p, " indices 0x%04x", dsmark->qdm_indices);
+}
+
+static void dsmark_qdisc_dump_details(struct rtnl_qdisc *qdisc,
+				      struct nl_dump_params *p)
+{
+	struct rtnl_dsmark_qdisc *dsmark = dsmark_qdisc(qdisc);
+
+	if (!dsmark)
+		return;
+
+	if (dsmark->qdm_mask & SCH_DSMARK_ATTR_DEFAULT_INDEX)
+		nl_dump(p, " default index 0x%04x", dsmark->qdm_default_index);
+
+	if (dsmark->qdm_mask & SCH_DSMARK_ATTR_SET_TC_INDEX)
+		nl_dump(p, " set-tc-index");
+}
+
+static void dsmark_class_dump_line(struct rtnl_class *class,
+				   struct nl_dump_params *p)
+{
+	struct rtnl_dsmark_class *dsmark = dsmark_class(class);
+
+	if (!dsmark)
+		return;
+
+	if (dsmark->cdm_mask & SCH_DSMARK_ATTR_VALUE)
+		nl_dump(p, " value 0x%02x", dsmark->cdm_value);
+
+	if (dsmark->cdm_mask & SCH_DSMARK_ATTR_MASK)
+		nl_dump(p, " mask 0x%02x", dsmark->cdm_bmask);
+}
+
+static struct nl_msg *dsmark_qdisc_get_opts(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_dsmark_qdisc *dsmark = dsmark_qdisc(qdisc);
+	struct nl_msg *msg;
+
+	if (!dsmark)
+		return NULL;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		goto nla_put_failure;
+
+	if (dsmark->qdm_mask & SCH_DSMARK_ATTR_INDICES)
+		NLA_PUT_U16(msg, TCA_DSMARK_INDICES, dsmark->qdm_indices);
+
+	if (dsmark->qdm_mask & SCH_DSMARK_ATTR_DEFAULT_INDEX)
+		NLA_PUT_U16(msg, TCA_DSMARK_DEFAULT_INDEX,
+			    dsmark->qdm_default_index);
+
+	if (dsmark->qdm_mask & SCH_DSMARK_ATTR_SET_TC_INDEX)
+		NLA_PUT_FLAG(msg, TCA_DSMARK_SET_TC_INDEX);
+
+	return msg;
+
+nla_put_failure:
+	nlmsg_free(msg);
+	return NULL;
+}
+
+static struct nl_msg *dsmark_class_get_opts(struct rtnl_class *class)
+{
+	struct rtnl_dsmark_class *dsmark = dsmark_class(class);
+	struct nl_msg *msg;
+
+	if (!dsmark)
+		return NULL;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		goto nla_put_failure;
+
+	if (dsmark->cdm_mask & SCH_DSMARK_ATTR_MASK)
+		NLA_PUT_U8(msg, TCA_DSMARK_MASK, dsmark->cdm_bmask);
+
+	if (dsmark->cdm_mask & SCH_DSMARK_ATTR_VALUE)
+		NLA_PUT_U8(msg, TCA_DSMARK_VALUE, dsmark->cdm_value);
+
+	return msg;
+
+nla_put_failure:
+	nlmsg_free(msg);
+	return NULL;
+}
+
+/**
+ * @name Class Attribute Access
+ * @{
+ */
+
+/**
+ * Set bitmask of DSMARK class.
+ * @arg class		DSMARK class to be modified.
+ * @arg mask		New bitmask.
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_class_dsmark_set_bitmask(struct rtnl_class *class, uint8_t mask)
+{
+	struct rtnl_dsmark_class *dsmark;
+	
+	dsmark = dsmark_class(class);
+	if (!dsmark)
+		return -NLE_NOMEM;
+
+	dsmark->cdm_bmask = mask;
+	dsmark->cdm_mask |= SCH_DSMARK_ATTR_MASK;
+
+	return 0;
+}
+
+/**
+ * Get bitmask of DSMARK class.
+ * @arg class		DSMARK class.
+ * @return Bitmask or a negative error code.
+ */
+int rtnl_class_dsmark_get_bitmask(struct rtnl_class *class)
+{
+	struct rtnl_dsmark_class *dsmark;
+
+	dsmark = dsmark_class(class);
+	if (dsmark && dsmark->cdm_mask & SCH_DSMARK_ATTR_MASK)
+		return dsmark->cdm_bmask;
+	else
+		return -NLE_NOATTR;
+}
+
+/**
+ * Set value of DSMARK class.
+ * @arg class		DSMARK class to be modified.
+ * @arg value		New value.
+ * @return 0 on success or a negative errror code.
+ */
+int rtnl_class_dsmark_set_value(struct rtnl_class *class, uint8_t value)
+{
+	struct rtnl_dsmark_class *dsmark;
+
+	dsmark = dsmark_class(class);
+	if (!dsmark)
+		return -NLE_NOMEM;
+
+	dsmark->cdm_value = value;
+	dsmark->cdm_mask |= SCH_DSMARK_ATTR_VALUE;
+
+	return 0;
+}
+
+/**
+ * Get value of DSMARK class.
+ * @arg class		DSMARK class.
+ * @return Value or a negative error code.
+ */
+int rtnl_class_dsmark_get_value(struct rtnl_class *class)
+{
+	struct rtnl_dsmark_class *dsmark;
+
+	dsmark = dsmark_class(class);
+	if (dsmark && dsmark->cdm_mask & SCH_DSMARK_ATTR_VALUE)
+		return dsmark->cdm_value;
+	else
+		return -NLE_NOATTR;
+}
+
+/** @} */
+
+/**
+ * @name Qdisc Attribute Access
+ * @{
+ */
+
+/**
+ * Set indices of DSMARK qdisc.
+ * @arg qdisc		DSMARK qdisc to be modified.
+ * @arg indices		New indices.
+ */
+int rtnl_qdisc_dsmark_set_indices(struct rtnl_qdisc *qdisc, uint16_t indices)
+{
+	struct rtnl_dsmark_qdisc *dsmark;
+
+	dsmark = dsmark_qdisc(qdisc);
+	if (!dsmark)
+		return -NLE_NOMEM;
+
+	dsmark->qdm_indices = indices;
+	dsmark->qdm_mask |= SCH_DSMARK_ATTR_INDICES;
+
+	return 0;
+}
+
+/**
+ * Get indices of DSMARK qdisc.
+ * @arg qdisc		DSMARK qdisc.
+ * @return Indices or a negative error code.
+ */
+int rtnl_qdisc_dsmark_get_indices(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_dsmark_qdisc *dsmark;
+
+	dsmark = dsmark_qdisc(qdisc);
+	if (dsmark && dsmark->qdm_mask & SCH_DSMARK_ATTR_INDICES)
+		return dsmark->qdm_indices;
+	else
+		return -NLE_NOATTR;
+}
+
+/**
+ * Set default index of DSMARK qdisc.
+ * @arg qdisc		DSMARK qdisc to be modified.
+ * @arg default_index	New default index.
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_qdisc_dsmark_set_default_index(struct rtnl_qdisc *qdisc,
+					uint16_t default_index)
+{
+	struct rtnl_dsmark_qdisc *dsmark;
+
+	dsmark = dsmark_qdisc(qdisc);
+	if (!dsmark)
+		return -NLE_NOMEM;
+
+	dsmark->qdm_default_index = default_index;
+	dsmark->qdm_mask |= SCH_DSMARK_ATTR_DEFAULT_INDEX;
+
+	return 0;
+}
+
+/**
+ * Get default index of DSMARK qdisc.
+ * @arg qdisc		DSMARK qdisc.
+ * @return Default index or a negative error code.
+ */
+int rtnl_qdisc_dsmark_get_default_index(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_dsmark_qdisc *dsmark;
+
+	dsmark = dsmark_qdisc(qdisc);
+	if (dsmark && dsmark->qdm_mask & SCH_DSMARK_ATTR_DEFAULT_INDEX)
+		return dsmark->qdm_default_index;
+	else
+		return -NLE_NOATTR;
+}
+
+/**
+ * Set set-tc-index flag of DSMARK qdisc.
+ * @arg qdisc		DSMARK qdisc to be modified.
+ * @arg flag		Flag indicating whether to enable or disable.
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_qdisc_dsmark_set_set_tc_index(struct rtnl_qdisc *qdisc, int flag)
+{
+	struct rtnl_dsmark_qdisc *dsmark;
+
+	dsmark = dsmark_qdisc(qdisc);
+	if (!dsmark)
+		return -NLE_NOMEM;
+
+	dsmark->qdm_set_tc_index = !!flag;
+	dsmark->qdm_mask |= SCH_DSMARK_ATTR_SET_TC_INDEX;
+
+	return 0;
+}
+
+/**
+ * Get set-tc-index flag of DSMARK qdisc.
+ * @arg qdisc		DSMARK qdisc to be modified.
+ * @return 1 or 0 to indicate wehther the flag is enabled or a negative
+ *         error code.
+ */
+int rtnl_qdisc_dsmark_get_set_tc_index(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_dsmark_qdisc *dsmark;
+
+	dsmark = dsmark_qdisc(qdisc);
+	if (dsmark && dsmark->qdm_mask & SCH_DSMARK_ATTR_SET_TC_INDEX)
+		return dsmark->qdm_set_tc_index;
+	else
+		return -NLE_NOATTR;
+}
+
+/** @} */
+
+static struct rtnl_qdisc_ops dsmark_qdisc_ops = {
+	.qo_kind		= "dsmark",
+	.qo_msg_parser		= dsmark_qdisc_msg_parser,
+	.qo_dump = {
+	    [NL_DUMP_LINE]	= dsmark_qdisc_dump_line,
+	    [NL_DUMP_DETAILS]	= dsmark_qdisc_dump_details,
+	},
+	.qo_get_opts		= dsmark_qdisc_get_opts,
+};
+
+static struct rtnl_class_ops dsmark_class_ops = {
+	.co_kind		= "dsmark",
+	.co_msg_parser		= dsmark_class_msg_parser,
+	.co_dump[NL_DUMP_LINE]	= dsmark_class_dump_line,
+	.co_get_opts		= dsmark_class_get_opts,
+};
+
+static void __init dsmark_init(void)
+{
+	rtnl_qdisc_register(&dsmark_qdisc_ops);
+	rtnl_class_register(&dsmark_class_ops);
+}
+
+static void __exit dsmark_exit(void)
+{
+	rtnl_qdisc_unregister(&dsmark_qdisc_ops);
+	rtnl_class_unregister(&dsmark_class_ops);
+}
+
+/** @} */
diff -uNr libnl_kk/lib/route/sch/fifo.c libnl/lib/route/sch/fifo.c
--- libnl_kk/lib/route/sch/fifo.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/sch/fifo.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,199 @@
+/*
+ * lib/route/sch/fifo.c		(p|b)fifo
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup qdisc_api
+ * @defgroup fifo Packet/Bytes FIFO (pfifo/bfifo)
+ * @brief
+ *
+ * The FIFO qdisc comes in two flavours:
+ * @par bfifo (Byte FIFO)
+ * Allows enqueuing until the currently queued volume in bytes exceeds
+ * the configured limit.backlog contains currently enqueued volume in bytes.
+ *
+ * @par pfifo (Packet FIFO)
+ * Allows enquueing until the currently queued number of packets
+ * exceeds the configured limit.
+ *
+ * The configuration is exactly the same, the decision which of
+ * the two variations is going to be used is made based on the
+ * kind of the qdisc (rtnl_qdisc_set_kind()).
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink-tc.h>
+#include <netlink/netlink.h>
+#include <netlink/route/qdisc.h>
+#include <netlink/route/qdisc-modules.h>
+#include <netlink/route/sch/fifo.h>
+#include <netlink/utils.h>
+
+/** @cond SKIP */
+#define SCH_FIFO_ATTR_LIMIT 1
+/** @endcond */
+
+static inline struct rtnl_fifo *fifo_qdisc(struct rtnl_qdisc *qdisc)
+{
+	return (struct rtnl_fifo *) qdisc->q_subdata;
+}
+
+static inline struct rtnl_fifo *fifo_alloc(struct rtnl_qdisc *qdisc)
+{
+	if (!qdisc->q_subdata)
+		qdisc->q_subdata = calloc(1, sizeof(struct rtnl_fifo));
+
+	return fifo_qdisc(qdisc);
+}
+
+static int fifo_msg_parser(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_fifo *fifo;
+	struct tc_fifo_qopt *opt;
+
+	if (qdisc->q_opts->d_size < sizeof(struct tc_fifo_qopt))
+		return -NLE_INVAL;
+
+	fifo = fifo_alloc(qdisc);
+	if (!fifo)
+		return -NLE_NOMEM;
+
+	opt = (struct tc_fifo_qopt *) qdisc->q_opts->d_data;
+	fifo->qf_limit = opt->limit;
+	fifo->qf_mask = SCH_FIFO_ATTR_LIMIT;
+
+	return 0;
+}
+
+static void fifo_free_data(struct rtnl_qdisc *qdisc)
+{
+	free(qdisc->q_subdata);
+}
+
+static void pfifo_dump_line(struct rtnl_qdisc *qdisc, struct nl_dump_params *p)
+{
+	struct rtnl_fifo *fifo = fifo_qdisc(qdisc);
+
+	if (fifo)
+		nl_dump(p, " limit %u packets", fifo->qf_limit);
+}
+
+static void bfifo_dump_line(struct rtnl_qdisc *qdisc, struct nl_dump_params *p)
+{
+	struct rtnl_fifo *fifo = fifo_qdisc(qdisc);
+
+	if (fifo) {
+		char *unit;
+		double r;
+
+		r = nl_cancel_down_bytes(fifo->qf_limit, &unit);
+		nl_dump(p, " limit %.1f%s", r, unit);
+	}
+}
+
+static struct nl_msg *fifo_get_opts(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_fifo *fifo;
+	struct tc_fifo_qopt opts;
+	struct nl_msg *msg;
+
+	fifo = fifo_qdisc(qdisc);
+	if (!fifo || !(fifo->qf_mask & SCH_FIFO_ATTR_LIMIT))
+		return NULL;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		goto errout;
+
+	memset(&opts, 0, sizeof(opts));
+	opts.limit = fifo->qf_limit;
+
+	if (nlmsg_append(msg, &opts, sizeof(opts), NL_DONTPAD) < 0)
+		goto errout;
+
+	return msg;
+errout:
+	nlmsg_free(msg);
+	return NULL;
+}
+
+/**
+ * @name Attribute Modification
+ * @{
+ */
+
+/**
+ * Set limit of FIFO qdisc.
+ * @arg qdisc		FIFO qdisc to be modified.
+ * @arg limit		New limit.
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_qdisc_fifo_set_limit(struct rtnl_qdisc *qdisc, int limit)
+{
+	struct rtnl_fifo *fifo;
+	
+	fifo = fifo_alloc(qdisc);
+	if (!fifo)
+		return -NLE_NOMEM;
+		
+	fifo->qf_limit = limit;
+	fifo->qf_mask |= SCH_FIFO_ATTR_LIMIT;
+
+	return 0;
+}
+
+/**
+ * Get limit of a FIFO qdisc.
+ * @arg qdisc		FIFO qdisc.
+ * @return Numeric limit or a negative error code.
+ */
+int rtnl_qdisc_fifo_get_limit(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_fifo *fifo;
+	
+	fifo = fifo_qdisc(qdisc);
+	if (fifo && fifo->qf_mask & SCH_FIFO_ATTR_LIMIT)
+		return fifo->qf_limit;
+	else
+		return -NLE_NOATTR;
+}
+
+/** @} */
+
+static struct rtnl_qdisc_ops pfifo_ops = {
+	.qo_kind		= "pfifo",
+	.qo_msg_parser		= fifo_msg_parser,
+	.qo_free_data		= fifo_free_data,
+	.qo_dump[NL_DUMP_LINE]	= pfifo_dump_line,
+	.qo_get_opts		= fifo_get_opts,
+};
+
+static struct rtnl_qdisc_ops bfifo_ops = {
+	.qo_kind		= "bfifo",
+	.qo_msg_parser		= fifo_msg_parser,
+	.qo_free_data		= fifo_free_data,
+	.qo_dump[NL_DUMP_LINE]	= bfifo_dump_line,
+	.qo_get_opts		= fifo_get_opts,
+};
+
+static void __init fifo_init(void)
+{
+	rtnl_qdisc_register(&pfifo_ops);
+	rtnl_qdisc_register(&bfifo_ops);
+}
+
+static void __exit fifo_exit(void)
+{
+	rtnl_qdisc_unregister(&pfifo_ops);
+	rtnl_qdisc_unregister(&bfifo_ops);
+}
+
+/** @} */
diff -uNr libnl_kk/lib/route/sch/htb.c libnl/lib/route/sch/htb.c
--- libnl_kk/lib/route/sch/htb.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/sch/htb.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,546 @@
+/*
+ * lib/route/sch/htb.c	HTB Qdisc
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ * Copyright (c) 2005-2006 Petr Gotthard <petr.gotthard@siemens.com>
+ * Copyright (c) 2005-2006 Siemens AG Oesterreich
+ */
+
+/**
+ * @ingroup qdisc_api
+ * @ingroup class_api
+ * @defgroup htb Hierachical Token Bucket (HTB)
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink-tc.h>
+#include <netlink/netlink.h>
+#include <netlink/cache.h>
+#include <netlink/utils.h>
+#include <netlink/route/tc.h>
+#include <netlink/route/qdisc.h>
+#include <netlink/route/qdisc-modules.h>
+#include <netlink/route/class.h>
+#include <netlink/route/class-modules.h>
+#include <netlink/route/link.h>
+#include <netlink/route/sch/htb.h>
+
+/** @cond SKIP */
+#define SCH_HTB_HAS_RATE2QUANTUM	0x01
+#define SCH_HTB_HAS_DEFCLS		0x02
+
+#define SCH_HTB_HAS_PRIO		0x001
+#define SCH_HTB_HAS_MTU			0x002
+#define SCH_HTB_HAS_RATE		0x004
+#define SCH_HTB_HAS_CEIL		0x008
+#define SCH_HTB_HAS_RBUFFER		0x010
+#define SCH_HTB_HAS_CBUFFER		0x020
+#define SCH_HTB_HAS_QUANTUM		0x040
+#define SCH_HTB_HAS_OVERHEAD		0x080
+#define SCH_HTB_HAS_MPU			0x100
+/** @endcond */
+
+static inline struct rtnl_htb_qdisc *htb_qdisc(struct rtnl_qdisc *qdisc)
+{
+	if (qdisc->q_subdata == NULL)
+		qdisc->q_subdata = calloc(1, sizeof(struct rtnl_htb_qdisc));
+
+	return (struct rtnl_htb_qdisc *) qdisc->q_subdata;
+}
+
+static struct nla_policy htb_policy[TCA_HTB_MAX+1] = {
+	[TCA_HTB_INIT]	= { .minlen = sizeof(struct tc_htb_glob) },
+	[TCA_HTB_PARMS] = { .minlen = sizeof(struct tc_htb_opt) },
+};
+
+static int htb_qdisc_msg_parser(struct rtnl_qdisc *qdisc)
+{
+	int err;
+	struct nlattr *tb[TCA_HTB_MAX + 1];
+	struct rtnl_htb_qdisc *d;
+
+	err = tca_parse(tb, TCA_HTB_MAX, (struct rtnl_tca *) qdisc, htb_policy);
+	if (err < 0)
+		return err;
+	
+	d = htb_qdisc(qdisc);
+
+	if (tb[TCA_HTB_INIT]) {
+		struct tc_htb_glob opts;
+
+		nla_memcpy(&opts, tb[TCA_HTB_INIT], sizeof(opts));
+		d->qh_rate2quantum = opts.rate2quantum;
+		d->qh_defcls = opts.defcls;
+
+		d->qh_mask = (SCH_HTB_HAS_RATE2QUANTUM | SCH_HTB_HAS_DEFCLS);
+	}
+
+	return 0;
+}
+
+static void htb_qdisc_free_data(struct rtnl_qdisc *qdisc)
+{
+	free(qdisc->q_subdata);
+}
+
+static inline struct rtnl_htb_class *htb_class(struct rtnl_class *class)
+{
+	if (class->c_subdata == NULL)
+		class->c_subdata = calloc(1, sizeof(struct rtnl_htb_class));
+
+	return (struct rtnl_htb_class *) class->c_subdata;
+}
+
+static int htb_class_msg_parser(struct rtnl_class *class)
+{
+	int err;
+	struct nlattr *tb[TCA_HTB_MAX + 1];
+	struct rtnl_htb_class *d;
+
+	err = tca_parse(tb, TCA_HTB_MAX, (struct rtnl_tca *) class, htb_policy);
+	if (err < 0)
+		return err;
+	
+	d = htb_class(class);
+
+	if (tb[TCA_HTB_PARMS]) {
+		struct tc_htb_opt opts;
+
+		nla_memcpy(&opts, tb[TCA_HTB_PARMS], sizeof(opts));
+		d->ch_prio = opts.prio;
+		rtnl_copy_ratespec(&d->ch_rate, &opts.rate);
+		rtnl_copy_ratespec(&d->ch_ceil, &opts.ceil);
+		d->ch_rbuffer = rtnl_tc_calc_bufsize(opts.buffer, opts.rate.rate);
+		d->ch_cbuffer = rtnl_tc_calc_bufsize(opts.cbuffer, opts.ceil.rate);
+		d->ch_quantum = opts.quantum;
+		d->ch_overhead = (opts.rate.mpu >> 8) & 0xff;
+		d->ch_mpu = opts.rate.mpu & 0xff;
+
+		d->ch_mask = (SCH_HTB_HAS_PRIO | SCH_HTB_HAS_RATE |
+			SCH_HTB_HAS_CEIL | SCH_HTB_HAS_RBUFFER |
+			SCH_HTB_HAS_CBUFFER | SCH_HTB_HAS_QUANTUM |
+			SCH_HTB_HAS_OVERHEAD | SCH_HTB_HAS_MPU);
+	}
+
+	return 0;
+}
+
+static void htb_class_free_data(struct rtnl_class *class)
+{
+	free(class->c_subdata);
+}
+
+static void htb_qdisc_dump_line(struct rtnl_qdisc *qdisc,
+				struct nl_dump_params *p)
+{
+	struct rtnl_htb_qdisc *d = (struct rtnl_htb_qdisc *) qdisc->q_subdata;
+
+	if (d == NULL)
+		return;
+
+	if (d->qh_mask & SCH_HTB_HAS_RATE2QUANTUM)
+		nl_dump(p, " r2q %u", d->qh_rate2quantum);
+
+	if (d->qh_mask & SCH_HTB_HAS_DEFCLS) {
+		char buf[32];
+		nl_dump(p, " default %s",
+			rtnl_tc_handle2str(d->qh_defcls, buf, sizeof(buf)));
+	}
+}
+
+static void htb_class_dump_line(struct rtnl_class *class,
+				struct nl_dump_params *p)
+{
+	struct rtnl_htb_class *d = (struct rtnl_htb_class *) class->c_subdata;
+
+	if (d == NULL)
+		return;
+
+	if (d->ch_mask & SCH_HTB_HAS_RATE) {
+		double r, rbit;
+		char *ru, *rubit;
+
+		r = nl_cancel_down_bytes(d->ch_rate.rs_rate, &ru);
+		rbit = nl_cancel_down_bits(d->ch_rate.rs_rate*8, &rubit);
+
+		nl_dump(p, " rate %.2f%s/s (%.0f%s) log %u",
+			r, ru, rbit, rubit, 1<<d->ch_rate.rs_cell_log);
+	}
+}
+
+static void htb_class_dump_details(struct rtnl_class *class,
+				   struct nl_dump_params *p)
+{
+	struct rtnl_htb_class *d = (struct rtnl_htb_class *) class->c_subdata;
+
+	if (d == NULL)
+		return;
+
+	/* line 1 */
+	if (d->ch_mask & SCH_HTB_HAS_CEIL) {
+		double r, rbit;
+		char *ru, *rubit;
+
+		r = nl_cancel_down_bytes(d->ch_ceil.rs_rate, &ru);
+		rbit = nl_cancel_down_bits(d->ch_ceil.rs_rate*8, &rubit);
+
+		nl_dump(p, "    ceil %.2f%s/s (%.0f%s) log %u",
+			r, ru, rbit, rubit, 1<<d->ch_ceil.rs_cell_log);
+	}
+
+	if (d->ch_mask & SCH_HTB_HAS_PRIO)
+		nl_dump(p, " prio %u", d->ch_prio);
+
+	if (d->ch_mask & SCH_HTB_HAS_MTU)
+		nl_dump(p, " mtu %u", d->ch_mtu);
+
+	if (d->ch_mask & SCH_HTB_HAS_RBUFFER) {
+		double b;
+		char *bu;
+
+		b = nl_cancel_down_bytes(d->ch_rbuffer, &bu);
+		nl_dump(p, " rbuffer %.2f%s", b, bu);
+	}
+
+	if (d->ch_mask & SCH_HTB_HAS_CBUFFER) {
+		double b;
+		char *bu;
+
+		b = nl_cancel_down_bytes(d->ch_cbuffer, &bu);
+		nl_dump(p, " cbuffer %.2f%s", b, bu);
+	}
+
+	if (d->ch_mask & SCH_HTB_HAS_QUANTUM)
+		nl_dump(p, " quantum %u", d->ch_quantum);
+
+	if (d->ch_mask & SCH_HTB_HAS_OVERHEAD)
+		nl_dump(p, " overhead %u", d->ch_overhead);
+
+	if (d->ch_mask & SCH_HTB_HAS_MPU)
+		nl_dump(p, " mpu %u", d->ch_mpu);
+}
+
+static struct nl_msg *htb_qdisc_get_opts(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_htb_qdisc *d = (struct rtnl_htb_qdisc *) qdisc->q_subdata;
+	struct tc_htb_glob opts;
+	struct nl_msg *msg;
+
+	if (d == NULL)
+		return NULL;
+
+	msg = nlmsg_alloc();
+	if (msg == NULL)
+		return NULL;
+
+	memset(&opts, 0, sizeof(opts));
+	opts.version = TC_HTB_PROTOVER;
+
+	if (d->qh_mask & SCH_HTB_HAS_RATE2QUANTUM)
+		opts.rate2quantum = d->qh_rate2quantum;
+	if (d->qh_mask & SCH_HTB_HAS_DEFCLS)
+		opts.defcls = d->qh_defcls;
+
+	nla_put(msg, TCA_HTB_INIT, sizeof(opts), &opts);
+
+	return msg;
+}
+
+static uint8_t compute_cell(uint32_t rate, uint32_t mtu)
+{
+	uint8_t cell_log = 0;
+	while (mtu > 255) {
+		mtu >>= 1;
+		cell_log++;
+	}
+
+	return cell_log;
+}
+
+static struct nl_msg *htb_class_get_opts(struct rtnl_class *class)
+{
+	struct rtnl_htb_class *d = (struct rtnl_htb_class *) class->c_subdata;
+	uint32_t mtu, rtable[RTNL_TC_RTABLE_SIZE], ctable[RTNL_TC_RTABLE_SIZE];
+	struct tc_htb_opt opts;
+	struct nl_msg *msg;
+	int buffer, cbuffer;
+	uint8_t overhead = 0, mpu = 0;
+
+	if (d == NULL)
+		return NULL;
+
+	msg = nlmsg_alloc();
+	memset(&opts, 0, sizeof(opts));
+
+	/* if not set, zero (0) is used as priority */
+	if (d->ch_mask & SCH_HTB_HAS_PRIO)
+		opts.prio = d->ch_prio;
+
+	if (d->ch_mask & SCH_HTB_HAS_MTU)
+		mtu = d->ch_mtu;
+	else
+		mtu = 1600; /* eth packet len */
+
+	if (!(d->ch_mask & SCH_HTB_HAS_RATE))
+		BUG();
+
+	rtnl_rcopy_ratespec(&opts.rate, &d->ch_rate);
+	/* if cell_log not set, compute default value */
+	if (opts.rate.cell_log == UINT8_MAX)
+		opts.rate.cell_log = compute_cell(opts.rate.rate, mtu);
+
+	/* if not set, configured rate is used as ceil, which implies no borrowing */
+	if (d->ch_mask & SCH_HTB_HAS_CEIL)
+		rtnl_rcopy_ratespec(&opts.ceil, &d->ch_ceil);
+	else
+		memcpy(&opts.ceil, &opts.rate, sizeof(struct tc_ratespec));
+	/* if cell_log not set, compute default value */
+	if (opts.ceil.cell_log == UINT8_MAX)
+		opts.ceil.cell_log = compute_cell(opts.ceil.rate, mtu);
+
+	if (d->ch_mask & SCH_HTB_HAS_RBUFFER)
+		buffer = d->ch_rbuffer;
+	else
+		buffer = opts.rate.rate / nl_get_hz() + mtu;
+
+	opts.buffer = rtnl_tc_calc_txtime(buffer, opts.rate.rate);
+
+	if (d->ch_mask & SCH_HTB_HAS_CBUFFER)
+		cbuffer = d->ch_cbuffer;
+	else
+		cbuffer = opts.ceil.rate / nl_get_hz() + mtu;
+
+	opts.cbuffer = rtnl_tc_calc_txtime(cbuffer, opts.ceil.rate);
+
+	if (d->ch_mask & SCH_HTB_HAS_QUANTUM)
+		opts.quantum = d->ch_quantum;
+
+	if (d->ch_mask & SCH_HTB_HAS_OVERHEAD)
+		overhead = d->ch_overhead;
+
+	if (d->ch_mask & SCH_HTB_HAS_MPU)
+		mpu = d->ch_mpu;
+	
+	opts.rate.mpu = mpu | (overhead << 8);
+	opts.ceil.mpu = mpu | (overhead << 8);
+
+	nla_put(msg, TCA_HTB_PARMS, sizeof(opts), &opts);
+
+	rtnl_tc_build_rate_table(rtable, mpu, overhead,
+				 1 << opts.rate.cell_log,
+				 opts.rate.rate);
+	nla_put(msg, TCA_HTB_RTAB, sizeof(rtable), &rtable);
+
+	rtnl_tc_build_rate_table(ctable, mpu, overhead,
+				 1 << opts.ceil.cell_log,
+				 opts.ceil.rate);
+	nla_put(msg, TCA_HTB_CTAB, sizeof(ctable), &ctable);
+
+	return msg;
+}
+
+/**
+ * @name Attribute Modifications
+ * @{
+ */
+
+void rtnl_htb_set_rate2quantum(struct rtnl_qdisc *qdisc, uint32_t rate2quantum)
+{
+	struct rtnl_htb_qdisc *d = htb_qdisc(qdisc);
+	if (d == NULL)
+		return;
+
+	d->qh_rate2quantum = rate2quantum;
+	d->qh_mask |= SCH_HTB_HAS_RATE2QUANTUM;
+}
+
+/**
+ * Set default class of the htb qdisc to the specified value
+ * @arg qdisc		qdisc to change
+ * @arg defcls		new default class
+ */
+void rtnl_htb_set_defcls(struct rtnl_qdisc *qdisc, uint32_t defcls)
+{
+	struct rtnl_htb_qdisc *d = htb_qdisc(qdisc);
+	if (d == NULL)
+		return;
+
+	d->qh_defcls = defcls;
+	d->qh_mask |= SCH_HTB_HAS_DEFCLS;
+}
+
+void rtnl_htb_set_prio(struct rtnl_class *class, uint32_t prio)
+{
+	struct rtnl_htb_class *d = htb_class(class);
+	if (d == NULL)
+		return;
+
+	d->ch_prio = prio;
+	d->ch_mask |= SCH_HTB_HAS_PRIO;
+}
+
+/**
+ * Set MTU of the data link.
+ * @arg class		HTB class to be modified.
+ * @arg mtu		New MTU in bytes.
+ *
+ * Sets MTU of the data link controlled by the HTB class.
+ * If not set, the Ethernet MTU (1600) is used.
+ */
+void rtnl_htb_set_mtu(struct rtnl_class *class, uint32_t mtu)
+{
+	struct rtnl_htb_class *d = htb_class(class);
+	if (d == NULL)
+		return;
+
+	d->ch_mtu = mtu;
+	d->ch_mask |= SCH_HTB_HAS_MTU;
+}
+
+/**
+ * Set rate of HTB class.
+ * @arg class		HTB class to be modified.
+ * @arg rate		New rate in bytes per second.
+ */
+void rtnl_htb_set_rate(struct rtnl_class *class, uint32_t rate)
+{
+	struct rtnl_htb_class *d = htb_class(class);
+	if (d == NULL)
+		return;
+
+	d->ch_rate.rs_cell_log = UINT8_MAX; /* use default value */
+	d->ch_rate.rs_rate = rate;
+	d->ch_mask |= SCH_HTB_HAS_RATE;
+}
+
+/**
+ * Set ceil of HTB class.
+ * @arg class		HTB class to be modified.
+ * @arg ceil		New ceil in bytes per second.
+ */
+void rtnl_htb_set_ceil(struct rtnl_class *class, uint32_t ceil)
+{
+	struct rtnl_htb_class *d = htb_class(class);
+	if (d == NULL)
+		return;
+
+	d->ch_ceil.rs_cell_log = UINT8_MAX; /* use default value */
+	d->ch_ceil.rs_rate = ceil;
+	d->ch_mask |= SCH_HTB_HAS_CEIL;
+}
+
+/**
+ * Set size of the rate bucket of HTB class.
+ * @arg class		HTB class to be modified.
+ * @arg rbuffer		New size in bytes.
+ */
+void rtnl_htb_set_rbuffer(struct rtnl_class *class, uint32_t rbuffer)
+{
+	struct rtnl_htb_class *d = htb_class(class);
+	if (d == NULL)
+		return;
+
+	d->ch_rbuffer = rbuffer;
+	d->ch_mask |= SCH_HTB_HAS_RBUFFER;
+}
+
+/**
+ * Set size of the ceil bucket of HTB class.
+ * @arg class		HTB class to be modified.
+ * @arg cbuffer		New size in bytes.
+ */
+void rtnl_htb_set_cbuffer(struct rtnl_class *class, uint32_t cbuffer)
+{
+	struct rtnl_htb_class *d = htb_class(class);
+	if (d == NULL)
+		return;
+
+	d->ch_cbuffer = cbuffer;
+	d->ch_mask |= SCH_HTB_HAS_CBUFFER;
+}
+
+/**
+ * Set how much bytes to serve from leaf at once of HTB class {use r2q}.
+ * @arg class		HTB class to be modified.
+ * @arg quantum		New size in bytes.
+ */
+void rtnl_htb_set_quantum(struct rtnl_class *class, uint32_t quantum)
+{
+	struct rtnl_htb_class *d = htb_class(class);
+	if (d == NULL)
+		return;
+
+	d->ch_quantum = quantum;
+	d->ch_mask |= SCH_HTB_HAS_QUANTUM;
+}
+
+/**
+ * Set per-packet size overhead used in rate computations of HTB class.
+ * @arg class		HTB class to be modified.
+ * @arg overhead		Size in bytes.
+ */
+void rtnl_htb_set_overhead(struct rtnl_class *class, uint8_t overhead)
+{
+	struct rtnl_htb_class *d = htb_class(class);
+	if (d == NULL)
+		return;
+
+	d->ch_overhead = overhead;
+	d->ch_mask |= SCH_HTB_HAS_OVERHEAD;
+}
+
+/**
+ * Set the minimum packet size used in rate computations of HTB class.
+ * @arg class		HTB class to be modified.
+ * @arg mpu		Size in bytes.
+ */
+void rtnl_htb_set_mpu(struct rtnl_class *class, uint8_t mpu)
+{
+	struct rtnl_htb_class *d = htb_class(class);
+	if (d == NULL)
+		return;
+
+	d->ch_mpu = mpu;
+	d->ch_mask |= SCH_HTB_HAS_MPU;
+}
+
+/** @} */
+
+static struct rtnl_qdisc_ops htb_qdisc_ops = {
+	.qo_kind		= "htb",
+	.qo_msg_parser		= htb_qdisc_msg_parser,
+	.qo_free_data		= htb_qdisc_free_data,
+	.qo_dump[NL_DUMP_LINE]	= htb_qdisc_dump_line,
+	.qo_get_opts		= htb_qdisc_get_opts,
+};
+
+static struct rtnl_class_ops htb_class_ops = {
+	.co_kind		= "htb",
+	.co_msg_parser		= htb_class_msg_parser,
+	.co_free_data		= htb_class_free_data,
+	.co_dump = {
+	    [NL_DUMP_LINE]	= htb_class_dump_line,
+	    [NL_DUMP_DETAILS]	= htb_class_dump_details,
+	},
+	.co_get_opts		= htb_class_get_opts,
+};
+
+static void __init htb_init(void)
+{
+	rtnl_qdisc_register(&htb_qdisc_ops);
+	rtnl_class_register(&htb_class_ops);
+}
+
+static void __exit htb_exit(void)
+{
+	rtnl_qdisc_unregister(&htb_qdisc_ops);
+	rtnl_class_unregister(&htb_class_ops);
+}
+
+/** @} */
diff -uNr libnl_kk/lib/route/sch/netem.c libnl/lib/route/sch/netem.c
--- libnl_kk/lib/route/sch/netem.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/sch/netem.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,939 @@
+/*
+ * lib/route/sch/netem.c		Network Emulator Qdisc
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup qdisc_api
+ * @defgroup netem Network Emulator
+ * @brief
+ *
+ * For further documentation see http://linux-net.osdl.org/index.php/Netem
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink-tc.h>
+#include <netlink/netlink.h>
+#include <netlink/utils.h>
+#include <netlink/route/qdisc.h>
+#include <netlink/route/qdisc-modules.h>
+#include <netlink/route/sch/netem.h>
+
+/** @cond SKIP */
+#define SCH_NETEM_ATTR_LATENCY		0x0001
+#define SCH_NETEM_ATTR_LIMIT		0x0002
+#define SCH_NETEM_ATTR_LOSS			0x0004
+#define SCH_NETEM_ATTR_GAP			0x0008
+#define SCH_NETEM_ATTR_DUPLICATE	0x0010
+#define SCH_NETEM_ATTR_JITTER		0x0020
+#define SCH_NETEM_ATTR_DELAY_CORR	0x0040
+#define SCH_NETEM_ATTR_LOSS_CORR	0x0080
+#define SCH_NETEM_ATTR_DUP_CORR		0x0100
+#define SCH_NETEM_ATTR_RO_PROB		0x0200
+#define SCH_NETEM_ATTR_RO_CORR		0x0400
+#define SCH_NETEM_ATTR_CORRUPT_PROB	0x0800
+#define SCH_NETEM_ATTR_CORRUPT_CORR	0x1000
+#define SCH_NETEM_ATTR_DIST         0x2000
+/** @endcond */
+
+static inline struct rtnl_netem *netem_qdisc(struct rtnl_qdisc *qdisc)
+{
+	return (struct rtnl_netem *) qdisc->q_subdata;
+}
+
+static inline struct rtnl_netem *netem_alloc(struct rtnl_qdisc *qdisc)
+{
+	if (!qdisc->q_subdata)
+		qdisc->q_subdata = calloc(1, sizeof(struct rtnl_netem));
+
+	return netem_qdisc(qdisc);
+}
+
+static struct nla_policy netem_policy[TCA_NETEM_MAX+1] = {
+	[TCA_NETEM_CORR]	= { .minlen = sizeof(struct tc_netem_corr) },
+	[TCA_NETEM_REORDER]	= { .minlen = sizeof(struct tc_netem_reorder) },
+	[TCA_NETEM_CORRUPT]	= { .minlen = sizeof(struct tc_netem_corrupt) },
+};
+
+static int netem_msg_parser(struct rtnl_qdisc *qdisc)
+{
+	int len, err = 0;
+	struct rtnl_netem *netem;
+	struct tc_netem_qopt *opts;
+
+	if (qdisc->q_opts->d_size < sizeof(*opts))
+		return -NLE_INVAL;
+
+	netem = netem_alloc(qdisc);
+	if (!netem)
+		return -NLE_NOMEM;
+
+	opts = (struct tc_netem_qopt *) qdisc->q_opts->d_data;
+	netem->qnm_latency = opts->latency;
+	netem->qnm_limit = opts->limit;
+	netem->qnm_loss = opts->loss;
+	netem->qnm_gap = opts->gap;
+	netem->qnm_duplicate = opts->duplicate;
+	netem->qnm_jitter = opts->jitter;
+
+	netem->qnm_mask = (SCH_NETEM_ATTR_LATENCY | SCH_NETEM_ATTR_LIMIT |
+			   SCH_NETEM_ATTR_LOSS | SCH_NETEM_ATTR_GAP |
+			   SCH_NETEM_ATTR_DUPLICATE | SCH_NETEM_ATTR_JITTER);
+
+	len = qdisc->q_opts->d_size - sizeof(*opts);
+
+	if (len > 0) {
+		struct nlattr *tb[TCA_NETEM_MAX+1];
+
+		err = nla_parse(tb, TCA_NETEM_MAX, (struct nlattr *)
+				(qdisc->q_opts->d_data + sizeof(*opts)),
+				len, netem_policy);
+		if (err < 0) {
+			free(netem);
+			return err;
+		}
+
+		if (tb[TCA_NETEM_CORR]) {
+			struct tc_netem_corr cor;
+
+			nla_memcpy(&cor, tb[TCA_NETEM_CORR], sizeof(cor));
+			netem->qnm_corr.nmc_delay = cor.delay_corr;
+			netem->qnm_corr.nmc_loss = cor.loss_corr;
+			netem->qnm_corr.nmc_duplicate = cor.dup_corr;
+
+			netem->qnm_mask |= (SCH_NETEM_ATTR_DELAY_CORR |
+					    SCH_NETEM_ATTR_LOSS_CORR |
+					SCH_NETEM_ATTR_DUP_CORR);
+		}
+
+		if (tb[TCA_NETEM_REORDER]) {
+			struct tc_netem_reorder ro;
+
+			nla_memcpy(&ro, tb[TCA_NETEM_REORDER], sizeof(ro));
+			netem->qnm_ro.nmro_probability = ro.probability;
+			netem->qnm_ro.nmro_correlation = ro.correlation;
+
+			netem->qnm_mask |= (SCH_NETEM_ATTR_RO_PROB |
+					    SCH_NETEM_ATTR_RO_CORR);
+		}
+			
+		if (tb[TCA_NETEM_CORRUPT]) {
+			struct tc_netem_corrupt corrupt;
+						
+			nla_memcpy(&corrupt, tb[TCA_NETEM_CORRUPT], sizeof(corrupt));
+			netem->qnm_crpt.nmcr_probability = corrupt.probability;
+			netem->qnm_crpt.nmcr_correlation = corrupt.correlation;
+	
+			netem->qnm_mask |= (SCH_NETEM_ATTR_CORRUPT_PROB |
+						SCH_NETEM_ATTR_CORRUPT_CORR);
+		}
+		
+		/* sch_netem does not currently dump TCA_NETEM_DELAY_DIST */
+		netem->qnm_dist.dist_data = NULL;
+		netem->qnm_dist.dist_size = 0;
+	}
+
+	return 0;
+}
+
+static void netem_free_data(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_netem *netem;
+	
+	if ( ! qdisc ) return;
+	
+	netem = netem_qdisc(qdisc);
+	if ( ! netem ) return;
+	
+	if ( netem->qnm_dist.dist_data )
+		free(netem->qnm_dist.dist_data);
+	
+	netem = NULL;
+	
+	free (qdisc->q_subdata);
+}
+
+static void netem_dump_line(struct rtnl_qdisc *qdisc, struct nl_dump_params *p)
+{
+	struct rtnl_netem *netem = netem_qdisc(qdisc);
+
+	if (netem)
+		nl_dump(p, "limit %d", netem->qnm_limit);
+}
+
+int netem_build_msg(struct rtnl_qdisc *qdisc, struct nl_msg *msg)
+{
+	int err = 0;
+	struct tc_netem_qopt opts;
+	struct tc_netem_corr cor;
+	struct tc_netem_reorder reorder;
+	struct tc_netem_corrupt corrupt;
+	struct rtnl_netem *netem;
+	
+	unsigned char set_correlation = 0, set_reorder = 0,
+		set_corrupt = 0, set_dist = 0;
+
+	memset(&opts, 0, sizeof(opts));
+	memset(&cor, 0, sizeof(cor));
+	memset(&reorder, 0, sizeof(reorder));
+	memset(&corrupt, 0, sizeof(corrupt));
+
+	netem = netem_qdisc(qdisc);
+	if (!netem || !msg)
+		return EFAULT;
+		
+	msg->nm_nlh->nlmsg_flags |= NLM_F_REQUEST;
+	
+	if ( netem->qnm_ro.nmro_probability != 0 ) {
+		if (netem->qnm_latency == 0) {
+			return -NLE_MISSING_ATTR;
+		}
+		if (netem->qnm_gap == 0) netem->qnm_gap = 1;
+	}
+	else if ( netem->qnm_gap ) { 
+		return -NLE_MISSING_ATTR;
+	}
+
+	if ( netem->qnm_corr.nmc_delay != 0 ) {
+		if ( netem->qnm_latency == 0 || netem->qnm_jitter == 0) {
+			return -NLE_MISSING_ATTR;
+		}
+		set_correlation = 1;
+	}
+	
+	if ( netem->qnm_corr.nmc_loss != 0 ) {
+		if ( netem->qnm_loss == 0 ) {
+			return -NLE_MISSING_ATTR;
+		}
+		set_correlation = 1;
+	}
+
+	if ( netem->qnm_corr.nmc_duplicate != 0 ) {
+		if ( netem->qnm_duplicate == 0 ) {
+			return -NLE_MISSING_ATTR;
+		}
+		set_correlation = 1;
+	}
+	
+	if ( netem->qnm_ro.nmro_probability != 0 ) set_reorder = 1;
+	else if ( netem->qnm_ro.nmro_correlation != 0 ) {
+			return -NLE_MISSING_ATTR;
+	}
+	
+	if ( netem->qnm_crpt.nmcr_probability != 0 ) set_corrupt = 1;
+	else if ( netem->qnm_crpt.nmcr_correlation != 0 ) {
+			return -NLE_MISSING_ATTR;
+	}
+	
+	if ( netem->qnm_dist.dist_data && netem->qnm_dist.dist_size ) {
+		if (netem->qnm_latency == 0 || netem->qnm_jitter == 0) {
+			return -NLE_MISSING_ATTR;
+	}
+	else {
+		/* Resize to accomodate the large distribution table */
+		int new_msg_len = msg->nm_size + netem->qnm_dist.dist_size *
+			sizeof(netem->qnm_dist.dist_data[0]);
+		
+		msg->nm_nlh = (struct nlmsghdr *) realloc(msg->nm_nlh, new_msg_len);
+		if ( msg->nm_nlh == NULL )
+			return -NLE_NOMEM;
+		msg->nm_size = new_msg_len;
+			set_dist = 1;
+		}
+	}
+	
+	opts.latency = netem->qnm_latency;
+	opts.limit = netem->qnm_limit ? netem->qnm_limit : 1000;
+	opts.loss = netem->qnm_loss;
+	opts.gap = netem->qnm_gap;
+	opts.duplicate = netem->qnm_duplicate;
+	opts.jitter = netem->qnm_jitter;
+	
+	NLA_PUT(msg, TCA_OPTIONS, sizeof(opts), &opts);
+	
+	if ( set_correlation ) {
+		cor.delay_corr = netem->qnm_corr.nmc_delay;
+		cor.loss_corr = netem->qnm_corr.nmc_loss;
+		cor.dup_corr = netem->qnm_corr.nmc_duplicate;
+
+		NLA_PUT(msg, TCA_NETEM_CORR, sizeof(cor), &cor);
+	}
+	
+	if ( set_reorder ) {
+		reorder.probability = netem->qnm_ro.nmro_probability;
+		reorder.correlation = netem->qnm_ro.nmro_correlation;
+
+		NLA_PUT(msg, TCA_NETEM_REORDER, sizeof(reorder), &reorder);
+	}
+	
+	if ( set_corrupt ) {
+		corrupt.probability = netem->qnm_crpt.nmcr_probability;
+		corrupt.correlation = netem->qnm_crpt.nmcr_correlation;
+
+		NLA_PUT(msg, TCA_NETEM_CORRUPT, sizeof(corrupt), &corrupt);
+	}
+	
+	if ( set_dist ) {
+		NLA_PUT(msg, TCA_NETEM_DELAY_DIST,
+			netem->qnm_dist.dist_size * sizeof(netem->qnm_dist.dist_data[0]),
+			netem->qnm_dist.dist_data);
+	}
+
+	/* Length specified in the TCA_OPTIONS section must span the entire
+	 * remainder of the message. That's just the way that sch_netem expects it.
+	 * Maybe there's a more succinct way to do this at a higher level.
+	 */
+	struct nlattr* head = (struct nlattr *)(NLMSG_DATA(msg->nm_nlh) +
+		NLMSG_LENGTH(sizeof(struct tcmsg)) - NLMSG_ALIGNTO);
+		
+	struct nlattr* tail = (struct nlattr *)(((void *) (msg->nm_nlh)) +
+		NLMSG_ALIGN(msg->nm_nlh->nlmsg_len));
+	
+	int old_len = head->nla_len;
+	head->nla_len = (void *)tail - (void *)head;
+	msg->nm_nlh->nlmsg_len += (head->nla_len - old_len);
+	
+	return err;
+nla_put_failure:
+	return -NLE_MSGSIZE;
+}
+
+/**
+ * @name Queue Limit
+ * @{
+ */
+
+/**
+ * Set limit of netem qdisc.
+ * @arg qdisc		Netem qdisc to be modified.
+ * @arg limit		New limit in bytes.
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_netem_set_limit(struct rtnl_qdisc *qdisc, int limit)
+{
+	struct rtnl_netem *netem;
+
+	netem = netem_alloc(qdisc);
+	if (!netem)
+		return -NLE_NOMEM;
+	
+	netem->qnm_limit = limit;
+	netem->qnm_mask |= SCH_NETEM_ATTR_LIMIT;
+
+	return 0;
+}
+
+/**
+ * Get limit of netem qdisc.
+ * @arg qdisc		Netem qdisc.
+ * @return Limit in bytes or a negative error code.
+ */
+int rtnl_netem_get_limit(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_netem *netem;
+
+	netem = netem_qdisc(qdisc);
+	if (netem && (netem->qnm_mask & SCH_NETEM_ATTR_LIMIT))
+		return netem->qnm_limit;
+	else
+		return -NLE_NOATTR;
+}
+
+/** @} */
+
+/**
+ * @name Packet Re-ordering
+ * @{
+ */
+
+/**
+ * Set re-ordering gap of netem qdisc.
+ * @arg qdisc		Netem qdisc to be modified.
+ * @arg gap		New gap in number of packets.
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_netem_set_gap(struct rtnl_qdisc *qdisc, int gap)
+{
+	struct rtnl_netem *netem;
+
+	netem = netem_alloc(qdisc);
+	if (!netem)
+		return -NLE_NOMEM;
+
+	netem->qnm_gap = gap;
+	netem->qnm_mask |= SCH_NETEM_ATTR_GAP;
+
+	return 0;
+}
+
+/**
+ * Get re-ordering gap of netem qdisc.
+ * @arg qdisc		Netem qdisc.
+ * @return Re-ordering gap in packets or a negative error code.
+ */
+int rtnl_netem_get_gap(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_netem *netem;
+
+	netem = netem_qdisc(qdisc);
+	if (netem && (netem->qnm_mask & SCH_NETEM_ATTR_GAP))
+		return netem->qnm_gap;
+	else
+		return -NLE_NOATTR;
+}
+
+/**
+ * Set re-ordering probability of netem qdisc.
+ * @arg qdisc		Netem qdisc to be modified.
+ * @arg prob		New re-ordering probability.
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_netem_set_reorder_probability(struct rtnl_qdisc *qdisc, int prob)
+{
+	struct rtnl_netem *netem;
+
+	netem = netem_alloc(qdisc);
+	if (!netem)
+		return -NLE_NOMEM;
+
+	netem->qnm_ro.nmro_probability = prob;
+	netem->qnm_mask |= SCH_NETEM_ATTR_RO_PROB;
+
+	return 0;
+}
+
+/**
+ * Get re-ordering probability of netem qdisc.
+ * @arg qdisc		Netem qdisc.
+ * @return Re-ordering probability or a negative error code.
+ */
+int rtnl_netem_get_reorder_probability(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_netem *netem;
+
+	netem = netem_qdisc(qdisc);
+	if (netem && (netem->qnm_mask & SCH_NETEM_ATTR_RO_PROB))
+		return netem->qnm_ro.nmro_probability;
+	else
+		return -NLE_NOATTR;
+}
+
+/**
+ * Set re-order correlation probability of netem qdisc.
+ * @arg qdisc		Netem qdisc to be modified.
+ * @arg prob		New re-ordering correlation probability.
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_netem_set_reorder_correlation(struct rtnl_qdisc *qdisc, int prob)
+{
+	struct rtnl_netem *netem;
+
+	netem = netem_alloc(qdisc);
+	if (!netem)
+		return -NLE_NOMEM;
+
+	netem->qnm_ro.nmro_correlation = prob;
+	netem->qnm_mask |= SCH_NETEM_ATTR_RO_CORR;
+
+	return 0;
+}
+
+/**
+ * Get re-ordering correlation probability of netem qdisc.
+ * @arg qdisc		Netem qdisc.
+ * @return Re-ordering correlation probability or a negative error code.
+ */
+int rtnl_netem_get_reorder_correlation(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_netem *netem;
+
+	netem = netem_qdisc(qdisc);
+	if (netem && (netem->qnm_mask & SCH_NETEM_ATTR_RO_CORR))
+		return netem->qnm_ro.nmro_correlation;
+	else
+		return -NLE_NOATTR;
+}
+
+/** @} */
+
+/**
+ * @name Corruption
+ * @{
+ */
+ 
+/**
+ * Set corruption probability of netem qdisc.
+ * @arg qdisc		Netem qdisc to be modified.
+ * @arg prob		New corruption probability.
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_netem_set_corruption_probability(struct rtnl_qdisc *qdisc, int prob)
+{
+	struct rtnl_netem *netem;
+
+	netem = netem_alloc(qdisc);
+	if (!netem)
+		return -NLE_NOMEM;
+
+	netem->qnm_crpt.nmcr_probability = prob;
+	netem->qnm_mask |= SCH_NETEM_ATTR_CORRUPT_PROB;
+
+	return 0;
+}
+
+/**
+ * Get corruption probability of netem qdisc.
+ * @arg qdisc		Netem qdisc.
+ * @return Corruption probability or a negative error code.
+ */
+int rtnl_netem_get_corruption_probability(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_netem *netem;
+
+	netem = netem_qdisc(qdisc);
+	if (netem && (netem->qnm_mask & SCH_NETEM_ATTR_CORRUPT_PROB))
+		return netem->qnm_crpt.nmcr_probability;
+	else
+		return -NLE_NOATTR;
+}
+
+/**
+ * Set corruption correlation probability of netem qdisc.
+ * @arg qdisc		Netem qdisc to be modified.
+ * @arg prob		New corruption correlation probability.
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_netem_set_corruption_correlation(struct rtnl_qdisc *qdisc, int prob)
+{
+	struct rtnl_netem *netem;
+
+	netem = netem_alloc(qdisc);
+	if (!netem)
+		return -NLE_NOMEM;
+
+	netem->qnm_crpt.nmcr_correlation = prob;
+	netem->qnm_mask |= SCH_NETEM_ATTR_CORRUPT_CORR;
+
+	return 0;
+}
+
+/**
+ * Get corruption correlation probability of netem qdisc.
+ * @arg qdisc		Netem qdisc.
+ * @return Corruption correlation probability or a negative error code.
+ */
+int rtnl_netem_get_corruption_correlation(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_netem *netem;
+
+	netem = netem_qdisc(qdisc);
+	if (netem && (netem->qnm_mask & SCH_NETEM_ATTR_CORRUPT_CORR))
+		return netem->qnm_crpt.nmcr_correlation;
+	else
+		return -NLE_NOATTR;
+}
+
+/** @} */
+
+/**
+ * @name Packet Loss
+ * @{
+ */
+
+/**
+ * Set packet loss probability of netem qdisc.
+ * @arg qdisc		Netem qdisc to be modified.
+ * @arg prob		New packet loss probability.
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_netem_set_loss(struct rtnl_qdisc *qdisc, int prob)
+{
+	struct rtnl_netem *netem;
+
+	netem = netem_alloc(qdisc);
+	if (!netem)
+		return -NLE_NOMEM;
+
+	netem->qnm_loss = prob;
+	netem->qnm_mask |= SCH_NETEM_ATTR_LOSS;
+
+	return 0;
+}
+
+/**
+ * Get packet loss probability of netem qdisc.
+ * @arg qdisc		Netem qdisc.
+ * @return Packet loss probability or a negative error code.
+ */
+int rtnl_netem_get_loss(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_netem *netem;
+
+	netem = netem_qdisc(qdisc);
+	if (netem && (netem->qnm_mask & SCH_NETEM_ATTR_LOSS))
+		return netem->qnm_loss;
+	else
+		return -NLE_NOATTR;
+}
+
+/**
+ * Set packet loss correlation probability of netem qdisc.
+ * @arg qdisc		Netem qdisc to be modified.
+ * @arg prob	New packet loss correlation.
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_netem_set_loss_correlation(struct rtnl_qdisc *qdisc, int prob)
+{
+	struct rtnl_netem *netem;
+
+	netem = netem_alloc(qdisc);
+	if (!netem)
+		return -NLE_NOMEM;
+
+	netem->qnm_corr.nmc_loss = prob;
+	netem->qnm_mask |= SCH_NETEM_ATTR_LOSS_CORR;
+
+	return 0;
+}
+
+/**
+ * Get packet loss correlation probability of netem qdisc.
+ * @arg qdisc		Netem qdisc.
+ * @return Packet loss correlation probability or a negative error code.
+ */
+int rtnl_netem_get_loss_correlation(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_netem *netem;
+
+	netem = netem_qdisc(qdisc);
+	if (netem && (netem->qnm_mask & SCH_NETEM_ATTR_LOSS_CORR))
+		return netem->qnm_corr.nmc_loss;
+	else
+		return -NLE_NOATTR;
+}
+
+/** @} */
+
+/**
+ * @name Packet Duplication
+ * @{
+ */
+
+/**
+ * Set packet duplication probability of netem qdisc.
+ * @arg qdisc		Netem qdisc to be modified.
+ * @arg prob	New packet duplication probability.
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_netem_set_duplicate(struct rtnl_qdisc *qdisc, int prob)
+{
+	struct rtnl_netem *netem;
+
+	netem = netem_alloc(qdisc);
+	if (!netem)
+		return -NLE_NOMEM;
+
+	netem->qnm_duplicate = prob;
+	netem->qnm_mask |= SCH_NETEM_ATTR_DUPLICATE;
+
+	return 0;
+}
+
+/**
+ * Get packet duplication probability of netem qdisc.
+ * @arg qdisc		Netem qdisc.
+ * @return Packet duplication probability or a negative error code.
+ */
+int rtnl_netem_get_duplicate(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_netem *netem;
+
+	netem = netem_qdisc(qdisc);
+	if (netem && (netem->qnm_mask & SCH_NETEM_ATTR_DUPLICATE))
+		return netem->qnm_duplicate;
+	else
+		return -NLE_NOATTR;
+}
+
+/**
+ * Set packet duplication correlation probability of netem qdisc.
+ * @arg qdisc		Netem qdisc to be modified.
+ * @arg prob		New packet duplication correlation probability.
+ * @return 0 on sucess or a negative error code.
+ */
+int rtnl_netem_set_duplicate_correlation(struct rtnl_qdisc *qdisc, int prob)
+{
+	struct rtnl_netem *netem;
+
+	netem = netem_alloc(qdisc);
+	if (!netem)
+		return -NLE_NOMEM;
+
+	netem->qnm_corr.nmc_duplicate = prob;
+	netem->qnm_mask |= SCH_NETEM_ATTR_DUP_CORR;
+
+	return 0;
+}
+
+/**
+ * Get packet duplication correlation probability of netem qdisc.
+ * @arg qdisc		Netem qdisc.
+ * @return Packet duplication correlation probability or a negative error code.
+ */
+int rtnl_netem_get_duplicate_correlation(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_netem *netem;
+
+	netem = netem_qdisc(qdisc);
+	if (netem && (netem->qnm_mask & SCH_NETEM_ATTR_DUP_CORR))
+		return netem->qnm_corr.nmc_duplicate;
+	else
+		return -NLE_NOATTR;
+}
+
+/** @} */
+
+/**
+ * @name Packet Delay
+ * @{
+ */
+
+/**
+ * Set packet delay of netem qdisc.
+ * @arg qdisc		Netem qdisc to be modified.
+ * @arg delay		New packet delay in micro seconds.
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_netem_set_delay(struct rtnl_qdisc *qdisc, int delay)
+{
+	struct rtnl_netem *netem;
+
+	netem = netem_alloc(qdisc);
+	if (!netem)
+		return -NLE_NOMEM;
+
+	netem->qnm_latency = nl_us2ticks(delay);
+	netem->qnm_mask |= SCH_NETEM_ATTR_LATENCY;
+
+	return 0;
+}
+
+/**
+ * Get packet delay of netem qdisc.
+ * @arg qdisc		Netem qdisc.
+ * @return Packet delay in micro seconds or a negative error code.
+ */
+int rtnl_netem_get_delay(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_netem *netem;
+
+	netem = netem_qdisc(qdisc);
+	if (netem && (netem->qnm_mask & SCH_NETEM_ATTR_LATENCY))
+		return nl_ticks2us(netem->qnm_latency);
+	else
+		return -NLE_NOATTR;
+}
+
+/**
+ * Set packet delay jitter of netem qdisc.
+ * @arg qdisc		Netem qdisc to be modified.
+ * @arg jitter		New packet delay jitter in micro seconds.
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_netem_set_jitter(struct rtnl_qdisc *qdisc, int jitter)
+{
+	struct rtnl_netem *netem;
+
+	netem = netem_alloc(qdisc);
+	if (!netem)
+		return -NLE_NOMEM;
+
+	netem->qnm_jitter = nl_us2ticks(jitter);
+	netem->qnm_mask |= SCH_NETEM_ATTR_JITTER;
+
+	return 0;
+}
+
+/**
+ * Get packet delay jitter of netem qdisc.
+ * @arg qdisc		Netem qdisc.
+ * @return Packet delay jitter in micro seconds or a negative error code.
+ */
+int rtnl_netem_get_jitter(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_netem *netem;
+
+	netem = netem_qdisc(qdisc);
+	if (netem && (netem->qnm_mask & SCH_NETEM_ATTR_JITTER))
+		return nl_ticks2us(netem->qnm_jitter);
+	else
+		return -NLE_NOATTR;
+}
+
+/**
+ * Set packet delay correlation probability of netem qdisc.
+ * @arg qdisc		Netem qdisc to be modified.
+ * @arg prob		New packet delay correlation probability.
+ */
+int rtnl_netem_set_delay_correlation(struct rtnl_qdisc *qdisc, int prob)
+{
+	struct rtnl_netem *netem;
+
+	netem = netem_alloc(qdisc);
+	if (!netem)
+		return -NLE_NOMEM;
+
+	netem->qnm_corr.nmc_delay = prob;
+	netem->qnm_mask |= SCH_NETEM_ATTR_DELAY_CORR;
+
+	return 0;
+}
+
+/**
+ * Get packet delay correlation probability of netem qdisc.
+ * @arg qdisc		Netem qdisc.
+ * @return Packet delay correlation probability or a negative error code.
+ */
+int rtnl_netem_get_delay_correlation(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_netem *netem;
+
+	netem = netem_qdisc(qdisc);
+	if (netem && (netem->qnm_mask & SCH_NETEM_ATTR_DELAY_CORR))
+		return netem->qnm_corr.nmc_delay;
+	else
+		return -NLE_NOATTR;
+}
+
+/**
+ * Get the size of the distribution table.
+ * @arg qdisc		Netem qdisc.
+ * @return Distribution table size or a negative error code.
+ */
+int rtnl_netem_get_delay_distribution_size(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_netem *netem;
+
+	netem = netem_qdisc(qdisc);
+	if (netem && (netem->qnm_mask & SCH_NETEM_ATTR_DIST))
+		return netem->qnm_dist.dist_size;
+	else
+		return -NLE_NOATTR;
+}
+
+/**
+ * Get a pointer to the distribution table.
+ * @arg qdisc		Netem qdisc.
+ * @arg dist_ptr	The pointer to set.
+ * @return Negative error code on failure or 0 on success.
+ */
+int rtnl_netem_get_delay_distribution(struct rtnl_qdisc *qdisc, int16_t **dist_ptr)
+{
+	struct rtnl_netem *netem;
+
+	netem = netem_qdisc(qdisc);
+	if (netem && (netem->qnm_mask & SCH_NETEM_ATTR_DIST)) {
+		*dist_ptr = netem->qnm_dist.dist_data;
+		return 0;
+	}
+	else
+		return -NLE_NOATTR;
+}
+
+/**
+ * Set the delay distribution. Latency/jitter must be set before applying.
+ * @arg qdisc Netem qdisc.
+ * @arg dist_type The name of the distribution (type, file, path/file).
+ * @return 0 on success, error code on failure.
+ */
+int rtnl_netem_set_delay_distribution(struct rtnl_qdisc *qdisc, const char *dist_type) {
+	struct rtnl_netem *netem;
+
+	netem = netem_alloc(qdisc);
+	if (!netem)
+		return -NLE_NOMEM;
+		
+	FILE *f = NULL;
+	int i, n = 0;
+	size_t len = 2048;
+	char *line;
+	char name[NAME_MAX];
+	char dist_suffix[] = ".dist";
+	
+	/* If the given filename already ends in .dist, don't append it later */
+	char *test_suffix = strstr(dist_type, dist_suffix);
+	if (test_suffix != NULL && strlen(test_suffix) == 5)
+		strcpy(dist_suffix, "");
+	
+	/* Check several locations for the dist file */
+	char *test_path[] = { "", "./", "/usr/lib/tc/", "/usr/local/lib/tc/" };
+	
+	for (i = 0; i < sizeof(test_path) && f == NULL; i++) {
+		snprintf(name, NAME_MAX, "%s%s%s", test_path[i], dist_type, dist_suffix);
+		f = fopen(name, "r");
+	}
+	
+	if ( f == NULL )
+		return -nl_syserr2nlerr(errno);
+	
+	netem->qnm_dist.dist_data = (int16_t *) calloc (MAXDIST, sizeof(int16_t));
+	
+	line = (char *) calloc (sizeof(char), len + 1);
+	
+	while (getline(&line, &len, f) != -1) {
+		char *p, *endp;
+		
+		if (*line == '\n' || *line == '#')
+			continue;
+
+		for (p = line; ; p = endp) {
+			long x = strtol(p, &endp, 0);
+			if (endp == p) break;
+
+			if (n >= MAXDIST) {
+				free(line);
+				fclose(f);
+				return -NLE_INVAL;
+			}
+			netem->qnm_dist.dist_data[n++] = x;
+		}		
+	}
+	
+	free(line);
+	
+	netem->qnm_dist.dist_size = n;
+	netem->qnm_mask |= SCH_NETEM_ATTR_DIST;
+	
+	fclose(f);
+	return 0;	
+}
+
+/** @} */
+
+static struct rtnl_qdisc_ops netem_ops = {
+	.qo_kind		= "netem",
+	.qo_msg_parser		= netem_msg_parser,
+	.qo_free_data		= netem_free_data,
+	.qo_dump[NL_DUMP_LINE]	= netem_dump_line,
+	.qo_get_opts		= 0,
+	.qo_build_msg	= netem_build_msg
+};
+
+static void __init netem_init(void)
+{
+	rtnl_qdisc_register(&netem_ops);
+}
+
+static void __exit netem_exit(void)
+{
+	rtnl_qdisc_unregister(&netem_ops);
+}
+
+/** @} */
diff -uNr libnl_kk/lib/route/sch/prio.c libnl/lib/route/sch/prio.c
--- libnl_kk/lib/route/sch/prio.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/sch/prio.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,326 @@
+/*
+ * lib/route/sch/prio.c		PRIO Qdisc/Class
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup qdisc_api
+ * @defgroup prio (Fast) Prio
+ * @brief
+ *
+ * @par 1) Typical PRIO configuration
+ * @code
+ * // Specify the maximal number of bands to be used for this PRIO qdisc.
+ * rtnl_qdisc_prio_set_bands(qdisc, QDISC_PRIO_DEFAULT_BANDS);
+ *
+ * // Provide a map assigning each priority to a band number.
+ * uint8_t map[] = QDISC_PRIO_DEFAULT_PRIOMAP;
+ * rtnl_qdisc_prio_set_priomap(qdisc, map, sizeof(map));
+ * @endcode
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink-tc.h>
+#include <netlink/netlink.h>
+#include <netlink/utils.h>
+#include <netlink/route/qdisc.h>
+#include <netlink/route/qdisc-modules.h>
+#include <netlink/route/sch/prio.h>
+
+/** @cond SKIP */
+#define SCH_PRIO_ATTR_BANDS	1
+#define SCH_PRIO_ATTR_PRIOMAP	2
+/** @endcond */
+
+static inline struct rtnl_prio *prio_qdisc(struct rtnl_qdisc *qdisc)
+{
+	return (struct rtnl_prio *) qdisc->q_subdata;
+}
+
+static inline struct rtnl_prio *prio_alloc(struct rtnl_qdisc *qdisc)
+{
+	if (!qdisc->q_subdata)
+		qdisc->q_subdata = calloc(1, sizeof(struct rtnl_prio));
+
+	return prio_qdisc(qdisc);
+}
+
+static int prio_msg_parser(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_prio *prio;
+	struct tc_prio_qopt *opt;
+
+	if (qdisc->q_opts->d_size < sizeof(*opt))
+		return -NLE_INVAL;
+
+	prio = prio_alloc(qdisc);
+	if (!prio)
+		return -NLE_NOMEM;
+
+	opt = (struct tc_prio_qopt *) qdisc->q_opts->d_data;
+	prio->qp_bands = opt->bands;
+	memcpy(prio->qp_priomap, opt->priomap, sizeof(prio->qp_priomap));
+	prio->qp_mask = (SCH_PRIO_ATTR_BANDS | SCH_PRIO_ATTR_PRIOMAP);
+	
+	return 0;
+}
+
+static void prio_free_data(struct rtnl_qdisc *qdisc)
+{
+	free(qdisc->q_subdata);
+}
+
+static void prio_dump_line(struct rtnl_qdisc *qdisc, struct nl_dump_params *p)
+{
+	struct rtnl_prio *prio = prio_qdisc(qdisc);
+
+	if (prio)
+		nl_dump(p, " bands %u", prio->qp_bands);
+}
+
+static void prio_dump_details(struct rtnl_qdisc *qdisc,struct nl_dump_params *p)
+{
+	struct rtnl_prio *prio = prio_qdisc(qdisc);
+	int i, hp;
+
+	if (!prio)
+		return;
+
+	nl_dump(p, "priomap [");
+	
+	for (i = 0; i <= TC_PRIO_MAX; i++)
+		nl_dump(p, "%u%s", prio->qp_priomap[i],
+			i < TC_PRIO_MAX ? " " : "");
+
+	nl_dump(p, "]\n");
+	nl_new_line(p);
+
+	hp = (((TC_PRIO_MAX/2) + 1) & ~1);
+
+	for (i = 0; i < hp; i++) {
+		char a[32];
+		nl_dump(p, "    %18s => %u",
+			rtnl_prio2str(i, a, sizeof(a)),
+			prio->qp_priomap[i]);
+		if (hp+i <= TC_PRIO_MAX) {
+			nl_dump(p, " %18s => %u",
+				rtnl_prio2str(hp+i, a, sizeof(a)),
+				prio->qp_priomap[hp+i]);
+			if (i < (hp - 1)) {
+				nl_dump(p, "\n");
+				nl_new_line(p);
+			}
+		}
+	}
+}
+
+static struct nl_msg *prio_get_opts(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_prio *prio;
+	struct tc_prio_qopt opts;
+	struct nl_msg *msg;
+
+	prio = prio_qdisc(qdisc);
+	if (!prio ||
+	    !(prio->qp_mask & SCH_PRIO_ATTR_PRIOMAP))
+		goto errout;
+
+	opts.bands = prio->qp_bands;
+	memcpy(opts.priomap, prio->qp_priomap, sizeof(opts.priomap));
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		goto errout;
+
+	if (nlmsg_append(msg, &opts, sizeof(opts), NL_DONTPAD) < 0) {
+		nlmsg_free(msg);
+		goto errout;
+	}
+
+	return msg;
+errout:
+	return NULL;
+}
+
+/**
+ * @name Attribute Modification
+ * @{
+ */
+
+/**
+ * Set number of bands of PRIO qdisc.
+ * @arg qdisc		PRIO qdisc to be modified.
+ * @arg bands		New number of bands.
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_qdisc_prio_set_bands(struct rtnl_qdisc *qdisc, int bands)
+{
+	struct rtnl_prio *prio;
+	
+	prio = prio_alloc(qdisc);
+	if (!prio)
+		return -NLE_NOMEM;
+
+	prio->qp_bands = bands;
+	prio->qp_mask |= SCH_PRIO_ATTR_BANDS;
+
+	return 0;
+}
+
+/**
+ * Get number of bands of PRIO qdisc.
+ * @arg qdisc		PRIO qdisc.
+ * @return Number of bands or a negative error code.
+ */
+int rtnl_qdisc_prio_get_bands(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_prio *prio;
+
+	prio = prio_qdisc(qdisc);
+	if (prio && prio->qp_mask & SCH_PRIO_ATTR_BANDS)
+		return prio->qp_bands;
+	else
+		return -NLE_NOMEM;
+}
+
+/**
+ * Set priomap of the PRIO qdisc.
+ * @arg qdisc		PRIO qdisc to be modified.
+ * @arg priomap		New priority mapping.
+ * @arg len		Length of priomap (# of elements).
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_qdisc_prio_set_priomap(struct rtnl_qdisc *qdisc, uint8_t priomap[],
+				int len)
+{
+	struct rtnl_prio *prio;
+	int i;
+
+	prio = prio_alloc(qdisc);
+	if (!prio)
+		return -NLE_NOMEM;
+
+	if (!(prio->qp_mask & SCH_PRIO_ATTR_BANDS))
+		return -NLE_MISSING_ATTR;
+
+	if ((len / sizeof(uint8_t)) > (TC_PRIO_MAX+1))
+		return -NLE_RANGE;
+
+	for (i = 0; i <= TC_PRIO_MAX; i++) {
+		if (priomap[i] > prio->qp_bands)
+			return -NLE_RANGE;
+	}
+
+	memcpy(prio->qp_priomap, priomap, len);
+	prio->qp_mask |= SCH_PRIO_ATTR_PRIOMAP;
+
+	return 0;
+}
+
+/**
+ * Get priomap of a PRIO qdisc.
+ * @arg qdisc		PRIO qdisc.
+ * @return Priority mapping as array of size TC_PRIO_MAX+1
+ *         or NULL if an error occured.
+ */
+uint8_t *rtnl_qdisc_prio_get_priomap(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_prio *prio;
+
+	prio = prio_qdisc(qdisc);
+	if (prio && prio->qp_mask & SCH_PRIO_ATTR_PRIOMAP)
+		return prio->qp_priomap;
+	else
+		return NULL;
+}
+
+/** @} */
+
+/**
+ * @name Priority Band Translations
+ * @{
+ */
+
+static struct trans_tbl prios[] = {
+	__ADD(TC_PRIO_BESTEFFORT,besteffort)
+	__ADD(TC_PRIO_FILLER,filler)
+	__ADD(TC_PRIO_BULK,bulk)
+	__ADD(TC_PRIO_INTERACTIVE_BULK,interactive_bulk)
+	__ADD(TC_PRIO_INTERACTIVE,interactive)
+	__ADD(TC_PRIO_CONTROL,control)
+};
+
+/**
+ * Convert priority to character string.
+ * @arg prio		Priority.
+ * @arg buf		Destination buffer
+ * @arg size		Size of destination buffer.
+ *
+ * Converts a priority to a character string and stores the result in
+ * the specified destination buffer.
+ *
+ * @return Name of priority as character string.
+ */
+char * rtnl_prio2str(int prio, char *buf, size_t size)
+{
+	return __type2str(prio, buf, size, prios, ARRAY_SIZE(prios));
+}
+
+/**
+ * Convert character string to priority.
+ * @arg name		Name of priority.
+ *
+ * Converts the provided character string specifying a priority
+ * to the corresponding numeric value.
+ *
+ * @return Numeric priority or a negative value if no match was found.
+ */
+int rtnl_str2prio(const char *name)
+{
+	return __str2type(name, prios, ARRAY_SIZE(prios));
+}
+
+/** @} */
+
+static struct rtnl_qdisc_ops prio_ops = {
+	.qo_kind		= "prio",
+	.qo_msg_parser		= prio_msg_parser,
+	.qo_free_data		= prio_free_data,
+	.qo_dump = {
+	    [NL_DUMP_LINE]	= prio_dump_line,
+	    [NL_DUMP_DETAILS]	= prio_dump_details,
+	},
+	.qo_get_opts		= prio_get_opts,
+};
+
+static struct rtnl_qdisc_ops pfifo_fast_ops = {
+	.qo_kind		= "pfifo_fast",
+	.qo_msg_parser		= prio_msg_parser,
+	.qo_free_data		= prio_free_data,
+	.qo_dump = {
+	    [NL_DUMP_LINE]	= prio_dump_line,
+	    [NL_DUMP_DETAILS]	= prio_dump_details,
+	},
+	.qo_get_opts		= prio_get_opts,
+};
+
+static void __init prio_init(void)
+{
+	rtnl_qdisc_register(&prio_ops);
+	rtnl_qdisc_register(&pfifo_fast_ops);
+}
+
+static void __exit prio_exit(void)
+{
+	rtnl_qdisc_unregister(&prio_ops);
+	rtnl_qdisc_unregister(&pfifo_fast_ops);
+}
+
+/** @} */
diff -uNr libnl_kk/lib/route/sch/red.c libnl/lib/route/sch/red.c
--- libnl_kk/lib/route/sch/red.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/sch/red.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,212 @@
+/*
+ * lib/route/sch/red.c		RED Qdisc
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup qdisc_api
+ * @defgroup red Random Early Detection (RED)
+ * @brief
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink-tc.h>
+#include <netlink/netlink.h>
+#include <netlink/utils.h>
+#include <netlink/route/qdisc.h>
+#include <netlink/route/qdisc-modules.h>
+#include <netlink/route/sch/red.h>
+
+/** @cond SKIP */
+#define RED_ATTR_LIMIT		0x01
+#define RED_ATTR_QTH_MIN	0x02
+#define RED_ATTR_QTH_MAX	0x04
+#define RED_ATTR_FLAGS		0x08
+#define RED_ATTR_WLOG		0x10
+#define RED_ATTR_PLOG		0x20
+#define RED_ATTR_SCELL_LOG	0x40
+/** @endcond */
+
+static inline struct rtnl_red *red_qdisc(struct rtnl_qdisc *qdisc)
+{
+	return (struct rtnl_red *) qdisc->q_subdata;
+}
+
+static inline struct rtnl_red *red_alloc(struct rtnl_qdisc *qdisc)
+{
+	if (!qdisc->q_subdata)
+		qdisc->q_subdata = calloc(1, sizeof(struct rtnl_red));
+
+	return red_qdisc(qdisc);
+}
+
+static struct nla_policy red_policy[TCA_RED_MAX+1] = {
+	[TCA_RED_PARMS]		= { .minlen = sizeof(struct tc_red_qopt) },
+};
+
+static int red_msg_parser(struct rtnl_qdisc *qdisc)
+{
+	struct nlattr *tb[TCA_RED_MAX+1];
+	struct rtnl_red *red;
+	struct tc_red_qopt *opts;
+	int err;
+
+	if (!(qdisc->ce_mask & TCA_ATTR_OPTS))
+		return 0;
+
+	err = tca_parse(tb, TCA_RED_MAX, (struct rtnl_tca *) qdisc, red_policy);
+	if (err < 0)
+		return err;
+
+	if (!tb[TCA_RED_PARMS])
+		return -NLE_MISSING_ATTR;
+
+	red = red_alloc(qdisc);
+	if (!red)
+		return -NLE_NOMEM;
+
+	opts = nla_data(tb[TCA_RED_PARMS]);
+
+	red->qr_limit = opts->limit;
+	red->qr_qth_min = opts->qth_min;
+	red->qr_qth_max = opts->qth_max;
+	red->qr_flags = opts->flags;
+	red->qr_wlog = opts->Wlog;
+	red->qr_plog = opts->Plog;
+	red->qr_scell_log = opts->Scell_log;
+
+	red->qr_mask = (RED_ATTR_LIMIT | RED_ATTR_QTH_MIN | RED_ATTR_QTH_MAX |
+			RED_ATTR_FLAGS | RED_ATTR_WLOG | RED_ATTR_PLOG |
+			RED_ATTR_SCELL_LOG);
+
+	return 0;
+}
+
+static void red_dump_line(struct rtnl_qdisc *qdisc, struct nl_dump_params *p)
+{
+	struct rtnl_red *red = red_qdisc(qdisc);
+
+	if (red) {
+		/* XXX: limit, min, max, flags */
+	}
+}
+
+static void red_dump_details(struct rtnl_qdisc *qdisc, struct nl_dump_params *p)
+{
+	struct rtnl_red *red = red_qdisc(qdisc);
+
+	if (red) {
+		/* XXX: wlog, plog, scell_log */
+	}
+}
+
+static void red_dump_stats(struct rtnl_qdisc *qdisc, struct nl_dump_params *p)
+{
+	struct rtnl_red *red = red_qdisc(qdisc);
+
+	if (red) {
+		/* XXX: xstats */
+	}
+}
+
+static struct nl_msg *red_get_opts(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_red *red;
+	struct nl_msg *msg;
+
+	red = red_qdisc(qdisc);
+	if (!red)
+		return NULL;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		goto errout;
+
+#if 0
+	memset(&opts, 0, sizeof(opts));
+	opts.quantum = sfq->qs_quantum;
+	opts.perturb_period = sfq->qs_perturb;
+	opts.limit = sfq->qs_limit;
+
+	if (nlmsg_append(msg, &opts, sizeof(opts), NL_DONTPAD) < 0)
+		goto errout;
+#endif
+
+	return msg;
+errout:
+	nlmsg_free(msg);
+	return NULL;
+}
+
+/**
+ * @name Attribute Access
+ * @{
+ */
+
+/**
+ * Set limit of RED qdisc.
+ * @arg qdisc		RED qdisc to be modified.
+ * @arg limit		New limit in number of packets.
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_red_set_limit(struct rtnl_qdisc *qdisc, int limit)
+{
+	struct rtnl_red *red;
+
+	red = red_alloc(qdisc);
+	if (!red)
+		return -NLE_NOMEM;
+
+	red->qr_limit = limit;
+	red->qr_mask |= RED_ATTR_LIMIT;
+
+	return 0;
+}
+
+/**
+ * Get limit of RED qdisc.
+ * @arg qdisc		RED qdisc.
+ * @return Limit or a negative error code.
+ */
+int rtnl_red_get_limit(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_red *red;
+
+	red = red_qdisc(qdisc);
+	if (red && (red->qr_mask & RED_ATTR_LIMIT))
+		return red->qr_limit;
+	else
+		return -NLE_NOATTR;
+}
+
+/** @} */
+
+static struct rtnl_qdisc_ops red_ops = {
+	.qo_kind		= "red",
+	.qo_msg_parser		= red_msg_parser,
+	.qo_dump = {
+	    [NL_DUMP_LINE]	= red_dump_line,
+	    [NL_DUMP_DETAILS]	= red_dump_details,
+	    [NL_DUMP_STATS]	= red_dump_stats,
+	},
+	.qo_get_opts		= red_get_opts,
+};
+
+static void __init red_init(void)
+{
+	rtnl_qdisc_register(&red_ops);
+}
+
+static void __exit red_exit(void)
+{
+	rtnl_qdisc_unregister(&red_ops);
+}
+
+/** @} */
diff -uNr libnl_kk/lib/route/sch/sfq.c libnl/lib/route/sch/sfq.c
--- libnl_kk/lib/route/sch/sfq.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/sch/sfq.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,289 @@
+/*
+ * lib/route/sch/sfq.c		SFQ Qdisc
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup qdisc_api
+ * @defgroup sfq Stochastic Fairness Queueing (SFQ)
+ * @brief
+ *
+ * @par Parameter Description
+ * - \b Quantum: Number of bytes to send out per slot and round.
+ * - \b Perturbation: Timer period between changing the hash function.
+ * - \b Limit:  Upper limit of queue in number of packets before SFQ starts
+ *	        dropping packets.
+ * - \b Divisor: Hash table divisor, i.e. size of hash table.
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink-tc.h>
+#include <netlink/netlink.h>
+#include <netlink/utils.h>
+#include <netlink/route/qdisc.h>
+#include <netlink/route/qdisc-modules.h>
+#include <netlink/route/sch/sfq.h>
+
+/** @cond SKIP */
+#define SCH_SFQ_ATTR_QUANTUM	0x01
+#define SCH_SFQ_ATTR_PERTURB	0x02
+#define SCH_SFQ_ATTR_LIMIT	0x04
+#define SCH_SFQ_ATTR_DIVISOR	0x08
+#define SCH_SFQ_ATTR_FLOWS	0x10
+/** @endcond */
+
+static inline struct rtnl_sfq *sfq_qdisc(struct rtnl_qdisc *qdisc)
+{
+	return (struct rtnl_sfq *) qdisc->q_subdata;
+}
+
+static inline struct rtnl_sfq *sfq_alloc(struct rtnl_qdisc *qdisc)
+{
+	if (!qdisc->q_subdata)
+		qdisc->q_subdata = calloc(1, sizeof(struct rtnl_sfq));
+
+	return sfq_qdisc(qdisc);
+}
+
+static int sfq_msg_parser(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_sfq *sfq;
+	struct tc_sfq_qopt *opts;
+
+	if (!(qdisc->ce_mask & TCA_ATTR_OPTS))
+		return 0;
+
+	if (qdisc->q_opts->d_size < sizeof(*opts))
+		return -NLE_INVAL;
+
+	sfq = sfq_alloc(qdisc);
+	if (!sfq)
+		return -NLE_NOMEM;
+
+	opts = (struct tc_sfq_qopt *) qdisc->q_opts->d_data;
+
+	sfq->qs_quantum = opts->quantum;
+	sfq->qs_perturb = opts->perturb_period;
+	sfq->qs_limit = opts->limit;
+	sfq->qs_divisor = opts->divisor;
+	sfq->qs_flows = opts->flows;
+
+	sfq->qs_mask = (SCH_SFQ_ATTR_QUANTUM | SCH_SFQ_ATTR_PERTURB |
+			SCH_SFQ_ATTR_LIMIT | SCH_SFQ_ATTR_DIVISOR |
+			SCH_SFQ_ATTR_FLOWS);
+
+	return 0;
+}
+
+static void sfq_free_data(struct rtnl_qdisc *qdisc)
+{
+	free(qdisc->q_subdata);
+}
+
+static void sfq_dump_line(struct rtnl_qdisc *qdisc, struct nl_dump_params *p)
+{
+	struct rtnl_sfq *sfq = sfq_qdisc(qdisc);
+
+	if (sfq)
+		nl_dump(p, " quantum %u perturb %us", sfq->qs_quantum,
+			nl_ticks2us(sfq->qs_perturb * nl_get_hz()));
+}
+
+static void sfq_dump_details(struct rtnl_qdisc *qdisc, struct nl_dump_params *p)
+{
+	struct rtnl_sfq *sfq = sfq_qdisc(qdisc);
+
+	if (sfq)
+		nl_dump(p, "limit %u divisor %u",
+			sfq->qs_limit, sfq->qs_divisor);
+}
+
+static struct nl_msg *sfq_get_opts(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_sfq *sfq;
+	struct tc_sfq_qopt opts;
+	struct nl_msg *msg;
+
+	sfq = sfq_qdisc(qdisc);
+	if (!sfq)
+		return NULL;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		goto errout;
+
+	memset(&opts, 0, sizeof(opts));
+	opts.quantum = sfq->qs_quantum;
+	opts.perturb_period = sfq->qs_perturb;
+	opts.limit = sfq->qs_limit;
+
+	if (nlmsg_append(msg, &opts, sizeof(opts), NL_DONTPAD) < 0)
+		goto errout;
+
+	return msg;
+errout:
+	nlmsg_free(msg);
+	return NULL;
+}
+
+/**
+ * @name Attribute Access
+ * @{
+ */
+
+/**
+ * Set quantum of SFQ qdisc.
+ * @arg qdisc		SFQ qdisc to be modified.
+ * @arg quantum		New quantum in bytes.
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_sfq_set_quantum(struct rtnl_qdisc *qdisc, int quantum)
+{
+	struct rtnl_sfq *sfq;
+	
+	sfq = sfq_alloc(qdisc);
+	if (!sfq)
+		return -NLE_NOMEM;
+
+	sfq->qs_quantum = quantum;
+	sfq->qs_mask |= SCH_SFQ_ATTR_QUANTUM;
+
+	return 0;
+}
+
+/**
+ * Get quantum of SFQ qdisc.
+ * @arg qdisc		SFQ qdisc.
+ * @return Quantum in bytes or a negative error code.
+ */
+int rtnl_sfq_get_quantum(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_sfq *sfq;
+
+	sfq = sfq_qdisc(qdisc);
+	if (sfq && sfq->qs_mask & SCH_SFQ_ATTR_QUANTUM)
+		return sfq->qs_quantum;
+	else
+		return -NLE_NOATTR;
+}
+
+/**
+ * Set limit of SFQ qdisc.
+ * @arg qdisc		SFQ qdisc to be modified.
+ * @arg limit		New limit in number of packets.
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_sfq_set_limit(struct rtnl_qdisc *qdisc, int limit)
+{
+	struct rtnl_sfq *sfq;
+
+	sfq = sfq_alloc(qdisc);
+	if (!sfq)
+		return -NLE_NOMEM;
+
+	sfq->qs_limit = limit;
+	sfq->qs_mask |= SCH_SFQ_ATTR_LIMIT;
+
+	return 0;
+}
+
+/**
+ * Get limit of SFQ qdisc.
+ * @arg qdisc		SFQ qdisc.
+ * @return Limit or a negative error code.
+ */
+int rtnl_sfq_get_limit(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_sfq *sfq;
+
+	sfq = sfq_qdisc(qdisc);
+	if (sfq && sfq->qs_mask & SCH_SFQ_ATTR_LIMIT)
+		return sfq->qs_limit;
+	else
+		return -NLE_NOATTR;
+}
+
+/**
+ * Set perturbation interval of SFQ qdisc.
+ * @arg qdisc		SFQ qdisc to be modified.
+ * @arg perturb		New perturbation interval in seconds.
+ * @note A value of 0 disables perturbation altogether.
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_sfq_set_perturb(struct rtnl_qdisc *qdisc, int perturb)
+{
+	struct rtnl_sfq *sfq;
+
+	sfq = sfq_alloc(qdisc);
+	if (!sfq)
+		return -NLE_NOMEM;
+
+	sfq->qs_perturb = perturb;
+	sfq->qs_mask |= SCH_SFQ_ATTR_PERTURB;
+
+	return 0;
+}
+
+/**
+ * Get perturbation interval of SFQ qdisc.
+ * @arg qdisc		SFQ qdisc.
+ * @return Perturbation interval in seconds or a negative error code.
+ */
+int rtnl_sfq_get_perturb(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_sfq *sfq;
+
+	sfq = sfq_qdisc(qdisc);
+	if (sfq && sfq->qs_mask & SCH_SFQ_ATTR_PERTURB)
+		return sfq->qs_perturb;
+	else
+		return -NLE_NOATTR;
+}
+
+/**
+ * Get divisor of SFQ qdisc.
+ * @arg qdisc		SFQ qdisc.
+ * @return Divisor in number of entries or a negative error code.
+ */
+int rtnl_sfq_get_divisor(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_sfq *sfq;
+
+	sfq = sfq_qdisc(qdisc);
+	if (sfq && sfq->qs_mask & SCH_SFQ_ATTR_DIVISOR)
+		return sfq->qs_divisor;
+	else
+		return -NLE_NOATTR;
+}
+
+/** @} */
+
+static struct rtnl_qdisc_ops sfq_ops = {
+	.qo_kind		= "sfq",
+	.qo_msg_parser		= sfq_msg_parser,
+	.qo_free_data		= sfq_free_data,
+	.qo_dump = {
+	    [NL_DUMP_LINE]	= sfq_dump_line,
+	    [NL_DUMP_DETAILS]	= sfq_dump_details,
+	},
+	.qo_get_opts		= sfq_get_opts,
+};
+
+static void __init sfq_init(void)
+{
+	rtnl_qdisc_register(&sfq_ops);
+}
+
+static void __exit sfq_exit(void)
+{
+	rtnl_qdisc_unregister(&sfq_ops);
+}
+
+/** @} */
diff -uNr libnl_kk/lib/route/sch/tbf.c libnl/lib/route/sch/tbf.c
--- libnl_kk/lib/route/sch/tbf.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/sch/tbf.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,539 @@
+/*
+ * lib/route/sch/tbf.c		TBF Qdisc
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup qdisc_api
+ * @defgroup tbf Token Bucket Filter (TBF)
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink-tc.h>
+#include <netlink/netlink.h>
+#include <netlink/cache.h>
+#include <netlink/utils.h>
+#include <netlink/route/tc.h>
+#include <netlink/route/qdisc.h>
+#include <netlink/route/qdisc-modules.h>
+#include <netlink/route/class.h>
+#include <netlink/route/class-modules.h>
+#include <netlink/route/link.h>
+#include <netlink/route/sch/tbf.h>
+
+/** @cond SKIP */
+#define TBF_ATTR_LIMIT			0x01
+#define TBF_ATTR_RATE			0x02
+#define TBF_ATTR_PEAKRATE		0x10
+#define TBF_ATTR_MPU			0x80
+/** @endcond */
+
+static inline struct rtnl_tbf *tbf_qdisc(struct rtnl_qdisc *qdisc)
+{
+	return (struct rtnl_tbf *) qdisc->q_subdata;
+}
+
+static inline struct rtnl_tbf *tbf_alloc(struct rtnl_qdisc *qdisc)
+{
+	if (!qdisc->q_subdata)
+		qdisc->q_subdata = calloc(1, sizeof(struct rtnl_tbf));
+
+	return tbf_qdisc(qdisc);
+}
+
+static struct nla_policy tbf_policy[TCA_TBF_MAX+1] = {
+	[TCA_TBF_PARMS]	= { .minlen = sizeof(struct tc_tbf_qopt) },
+};
+
+static int tbf_msg_parser(struct rtnl_qdisc *q)
+{
+	int err;
+	struct nlattr *tb[TCA_TBF_MAX + 1];
+	struct rtnl_tbf *tbf;
+
+	err = tca_parse(tb, TCA_TBF_MAX, (struct rtnl_tca *) q, tbf_policy);
+	if (err < 0)
+		return err;
+	
+	tbf = tbf_alloc(q);
+	if (!tbf)
+		return -NLE_NOMEM;
+
+	if (tb[TCA_TBF_PARMS]) {
+		struct tc_tbf_qopt opts;
+		int bufsize;
+
+		nla_memcpy(&opts, tb[TCA_TBF_PARMS], sizeof(opts));
+		tbf->qt_limit = opts.limit;
+		tbf->qt_mpu = opts.rate.mpu;
+	
+		rtnl_copy_ratespec(&tbf->qt_rate, &opts.rate);
+		tbf->qt_rate_txtime = opts.buffer;
+		bufsize = rtnl_tc_calc_bufsize(nl_ticks2us(opts.buffer),
+					       opts.rate.rate);
+		tbf->qt_rate_bucket = bufsize;
+
+		rtnl_copy_ratespec(&tbf->qt_peakrate, &opts.peakrate);
+		tbf->qt_peakrate_txtime = opts.mtu;
+		bufsize = rtnl_tc_calc_bufsize(nl_ticks2us(opts.mtu),
+					       opts.peakrate.rate);
+		tbf->qt_peakrate_bucket = bufsize;
+
+		tbf->qt_mask = (TBF_ATTR_LIMIT | TBF_ATTR_MPU | TBF_ATTR_RATE |
+				TBF_ATTR_PEAKRATE);
+	}
+
+	return 0;
+}
+
+static void tbf_free_data(struct rtnl_qdisc *qdisc)
+{
+	free(qdisc->q_subdata);
+}
+
+static void tbf_dump_line(struct rtnl_qdisc *qdisc, struct nl_dump_params *p)
+{
+	double r, rbit, lim;
+	char *ru, *rubit, *limu;
+	struct rtnl_tbf *tbf = tbf_qdisc(qdisc);
+
+	if (!tbf)
+		return;
+
+	r = nl_cancel_down_bytes(tbf->qt_rate.rs_rate, &ru);
+	rbit = nl_cancel_down_bits(tbf->qt_rate.rs_rate*8, &rubit);
+	lim = nl_cancel_down_bytes(tbf->qt_limit, &limu);
+
+	nl_dump(p, " rate %.2f%s/s (%.0f%s) limit %.2f%s",
+		r, ru, rbit, rubit, lim, limu);
+}
+
+static void tbf_dump_details(struct rtnl_qdisc *qdisc, struct nl_dump_params *p)
+{
+	struct rtnl_tbf *tbf = tbf_qdisc(qdisc);
+
+	if (!tbf)
+		return;
+
+	if (1) {
+		char *bu, *cu;
+		double bs = nl_cancel_down_bytes(tbf->qt_rate_bucket, &bu);
+		double cl = nl_cancel_down_bytes(1 << tbf->qt_rate.rs_cell_log,
+						 &cu);
+
+		nl_dump(p, "mpu %u rate-bucket-size %1.f%s "
+			   "rate-cell-size %.1f%s\n",
+			tbf->qt_mpu, bs, bu, cl, cu);
+
+	}
+
+	if (tbf->qt_mask & TBF_ATTR_PEAKRATE) {
+		char *pru, *prbu, *bsu, *clu;
+		double pr, prb, bs, cl;
+		
+		pr = nl_cancel_down_bytes(tbf->qt_peakrate.rs_rate, &pru);
+		prb = nl_cancel_down_bits(tbf->qt_peakrate.rs_rate * 8, &prbu);
+		bs = nl_cancel_down_bits(tbf->qt_peakrate_bucket, &bsu);
+		cl = nl_cancel_down_bits(1 << tbf->qt_peakrate.rs_cell_log,
+					 &clu);
+
+		nl_dump_line(p, "    peak-rate %.2f%s/s (%.0f%s) "
+				"bucket-size %.1f%s cell-size %.1f%s"
+				"latency %.1f%s",
+			     pr, pru, prb, prbu, bs, bsu, cl, clu);
+	}
+}
+
+static struct nl_msg *tbf_get_opts(struct rtnl_qdisc *qdisc)
+{
+	struct tc_tbf_qopt opts;
+	struct rtnl_tbf *tbf;
+	struct nl_msg *msg;
+	uint32_t rtab[RTNL_TC_RTABLE_SIZE];
+	uint32_t ptab[RTNL_TC_RTABLE_SIZE];
+	int required = TBF_ATTR_RATE | TBF_ATTR_LIMIT;
+
+	memset(&opts, 0, sizeof(opts));
+
+	tbf = tbf_qdisc(qdisc);
+	if (!tbf)
+		return NULL;
+
+	if (!(tbf->qt_mask & required) != required)
+		return NULL;
+
+	opts.limit = tbf->qt_limit;
+	opts.buffer = tbf->qt_rate_txtime;
+	tbf->qt_rate.rs_mpu = tbf->qt_mpu;
+	rtnl_rcopy_ratespec(&opts.rate, &tbf->qt_rate);
+
+	rtnl_tc_build_rate_table(rtab, tbf->qt_mpu & 0xff, tbf->qt_mpu >> 8,
+				 1 << tbf->qt_rate.rs_cell_log,
+				 tbf->qt_rate.rs_rate);
+
+	if (tbf->qt_mask & TBF_ATTR_PEAKRATE) {
+		opts.mtu = tbf->qt_peakrate_txtime;
+		tbf->qt_peakrate.rs_mpu = tbf->qt_mpu;
+		rtnl_rcopy_ratespec(&opts.peakrate, &tbf->qt_peakrate);
+
+		rtnl_tc_build_rate_table(ptab, tbf->qt_mpu & 0xff,
+					 tbf->qt_mpu >> 8,
+					 1 << tbf->qt_peakrate.rs_cell_log,
+					 tbf->qt_peakrate.rs_rate);
+	}
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		goto nla_put_failure;
+
+	NLA_PUT(msg, TCA_TBF_PARMS, sizeof(opts), &opts);
+	NLA_PUT(msg, TCA_TBF_RTAB, sizeof(rtab), rtab);
+
+	if (tbf->qt_mask & TBF_ATTR_PEAKRATE)
+		NLA_PUT(msg, TCA_TBF_PTAB, sizeof(ptab), ptab);
+
+	return msg;
+
+nla_put_failure:
+	nlmsg_free(msg);
+	return NULL;
+}
+
+/**
+ * @name Attribute Access
+ * @{
+ */
+
+/**
+ * Set limit of TBF qdisc.
+ * @arg qdisc		TBF qdisc to be modified.
+ * @arg limit		New limit in bytes.
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_qdisc_tbf_set_limit(struct rtnl_qdisc *qdisc, int limit)
+{
+	struct rtnl_tbf *tbf;
+	
+	tbf = tbf_alloc(qdisc);
+	if (!tbf)
+		return -NLE_NOMEM;
+
+	tbf->qt_limit = limit;
+	tbf->qt_mask |= TBF_ATTR_LIMIT;
+
+	return 0;
+}
+
+static inline double calc_limit(struct rtnl_ratespec *spec, int latency,
+				int bucket)
+{
+	double limit;
+
+	limit = (double) spec->rs_rate * ((double) latency / 1000000.);
+	limit += bucket;
+
+	return limit;
+}
+
+/**
+ * Set limit of TBF qdisc by latency.
+ * @arg qdisc		TBF qdisc to be modified.
+ * @arg latency		Latency in micro seconds.
+ *
+ * Calculates and sets the limit based on the desired latency and the
+ * configured rate and peak rate. In order for this operation to succeed,
+ * the rate and if required the peak rate must have been set in advance.
+ *
+ * @f[
+ *   limit_n = \frac{{rate_n} \times {latency}}{10^6}+{bucketsize}_n
+ * @f]
+ * @f[
+ *   limit = min(limit_{rate},limit_{peak})
+ * @f]
+ * 
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_qdisc_tbf_set_limit_by_latency(struct rtnl_qdisc *qdisc, int latency)
+{
+	struct rtnl_tbf *tbf;
+	double limit, limit2;
+
+	tbf = tbf_alloc(qdisc);
+	if (!tbf)
+		return -NLE_NOMEM;
+
+	if (!(tbf->qt_mask & TBF_ATTR_RATE))
+		return -NLE_MISSING_ATTR;
+
+	limit = calc_limit(&tbf->qt_rate, latency, tbf->qt_rate_bucket);
+
+	if (tbf->qt_mask & TBF_ATTR_PEAKRATE) {
+		limit2 = calc_limit(&tbf->qt_peakrate, latency,
+				    tbf->qt_peakrate_bucket);
+
+		if (limit2 < limit)
+			limit = limit2;
+	}
+
+	return rtnl_qdisc_tbf_set_limit(qdisc, (int) limit);
+}
+
+/**
+ * Get limit of TBF qdisc.
+ * @arg qdisc		TBF qdisc.
+ * @return Limit in bytes or a negative error code.
+ */
+int rtnl_qdisc_tbf_get_limit(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_tbf *tbf;
+	
+	tbf = tbf_qdisc(qdisc);
+	if (tbf && (tbf->qt_mask & TBF_ATTR_LIMIT))
+		return tbf->qt_limit;
+	else
+		return -NLE_NOATTR;
+}
+
+/**
+ * Set MPU of TBF qdisc.
+ * @arg qdisc		TBF qdisc to be modified.
+ * @arg mpu		New MPU in bytes.
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_qdisc_tbf_set_mpu(struct rtnl_qdisc *qdisc, int mpu)
+{
+	struct rtnl_tbf *tbf;
+	
+	tbf = tbf_alloc(qdisc);
+	if (!tbf)
+		return -NLE_NOMEM;
+
+	tbf->qt_mpu = mpu;
+	tbf->qt_mask |= TBF_ATTR_MPU;
+
+	return 0;
+}
+
+/**
+ * Get MPU of TBF qdisc.
+ * @arg qdisc		TBF qdisc.
+ * @return MPU in bytes or a negative error code.
+ */
+int rtnl_qdisc_tbf_get_mpu(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_tbf *tbf;
+	
+	tbf = tbf_qdisc(qdisc);
+	if (tbf && (tbf->qt_mask & TBF_ATTR_MPU))
+		return tbf->qt_mpu;
+	else
+		return -NLE_NOATTR;
+}
+
+static inline int calc_cell_log(int cell, int bucket)
+{
+	if (cell > 0)
+		cell = rtnl_tc_calc_cell_log(cell);
+	else {
+		cell = 0;
+
+		if (!bucket)
+			bucket = 2047; /* defaults to cell_log=3 */
+
+		while ((bucket >> cell) > 255)
+			cell++;
+	}
+
+	return cell;
+}
+
+/**
+ * Set rate of TBF qdisc.
+ * @arg qdisc		TBF qdisc to be modified.
+ * @arg rate		New rate in bytes per second.
+ * @arg bucket		Size of bucket in bytes.
+ * @arg cell		Size of a rate cell or 0 to get default value.
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_qdisc_tbf_set_rate(struct rtnl_qdisc *qdisc, int rate, int bucket,
+			    int cell)
+{
+	struct rtnl_tbf *tbf;
+	int cell_log;
+	
+	tbf = tbf_alloc(qdisc);
+	if (!tbf)
+		return -NLE_NOMEM;
+
+	cell_log = calc_cell_log(cell, bucket);
+	if (cell_log < 0)
+		return cell_log;
+
+	tbf->qt_rate.rs_rate = rate;
+	tbf->qt_rate_bucket = bucket;
+	tbf->qt_rate.rs_cell_log = cell_log;
+	tbf->qt_rate_txtime = rtnl_tc_calc_txtime(bucket, rate);
+	tbf->qt_mask |= TBF_ATTR_RATE;
+
+	return 0;
+}
+
+/**
+ * Get rate of TBF qdisc.
+ * @arg qdisc		TBF qdisc.
+ * @return Rate in bytes per seconds or a negative error code.
+ */
+int rtnl_qdisc_tbf_get_rate(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_tbf *tbf;
+
+	tbf = tbf_qdisc(qdisc);
+	if (tbf && (tbf->qt_mask & TBF_ATTR_RATE))
+		return tbf->qt_rate.rs_rate;
+	else
+		return -1;
+}
+
+/**
+ * Get rate bucket size of TBF qdisc.
+ * @arg qdisc		TBF qdisc.
+ * @return Size of rate bucket or a negative error code.
+ */
+int rtnl_qdisc_tbf_get_rate_bucket(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_tbf *tbf;
+
+	tbf = tbf_qdisc(qdisc);
+	if (tbf && (tbf->qt_mask & TBF_ATTR_RATE))
+		return tbf->qt_rate_bucket;
+	else
+		return -1;
+}
+
+/**
+ * Get rate cell size of TBF qdisc.
+ * @arg qdisc		TBF qdisc.
+ * @return Size of rate cell in bytes or a negative error code.
+ */
+int rtnl_qdisc_tbf_get_rate_cell(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_tbf *tbf;
+
+	tbf = tbf_qdisc(qdisc);
+	if (tbf && (tbf->qt_mask & TBF_ATTR_RATE))
+		return (1 << tbf->qt_rate.rs_cell_log);
+	else
+		return -1;
+}
+
+/**
+ * Set peak rate of TBF qdisc.
+ * @arg qdisc		TBF qdisc to be modified.
+ * @arg rate		New peak rate in bytes per second.
+ * @arg bucket		Size of peakrate bucket.
+ * @arg cell		Size of a peakrate cell or 0 to get default value.
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_qdisc_tbf_set_peakrate(struct rtnl_qdisc *qdisc, int rate, int bucket,
+				int cell)
+{
+	struct rtnl_tbf *tbf;
+	int cell_log;
+	
+	tbf = tbf_alloc(qdisc);
+	if (!tbf)
+		return -NLE_NOMEM;
+
+	cell_log = calc_cell_log(cell, bucket);
+	if (cell_log < 0)
+		return cell_log;
+
+	tbf->qt_peakrate.rs_rate = rate;
+	tbf->qt_peakrate_bucket = bucket;
+	tbf->qt_peakrate.rs_cell_log = cell_log;
+	tbf->qt_peakrate_txtime = rtnl_tc_calc_txtime(bucket, rate);
+	
+	tbf->qt_mask |= TBF_ATTR_PEAKRATE;
+
+	return 0;
+}
+
+/**
+ * Get peak rate of TBF qdisc.
+ * @arg qdisc		TBF qdisc.
+ * @return Peak rate in bytes per seconds or a negative error code.
+ */
+int rtnl_qdisc_tbf_get_peakrate(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_tbf *tbf;
+
+	tbf = tbf_qdisc(qdisc);
+	if (tbf && (tbf->qt_mask & TBF_ATTR_PEAKRATE))
+		return tbf->qt_peakrate.rs_rate;
+	else
+		return -1;
+}
+
+/**
+ * Get peak rate bucket size of TBF qdisc.
+ * @arg qdisc		TBF qdisc.
+ * @return Size of peak rate bucket or a negative error code.
+ */
+int rtnl_qdisc_tbf_get_peakrate_bucket(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_tbf *tbf;
+
+	tbf = tbf_qdisc(qdisc);
+	if (tbf && (tbf->qt_mask & TBF_ATTR_PEAKRATE))
+		return tbf->qt_peakrate_bucket;
+	else
+		return -1;
+}
+
+/**
+ * Get peak rate cell size of TBF qdisc.
+ * @arg qdisc		TBF qdisc.
+ * @return Size of peak rate cell in bytes or a negative error code.
+ */
+int rtnl_qdisc_tbf_get_peakrate_cell(struct rtnl_qdisc *qdisc)
+{
+	struct rtnl_tbf *tbf;
+
+	tbf = tbf_qdisc(qdisc);
+	if (tbf && (tbf->qt_mask & TBF_ATTR_PEAKRATE))
+		return (1 << tbf->qt_peakrate.rs_cell_log);
+	else
+		return -1;
+}
+
+/** @} */
+
+static struct rtnl_qdisc_ops tbf_qdisc_ops = {
+	.qo_kind		= "tbf",
+	.qo_msg_parser		= tbf_msg_parser,
+	.qo_dump = {
+	    [NL_DUMP_LINE]	= tbf_dump_line,
+	    [NL_DUMP_DETAILS]	= tbf_dump_details,
+	},
+	.qo_free_data		= tbf_free_data,
+	.qo_get_opts		= tbf_get_opts,
+};
+
+static void __init tbf_init(void)
+{
+	rtnl_qdisc_register(&tbf_qdisc_ops);
+}
+
+static void __exit tbf_exit(void)
+{
+	rtnl_qdisc_unregister(&tbf_qdisc_ops);
+}
+
+/** @} */
diff -uNr libnl_kk/lib/route/tc.c libnl/lib/route/tc.c
--- libnl_kk/lib/route/tc.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/route/tc.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,577 @@
+/*
+ * lib/route/tc.c		Traffic Control
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup rtnl
+ * @defgroup tc Traffic Control
+ * @brief
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink-tc.h>
+#include <netlink/netlink.h>
+#include <netlink/utils.h>
+#include <netlink/route/rtnl.h>
+#include <netlink/route/link.h>
+#include <netlink/route/tc.h>
+
+/** @cond SKIP */
+
+static struct nla_policy tc_policy[TCA_MAX+1] = {
+	[TCA_KIND]	= { .type = NLA_STRING,
+			    .maxlen = TCKINDSIZ },
+	[TCA_STATS]	= { .minlen = sizeof(struct tc_stats) },
+	[TCA_STATS2]	= { .type = NLA_NESTED },
+};
+
+int tca_parse(struct nlattr **tb, int maxattr, struct rtnl_tca *g,
+	      struct nla_policy *policy)
+{
+	
+	if (g->ce_mask & TCA_ATTR_OPTS)
+		return nla_parse(tb, maxattr,
+				 (struct nlattr *) g->tc_opts->d_data,
+				 g->tc_opts->d_size, policy);
+	else {
+		/* Ugly but tb[] must be in a defined state even if no
+		 * attributes can be found. */
+		memset(tb, 0, sizeof(struct nlattr *) * (maxattr + 1));
+		return 0;
+	}
+}
+
+static struct nla_policy tc_stats2_policy[TCA_STATS_MAX+1] = {
+	[TCA_STATS_BASIC]    = { .minlen = sizeof(struct gnet_stats_basic) },
+	[TCA_STATS_RATE_EST] = { .minlen = sizeof(struct gnet_stats_rate_est) },
+	[TCA_STATS_QUEUE]    = { .minlen = sizeof(struct gnet_stats_queue) },
+};
+
+int tca_msg_parser(struct nlmsghdr *n, struct rtnl_tca *g)
+{
+	struct nlattr *tb[TCA_MAX + 1];
+	struct tcmsg *tm;
+	int err;
+
+	err = nlmsg_parse(n, sizeof(*tm), tb, TCA_MAX, tc_policy);
+	if (err < 0)
+		return err;
+
+	if (tb[TCA_KIND] == NULL)
+		return -NLE_MISSING_ATTR;
+
+	nla_strlcpy(g->tc_kind, tb[TCA_KIND], TCKINDSIZ);
+
+	tm = nlmsg_data(n);
+	g->tc_family  = tm->tcm_family;
+	g->tc_ifindex = tm->tcm_ifindex;
+	g->tc_handle  = tm->tcm_handle;
+	g->tc_parent  = tm->tcm_parent;
+	g->tc_info    = tm->tcm_info;
+
+	g->ce_mask = (TCA_ATTR_FAMILY | TCA_ATTR_IFINDEX | TCA_ATTR_HANDLE |
+		      TCA_ATTR_PARENT | TCA_ATTR_INFO | TCA_ATTR_KIND);
+
+	if (tb[TCA_OPTIONS]) {
+		g->tc_opts = nl_data_alloc_attr(tb[TCA_OPTIONS]);
+		if (!g->tc_opts)
+			return -NLE_NOMEM;
+		g->ce_mask |= TCA_ATTR_OPTS;
+	}
+	
+
+	if (tb[TCA_STATS2]) {
+		struct nlattr *tbs[TCA_STATS_MAX + 1];
+
+		err = nla_parse_nested(tbs, TCA_STATS_MAX, tb[TCA_STATS2],
+				       tc_stats2_policy);
+		if (err < 0)
+			return err;
+
+		if (tbs[TCA_STATS_BASIC]) {
+			struct gnet_stats_basic *bs;
+			
+			bs = nla_data(tbs[TCA_STATS_BASIC]);
+			g->tc_stats[RTNL_TC_BYTES]	= bs->bytes;
+			g->tc_stats[RTNL_TC_PACKETS]	= bs->packets;
+		}
+
+		if (tbs[TCA_STATS_RATE_EST]) {
+			struct gnet_stats_rate_est *re;
+
+			re = nla_data(tbs[TCA_STATS_RATE_EST]);
+			g->tc_stats[RTNL_TC_RATE_BPS]	= re->bps;
+			g->tc_stats[RTNL_TC_RATE_PPS]	= re->pps;
+		}
+		
+		if (tbs[TCA_STATS_QUEUE]) {
+			struct gnet_stats_queue *q;
+
+			q = nla_data(tbs[TCA_STATS_QUEUE]);
+			g->tc_stats[RTNL_TC_QLEN]	= q->qlen;
+			g->tc_stats[RTNL_TC_BACKLOG]	= q->backlog;
+			g->tc_stats[RTNL_TC_DROPS]	= q->drops;
+			g->tc_stats[RTNL_TC_REQUEUES]	= q->requeues;
+			g->tc_stats[RTNL_TC_OVERLIMITS]	= q->overlimits;
+		}
+
+		g->ce_mask |= TCA_ATTR_STATS;
+		
+		if (tbs[TCA_STATS_APP]) {
+			g->tc_xstats = nl_data_alloc_attr(tbs[TCA_STATS_APP]);
+			if (g->tc_xstats == NULL)
+				return -NLE_NOMEM;
+		} else
+			goto compat_xstats;
+	} else {
+		if (tb[TCA_STATS]) {
+			struct tc_stats *st = nla_data(tb[TCA_STATS]);
+
+			g->tc_stats[RTNL_TC_BYTES]	= st->bytes;
+			g->tc_stats[RTNL_TC_PACKETS]	= st->packets;
+			g->tc_stats[RTNL_TC_RATE_BPS]	= st->bps;
+			g->tc_stats[RTNL_TC_RATE_PPS]	= st->pps;
+			g->tc_stats[RTNL_TC_QLEN]	= st->qlen;
+			g->tc_stats[RTNL_TC_BACKLOG]	= st->backlog;
+			g->tc_stats[RTNL_TC_DROPS]	= st->drops;
+			g->tc_stats[RTNL_TC_OVERLIMITS]	= st->overlimits;
+
+			g->ce_mask |= TCA_ATTR_STATS;
+		}
+
+compat_xstats:
+		if (tb[TCA_XSTATS]) {
+			g->tc_xstats = nl_data_alloc_attr(tb[TCA_XSTATS]);
+			if (g->tc_xstats == NULL)
+				return -NLE_NOMEM;
+			g->ce_mask |= TCA_ATTR_XSTATS;
+		}
+	}
+
+
+	return 0;
+}
+
+void tca_free_data(struct rtnl_tca *tca)
+{
+	nl_data_free(tca->tc_opts);
+	nl_data_free(tca->tc_xstats);
+}
+
+int tca_clone(struct rtnl_tca *dst, struct rtnl_tca *src)
+{
+	if (src->tc_opts) {
+		dst->tc_opts = nl_data_clone(src->tc_opts);
+		if (!dst->tc_opts)
+			return -NLE_NOMEM;
+	}
+	
+	if (src->tc_xstats) {
+		dst->tc_xstats = nl_data_clone(src->tc_xstats);
+		if (!dst->tc_xstats)
+			return -NLE_NOMEM;
+	}
+
+	return 0;
+}
+
+void tca_dump_line(struct rtnl_tca *g, const char *type,
+		   struct nl_dump_params *p)
+{
+	char handle[32], parent[32];
+	struct nl_cache *link_cache;
+	
+	link_cache = nl_cache_mngt_require("route/link");
+
+	nl_dump_line(p, "%s %s ", g->tc_kind, type);
+
+	if (link_cache) {
+		char buf[32];
+		nl_dump(p, "dev %s ",
+			rtnl_link_i2name(link_cache, g->tc_ifindex,
+					 buf, sizeof(buf)));
+	} else
+		nl_dump(p, "dev %u ", g->tc_ifindex);
+	
+	nl_dump(p, "handle %s parent %s",
+		rtnl_tc_handle2str(g->tc_handle, handle, sizeof(handle)),
+		rtnl_tc_handle2str(g->tc_parent, parent, sizeof(parent)));
+}
+
+void tca_dump_details(struct rtnl_tca *g, struct nl_dump_params *p)
+{
+	nl_dump_line(p, "  ");
+}
+
+void tca_dump_stats(struct rtnl_tca *g, struct nl_dump_params *p)
+{
+	char *unit, fmt[64];
+	float res;
+	strcpy(fmt, "        %7.2f %s %10u %10u %10u %10u %10u\n");
+
+	nl_dump_line(p, 
+		"    Stats:    bytes    packets      drops overlimits" \
+		"       qlen    backlog\n");
+
+	res = nl_cancel_down_bytes(g->tc_stats[RTNL_TC_BYTES], &unit);
+	if (*unit == 'B')
+		fmt[11] = '9';
+
+	nl_dump_line(p, fmt, res, unit,
+		g->tc_stats[RTNL_TC_PACKETS],
+		g->tc_stats[RTNL_TC_DROPS],
+		g->tc_stats[RTNL_TC_OVERLIMITS],
+		g->tc_stats[RTNL_TC_QLEN],
+		g->tc_stats[RTNL_TC_BACKLOG]);
+
+	res = nl_cancel_down_bytes(g->tc_stats[RTNL_TC_RATE_BPS], &unit);
+
+	strcpy(fmt, "        %7.2f %s/s%9u pps");
+
+	if (*unit == 'B')
+		fmt[11] = '9';
+
+	nl_dump_line(p, fmt, res, unit, g->tc_stats[RTNL_TC_RATE_PPS]);
+}
+
+int tca_compare(struct nl_object *_a, struct nl_object *_b,
+		uint32_t attrs, int flags)
+{
+	struct rtnl_tca *a = (struct rtnl_tca *) _a;
+	struct rtnl_tca *b = (struct rtnl_tca *) _b;
+	int diff = 0;
+
+#define TC_DIFF(ATTR, EXPR) ATTR_DIFF(attrs, TCA_ATTR_##ATTR, a, b, EXPR)
+
+	diff |= TC_DIFF(HANDLE,		a->tc_handle != b->tc_handle);
+	diff |= TC_DIFF(PARENT,		a->tc_parent != b->tc_parent);
+	diff |= TC_DIFF(IFINDEX,	a->tc_ifindex != b->tc_ifindex);
+	diff |= TC_DIFF(KIND,		strcmp(a->tc_kind, b->tc_kind));
+
+#undef TC_DIFF
+
+	return diff;
+}
+
+void tca_set_ifindex(struct rtnl_tca *t, int ifindex)
+{
+	t->tc_ifindex = ifindex;
+	t->ce_mask |= TCA_ATTR_IFINDEX;
+}
+
+int tca_get_ifindex(struct rtnl_tca *t)
+{
+	return t->tc_ifindex;
+}
+
+void tca_set_handle(struct rtnl_tca *t, uint32_t handle)
+{
+	t->tc_handle = handle;
+	t->ce_mask |= TCA_ATTR_HANDLE;
+}
+
+uint32_t tca_get_handle(struct rtnl_tca *t)
+{
+	if (t->ce_mask & TCA_ATTR_HANDLE)
+		return t->tc_handle;
+	else
+		return 0;
+}
+
+void tca_set_parent(struct rtnl_tca *t, uint32_t parent)
+{
+	t->tc_parent = parent;
+	t->ce_mask |= TCA_ATTR_PARENT;
+}
+
+uint32_t tca_get_parent(struct rtnl_tca *t)
+{
+	if (t->ce_mask & TCA_ATTR_PARENT)
+		return t->tc_parent;
+	else
+		return 0;
+}
+
+void tca_set_kind(struct rtnl_tca *t, const char *kind)
+{
+	strncpy(t->tc_kind, kind, sizeof(t->tc_kind) - 1);
+	t->ce_mask |= TCA_ATTR_KIND;
+}
+
+char *tca_get_kind(struct rtnl_tca *t)
+{
+	if (t->ce_mask & TCA_ATTR_KIND)
+		return t->tc_kind;
+	else
+		return NULL;
+}
+
+uint64_t tca_get_stat(struct rtnl_tca *t, int id)
+{
+	if (id < 0 || id > RTNL_TC_STATS_MAX)
+		return 0;
+
+	return t->tc_stats[id];
+}
+
+int tca_build_msg(struct rtnl_tca *tca, int type, int flags,
+		  struct nl_msg **result)
+{
+	struct nl_msg *msg;
+	struct tcmsg tchdr = {
+		.tcm_family = AF_UNSPEC,
+		.tcm_ifindex = tca->tc_ifindex,
+		.tcm_handle = tca->tc_handle,
+		.tcm_parent = tca->tc_parent,
+	};
+
+	msg = nlmsg_alloc_simple(type, flags);
+	if (!msg)
+		return -NLE_NOMEM;
+
+	if (nlmsg_append(msg, &tchdr, sizeof(tchdr), NLMSG_ALIGNTO) < 0)
+		goto nla_put_failure;
+
+	if (tca->ce_mask & TCA_ATTR_KIND)
+	    NLA_PUT_STRING(msg, TCA_KIND, tca->tc_kind);
+
+	*result = msg;
+	return 0;
+
+nla_put_failure:
+	nlmsg_free(msg);
+	return -NLE_MSGSIZE;
+}
+
+/** @endcond */
+
+/**
+ * @name Utilities
+ * @{
+ */
+
+/**
+ * Calculate time required to transmit buffer at a specific rate
+ * @arg bufsize		Size of buffer to be transmited in bytes.
+ * @arg rate		Transmit rate in bytes per second.
+ *
+ * Calculates the number of micro seconds required to transmit a
+ * specific buffer at a specific transmit rate.
+ *
+ * @f[
+ *   txtime=\frac{bufsize}{rate}10^6
+ * @f]
+ * 
+ * @return Required transmit time in micro seconds.
+ */
+int rtnl_tc_calc_txtime(int bufsize, int rate)
+{
+	double tx_time_secs;
+	
+	tx_time_secs = (double) bufsize / (double) rate;
+
+	return tx_time_secs * 1000000.;
+}
+
+/**
+ * Calculate buffer size able to transmit in a specific time and rate.
+ * @arg txtime		Available transmit time in micro seconds.
+ * @arg rate		Transmit rate in bytes per second.
+ *
+ * Calculates the size of the buffer that can be transmitted in a
+ * specific time period at a specific transmit rate.
+ *
+ * @f[
+ *   bufsize=\frac{{txtime} \times {rate}}{10^6}
+ * @f]
+ *
+ * @return Size of buffer in bytes.
+ */
+int rtnl_tc_calc_bufsize(int txtime, int rate)
+{
+	double bufsize;
+
+	bufsize = (double) txtime * (double) rate;
+
+	return bufsize / 1000000.;
+}
+
+/**
+ * Calculate the binary logarithm for a specific cell size
+ * @arg cell_size	Size of cell, must be a power of two.
+ * @return Binary logirhtm of cell size or a negative error code.
+ */
+int rtnl_tc_calc_cell_log(int cell_size)
+{
+	int i;
+
+	for (i = 0; i < 32; i++)
+		if ((1 << i) == cell_size)
+			return i;
+
+	return -NLE_INVAL;
+}
+
+
+/** @} */
+
+/**
+ * @name Rate Tables
+ * @{
+ */
+
+/**
+ * Compute a transmission time lookup table
+ * @arg dst	 Destination buffer of RTNL_TC_RTABLE_SIZE uint32_t[].
+ * @arg mpu	 Minimal size of a packet at all times.
+ * @arg overhead Overhead to be added to each packet.
+ * @arg cell	 Size of cell, i.e. size of step between entries in bytes.
+ * @arg rate	 Rate in bytes per second.
+ *
+ * Computes a table of RTNL_TC_RTABLE_SIZE entries specyfing the
+ * transmission times for various packet sizes, e.g. the transmission
+ * time for a packet of size \c pktsize could be looked up:
+ * @code
+ * txtime = table[pktsize >> log2(cell)];
+ * @endcode
+ */
+int rtnl_tc_build_rate_table(uint32_t *dst, uint8_t mpu, uint8_t overhead,
+			     int cell, int rate)
+{
+	int i, size, cell_log;
+
+	cell_log = rtnl_tc_calc_cell_log(cell);
+	if (cell_log < 0)
+		return cell_log;
+
+	for (i = 0; i < RTNL_TC_RTABLE_SIZE; i++) {
+		size = (i << cell_log) + overhead;
+		if (size < mpu)
+			size = mpu;
+
+		dst[i] = rtnl_tc_calc_txtime(size, rate);
+	}
+
+	return 0;
+}
+
+/** @} */
+
+/**
+ * @name Traffic Control Handle Translations
+ * @{
+ */
+
+/**
+ * Convert a traffic control handle to a character string (Reentrant).
+ * @arg handle		traffic control handle
+ * @arg buf		destination buffer
+ * @arg len		buffer length
+ *
+ * Converts a tarffic control handle to a character string in the
+ * form of \c MAJ:MIN and stores it in the specified destination buffer.
+ *
+ * @return The destination buffer or the type encoded in hexidecimal
+ *         form if no match was found.
+ */
+char * rtnl_tc_handle2str(uint32_t handle, char *buf, size_t len)
+{
+	if (TC_H_ROOT == handle)
+		snprintf(buf, len, "root");
+	else if (TC_H_UNSPEC == handle)
+		snprintf(buf, len, "none");
+	else if (0 == TC_H_MAJ(handle))
+		snprintf(buf, len, ":%02x", TC_H_MIN(handle));
+	else if (0 == TC_H_MIN(handle))
+		snprintf(buf, len, "%02x:", TC_H_MAJ(handle) >> 16);
+	else
+		snprintf(buf, len, "%02x:%02x",
+			TC_H_MAJ(handle) >> 16, TC_H_MIN(handle));
+
+	return buf;
+}
+
+/**
+ * Convert a charactering strint to a traffic control handle
+ * @arg name		traffic control handle as character string
+ * @arg res		destination buffer
+ *
+ * Converts the provided character string specifying a traffic
+ * control handle to the corresponding numeric value.
+ *
+ * The handle must be provided in one of the following formats:
+ *  - root
+ *  - none
+ *  - XXXX:
+ *  - :YYYY
+ *  - XXXX:YYYY
+ *  - XXXXYYYY
+ *
+ * @return 0 on success or a negative error code
+ */
+int rtnl_tc_str2handle(const char *name, uint32_t *res)
+{
+	char *colon, *end;
+	uint32_t h;
+
+	if (!strcasecmp(name, "root")) {
+		*res = TC_H_ROOT;
+		return 0;
+	}
+
+	if (!strcasecmp(name, "none")) {
+		*res = TC_H_UNSPEC;
+		return 0;
+	}
+
+	h = strtoul(name, &colon, 16);
+
+	if (colon == name) {
+		/* :YYYY */
+		h = 0;
+		if (':' != *colon)
+			return -NLE_INVAL;
+	}
+
+	if (':' == *colon) {
+		/* check if we would lose bits */
+		if (TC_H_MAJ(h))
+			return -NLE_RANGE;
+		h <<= 16;
+
+		if ('\0' == colon[1]) {
+			/* XXXX: */
+			*res = h;
+		} else {
+			/* XXXX:YYYY */
+			uint32_t l = strtoul(colon+1, &end, 16);
+
+			/* check if we overlap with major part */
+			if (TC_H_MAJ(l))
+				return -NLE_RANGE;
+
+			if ('\0' != *end)
+				return -NLE_INVAL;
+
+			*res = (h | l);
+		}
+	} else if ('\0' == *colon) {
+		/* XXXXYYYY */
+		*res = h;
+	} else
+		return -NLE_INVAL;
+
+	return 0;
+}
+
+/** @} */
+
+/** @} */
diff -uNr libnl_kk/lib/socket.c libnl/lib/socket.c
--- libnl_kk/lib/socket.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/socket.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,582 @@
+/*
+ * lib/socket.c		Netlink Socket
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup core
+ * @defgroup socket Socket
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink/netlink.h>
+#include <netlink/utils.h>
+#include <netlink/handlers.h>
+#include <netlink/msg.h>
+#include <netlink/attr.h>
+
+static int default_cb = NL_CB_DEFAULT;
+
+static void __init init_default_cb(void)
+{
+	char *nlcb;
+
+	if ((nlcb = getenv("NLCB"))) {
+		if (!strcasecmp(nlcb, "default"))
+			default_cb = NL_CB_DEFAULT;
+		else if (!strcasecmp(nlcb, "verbose"))
+			default_cb = NL_CB_VERBOSE;
+		else if (!strcasecmp(nlcb, "debug"))
+			default_cb = NL_CB_DEBUG;
+		else {
+			fprintf(stderr, "Unknown value for NLCB, valid values: "
+				"{default | verbose | debug}\n");
+		}
+	}
+}
+
+static uint32_t used_ports_map[32];
+
+static uint32_t generate_local_port(void)
+{
+	int i, n;
+	uint32_t pid = getpid() & 0x3FFFFF;
+
+	for (i = 0; i < 32; i++) {
+		if (used_ports_map[i] == 0xFFFFFFFF)
+			continue;
+
+		for (n = 0; n < 32; n++) {
+			if (1UL & (used_ports_map[i] >> n))
+				continue;
+
+			used_ports_map[i] |= (1UL << n);
+			n += (i * 32);
+
+			/* PID_MAX_LIMIT is currently at 2^22, leaving 10 bit
+			 * to, i.e. 1024 unique ports per application. */
+			return pid + (n << 22);
+
+		}
+	}
+
+	/* Out of sockets in our own PID namespace, what to do? FIXME */
+	return UINT_MAX;
+}
+
+static void release_local_port(uint32_t port)
+{
+	int nr;
+
+	if (port == UINT_MAX)
+		return;
+	
+	nr = port >> 22;
+	used_ports_map[nr / 32] &= ~(1 << nr % 32);
+}
+
+/**
+ * @name Allocation
+ * @{
+ */
+
+static struct nl_sock *__alloc_socket(struct nl_cb *cb)
+{
+	struct nl_sock *sk;
+
+	sk = calloc(1, sizeof(*sk));
+	if (!sk)
+		return NULL;
+
+	sk->s_fd = -1;
+	sk->s_cb = cb;
+	sk->s_local.nl_family = AF_NETLINK;
+	sk->s_peer.nl_family = AF_NETLINK;
+	sk->s_seq_expect = sk->s_seq_next = time(0);
+	sk->s_local.nl_pid = generate_local_port();
+	if (sk->s_local.nl_pid == UINT_MAX) {
+		nl_socket_free(sk);
+		return NULL;
+	}
+
+	return sk;
+}
+
+/**
+ * Allocate new netlink socket
+ *
+ * @return Newly allocated netlink socket or NULL.
+ */
+struct nl_sock *nl_socket_alloc(void)
+{
+	struct nl_cb *cb;
+	
+	cb = nl_cb_alloc(default_cb);
+	if (!cb)
+		return NULL;
+
+	return __alloc_socket(cb);
+}
+
+/**
+ * Allocate new socket with custom callbacks
+ * @arg cb		Callback handler
+ *
+ * The reference to the callback handler is taken into account
+ * automatically, it is released again upon calling nl_socket_free().
+ *
+ *@return Newly allocted socket handle or NULL.
+ */
+struct nl_sock *nl_socket_alloc_cb(struct nl_cb *cb)
+{
+	if (cb == NULL)
+		BUG();
+
+	return __alloc_socket(nl_cb_get(cb));
+}
+
+/**
+ * Free a netlink socket.
+ * @arg sk		Netlink socket.
+ */
+void nl_socket_free(struct nl_sock *sk)
+{
+	if (!sk)
+		return;
+
+	if (sk->s_fd >= 0)
+		close(sk->s_fd);
+
+	if (!(sk->s_flags & NL_OWN_PORT))
+		release_local_port(sk->s_local.nl_pid);
+
+	nl_cb_put(sk->s_cb);
+	free(sk);
+}
+
+/** @} */
+
+/**
+ * @name Sequence Numbers
+ * @{
+ */
+
+static int noop_seq_check(struct nl_msg *msg, void *arg)
+{
+	return NL_OK;
+}
+
+
+/**
+ * Disable sequence number checking.
+ * @arg sk		Netlink socket.
+ *
+ * Disables checking of sequence numbers on the netlink socket This is
+ * required to allow messages to be processed which were not requested by
+ * a preceding request message, e.g. netlink events.
+ *
+ * @note This function modifies the NL_CB_SEQ_CHECK configuration in
+ * the callback handle associated with the socket.
+ */
+void nl_socket_disable_seq_check(struct nl_sock *sk)
+{
+	nl_cb_set(sk->s_cb, NL_CB_SEQ_CHECK,
+		  NL_CB_CUSTOM, noop_seq_check, NULL);
+}
+
+/**
+ * Use next sequence number
+ * @arg sk		Netlink socket.
+ *
+ * Uses the next available sequence number and increases the counter
+ * by one for subsequent calls.
+ *
+ * @return Unique serial sequence number
+ */
+unsigned int nl_socket_use_seq(struct nl_sock *sk)
+{
+	return sk->s_seq_next++;
+}
+
+/**
+ * Disable automatic request for ACK
+ * @arg sk		Netlink socket.
+ *
+ * The default behaviour of a socket is to request an ACK for
+ * each message sent to allow for the caller to synchronize to
+ * the completion of the netlink operation. This function
+ * disables this behaviour and will result in requests being
+ * sent which will not have the NLM_F_ACK flag set automatically.
+ * However, it is still possible for the caller to set the
+ * NLM_F_ACK flag explicitely.
+ */
+void nl_socket_disable_auto_ack(struct nl_sock *sk)
+{
+	sk->s_flags |= NL_NO_AUTO_ACK;
+}
+
+/**
+ * Enable automatic request for ACK (default)
+ * @arg sk		Netlink socket.
+ * @see nl_socket_disable_auto_ack
+ */
+void nl_socket_enable_auto_ack(struct nl_sock *sk)
+{
+	sk->s_flags &= ~NL_NO_AUTO_ACK;
+}
+
+/** @} */
+
+/**
+ * @name Source Idenficiation
+ * @{
+ */
+
+uint32_t nl_socket_get_local_port(struct nl_sock *sk)
+{
+	return sk->s_local.nl_pid;
+}
+
+/**
+ * Set local port of socket
+ * @arg sk		Netlink socket.
+ * @arg port		Local port identifier
+ *
+ * Assigns a local port identifier to the socket. If port is 0
+ * a unique port identifier will be generated automatically.
+ */
+void nl_socket_set_local_port(struct nl_sock *sk, uint32_t port)
+{
+	if (port == 0) {
+		port = generate_local_port(); 
+		sk->s_flags &= ~NL_OWN_PORT;
+	} else  {
+		if (!(sk->s_flags & NL_OWN_PORT))
+			release_local_port(sk->s_local.nl_pid);
+		sk->s_flags |= NL_OWN_PORT;
+	}
+
+	sk->s_local.nl_pid = port;
+}
+
+/** @} */
+
+/**
+ * @name Group Subscriptions
+ * @{
+ */
+
+/**
+ * Join groups
+ * @arg sk		Netlink socket
+ * @arg group		Group identifier
+ *
+ * Joins the specified groups using the modern socket option which
+ * is available since kernel version 2.6.14. It allows joining an
+ * almost arbitary number of groups without limitation.  The list
+ * of groups has to be terminated by 0 (%NFNLGRP_NONE).
+ *
+ * Make sure to use the correct group definitions as the older
+ * bitmask definitions for nl_join_groups() are likely to still
+ * be present for backward compatibility reasons.
+ *
+ * @return 0 on sucess or a negative error code.
+ */
+int nl_socket_add_memberships(struct nl_sock *sk, int group, ...)
+{
+	int err;
+	va_list ap;
+
+	if (sk->s_fd == -1)
+		return -NLE_BAD_SOCK;
+
+	va_start(ap, group);
+
+	while (group != 0) {
+		if (group < 0)
+			return -NLE_INVAL;
+
+		err = setsockopt(sk->s_fd, SOL_NETLINK, NETLINK_ADD_MEMBERSHIP,
+						 &group, sizeof(group));
+		if (err < 0)
+			return -nl_syserr2nlerr(errno);
+
+		group = va_arg(ap, int);
+	}
+
+	va_end(ap);
+
+	return 0;
+}
+
+int nl_socket_add_membership(struct nl_sock *sk, int group)
+{
+	return nl_socket_add_memberships(sk, group, 0);
+}
+
+/**
+ * Leave groups
+ * @arg sk		Netlink socket
+ * @arg group		Group identifier
+ *
+ * Leaves the specified groups using the modern socket option
+ * which is available since kernel version 2.6.14. The list of groups
+ * has to terminated by 0 (%NFNLGRP_NONE).
+ *
+ * @see nl_socket_add_membership
+ * @return 0 on success or a negative error code.
+ */
+int nl_socket_drop_memberships(struct nl_sock *sk, int group, ...)
+{
+	int err;
+	va_list ap;
+
+	if (sk->s_fd == -1)
+		return -NLE_BAD_SOCK;
+
+	va_start(ap, group);
+
+	while (group != 0) {
+		if (group < 0)
+			return -NLE_INVAL;
+
+		err = setsockopt(sk->s_fd, SOL_NETLINK, NETLINK_DROP_MEMBERSHIP,
+						 &group, sizeof(group));
+		if (err < 0)
+			return -nl_syserr2nlerr(errno);
+
+		group = va_arg(ap, int);
+	}
+
+	va_end(ap);
+
+	return 0;
+}
+
+int nl_socket_drop_membership(struct nl_sock *sk, int group)
+{
+	return nl_socket_drop_memberships(sk, group, 0);
+}
+
+
+/**
+ * Join multicast groups (deprecated)
+ * @arg sk		Netlink socket.
+ * @arg groups		Bitmask of groups to join.
+ *
+ * This function defines the old way of joining multicast group which
+ * has to be done prior to calling nl_connect(). It works on any kernel
+ * version but is very limited as only 32 groups can be joined.
+ */
+void nl_join_groups(struct nl_sock *sk, int groups)
+{
+	sk->s_local.nl_groups |= groups;
+}
+
+
+/** @} */
+
+/**
+ * @name Peer Identfication
+ * @{
+ */
+
+uint32_t nl_socket_get_peer_port(struct nl_sock *sk)
+{
+	return sk->s_peer.nl_pid;
+}
+
+void nl_socket_set_peer_port(struct nl_sock *sk, uint32_t port)
+{
+	sk->s_peer.nl_pid = port;
+}
+
+/** @} */
+
+/**
+ * @name File Descriptor
+ * @{
+ */
+
+int nl_socket_get_fd(struct nl_sock *sk)
+{
+	return sk->s_fd;
+}
+
+/**
+ * Set file descriptor of socket to non-blocking state
+ * @arg sk		Netlink socket.
+ *
+ * @return 0 on success or a negative error code.
+ */
+int nl_socket_set_nonblocking(struct nl_sock *sk)
+{
+	if (sk->s_fd == -1)
+		return -NLE_BAD_SOCK;
+
+	if (fcntl(sk->s_fd, F_SETFL, O_NONBLOCK) < 0)
+		return -nl_syserr2nlerr(errno);
+
+	return 0;
+}
+
+/**
+ * Enable use of MSG_PEEK when reading from socket
+ * @arg sk		Netlink socket.
+ */
+void nl_socket_enable_msg_peek(struct nl_sock *sk)
+{
+	sk->s_flags |= NL_MSG_PEEK;
+}
+
+/**
+ * Disable use of MSG_PEEK when reading from socket
+ * @arg sk		Netlink socket.
+ */
+void nl_socket_disable_msg_peek(struct nl_sock *sk)
+{
+	sk->s_flags &= ~NL_MSG_PEEK;
+}
+
+/** @} */
+
+/**
+ * @name Callback Handler
+ * @{
+ */
+
+struct nl_cb *nl_socket_get_cb(struct nl_sock *sk)
+{
+	return nl_cb_get(sk->s_cb);
+}
+
+void nl_socket_set_cb(struct nl_sock *sk, struct nl_cb *cb)
+{
+	nl_cb_put(sk->s_cb);
+	sk->s_cb = nl_cb_get(cb);
+}
+
+/**
+ * Modify the callback handler associated to the socket
+ * @arg sk		Netlink socket.
+ * @arg type		which type callback to set
+ * @arg kind		kind of callback
+ * @arg func		callback function
+ * @arg arg		argument to be passwd to callback function
+ *
+ * @see nl_cb_set
+ */
+int nl_socket_modify_cb(struct nl_sock *sk, enum nl_cb_type type,
+			enum nl_cb_kind kind, nl_recvmsg_msg_cb_t func,
+			void *arg)
+{
+	return nl_cb_set(sk->s_cb, type, kind, func, arg);
+}
+
+/** @} */
+
+/**
+ * @name Utilities
+ * @{
+ */
+
+/**
+ * Set socket buffer size of netlink socket.
+ * @arg sk		Netlink socket.
+ * @arg rxbuf		New receive socket buffer size in bytes.
+ * @arg txbuf		New transmit socket buffer size in bytes.
+ *
+ * Sets the socket buffer size of a netlink socket to the specified
+ * values \c rxbuf and \c txbuf. Providing a value of \c 0 assumes a
+ * good default value.
+ *
+ * @note It is not required to call this function prior to nl_connect().
+ * @return 0 on sucess or a negative error code.
+ */
+int nl_socket_set_buffer_size(struct nl_sock *sk, int rxbuf, int txbuf)
+{
+	int err;
+
+	if (rxbuf <= 0)
+		rxbuf = 32768;
+
+	if (txbuf <= 0)
+		txbuf = 32768;
+
+	if (sk->s_fd == -1)
+		return -NLE_BAD_SOCK;
+	
+	err = setsockopt(sk->s_fd, SOL_SOCKET, SO_SNDBUF,
+			 &txbuf, sizeof(txbuf));
+	if (err < 0)
+		return -nl_syserr2nlerr(errno);
+
+	err = setsockopt(sk->s_fd, SOL_SOCKET, SO_RCVBUF,
+			 &rxbuf, sizeof(rxbuf));
+	if (err < 0)
+		return -nl_syserr2nlerr(errno);
+
+	sk->s_flags |= NL_SOCK_BUFSIZE_SET;
+
+	return 0;
+}
+
+/**
+ * Enable/disable credential passing on netlink socket.
+ * @arg sk		Netlink socket.
+ * @arg state		New state (0 - disabled, 1 - enabled)
+ *
+ * @return 0 on success or a negative error code
+ */
+int nl_socket_set_passcred(struct nl_sock *sk, int state)
+{
+	int err;
+
+	if (sk->s_fd == -1)
+		return -NLE_BAD_SOCK;
+
+	err = setsockopt(sk->s_fd, SOL_SOCKET, SO_PASSCRED,
+			 &state, sizeof(state));
+	if (err < 0)
+		return -nl_syserr2nlerr(errno);
+
+	if (state)
+		sk->s_flags |= NL_SOCK_PASSCRED;
+	else
+		sk->s_flags &= ~NL_SOCK_PASSCRED;
+
+	return 0;
+}
+
+/**
+ * Enable/disable receival of additional packet information
+ * @arg sk		Netlink socket.
+ * @arg state		New state (0 - disabled, 1 - enabled)
+ *
+ * @return 0 on success or a negative error code
+ */
+int nl_socket_recv_pktinfo(struct nl_sock *sk, int state)
+{
+	int err;
+
+	if (sk->s_fd == -1)
+		return -NLE_BAD_SOCK;
+
+	err = setsockopt(sk->s_fd, SOL_NETLINK, NETLINK_PKTINFO,
+			 &state, sizeof(state));
+	if (err < 0)
+		return -nl_syserr2nlerr(errno);
+
+	return 0;
+}
+
+/** @} */
+
+/** @} */
diff -uNr libnl_kk/lib/utils.c libnl/lib/utils.c
--- libnl_kk/lib/utils.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/lib/utils.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,935 @@
+/*
+ * lib/utils.c		Utility Functions
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup core
+ * @defgroup utils Utilities
+ * @{
+ */
+
+#include <netlink-local.h>
+#include <netlink/netlink.h>
+#include <netlink/utils.h>
+#include <linux/socket.h>
+
+/**
+ * Debug level
+ */
+int nl_debug = 0;
+
+struct nl_dump_params nl_debug_dp = {
+	.dp_type = NL_DUMP_DETAILS,
+};
+
+static void __init nl_debug_init(void)
+{
+	char *nldbg, *end;
+	
+	if ((nldbg = getenv("NLDBG"))) {
+		long level = strtol(nldbg, &end, 0);
+		if (nldbg != end)
+			nl_debug = level;
+	}
+
+	nl_debug_dp.dp_fd = stderr;
+}
+
+int __nl_read_num_str_file(const char *path, int (*cb)(long, const char *))
+{
+	FILE *fd;
+	char buf[128];
+
+	fd = fopen(path, "r");
+	if (fd == NULL)
+		return -nl_syserr2nlerr(errno);
+
+	while (fgets(buf, sizeof(buf), fd)) {
+		int goodlen, err;
+		long num;
+		char *end;
+
+		if (*buf == '#' || *buf == '\n' || *buf == '\r')
+			continue;
+
+		num = strtol(buf, &end, 0);
+		if (end == buf)
+			return -NLE_INVAL;
+
+		if (num == LONG_MIN || num == LONG_MAX)
+			return -NLE_RANGE;
+
+		while (*end == ' ' || *end == '\t')
+			end++;
+
+		goodlen = strcspn(end, "#\r\n\t ");
+		if (goodlen == 0)
+			return -NLE_INVAL;
+
+		end[goodlen] = '\0';
+
+		err = cb(num, end);
+		if (err < 0)
+			return err;
+	}
+
+	fclose(fd);
+
+	return 0;
+}
+
+/**
+ * @name Unit Pretty-Printing
+ * @{
+ */
+
+/**
+ * Cancel down a byte counter
+ * @arg	l		byte counter
+ * @arg	unit		destination unit pointer
+ *
+ * Cancels down a byte counter until it reaches a reasonable
+ * unit. The chosen unit is assigned to \a unit.
+ * 
+ * @return The cancelled down byte counter in the new unit.
+ */
+double nl_cancel_down_bytes(unsigned long long l, char **unit)
+{
+	if (l >= 1099511627776LL) {
+		*unit = "TiB";
+		return ((double) l) / 1099511627776LL;
+	} else if (l >= 1073741824) {
+		*unit = "GiB";
+		return ((double) l) / 1073741824;
+	} else if (l >= 1048576) {
+		*unit = "MiB";
+		return ((double) l) / 1048576;
+	} else if (l >= 1024) {
+		*unit = "KiB";
+		return ((double) l) / 1024;
+	} else {
+		*unit = "B";
+		return (double) l;
+	}
+}
+
+/**
+ * Cancel down a bit counter
+ * @arg	l		bit counter
+ * @arg unit		destination unit pointer
+ *
+ * Cancels downa bit counter until it reaches a reasonable
+ * unit. The chosen unit is assigned to \a unit.
+ *
+ * @return The cancelled down bit counter in the new unit.
+ */
+double nl_cancel_down_bits(unsigned long long l, char **unit)
+{
+	if (l >= 1099511627776ULL) {
+		*unit = "Tbit";
+		return ((double) l) / 1099511627776ULL;
+	} else if (l >= 1073741824) {
+		*unit = "Gbit";
+		return ((double) l) / 1073741824;
+	} else if (l >= 1048576) {
+		*unit = "Mbit";
+		return ((double) l) / 1048576;
+	} else if (l >= 1024) {
+		*unit = "Kbit";
+		return ((double) l) / 1024;
+	} else {
+		*unit = "bit";
+		return (double) l;
+	}
+		
+}
+
+/**
+ * Cancel down a micro second value
+ * @arg	l		micro seconds
+ * @arg unit		destination unit pointer
+ *
+ * Cancels down a microsecond counter until it reaches a
+ * reasonable unit. The chosen unit is assigned to \a unit.
+ *
+ * @return The cancelled down microsecond in the new unit
+ */
+double nl_cancel_down_us(uint32_t l, char **unit)
+{
+	if (l >= 1000000) {
+		*unit = "s";
+		return ((double) l) / 1000000;
+	} else if (l >= 1000) {
+		*unit = "ms";
+		return ((double) l) / 1000;
+	} else {
+		*unit = "us";
+		return (double) l;
+	}
+}
+
+/** @} */
+
+/**
+ * @name Generic Unit Translations
+ * @{
+ */
+
+/**
+ * Convert a character string to a size
+ * @arg str		size encoded as character string
+ *
+ * Converts the specified size as character to the corresponding
+ * number of bytes.
+ *
+ * Supported formats are:
+ *  - b,kb/k,m/mb,gb/g for bytes
+ *  - bit,kbit/mbit/gbit
+ *
+ * @return The number of bytes or -1 if the string is unparseable
+ */
+long nl_size2int(const char *str)
+{
+	char *p;
+	long l = strtol(str, &p, 0);
+	if (p == str)
+		return -NLE_INVAL;
+
+	if (*p) {
+		if (!strcasecmp(p, "kb") || !strcasecmp(p, "k"))
+			l *= 1024;
+		else if (!strcasecmp(p, "gb") || !strcasecmp(p, "g"))
+			l *= 1024*1024*1024;
+		else if (!strcasecmp(p, "gbit"))
+			l *= 1024*1024*1024/8;
+		else if (!strcasecmp(p, "mb") || !strcasecmp(p, "m"))
+			l *= 1024*1024;
+		else if (!strcasecmp(p, "mbit"))
+			l *= 1024*1024/8;
+		else if (!strcasecmp(p, "kbit"))
+			l *= 1024/8;
+		else if (!strcasecmp(p, "bit"))
+			l /= 8;
+		else if (strcasecmp(p, "b") != 0)
+			return -NLE_INVAL;
+	}
+
+	return l;
+}
+
+/**
+ * Convert a character string to a probability
+ * @arg str		probability encoded as character string
+ *
+ * Converts the specified probability as character to the
+ * corresponding probability number.
+ *
+ * Supported formats are:
+ *  - 0.0-1.0
+ *  - 0%-100%
+ *
+ * @return The probability relative to NL_PROB_MIN and NL_PROB_MAX
+ */
+long nl_prob2int(const char *str)
+{
+	char *p;
+	double d = strtod(str, &p);
+
+	if (p == str)
+		return -NLE_INVAL;
+
+	if (d > 1.0)
+		d /= 100.0f;
+
+	if (d > 1.0f || d < 0.0f)
+		return -NLE_RANGE;
+
+	if (*p && strcmp(p, "%") != 0)
+		return -NLE_INVAL;
+
+	return rint(d * NL_PROB_MAX);
+}
+
+/** @} */
+
+/**
+ * @name Time Translations
+ * @{
+ */
+
+#ifdef USER_HZ
+static uint32_t user_hz = USER_HZ;
+#else
+static uint32_t user_hz = 100;
+#endif
+
+static double ticks_per_usec = 1.0f;
+
+/* Retrieves the configured HZ and ticks/us value in the kernel.
+ * The value is cached. Supported ways of getting it:
+ *
+ * 1) environment variable
+ * 2) /proc/net/psched and sysconf
+ *
+ * Supports the environment variables:
+ *   PROC_NET_PSCHED  - may point to psched file in /proc
+ *   PROC_ROOT        - may point to /proc fs */ 
+static void __init get_psched_settings(void)
+{
+	char name[FILENAME_MAX];
+	FILE *fd;
+	int got_hz = 0;
+
+	if (getenv("HZ")) {
+		long hz = strtol(getenv("HZ"), NULL, 0);
+
+		if (LONG_MIN != hz && LONG_MAX != hz) {
+			user_hz = hz;
+			got_hz = 1;
+		}
+	}
+
+	if (!got_hz)
+		user_hz = sysconf(_SC_CLK_TCK);
+
+	if (getenv("TICKS_PER_USEC")) {
+		double t = strtod(getenv("TICKS_PER_USEC"), NULL);
+		ticks_per_usec = t;
+	}
+	else {
+		if (getenv("PROC_NET_PSCHED"))
+			snprintf(name, sizeof(name), "%s", getenv("PROC_NET_PSCHED"));
+		else if (getenv("PROC_ROOT"))
+			snprintf(name, sizeof(name), "%s/net/psched",
+				 getenv("PROC_ROOT"));
+		else
+			strncpy(name, "/proc/net/psched", sizeof(name) - 1);
+		
+		if ((fd = fopen(name, "r"))) {
+			uint32_t tick, us;
+			/* the file contains 4 hexadecimals, but we just use
+			   the first two of them */
+			fscanf(fd, "%08x %08x", &tick, &us);
+			ticks_per_usec = (double)tick/(double)us;
+			fclose(fd);
+		}
+	}
+}
+
+
+/**
+ * Return the value of HZ
+ */
+int nl_get_hz(void)
+{
+	return user_hz;
+}
+
+
+/**
+ * Convert micro seconds to ticks
+ * @arg us		micro seconds
+ * @return number of ticks
+ */
+uint32_t nl_us2ticks(uint32_t us)
+{
+	return us * ticks_per_usec;
+}
+
+
+/**
+ * Convert ticks to micro seconds
+ * @arg ticks		number of ticks
+ * @return microseconds
+ */
+uint32_t nl_ticks2us(uint32_t ticks)
+{
+	return ticks / ticks_per_usec;
+}
+
+int nl_str2msec(const char *str, uint64_t *result)
+{
+	uint64_t total = 0, l;
+	int plen;
+	char *p;
+
+	do {
+		l = strtoul(str, &p, 0);
+		if (p == str)
+			return -NLE_INVAL;
+		else if (*p) {
+			plen = strcspn(p, " \t");
+
+			if (!plen)
+				total += l;
+			else if (!strncasecmp(p, "sec", plen))
+				total += (l * 1000);
+			else if (!strncasecmp(p, "min", plen))
+				total += (l * 1000*60);
+			else if (!strncasecmp(p, "hour", plen))
+				total += (l * 1000*60*60);
+			else if (!strncasecmp(p, "day", plen))
+				total += (l * 1000*60*60*24);
+			else
+				return -NLE_INVAL;
+
+			str = p + plen;
+		} else
+			total += l;
+	} while (*str && *p);
+
+	*result = total;
+
+	return 0;
+}
+
+/**
+ * Convert milliseconds to a character string
+ * @arg msec		number of milliseconds
+ * @arg buf		destination buffer
+ * @arg len		buffer length
+ *
+ * Converts milliseconds to a character string split up in days, hours,
+ * minutes, seconds, and milliseconds and stores it in the specified
+ * destination buffer.
+ *
+ * @return The destination buffer.
+ */
+char * nl_msec2str(uint64_t msec, char *buf, size_t len)
+{
+	int i, split[5];
+	char *units[] = {"d", "h", "m", "s", "msec"};
+
+#define _SPLIT(idx, unit) if ((split[idx] = msec / unit) > 0) msec %= unit
+	_SPLIT(0, 86400000);	/* days */
+	_SPLIT(1, 3600000);	/* hours */
+	_SPLIT(2, 60000);	/* minutes */
+	_SPLIT(3, 1000);	/* seconds */
+#undef  _SPLIT
+	split[4] = msec;
+
+	memset(buf, 0, len);
+
+	for (i = 0; i < ARRAY_SIZE(split); i++) {
+		if (split[i] > 0) {
+			char t[64];
+			snprintf(t, sizeof(t), "%s%d%s",
+				 strlen(buf) ? " " : "", split[i], units[i]);
+			strncat(buf, t, len - strlen(buf) - 1);
+		}
+	}
+
+	return buf;
+}
+
+/** @} */
+
+/**
+ * @name Netlink Family Translations
+ * @{
+ */
+
+static struct trans_tbl nlfamilies[] = {
+	__ADD(NETLINK_ROUTE,route)
+	__ADD(NETLINK_USERSOCK,usersock)
+	__ADD(NETLINK_FIREWALL,firewall)
+	__ADD(NETLINK_INET_DIAG,inetdiag)
+	__ADD(NETLINK_NFLOG,nflog)
+	__ADD(NETLINK_XFRM,xfrm)
+	__ADD(NETLINK_SELINUX,selinux)
+	__ADD(NETLINK_ISCSI,iscsi)
+	__ADD(NETLINK_AUDIT,audit)
+	__ADD(NETLINK_FIB_LOOKUP,fib_lookup)
+	__ADD(NETLINK_CONNECTOR,connector)
+	__ADD(NETLINK_NETFILTER,netfilter)
+	__ADD(NETLINK_IP6_FW,ip6_fw)
+	__ADD(NETLINK_DNRTMSG,dnrtmsg)
+	__ADD(NETLINK_KOBJECT_UEVENT,kobject_uevent)
+	__ADD(NETLINK_GENERIC,generic)
+	__ADD(NETLINK_SCSITRANSPORT,scsitransport)
+	__ADD(NETLINK_ECRYPTFS,ecryptfs)
+};
+
+char * nl_nlfamily2str(int family, char *buf, size_t size)
+{
+	return __type2str(family, buf, size, nlfamilies,
+			  ARRAY_SIZE(nlfamilies));
+}
+
+int nl_str2nlfamily(const char *name)
+{
+	return __str2type(name, nlfamilies, ARRAY_SIZE(nlfamilies));
+}
+
+/**
+ * @}
+ */
+
+/**
+ * @name Link Layer Protocol Translations
+ * @{
+ */
+
+static struct trans_tbl llprotos[] = {
+	{0, "generic"},
+	__ADD(ARPHRD_ETHER,ether)
+	__ADD(ARPHRD_EETHER,eether)
+	__ADD(ARPHRD_AX25,ax25)
+	__ADD(ARPHRD_PRONET,pronet)
+	__ADD(ARPHRD_CHAOS,chaos)
+	__ADD(ARPHRD_IEEE802,ieee802)
+	__ADD(ARPHRD_ARCNET,arcnet)
+	__ADD(ARPHRD_APPLETLK,atalk)
+	__ADD(ARPHRD_DLCI,dlci)
+	__ADD(ARPHRD_ATM,atm)
+	__ADD(ARPHRD_METRICOM,metricom)
+	__ADD(ARPHRD_IEEE1394,ieee1394)
+#ifdef ARPHRD_EUI64
+	__ADD(ARPHRD_EUI64,eui64)
+#endif
+	__ADD(ARPHRD_INFINIBAND,infiniband)
+	__ADD(ARPHRD_SLIP,slip)
+	__ADD(ARPHRD_CSLIP,cslip)
+	__ADD(ARPHRD_SLIP6,slip6)
+	__ADD(ARPHRD_CSLIP6,cslip6)
+	__ADD(ARPHRD_RSRVD,rsrvd)
+	__ADD(ARPHRD_ADAPT,adapt)
+	__ADD(ARPHRD_ROSE,rose)
+	__ADD(ARPHRD_X25,x25)
+#ifdef ARPHRD_HWX25
+	__ADD(ARPHRD_HWX25,hwx25)
+#endif
+	__ADD(ARPHRD_PPP,ppp)
+	__ADD(ARPHRD_HDLC,hdlc)
+	__ADD(ARPHRD_LAPB,lapb)
+	__ADD(ARPHRD_DDCMP,ddcmp)
+	__ADD(ARPHRD_RAWHDLC,rawhdlc)
+	__ADD(ARPHRD_TUNNEL,ipip)
+	__ADD(ARPHRD_TUNNEL6,tunnel6)
+	__ADD(ARPHRD_FRAD,frad)
+	__ADD(ARPHRD_SKIP,skip)
+	__ADD(ARPHRD_LOOPBACK,loopback)
+	__ADD(ARPHRD_LOCALTLK,localtlk)
+	__ADD(ARPHRD_FDDI,fddi)
+	__ADD(ARPHRD_BIF,bif)
+	__ADD(ARPHRD_SIT,sit)
+	__ADD(ARPHRD_IPDDP,ip/ddp)
+	__ADD(ARPHRD_IPGRE,gre)
+	__ADD(ARPHRD_PIMREG,pimreg)
+	__ADD(ARPHRD_HIPPI,hippi)
+	__ADD(ARPHRD_ASH,ash)
+	__ADD(ARPHRD_ECONET,econet)
+	__ADD(ARPHRD_IRDA,irda)
+	__ADD(ARPHRD_FCPP,fcpp)
+	__ADD(ARPHRD_FCAL,fcal)
+	__ADD(ARPHRD_FCPL,fcpl)
+	__ADD(ARPHRD_FCFABRIC,fcfb_0)
+	__ADD(ARPHRD_FCFABRIC+1,fcfb_1)
+	__ADD(ARPHRD_FCFABRIC+2,fcfb_2)
+	__ADD(ARPHRD_FCFABRIC+3,fcfb_3)
+	__ADD(ARPHRD_FCFABRIC+4,fcfb_4)
+	__ADD(ARPHRD_FCFABRIC+5,fcfb_5)
+	__ADD(ARPHRD_FCFABRIC+6,fcfb_6)
+	__ADD(ARPHRD_FCFABRIC+7,fcfb_7)
+	__ADD(ARPHRD_FCFABRIC+8,fcfb_8)
+	__ADD(ARPHRD_FCFABRIC+9,fcfb_9)
+	__ADD(ARPHRD_FCFABRIC+10,fcfb_10)
+	__ADD(ARPHRD_FCFABRIC+11,fcfb_11)
+	__ADD(ARPHRD_FCFABRIC+12,fcfb_12)
+	__ADD(ARPHRD_IEEE802_TR,tr)
+	__ADD(ARPHRD_IEEE80211,ieee802.11)
+#ifdef ARPHRD_IEEE80211_PRISM
+	__ADD(ARPHRD_IEEE80211_PRISM, ieee802.11_prism)
+#endif
+#ifdef ARPHRD_VOID
+	__ADD(ARPHRD_VOID,void)
+#endif
+};
+
+char * nl_llproto2str(int llproto, char *buf, size_t len)
+{
+	return __type2str(llproto, buf, len, llprotos, ARRAY_SIZE(llprotos));
+}
+
+int nl_str2llproto(const char *name)
+{
+	return __str2type(name, llprotos, ARRAY_SIZE(llprotos));
+}
+
+/** @} */
+
+
+/**
+ * @name Ethernet Protocol Translations
+ * @{
+ */
+
+static struct trans_tbl ether_protos[] = {
+	__ADD(ETH_P_LOOP,loop)
+	__ADD(ETH_P_PUP,pup)
+	__ADD(ETH_P_PUPAT,pupat)
+	__ADD(ETH_P_IP,ip)
+	__ADD(ETH_P_X25,x25)
+	__ADD(ETH_P_ARP,arp)
+	__ADD(ETH_P_BPQ,bpq)
+	__ADD(ETH_P_IEEEPUP,ieeepup)
+	__ADD(ETH_P_IEEEPUPAT,ieeepupat)
+	__ADD(ETH_P_DEC,dec)
+	__ADD(ETH_P_DNA_DL,dna_dl)
+	__ADD(ETH_P_DNA_RC,dna_rc)
+	__ADD(ETH_P_DNA_RT,dna_rt)
+	__ADD(ETH_P_LAT,lat)
+	__ADD(ETH_P_DIAG,diag)
+	__ADD(ETH_P_CUST,cust)
+	__ADD(ETH_P_SCA,sca)
+	__ADD(ETH_P_RARP,rarp)
+	__ADD(ETH_P_ATALK,atalk)
+	__ADD(ETH_P_AARP,aarp)
+#ifdef ETH_P_8021Q
+	__ADD(ETH_P_8021Q,802.1q)
+#endif
+	__ADD(ETH_P_IPX,ipx)
+	__ADD(ETH_P_IPV6,ipv6)
+#ifdef ETH_P_WCCP
+	__ADD(ETH_P_WCCP,wccp)
+#endif
+	__ADD(ETH_P_PPP_DISC,ppp_disc)
+	__ADD(ETH_P_PPP_SES,ppp_ses)
+	__ADD(ETH_P_MPLS_UC,mpls_uc)
+	__ADD(ETH_P_MPLS_MC,mpls_mc)
+	__ADD(ETH_P_ATMMPOA,atmmpoa)
+	__ADD(ETH_P_ATMFATE,atmfate)
+	__ADD(ETH_P_EDP2,edp2)
+	__ADD(ETH_P_802_3,802.3)
+	__ADD(ETH_P_AX25,ax25)
+	__ADD(ETH_P_ALL,all)
+	__ADD(ETH_P_802_2,802.2)
+	__ADD(ETH_P_SNAP,snap)
+	__ADD(ETH_P_DDCMP,ddcmp)
+	__ADD(ETH_P_WAN_PPP,wan_ppp)
+	__ADD(ETH_P_PPP_MP,ppp_mp)
+	__ADD(ETH_P_LOCALTALK,localtalk)
+	__ADD(ETH_P_PPPTALK,ppptalk)
+	__ADD(ETH_P_TR_802_2,tr_802.2)
+	__ADD(ETH_P_MOBITEX,mobitex)
+	__ADD(ETH_P_CONTROL,control)
+	__ADD(ETH_P_IRDA,irda)
+	__ADD(ETH_P_ECONET,econet)
+	__ADD(ETH_P_HDLC,hdlc)
+};
+
+char *nl_ether_proto2str(int eproto, char *buf, size_t len)
+{
+	return __type2str(eproto, buf, len, ether_protos,
+			    ARRAY_SIZE(ether_protos));
+}
+
+int nl_str2ether_proto(const char *name)
+{
+	return __str2type(name, ether_protos, ARRAY_SIZE(ether_protos));
+}
+
+/** @} */
+
+/**
+ * @name IP Protocol Translations
+ * @{
+ */
+
+char *nl_ip_proto2str(int proto, char *buf, size_t len)
+{
+	struct protoent *p = getprotobynumber(proto);
+
+	if (p) {
+		snprintf(buf, len, "%s", p->p_name);
+		return buf;
+	}
+
+	snprintf(buf, len, "0x%x", proto);
+	return buf;
+}
+
+int nl_str2ip_proto(const char *name)
+{
+	struct protoent *p = getprotobyname(name);
+	unsigned long l;
+	char *end;
+
+	if (p)
+		return p->p_proto;
+
+	l = strtoul(name, &end, 0);
+	if (l == ULONG_MAX || *end != '\0')
+		return -NLE_OBJ_NOTFOUND;
+
+	return (int) l;
+}
+
+/** @} */
+
+/**
+ * @name Dumping Helpers
+ * @{
+ */
+
+/**
+ * Handle a new line while dumping
+ * @arg params		Dumping parameters
+ *
+ * This function must be called before dumping any onto a
+ * new line. It will ensure proper prefixing as specified
+ * by the dumping parameters.
+ *
+ * @note This function will NOT dump any newlines itself
+ */
+void nl_new_line(struct nl_dump_params *params)
+{
+	params->dp_line++;
+
+	if (params->dp_prefix) {
+		int i;
+		for (i = 0; i < params->dp_prefix; i++) {
+			if (params->dp_fd)
+				fprintf(params->dp_fd, " ");
+			else if (params->dp_buf)
+				strncat(params->dp_buf, " ",
+					params->dp_buflen -
+					sizeof(params->dp_buf) - 1);
+		}
+	}
+
+	if (params->dp_nl_cb)
+		params->dp_nl_cb(params, params->dp_line);
+}
+
+static void dump_one(struct nl_dump_params *parms, const char *fmt,
+		     va_list args)
+{
+	if (parms->dp_fd)
+		vfprintf(parms->dp_fd, fmt, args);
+	else if (parms->dp_buf || parms->dp_cb) {
+		char *buf = NULL;
+		vasprintf(&buf, fmt, args);
+		if (parms->dp_cb)
+			parms->dp_cb(parms, buf);
+		else
+			strncat(parms->dp_buf, buf,
+			        parms->dp_buflen - strlen(parms->dp_buf) - 1);
+		free(buf);
+	}
+}
+
+
+/**
+ * Dump a formatted character string
+ * @arg params		Dumping parameters
+ * @arg fmt		printf style formatting string
+ * @arg ...		Arguments to formatting string
+ *
+ * Dumps a printf style formatting string to the output device
+ * as specified by the dumping parameters.
+ */
+void nl_dump(struct nl_dump_params *params, const char *fmt, ...)
+{
+	va_list args;
+
+	va_start(args, fmt);
+	dump_one(params, fmt, args);
+	va_end(args);
+}
+
+void nl_dump_line(struct nl_dump_params *parms, const char *fmt, ...)
+{
+	va_list args;
+
+	nl_new_line(parms);
+
+	va_start(args, fmt);
+	dump_one(parms, fmt, args);
+	va_end(args);
+}
+
+
+/** @} */
+
+/** @cond SKIP */
+
+int __trans_list_add(int i, const char *a, struct nl_list_head *head)
+{
+	struct trans_list *tl;
+
+	tl = calloc(1, sizeof(*tl));
+	if (!tl)
+		return -NLE_NOMEM;
+
+	tl->i = i;
+	tl->a = strdup(a);
+
+	nl_list_add_tail(&tl->list, head);
+
+	return 0;
+}
+
+void __trans_list_clear(struct nl_list_head *head)
+{
+	struct trans_list *tl, *next;
+
+	nl_list_for_each_entry_safe(tl, next, head, list) {
+		free(tl->a);
+		free(tl);
+	}
+}
+
+char *__type2str(int type, char *buf, size_t len, struct trans_tbl *tbl,
+		 size_t tbl_len)
+{
+	int i;
+	for (i = 0; i < tbl_len; i++) {
+		if (tbl[i].i == type) {
+			snprintf(buf, len, "%s", tbl[i].a);
+			return buf;
+		}
+	}
+
+	snprintf(buf, len, "0x%x", type);
+	return buf;
+}
+
+char *__list_type2str(int type, char *buf, size_t len,
+		      struct nl_list_head *head)
+{
+	struct trans_list *tl;
+
+	nl_list_for_each_entry(tl, head, list) {
+		if (tl->i == type) {
+			snprintf(buf, len, "%s", tl->a);
+			return buf;
+		}
+	}
+
+	snprintf(buf, len, "0x%x", type);
+	return buf;
+}
+
+char *__flags2str(int flags, char *buf, size_t len,
+		  struct trans_tbl *tbl, size_t tbl_len)
+{
+	int i;
+	int tmp = flags;
+
+	memset(buf, 0, len);
+	
+	for (i = 0; i < tbl_len; i++) {
+		if (tbl[i].i & tmp) {
+			tmp &= ~tbl[i].i;
+			strncat(buf, tbl[i].a, len - strlen(buf) - 1);
+			if ((tmp & flags))
+				strncat(buf, ",", len - strlen(buf) - 1);
+		}
+	}
+
+	return buf;
+}
+
+int __str2type(const char *buf, struct trans_tbl *tbl, size_t tbl_len)
+{
+	unsigned long l;
+	char *end;
+	int i;
+
+	if (*buf == '\0')
+		return -NLE_INVAL;
+
+	for (i = 0; i < tbl_len; i++)
+		if (!strcasecmp(tbl[i].a, buf))
+			return tbl[i].i;
+
+	l = strtoul(buf, &end, 0);
+	if (l == ULONG_MAX || *end != '\0')
+		return -NLE_OBJ_NOTFOUND;
+
+	return (int) l;
+}
+
+int __list_str2type(const char *buf, struct nl_list_head *head)
+{
+	struct trans_list *tl;
+	unsigned long l;
+	char *end;
+
+	if (*buf == '\0')
+		return -NLE_INVAL;
+
+	nl_list_for_each_entry(tl, head, list) {
+		if (!strcasecmp(tl->a, buf))
+			return tl->i;
+	}
+
+	l = strtoul(buf, &end, 0);
+	if (l == ULONG_MAX || *end != '\0')
+		return -NLE_OBJ_NOTFOUND;
+
+	return (int) l;
+}
+
+int __str2flags(const char *buf, struct trans_tbl *tbl, size_t tbl_len)
+{
+	int i, flags = 0, len;
+	char *p = (char *) buf, *t;
+
+	for (;;) {
+		if (*p == ' ')
+			p++;
+	
+		t = strchr(p, ',');
+		len = t ? t - p : strlen(p);
+		for (i = 0; i < tbl_len; i++)
+			if (!strncasecmp(tbl[i].a, p, len))
+				flags |= tbl[i].i;
+
+		if (!t)
+			return flags;
+
+		p = ++t;
+	}
+
+	return 0;
+}
+
+void dump_from_ops(struct nl_object *obj, struct nl_dump_params *params)
+{
+	int type = params->dp_type;
+
+	if (type < 0 || type > NL_DUMP_MAX)
+		BUG();
+
+	params->dp_line = 0;
+
+	if (params->dp_dump_msgtype) {
+#if 0
+		/* XXX */
+		char buf[64];
+
+		dp_dump_line(params, 0, "%s ",
+			     nl_cache_mngt_type2name(obj->ce_ops,
+			     			     obj->ce_ops->co_protocol,
+						     obj->ce_msgtype,
+						     buf, sizeof(buf)));
+#endif
+		params->dp_pre_dump = 1;
+	}
+
+	if (obj->ce_ops->oo_dump[type])
+		obj->ce_ops->oo_dump[type](obj, params);
+}
+
+/** @endcond */
+
+/** @} */
diff -uNr libnl_kk/libnl-2.0.pc.in libnl/libnl-2.0.pc.in
--- libnl_kk/libnl-2.0.pc.in	1970-01-01 08:00:00.000000000 +0800
+++ libnl/libnl-2.0.pc.in	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,10 @@
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+libdir=@libdir@
+includedir=@includedir@
+
+Name: libnl
+Description: Convenience library for netlink sockets
+Version: @PACKAGE_VERSION@
+Libs: -L${libdir} -lnl
+Cflags: -I${includedir}
diff -uNr libnl_kk/m4/.gitignore libnl/m4/.gitignore
--- libnl_kk/m4/.gitignore	1970-01-01 08:00:00.000000000 +0800
+++ libnl/m4/.gitignore	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,2 @@
+/lt*.m4
+/libtool.m4
diff -uNr libnl_kk/Makefile.am libnl/Makefile.am
--- libnl_kk/Makefile.am	1970-01-01 08:00:00.000000000 +0800
+++ libnl/Makefile.am	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,20 @@
+# -*- Makefile -*-
+
+ACLOCAL_AMFLAGS = -I m4
+
+OPT_DIRS =
+
+if ENABLE_CLI
+OPT_DIRS += src
+endif
+
+SUBDIRS = include lib doc $(OPT_DIRS)
+
+pkgconfig_DATA = libnl-2.0.pc
+
+sysconfdir = @sysconfdir@/libnl
+sysconf_DATA = etc/pktloc
+
+.PHONY: cscope
+cscope:
+	cscope -b -q -R -Iinclude -slib -ssrc;
diff -uNr libnl_kk/NOTICE libnl/NOTICE
--- libnl_kk/NOTICE	1970-01-01 08:00:00.000000000 +0800
+++ libnl/NOTICE	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,506 @@
+		  GNU LESSER GENERAL PUBLIC LICENSE
+		       Version 2.1, February 1999
+
+ Copyright (C) 1991, 1999 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+[This is the first released version of the Lesser GPL.  It also counts
+ as the successor of the GNU Library Public License, version 2, hence
+ the version number 2.1.]
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+Licenses are intended to guarantee your freedom to share and change
+free software--to make sure the software is free for all its users.
+
+  This license, the Lesser General Public License, applies to some
+specially designated software packages--typically libraries--of the
+Free Software Foundation and other authors who decide to use it.  You
+can use it too, but we suggest you first think carefully about whether
+this license or the ordinary General Public License is the better
+strategy to use in any particular case, based on the explanations below.
+
+  When we speak of free software, we are referring to freedom of use,
+not price.  Our General Public Licenses are designed to make sure that
+you have the freedom to distribute copies of free software (and charge
+for this service if you wish); that you receive source code or can get
+it if you want it; that you can change the software and use pieces of
+it in new free programs; and that you are informed that you can do
+these things.
+
+  To protect your rights, we need to make restrictions that forbid
+distributors to deny you these rights or to ask you to surrender these
+rights.  These restrictions translate to certain responsibilities for
+you if you distribute copies of the library or if you modify it.
+
+  For example, if you distribute copies of the library, whether gratis
+or for a fee, you must give the recipients all the rights that we gave
+you.  You must make sure that they, too, receive or can get the source
+code.  If you link other code with the library, you must provide
+complete object files to the recipients, so that they can relink them
+with the library after making changes to the library and recompiling
+it.  And you must show them these terms so they know their rights.
+
+  We protect your rights with a two-step method: (1) we copyright the
+library, and (2) we offer you this license, which gives you legal
+permission to copy, distribute and/or modify the library.
+
+  To protect each distributor, we want to make it very clear that
+there is no warranty for the free library.  Also, if the library is
+modified by someone else and passed on, the recipients should know
+that what they have is not the original version, so that the original
+author's reputation will not be affected by problems that might be
+introduced by others.
+
+  Finally, software patents pose a constant threat to the existence of
+any free program.  We wish to make sure that a company cannot
+effectively restrict the users of a free program by obtaining a
+restrictive license from a patent holder.  Therefore, we insist that
+any patent license obtained for a version of the library must be
+consistent with the full freedom of use specified in this license.
+
+  Most GNU software, including some libraries, is covered by the
+ordinary GNU General Public License.  This license, the GNU Lesser
+General Public License, applies to certain designated libraries, and
+is quite different from the ordinary General Public License.  We use
+this license for certain libraries in order to permit linking those
+libraries into non-free programs.
+
+  When a program is linked with a library, whether statically or using
+a shared library, the combination of the two is legally speaking a
+combined work, a derivative of the original library.  The ordinary
+General Public License therefore permits such linking only if the
+entire combination fits its criteria of freedom.  The Lesser General
+Public License permits more lax criteria for linking other code with
+the library.
+
+  We call this license the "Lesser" General Public License because it
+does Less to protect the user's freedom than the ordinary General
+Public License.  It also provides other free software developers Less
+of an advantage over competing non-free programs.  These disadvantages
+are the reason we use the ordinary General Public License for many
+libraries.  However, the Lesser license provides advantages in certain
+special circumstances.
+
+  For example, on rare occasions, there may be a special need to
+encourage the widest possible use of a certain library, so that it becomes
+a de-facto standard.  To achieve this, non-free programs must be
+allowed to use the library.  A more frequent case is that a free
+library does the same job as widely used non-free libraries.  In this
+case, there is little to gain by limiting the free library to free
+software only, so we use the Lesser General Public License.
+
+  In other cases, permission to use a particular library in non-free
+programs enables a greater number of people to use a large body of
+free software.  For example, permission to use the GNU C Library in
+non-free programs enables many more people to use the whole GNU
+operating system, as well as its variant, the GNU/Linux operating
+system.
+
+  Although the Lesser General Public License is Less protective of the
+users' freedom, it does ensure that the user of a program that is
+linked with the Library has the freedom and the wherewithal to run
+that program using a modified version of the Library.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.  Pay close attention to the difference between a
+"work based on the library" and a "work that uses the library".  The
+former contains code derived from the library, whereas the latter must
+be combined with the library in order to run.
+
+		  GNU LESSER GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License Agreement applies to any software library or other
+program which contains a notice placed by the copyright holder or
+other authorized party saying it may be distributed under the terms of
+this Lesser General Public License (also called "this License").
+Each licensee is addressed as "you".
+
+  A "library" means a collection of software functions and/or data
+prepared so as to be conveniently linked with application programs
+(which use some of those functions and data) to form executables.
+
+  The "Library", below, refers to any such software library or work
+which has been distributed under these terms.  A "work based on the
+Library" means either the Library or any derivative work under
+copyright law: that is to say, a work containing the Library or a
+portion of it, either verbatim or with modifications and/or translated
+straightforwardly into another language.  (Hereinafter, translation is
+included without limitation in the term "modification".)
+
+  "Source code" for a work means the preferred form of the work for
+making modifications to it.  For a library, complete source code means
+all the source code for all modules it contains, plus any associated
+interface definition files, plus the scripts used to control compilation
+and installation of the library.
+
+  Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running a program using the Library is not restricted, and output from
+such a program is covered only if its contents constitute a work based
+on the Library (independent of the use of the Library in a tool for
+writing it).  Whether that is true depends on what the Library does
+and what the program that uses the Library does.
+  
+  1. You may copy and distribute verbatim copies of the Library's
+complete source code as you receive it, in any medium, provided that
+you conspicuously and appropriately publish on each copy an
+appropriate copyright notice and disclaimer of warranty; keep intact
+all the notices that refer to this License and to the absence of any
+warranty; and distribute a copy of this License along with the
+Library.
+
+  You may charge a fee for the physical act of transferring a copy,
+and you may at your option offer warranty protection in exchange for a
+fee.
+
+  2. You may modify your copy or copies of the Library or any portion
+of it, thus forming a work based on the Library, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) The modified work must itself be a software library.
+
+    b) You must cause the files modified to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    c) You must cause the whole of the work to be licensed at no
+    charge to all third parties under the terms of this License.
+
+    d) If a facility in the modified Library refers to a function or a
+    table of data to be supplied by an application program that uses
+    the facility, other than as an argument passed when the facility
+    is invoked, then you must make a good faith effort to ensure that,
+    in the event an application does not supply such function or
+    table, the facility still operates, and performs whatever part of
+    its purpose remains meaningful.
+
+    (For example, a function in a library to compute square roots has
+    a purpose that is entirely well-defined independent of the
+    application.  Therefore, Subsection 2d requires that any
+    application-supplied function or table used by this function must
+    be optional: if the application does not supply it, the square
+    root function must still compute square roots.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Library,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Library, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote
+it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Library.
+
+In addition, mere aggregation of another work not based on the Library
+with the Library (or with a work based on the Library) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may opt to apply the terms of the ordinary GNU General Public
+License instead of this License to a given copy of the Library.  To do
+this, you must alter all the notices that refer to this License, so
+that they refer to the ordinary GNU General Public License, version 2,
+instead of to this License.  (If a newer version than version 2 of the
+ordinary GNU General Public License has appeared, then you can specify
+that version instead if you wish.)  Do not make any other change in
+these notices.
+
+  Once this change is made in a given copy, it is irreversible for
+that copy, so the ordinary GNU General Public License applies to all
+subsequent copies and derivative works made from that copy.
+
+  This option is useful when you wish to copy part of the code of
+the Library into a program that is not a library.
+
+  4. You may copy and distribute the Library (or a portion or
+derivative of it, under Section 2) in object code or executable form
+under the terms of Sections 1 and 2 above provided that you accompany
+it with the complete corresponding machine-readable source code, which
+must be distributed under the terms of Sections 1 and 2 above on a
+medium customarily used for software interchange.
+
+  If distribution of object code is made by offering access to copy
+from a designated place, then offering equivalent access to copy the
+source code from the same place satisfies the requirement to
+distribute the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  5. A program that contains no derivative of any portion of the
+Library, but is designed to work with the Library by being compiled or
+linked with it, is called a "work that uses the Library".  Such a
+work, in isolation, is not a derivative work of the Library, and
+therefore falls outside the scope of this License.
+
+  However, linking a "work that uses the Library" with the Library
+creates an executable that is a derivative of the Library (because it
+contains portions of the Library), rather than a "work that uses the
+library".  The executable is therefore covered by this License.
+Section 6 states terms for distribution of such executables.
+
+  When a "work that uses the Library" uses material from a header file
+that is part of the Library, the object code for the work may be a
+derivative work of the Library even though the source code is not.
+Whether this is true is especially significant if the work can be
+linked without the Library, or if the work is itself a library.  The
+threshold for this to be true is not precisely defined by law.
+
+  If such an object file uses only numerical parameters, data
+structure layouts and accessors, and small macros and small inline
+functions (ten lines or less in length), then the use of the object
+file is unrestricted, regardless of whether it is legally a derivative
+work.  (Executables containing this object code plus portions of the
+Library will still fall under Section 6.)
+
+  Otherwise, if the work is a derivative of the Library, you may
+distribute the object code for the work under the terms of Section 6.
+Any executables containing that work also fall under Section 6,
+whether or not they are linked directly with the Library itself.
+
+  6. As an exception to the Sections above, you may also combine or
+link a "work that uses the Library" with the Library to produce a
+work containing portions of the Library, and distribute that work
+under terms of your choice, provided that the terms permit
+modification of the work for the customer's own use and reverse
+engineering for debugging such modifications.
+
+  You must give prominent notice with each copy of the work that the
+Library is used in it and that the Library and its use are covered by
+this License.  You must supply a copy of this License.  If the work
+during execution displays copyright notices, you must include the
+copyright notice for the Library among them, as well as a reference
+directing the user to the copy of this License.  Also, you must do one
+of these things:
+
+    a) Accompany the work with the complete corresponding
+    machine-readable source code for the Library including whatever
+    changes were used in the work (which must be distributed under
+    Sections 1 and 2 above); and, if the work is an executable linked
+    with the Library, with the complete machine-readable "work that
+    uses the Library", as object code and/or source code, so that the
+    user can modify the Library and then relink to produce a modified
+    executable containing the modified Library.  (It is understood
+    that the user who changes the contents of definitions files in the
+    Library will not necessarily be able to recompile the application
+    to use the modified definitions.)
+
+    b) Use a suitable shared library mechanism for linking with the
+    Library.  A suitable mechanism is one that (1) uses at run time a
+    copy of the library already present on the user's computer system,
+    rather than copying library functions into the executable, and (2)
+    will operate properly with a modified version of the library, if
+    the user installs one, as long as the modified version is
+    interface-compatible with the version that the work was made with.
+
+    c) Accompany the work with a written offer, valid for at
+    least three years, to give the same user the materials
+    specified in Subsection 6a, above, for a charge no more
+    than the cost of performing this distribution.
+
+    d) If distribution of the work is made by offering access to copy
+    from a designated place, offer equivalent access to copy the above
+    specified materials from the same place.
+
+    e) Verify that the user has already received a copy of these
+    materials or that you have already sent this user a copy.
+
+  For an executable, the required form of the "work that uses the
+Library" must include any data and utility programs needed for
+reproducing the executable from it.  However, as a special exception,
+the materials to be distributed need not include anything that is
+normally distributed (in either source or binary form) with the major
+components (compiler, kernel, and so on) of the operating system on
+which the executable runs, unless that component itself accompanies
+the executable.
+
+  It may happen that this requirement contradicts the license
+restrictions of other proprietary libraries that do not normally
+accompany the operating system.  Such a contradiction means you cannot
+use both them and the Library together in an executable that you
+distribute.
+
+  7. You may place library facilities that are a work based on the
+Library side-by-side in a single library together with other library
+facilities not covered by this License, and distribute such a combined
+library, provided that the separate distribution of the work based on
+the Library and of the other library facilities is otherwise
+permitted, and provided that you do these two things:
+
+    a) Accompany the combined library with a copy of the same work
+    based on the Library, uncombined with any other library
+    facilities.  This must be distributed under the terms of the
+    Sections above.
+
+    b) Give prominent notice with the combined library of the fact
+    that part of it is a work based on the Library, and explaining
+    where to find the accompanying uncombined form of the same work.
+
+  8. You may not copy, modify, sublicense, link with, or distribute
+the Library except as expressly provided under this License.  Any
+attempt otherwise to copy, modify, sublicense, link with, or
+distribute the Library is void, and will automatically terminate your
+rights under this License.  However, parties who have received copies,
+or rights, from you under this License will not have their licenses
+terminated so long as such parties remain in full compliance.
+
+  9. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Library or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Library (or any work based on the
+Library), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Library or works based on it.
+
+  10. Each time you redistribute the Library (or any work based on the
+Library), the recipient automatically receives a license from the
+original licensor to copy, distribute, link with or modify the Library
+subject to these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties with
+this License.
+
+  11. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Library at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Library by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Library.
+
+If any portion of this section is held invalid or unenforceable under any
+particular circumstance, the balance of the section is intended to apply,
+and the section as a whole is intended to apply in other circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  12. If the distribution and/or use of the Library is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Library under this License may add
+an explicit geographical distribution limitation excluding those countries,
+so that distribution is permitted only in or among countries not thus
+excluded.  In such case, this License incorporates the limitation as if
+written in the body of this License.
+
+  13. The Free Software Foundation may publish revised and/or new
+versions of the Lesser General Public License from time to time.
+Such new versions will be similar in spirit to the present version,
+but may differ in detail to address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Library
+specifies a version number of this License which applies to it and
+"any later version", you have the option of following the terms and
+conditions either of that version or of any later version published by
+the Free Software Foundation.  If the Library does not specify a
+license version number, you may choose any version ever published by
+the Free Software Foundation.
+
+  14. If you wish to incorporate parts of the Library into other free
+programs whose distribution conditions are incompatible with these,
+write to the author to ask for permission.  For software which is
+copyrighted by the Free Software Foundation, write to the Free
+Software Foundation; we sometimes make exceptions for this.  Our
+decision will be guided by the two goals of preserving the free status
+of all derivatives of our free software and of promoting the sharing
+and reuse of software generally.
+
+			    NO WARRANTY
+
+  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
+WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
+EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
+OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
+KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
+LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
+THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
+WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
+AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
+FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
+CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
+LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
+RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
+FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
+SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+           How to Apply These Terms to Your New Libraries
+
+  If you develop a new library, and you want it to be of the greatest
+possible use to the public, we recommend making it free software that
+everyone can redistribute and change.  You can do so by permitting
+redistribution under these terms (or, alternatively, under the terms of the
+ordinary General Public License).
+
+  To apply these terms, attach the following notices to the library.  It is
+safest to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least the
+"copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the library's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+Also add information on how to contact you by electronic and paper mail.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the library, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the
+  library `Frob' (a library for tweaking knobs) written by James Random Hacker.
+
+  <signature of Ty Coon>, 1 April 1990
+  Ty Coon, President of Vice
+
+That's all there is to it!
+
+
+
+
diff -uNr libnl_kk/src/cls/basic.c libnl/src/cls/basic.c
--- libnl_kk/src/cls/basic.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/cls/basic.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,90 @@
+/*
+ * src/cls/basic.c	Basic Classifier
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation version 2 of the License.
+ *
+ * Copyright (c) 2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+#include "utils.h"
+#include <netlink/route/cls/basic.h>
+#include <netlink/route/cls/ematch.h>
+
+static void print_usage(void)
+{
+	printf(
+"Usage: ... basic [OPTIONS]...\n"
+"\n"
+"Options\n"
+" -h, --help                Show this help.\n"
+" -e, --ematch=MATCH        Extended match (See --ematch help).\n"
+" -c, --classid=HANDLE      Target class to classify matching packets to.\n"
+	);
+	exit(0);
+}
+
+static void basic_parse_argv(struct rtnl_cls *cls, int argc, char **argv)
+{
+	uint32_t classid;
+
+	for (;;) {
+		int c, optidx = 0, err;
+		static struct option long_opts[] = {
+			{ "help", 0, 0, 'h' },
+			{ "ematch", 1, 0, 'e' },
+			{ "classid", 1, 0, 'c' },
+			{ 0, 0, 0, 0 }
+		};
+	
+		c = getopt_long(argc, argv, "he:c:", long_opts, &optidx);
+		if (c == -1)
+			break;
+
+		switch (c) {
+		case '?':
+			exit(NLE_INVAL);
+
+		case 'h':
+			print_usage();
+
+		case 'e':
+#if 0
+			if ((err = parse_ematch_syntax(optarg, &tree)) < 0)
+				fatal(err, "Error while parsing ematch: %s",
+				      nl_geterror(err));
+
+			if ((err = rtnl_basic_set_ematch(cls, tree)) < 0)
+				fatal(err, "Unable to set ematch: %s",
+					nl_geterror(err));
+#endif
+			break;
+
+		case 'c':
+			if ((err = rtnl_tc_str2handle(optarg, &classid)) < 0)
+				fatal(err, "Invalid classid \"%s\": %s",
+				      optarg, nl_geterror(err));
+				
+			if ((err = rtnl_basic_set_classid(cls, classid)) < 0)
+				fatal(err, "Unable to set classid: %s",
+				      nl_geterror(err));
+			break;
+		}
+ 	}
+}
+
+static struct cls_module basic_module = {
+	.name		= "basic",
+	.parse_argv	= basic_parse_argv,
+};
+
+static void __attribute__ ((constructor)) basic_init(void)
+{
+	register_cls_module(&basic_module);
+}
+
+static void __attribute__ ((destructor)) basic_exit(void)
+{
+	unregister_cls_module(&basic_module);
+}
diff -uNr libnl_kk/src/cls/cgroup.c libnl/src/cls/cgroup.c
--- libnl_kk/src/cls/cgroup.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/cls/cgroup.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,78 @@
+/*
+ * src/cls/cgroup.c	Control Groups Classifier
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation version 2 of the License.
+ *
+ * Copyright (c) 2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#include "utils.h"
+#include <netlink/route/cls/cgroup.h>
+#include <netlink/route/cls/ematch.h>
+
+static void print_usage(void)
+{
+	printf(
+"Usage: ... cgroup [OPTIONS]...\n"
+"\n"
+"Options\n"
+" -h, --help                Show this help.\n"
+" -e, --ematch=MATCH        Extended match (See --ematch help).\n"
+" -c, --classid=HANDLE      Target class to classify matching packets to.\n"
+	);
+	exit(0);
+}
+
+static void basic_parse_argv(struct rtnl_cls *cls, int argc, char **argv)
+{
+	for (;;) {
+		int c, optidx = 0;
+		static struct option long_opts[] = {
+			{ "help", 0, 0, 'h' },
+			{ "ematch", 1, 0, 'e' },
+			{ "classid", 1, 0, 'c' },
+			{ 0, 0, 0, 0 }
+		};
+	
+		c = getopt_long(argc, argv, "he:c:", long_opts, &optidx);
+		if (c == -1)
+			break;
+
+		switch (c) {
+		case '?':
+			exit(NLE_INVAL);
+
+		case 'h':
+			print_usage();
+
+#if 0
+		case 'e':
+			if ((err = parse_ematch_syntax(optarg, &tree)) < 0)
+				fatal(err, "Error while parsing ematch: %s",
+				      nl_geterror(err));
+
+			if ((err = rtnl_basic_set_ematch(cls, tree)) < 0)
+				fatal(err, "Unable to set ematch: %s",
+					nl_geterror(err));
+			break;
+#endif
+		}
+ 	}
+}
+
+static struct cls_module cgroup_module = {
+	.name		= "cgroup",
+	.parse_argv	= basic_parse_argv,
+};
+
+static void __init cgroup_init(void)
+{
+	register_cls_module(&cgroup_module);
+}
+
+static void __exit cgroup_exit(void)
+{
+	unregister_cls_module(&cgroup_module);
+}
diff -uNr libnl_kk/src/cls/utils.c libnl/src/cls/utils.c
--- libnl_kk/src/cls/utils.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/cls/utils.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,105 @@
+/*
+ * src/cls-utils.c     Classifier Helpers
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation version 2 of the License.
+ *
+ * Copyright (c) 2008-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#include "utils.h"
+
+struct rtnl_cls *nlt_alloc_cls(void)
+{
+	struct rtnl_cls *cls;
+
+	cls = rtnl_cls_alloc();
+	if (!cls)
+		fatal(ENOMEM, "Unable to allocate classifier object");
+
+	return cls;
+}
+
+void parse_dev(struct rtnl_cls *cls, struct nl_cache *link_cache, char *arg)
+{
+	int ival;
+
+	if (!(ival = rtnl_link_name2i(link_cache, arg)))
+		fatal(ENOENT, "Link \"%s\" does not exist", arg);
+
+	rtnl_cls_set_ifindex(cls, ival);
+}
+  
+void parse_prio(struct rtnl_cls *cls, char *arg)
+{
+	uint32_t prio = parse_u32(arg);
+	rtnl_cls_set_prio(cls, prio);
+}
+
+void parse_parent(struct rtnl_cls *cls, char *arg)
+{
+	uint32_t parent;
+	int err;
+
+	if ((err = rtnl_tc_str2handle(arg, &parent)) < 0)
+		fatal(err, "Unable to parse handle \"%s\": %s",
+		      arg, nl_geterror(err));
+
+	rtnl_cls_set_parent(cls, parent);
+}
+
+void parse_handle(struct rtnl_cls *cls, char *arg)
+{
+	uint32_t handle;
+	int err;
+
+	if ((err = rtnl_tc_str2handle(arg, &handle)) < 0)
+		fatal(err, "Unable to parse handle \"%s\": %s",
+		      arg, nl_geterror(err));
+
+	rtnl_cls_set_handle(cls, handle);
+}
+
+void parse_proto(struct rtnl_cls *cls, char *arg)
+{
+	int proto = nl_str2ether_proto(arg);
+	if (proto < 0)
+		fatal(proto, "Unable to parse protocol \"%s\": %s",
+		      arg, nl_geterror(proto));
+	rtnl_cls_set_protocol(cls, proto);
+}
+
+static NL_LIST_HEAD(cls_modules);
+
+struct cls_module *lookup_cls_mod(struct rtnl_cls_ops *ops)
+{
+	struct cls_module *mod;
+
+	nl_list_for_each_entry(mod, &cls_modules, list) {
+		if (mod->ops == ops)
+			return mod;
+	}
+
+	return NULL;
+}
+
+void register_cls_module(struct cls_module *mod)
+{
+	struct rtnl_cls_ops *ops;
+
+	if (!(ops = __rtnl_cls_lookup_ops(mod->name)))
+		fatal(ENOENT, "Could not locate classifier module \"%s\"",
+			mod->name);
+
+	if (lookup_cls_mod(ops) != NULL)
+		fatal(EEXIST, "Duplicate classifier module registration.");
+
+	mod->ops = ops;
+	nl_list_add_tail(&mod->list, &cls_modules);
+}
+
+void unregister_cls_module(struct cls_module *mod)
+{
+	nl_list_del(&mod->list);
+}
diff -uNr libnl_kk/src/cls/utils.h libnl/src/cls/utils.h
--- libnl_kk/src/cls/utils.h	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/cls/utils.h	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,51 @@
+/*
+ * src/cls-utils.h     Classifier Helpers
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation version 2 of the License.
+ *
+ * Copyright (c) 2008-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef __CLS_UTILS_H_
+#define __CLS_UTILS_H_
+
+#include "../utils.h"
+#include <netlink/route/classifier-modules.h>
+#include <netlink/route/cls/ematch.h>
+
+struct cls_module
+{
+	const char *		name;
+	struct rtnl_cls_ops *	ops;
+	void		      (*parse_argv)(struct rtnl_cls *, int, char **);
+	struct nl_list_head	list;
+};
+
+extern struct cls_module *lookup_cls_mod(struct rtnl_cls_ops *);
+extern void register_cls_module(struct cls_module *);
+extern void unregister_cls_module(struct cls_module *);
+
+struct ematch_module
+{
+	int kind;
+	struct rtnl_ematch_ops *ops;
+	void (*parse_argv)(struct rtnl_ematch *, int, char **);
+	struct nl_list_head list;
+};
+
+extern struct ematch_module *lookup_ematch_mod(struct rtnl_ematch_ops *);
+extern void register_ematch_module(struct ematch_module *);
+extern void unregister_ematch_module(struct ematch_module *);
+
+extern struct rtnl_cls *nlt_alloc_cls(void);
+extern void parse_dev(struct rtnl_cls *, struct nl_cache *, char *);
+extern void parse_prio(struct rtnl_cls *, char *);
+extern void parse_parent(struct rtnl_cls *, char *);
+extern void parse_handle(struct rtnl_cls *, char *);
+extern void parse_proto(struct rtnl_cls *, char *);
+
+extern int parse_ematch_syntax(const char *, struct rtnl_ematch_tree **);
+
+#endif
diff -uNr libnl_kk/src/COPYING libnl/src/COPYING
--- libnl_kk/src/COPYING	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/COPYING	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,676 @@
+
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 3, 29 June 2007
+
+ Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The GNU General Public License is a free, copyleft license for
+software and other kinds of works.
+
+  The licenses for most software and other practical works are designed
+to take away your freedom to share and change the works.  By contrast,
+the GNU General Public License is intended to guarantee your freedom to
+share and change all versions of a program--to make sure it remains free
+software for all its users.  We, the Free Software Foundation, use the
+GNU General Public License for most of our software; it applies also to
+any other work released this way by its authors.  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+them if you wish), that you receive source code or can get it if you
+want it, that you can change the software or use pieces of it in new
+free programs, and that you know you can do these things.
+
+  To protect your rights, we need to prevent others from denying you
+these rights or asking you to surrender the rights.  Therefore, you have
+certain responsibilities if you distribute copies of the software, or if
+you modify it: responsibilities to respect the freedom of others.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must pass on to the recipients the same
+freedoms that you received.  You must make sure that they, too, receive
+or can get the source code.  And you must show them these terms so they
+know their rights.
+
+  Developers that use the GNU GPL protect your rights with two steps:
+(1) assert copyright on the software, and (2) offer you this License
+giving you legal permission to copy, distribute and/or modify it.
+
+  For the developers' and authors' protection, the GPL clearly explains
+that there is no warranty for this free software.  For both users' and
+authors' sake, the GPL requires that modified versions be marked as
+changed, so that their problems will not be attributed erroneously to
+authors of previous versions.
+
+  Some devices are designed to deny users access to install or run
+modified versions of the software inside them, although the manufacturer
+can do so.  This is fundamentally incompatible with the aim of
+protecting users' freedom to change the software.  The systematic
+pattern of such abuse occurs in the area of products for individuals to
+use, which is precisely where it is most unacceptable.  Therefore, we
+have designed this version of the GPL to prohibit the practice for those
+products.  If such problems arise substantially in other domains, we
+stand ready to extend this provision to those domains in future versions
+of the GPL, as needed to protect the freedom of users.
+
+  Finally, every program is threatened constantly by software patents.
+States should not allow patents to restrict development and use of
+software on general-purpose computers, but in those that do, we wish to
+avoid the special danger that patents applied to a free program could
+make it effectively proprietary.  To prevent this, the GPL assures that
+patents cannot be used to render the program non-free.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		       TERMS AND CONDITIONS
+
+  0. Definitions.
+
+  "This License" refers to version 3 of the GNU General Public License.
+
+  "Copyright" also means copyright-like laws that apply to other kinds of
+works, such as semiconductor masks.
+ 
+  "The Program" refers to any copyrightable work licensed under this
+License.  Each licensee is addressed as "you".  "Licensees" and
+"recipients" may be individuals or organizations.
+
+  To "modify" a work means to copy from or adapt all or part of the work
+in a fashion requiring copyright permission, other than the making of an
+exact copy.  The resulting work is called a "modified version" of the
+earlier work or a work "based on" the earlier work.
+
+  A "covered work" means either the unmodified Program or a work based
+on the Program.
+
+  To "propagate" a work means to do anything with it that, without
+permission, would make you directly or secondarily liable for
+infringement under applicable copyright law, except executing it on a
+computer or modifying a private copy.  Propagation includes copying,
+distribution (with or without modification), making available to the
+public, and in some countries other activities as well.
+
+  To "convey" a work means any kind of propagation that enables other
+parties to make or receive copies.  Mere interaction with a user through
+a computer network, with no transfer of a copy, is not conveying.
+
+  An interactive user interface displays "Appropriate Legal Notices"
+to the extent that it includes a convenient and prominently visible
+feature that (1) displays an appropriate copyright notice, and (2)
+tells the user that there is no warranty for the work (except to the
+extent that warranties are provided), that licensees may convey the
+work under this License, and how to view a copy of this License.  If
+the interface presents a list of user commands or options, such as a
+menu, a prominent item in the list meets this criterion.
+
+  1. Source Code.
+
+  The "source code" for a work means the preferred form of the work
+for making modifications to it.  "Object code" means any non-source
+form of a work.
+
+  A "Standard Interface" means an interface that either is an official
+standard defined by a recognized standards body, or, in the case of
+interfaces specified for a particular programming language, one that
+is widely used among developers working in that language.
+
+  The "System Libraries" of an executable work include anything, other
+than the work as a whole, that (a) is included in the normal form of
+packaging a Major Component, but which is not part of that Major
+Component, and (b) serves only to enable use of the work with that
+Major Component, or to implement a Standard Interface for which an
+implementation is available to the public in source code form.  A
+"Major Component", in this context, means a major essential component
+(kernel, window system, and so on) of the specific operating system
+(if any) on which the executable work runs, or a compiler used to
+produce the work, or an object code interpreter used to run it.
+
+  The "Corresponding Source" for a work in object code form means all
+the source code needed to generate, install, and (for an executable
+work) run the object code and to modify the work, including scripts to
+control those activities.  However, it does not include the work's
+System Libraries, or general-purpose tools or generally available free
+programs which are used unmodified in performing those activities but
+which are not part of the work.  For example, Corresponding Source
+includes interface definition files associated with source files for
+the work, and the source code for shared libraries and dynamically
+linked subprograms that the work is specifically designed to require,
+such as by intimate data communication or control flow between those
+subprograms and other parts of the work.
+
+  The Corresponding Source need not include anything that users
+can regenerate automatically from other parts of the Corresponding
+Source.
+
+  The Corresponding Source for a work in source code form is that
+same work.
+
+  2. Basic Permissions.
+
+  All rights granted under this License are granted for the term of
+copyright on the Program, and are irrevocable provided the stated
+conditions are met.  This License explicitly affirms your unlimited
+permission to run the unmodified Program.  The output from running a
+covered work is covered by this License only if the output, given its
+content, constitutes a covered work.  This License acknowledges your
+rights of fair use or other equivalent, as provided by copyright law.
+
+  You may make, run and propagate covered works that you do not
+convey, without conditions so long as your license otherwise remains
+in force.  You may convey covered works to others for the sole purpose
+of having them make modifications exclusively for you, or provide you
+with facilities for running those works, provided that you comply with
+the terms of this License in conveying all material for which you do
+not control copyright.  Those thus making or running the covered works
+for you must do so exclusively on your behalf, under your direction
+and control, on terms that prohibit them from making any copies of
+your copyrighted material outside their relationship with you.
+
+  Conveying under any other circumstances is permitted solely under
+the conditions stated below.  Sublicensing is not allowed; section 10
+makes it unnecessary.
+
+  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
+
+  No covered work shall be deemed part of an effective technological
+measure under any applicable law fulfilling obligations under article
+11 of the WIPO copyright treaty adopted on 20 December 1996, or
+similar laws prohibiting or restricting circumvention of such
+measures.
+
+  When you convey a covered work, you waive any legal power to forbid
+circumvention of technological measures to the extent such circumvention
+is effected by exercising rights under this License with respect to
+the covered work, and you disclaim any intention to limit operation or
+modification of the work as a means of enforcing, against the work's
+users, your or third parties' legal rights to forbid circumvention of
+technological measures.
+
+  4. Conveying Verbatim Copies.
+
+  You may convey verbatim copies of the Program's source code as you
+receive it, in any medium, provided that you conspicuously and
+appropriately publish on each copy an appropriate copyright notice;
+keep intact all notices stating that this License and any
+non-permissive terms added in accord with section 7 apply to the code;
+keep intact all notices of the absence of any warranty; and give all
+recipients a copy of this License along with the Program.
+
+  You may charge any price or no price for each copy that you convey,
+and you may offer support or warranty protection for a fee.
+
+  5. Conveying Modified Source Versions.
+
+  You may convey a work based on the Program, or the modifications to
+produce it from the Program, in the form of source code under the
+terms of section 4, provided that you also meet all of these conditions:
+
+    a) The work must carry prominent notices stating that you modified
+    it, and giving a relevant date.
+
+    b) The work must carry prominent notices stating that it is
+    released under this License and any conditions added under section
+    7.  This requirement modifies the requirement in section 4 to
+    "keep intact all notices".
+
+    c) You must license the entire work, as a whole, under this
+    License to anyone who comes into possession of a copy.  This
+    License will therefore apply, along with any applicable section 7
+    additional terms, to the whole of the work, and all its parts,
+    regardless of how they are packaged.  This License gives no
+    permission to license the work in any other way, but it does not
+    invalidate such permission if you have separately received it.
+
+    d) If the work has interactive user interfaces, each must display
+    Appropriate Legal Notices; however, if the Program has interactive
+    interfaces that do not display Appropriate Legal Notices, your
+    work need not make them do so.
+
+  A compilation of a covered work with other separate and independent
+works, which are not by their nature extensions of the covered work,
+and which are not combined with it such as to form a larger program,
+in or on a volume of a storage or distribution medium, is called an
+"aggregate" if the compilation and its resulting copyright are not
+used to limit the access or legal rights of the compilation's users
+beyond what the individual works permit.  Inclusion of a covered work
+in an aggregate does not cause this License to apply to the other
+parts of the aggregate.
+
+  6. Conveying Non-Source Forms.
+
+  You may convey a covered work in object code form under the terms
+of sections 4 and 5, provided that you also convey the
+machine-readable Corresponding Source under the terms of this License,
+in one of these ways:
+
+    a) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by the
+    Corresponding Source fixed on a durable physical medium
+    customarily used for software interchange.
+
+    b) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by a
+    written offer, valid for at least three years and valid for as
+    long as you offer spare parts or customer support for that product
+    model, to give anyone who possesses the object code either (1) a
+    copy of the Corresponding Source for all the software in the
+    product that is covered by this License, on a durable physical
+    medium customarily used for software interchange, for a price no
+    more than your reasonable cost of physically performing this
+    conveying of source, or (2) access to copy the
+    Corresponding Source from a network server at no charge.
+
+    c) Convey individual copies of the object code with a copy of the
+    written offer to provide the Corresponding Source.  This
+    alternative is allowed only occasionally and noncommercially, and
+    only if you received the object code with such an offer, in accord
+    with subsection 6b.
+
+    d) Convey the object code by offering access from a designated
+    place (gratis or for a charge), and offer equivalent access to the
+    Corresponding Source in the same way through the same place at no
+    further charge.  You need not require recipients to copy the
+    Corresponding Source along with the object code.  If the place to
+    copy the object code is a network server, the Corresponding Source
+    may be on a different server (operated by you or a third party)
+    that supports equivalent copying facilities, provided you maintain
+    clear directions next to the object code saying where to find the
+    Corresponding Source.  Regardless of what server hosts the
+    Corresponding Source, you remain obligated to ensure that it is
+    available for as long as needed to satisfy these requirements.
+
+    e) Convey the object code using peer-to-peer transmission, provided
+    you inform other peers where the object code and Corresponding
+    Source of the work are being offered to the general public at no
+    charge under subsection 6d.
+
+  A separable portion of the object code, whose source code is excluded
+from the Corresponding Source as a System Library, need not be
+included in conveying the object code work.
+
+  A "User Product" is either (1) a "consumer product", which means any
+tangible personal property which is normally used for personal, family,
+or household purposes, or (2) anything designed or sold for incorporation
+into a dwelling.  In determining whether a product is a consumer product,
+doubtful cases shall be resolved in favor of coverage.  For a particular
+product received by a particular user, "normally used" refers to a
+typical or common use of that class of product, regardless of the status
+of the particular user or of the way in which the particular user
+actually uses, or expects or is expected to use, the product.  A product
+is a consumer product regardless of whether the product has substantial
+commercial, industrial or non-consumer uses, unless such uses represent
+the only significant mode of use of the product.
+
+  "Installation Information" for a User Product means any methods,
+procedures, authorization keys, or other information required to install
+and execute modified versions of a covered work in that User Product from
+a modified version of its Corresponding Source.  The information must
+suffice to ensure that the continued functioning of the modified object
+code is in no case prevented or interfered with solely because
+modification has been made.
+
+  If you convey an object code work under this section in, or with, or
+specifically for use in, a User Product, and the conveying occurs as
+part of a transaction in which the right of possession and use of the
+User Product is transferred to the recipient in perpetuity or for a
+fixed term (regardless of how the transaction is characterized), the
+Corresponding Source conveyed under this section must be accompanied
+by the Installation Information.  But this requirement does not apply
+if neither you nor any third party retains the ability to install
+modified object code on the User Product (for example, the work has
+been installed in ROM).
+
+  The requirement to provide Installation Information does not include a
+requirement to continue to provide support service, warranty, or updates
+for a work that has been modified or installed by the recipient, or for
+the User Product in which it has been modified or installed.  Access to a
+network may be denied when the modification itself materially and
+adversely affects the operation of the network or violates the rules and
+protocols for communication across the network.
+
+  Corresponding Source conveyed, and Installation Information provided,
+in accord with this section must be in a format that is publicly
+documented (and with an implementation available to the public in
+source code form), and must require no special password or key for
+unpacking, reading or copying.
+
+  7. Additional Terms.
+
+  "Additional permissions" are terms that supplement the terms of this
+License by making exceptions from one or more of its conditions.
+Additional permissions that are applicable to the entire Program shall
+be treated as though they were included in this License, to the extent
+that they are valid under applicable law.  If additional permissions
+apply only to part of the Program, that part may be used separately
+under those permissions, but the entire Program remains governed by
+this License without regard to the additional permissions.
+
+  When you convey a copy of a covered work, you may at your option
+remove any additional permissions from that copy, or from any part of
+it.  (Additional permissions may be written to require their own
+removal in certain cases when you modify the work.)  You may place
+additional permissions on material, added by you to a covered work,
+for which you have or can give appropriate copyright permission.
+
+  Notwithstanding any other provision of this License, for material you
+add to a covered work, you may (if authorized by the copyright holders of
+that material) supplement the terms of this License with terms:
+
+    a) Disclaiming warranty or limiting liability differently from the
+    terms of sections 15 and 16 of this License; or
+
+    b) Requiring preservation of specified reasonable legal notices or
+    author attributions in that material or in the Appropriate Legal
+    Notices displayed by works containing it; or
+
+    c) Prohibiting misrepresentation of the origin of that material, or
+    requiring that modified versions of such material be marked in
+    reasonable ways as different from the original version; or
+
+    d) Limiting the use for publicity purposes of names of licensors or
+    authors of the material; or
+
+    e) Declining to grant rights under trademark law for use of some
+    trade names, trademarks, or service marks; or
+
+    f) Requiring indemnification of licensors and authors of that
+    material by anyone who conveys the material (or modified versions of
+    it) with contractual assumptions of liability to the recipient, for
+    any liability that these contractual assumptions directly impose on
+    those licensors and authors.
+
+  All other non-permissive additional terms are considered "further
+restrictions" within the meaning of section 10.  If the Program as you
+received it, or any part of it, contains a notice stating that it is
+governed by this License along with a term that is a further
+restriction, you may remove that term.  If a license document contains
+a further restriction but permits relicensing or conveying under this
+License, you may add to a covered work material governed by the terms
+of that license document, provided that the further restriction does
+not survive such relicensing or conveying.
+
+  If you add terms to a covered work in accord with this section, you
+must place, in the relevant source files, a statement of the
+additional terms that apply to those files, or a notice indicating
+where to find the applicable terms.
+
+  Additional terms, permissive or non-permissive, may be stated in the
+form of a separately written license, or stated as exceptions;
+the above requirements apply either way.
+
+  8. Termination.
+
+  You may not propagate or modify a covered work except as expressly
+provided under this License.  Any attempt otherwise to propagate or
+modify it is void, and will automatically terminate your rights under
+this License (including any patent licenses granted under the third
+paragraph of section 11).
+
+  However, if you cease all violation of this License, then your
+license from a particular copyright holder is reinstated (a)
+provisionally, unless and until the copyright holder explicitly and
+finally terminates your license, and (b) permanently, if the copyright
+holder fails to notify you of the violation by some reasonable means
+prior to 60 days after the cessation.
+
+  Moreover, your license from a particular copyright holder is
+reinstated permanently if the copyright holder notifies you of the
+violation by some reasonable means, this is the first time you have
+received notice of violation of this License (for any work) from that
+copyright holder, and you cure the violation prior to 30 days after
+your receipt of the notice.
+
+  Termination of your rights under this section does not terminate the
+licenses of parties who have received copies or rights from you under
+this License.  If your rights have been terminated and not permanently
+reinstated, you do not qualify to receive new licenses for the same
+material under section 10.
+
+  9. Acceptance Not Required for Having Copies.
+
+  You are not required to accept this License in order to receive or
+run a copy of the Program.  Ancillary propagation of a covered work
+occurring solely as a consequence of using peer-to-peer transmission
+to receive a copy likewise does not require acceptance.  However,
+nothing other than this License grants you permission to propagate or
+modify any covered work.  These actions infringe copyright if you do
+not accept this License.  Therefore, by modifying or propagating a
+covered work, you indicate your acceptance of this License to do so.
+
+  10. Automatic Licensing of Downstream Recipients.
+
+  Each time you convey a covered work, the recipient automatically
+receives a license from the original licensors, to run, modify and
+propagate that work, subject to this License.  You are not responsible
+for enforcing compliance by third parties with this License.
+
+  An "entity transaction" is a transaction transferring control of an
+organization, or substantially all assets of one, or subdividing an
+organization, or merging organizations.  If propagation of a covered
+work results from an entity transaction, each party to that
+transaction who receives a copy of the work also receives whatever
+licenses to the work the party's predecessor in interest had or could
+give under the previous paragraph, plus a right to possession of the
+Corresponding Source of the work from the predecessor in interest, if
+the predecessor has it or can get it with reasonable efforts.
+
+  You may not impose any further restrictions on the exercise of the
+rights granted or affirmed under this License.  For example, you may
+not impose a license fee, royalty, or other charge for exercise of
+rights granted under this License, and you may not initiate litigation
+(including a cross-claim or counterclaim in a lawsuit) alleging that
+any patent claim is infringed by making, using, selling, offering for
+sale, or importing the Program or any portion of it.
+
+  11. Patents.
+
+  A "contributor" is a copyright holder who authorizes use under this
+License of the Program or a work on which the Program is based.  The
+work thus licensed is called the contributor's "contributor version".
+
+  A contributor's "essential patent claims" are all patent claims
+owned or controlled by the contributor, whether already acquired or
+hereafter acquired, that would be infringed by some manner, permitted
+by this License, of making, using, or selling its contributor version,
+but do not include claims that would be infringed only as a
+consequence of further modification of the contributor version.  For
+purposes of this definition, "control" includes the right to grant
+patent sublicenses in a manner consistent with the requirements of
+this License.
+
+  Each contributor grants you a non-exclusive, worldwide, royalty-free
+patent license under the contributor's essential patent claims, to
+make, use, sell, offer for sale, import and otherwise run, modify and
+propagate the contents of its contributor version.
+
+  In the following three paragraphs, a "patent license" is any express
+agreement or commitment, however denominated, not to enforce a patent
+(such as an express permission to practice a patent or covenant not to
+sue for patent infringement).  To "grant" such a patent license to a
+party means to make such an agreement or commitment not to enforce a
+patent against the party.
+
+  If you convey a covered work, knowingly relying on a patent license,
+and the Corresponding Source of the work is not available for anyone
+to copy, free of charge and under the terms of this License, through a
+publicly available network server or other readily accessible means,
+then you must either (1) cause the Corresponding Source to be so
+available, or (2) arrange to deprive yourself of the benefit of the
+patent license for this particular work, or (3) arrange, in a manner
+consistent with the requirements of this License, to extend the patent
+license to downstream recipients.  "Knowingly relying" means you have
+actual knowledge that, but for the patent license, your conveying the
+covered work in a country, or your recipient's use of the covered work
+in a country, would infringe one or more identifiable patents in that
+country that you have reason to believe are valid.
+  
+  If, pursuant to or in connection with a single transaction or
+arrangement, you convey, or propagate by procuring conveyance of, a
+covered work, and grant a patent license to some of the parties
+receiving the covered work authorizing them to use, propagate, modify
+or convey a specific copy of the covered work, then the patent license
+you grant is automatically extended to all recipients of the covered
+work and works based on it.
+
+  A patent license is "discriminatory" if it does not include within
+the scope of its coverage, prohibits the exercise of, or is
+conditioned on the non-exercise of one or more of the rights that are
+specifically granted under this License.  You may not convey a covered
+work if you are a party to an arrangement with a third party that is
+in the business of distributing software, under which you make payment
+to the third party based on the extent of your activity of conveying
+the work, and under which the third party grants, to any of the
+parties who would receive the covered work from you, a discriminatory
+patent license (a) in connection with copies of the covered work
+conveyed by you (or copies made from those copies), or (b) primarily
+for and in connection with specific products or compilations that
+contain the covered work, unless you entered into that arrangement,
+or that patent license was granted, prior to 28 March 2007.
+
+  Nothing in this License shall be construed as excluding or limiting
+any implied license or other defenses to infringement that may
+otherwise be available to you under applicable patent law.
+
+  12. No Surrender of Others' Freedom.
+
+  If conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot convey a
+covered work so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you may
+not convey it at all.  For example, if you agree to terms that obligate you
+to collect a royalty for further conveying from those to whom you convey
+the Program, the only way you could satisfy both those terms and this
+License would be to refrain entirely from conveying the Program.
+
+  13. Use with the GNU Affero General Public License.
+
+  Notwithstanding any other provision of this License, you have
+permission to link or combine any covered work with a work licensed
+under version 3 of the GNU Affero General Public License into a single
+combined work, and to convey the resulting work.  The terms of this
+License will continue to apply to the part which is the covered work,
+but the special requirements of the GNU Affero General Public License,
+section 13, concerning interaction through a network will apply to the
+combination as such.
+
+  14. Revised Versions of this License.
+
+  The Free Software Foundation may publish revised and/or new versions of
+the GNU General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+  Each version is given a distinguishing version number.  If the
+Program specifies that a certain numbered version of the GNU General
+Public License "or any later version" applies to it, you have the
+option of following the terms and conditions either of that numbered
+version or of any later version published by the Free Software
+Foundation.  If the Program does not specify a version number of the
+GNU General Public License, you may choose any version ever published
+by the Free Software Foundation.
+
+  If the Program specifies that a proxy can decide which future
+versions of the GNU General Public License can be used, that proxy's
+public statement of acceptance of a version permanently authorizes you
+to choose that version for the Program.
+
+  Later license versions may give you additional or different
+permissions.  However, no additional obligations are imposed on any
+author or copyright holder as a result of your choosing to follow a
+later version.
+
+  15. Disclaimer of Warranty.
+
+  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
+APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
+HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
+OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
+IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
+ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. Limitation of Liability.
+
+  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
+THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
+GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
+USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
+DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
+PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
+EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGES.
+
+  17. Interpretation of Sections 15 and 16.
+
+  If the disclaimer of warranty and limitation of liability provided
+above cannot be given local legal effect according to their terms,
+reviewing courts shall apply local law that most closely approximates
+an absolute waiver of all civil liability in connection with the
+Program, unless a warranty or assumption of liability accompanies a
+copy of the Program in return for a fee.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+state the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+Also add information on how to contact you by electronic and paper mail.
+
+  If the program does terminal interaction, make it output a short
+notice like this when it starts in an interactive mode:
+
+    <program>  Copyright (C) <year>  <name of author>
+    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, your program's commands
+might be different; for a GUI interface, you would use an "about box".
+
+  You should also get your employer (if you work as a programmer) or school,
+if any, to sign a "copyright disclaimer" for the program, if necessary.
+For more information on this, and how to apply and follow the GNU GPL, see
+<http://www.gnu.org/licenses/>.
+
+  The GNU General Public License does not permit incorporating your program
+into proprietary programs.  If your program is a subroutine library, you
+may consider it more useful to permit linking proprietary applications with
+the library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.  But first, please read
+<http://www.gnu.org/philosophy/why-not-lgpl.html>.
+
diff -uNr libnl_kk/src/disabled-nl-qdisc-add.c libnl/src/disabled-nl-qdisc-add.c
--- libnl_kk/src/disabled-nl-qdisc-add.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/disabled-nl-qdisc-add.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,196 @@
+/*
+ * src/nl-qdisc-dump.c     Dump qdisc attributes
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2006 Thomas Graf <tgraf@suug.ch>
+ */
+
+#include "utils.h"
+#include <netlink/route/sch/fifo.h>
+#include <netlink/route/sch/prio.h>
+
+static void print_usage(void)
+{
+	printf(
+"Usage: nl-qdisc-add <ifindex> <handle> <parent> <kind>\n");
+	exit(1);
+}
+
+static int parse_blackhole_opts(struct rtnl_qdisc *qdisc, char *argv[],
+				int argc)
+{
+	return 0;
+}
+
+static int parse_pfifo_opts(struct rtnl_qdisc *qdisc, char *argv[], int argc)
+{
+	int err, limit;
+
+	if (argc > 0) {
+		if (argc != 2 || strcasecmp(argv[0], "limit")) {
+			fprintf(stderr, "Usage: ... pfifo limit <limit>\n");
+			return -1;
+		}
+
+		limit = strtoul(argv[1], NULL, 0);
+		err = rtnl_qdisc_fifo_set_limit(qdisc, limit);
+		if (err < 0) {
+			fprintf(stderr, "%s\n", nl_geterror());
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+static int parse_bfifo_opts(struct rtnl_qdisc *qdisc, char *argv[], int argc)
+{
+	int err, limit;
+
+	if (argc > 0) {
+		if (argc != 2 || strcasecmp(argv[0], "limit")) {
+			fprintf(stderr, "Usage: ... bfifo limit <limit>\n");
+			return -1;
+		}
+
+		limit = nl_size2int(argv[1]);
+		if (limit < 0) {
+			fprintf(stderr, "Invalid value for limit.\n");
+			return -1;
+		}
+
+		err = rtnl_qdisc_fifo_set_limit(qdisc, limit);
+		if (err < 0) {
+			fprintf(stderr, "%s\n", nl_geterror());
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+static int parse_prio_opts(struct rtnl_qdisc *qdisc, char *argv[], int argc)
+{
+	int i, err, bands;
+	uint8_t map[] = QDISC_PRIO_DEFAULT_PRIOMAP;
+
+	if (argc > 0) {
+		if (argc < 2 || strcasecmp(argv[0], "bands"))
+			goto usage;
+
+		bands = strtoul(argv[1], NULL, 0);
+		err = rtnl_qdisc_prio_set_bands(qdisc, bands);
+		if (err < 0) {
+			fprintf(stderr, "%s\n", nl_geterror());
+			return -1;
+		}
+	}
+
+	if (argc > 2) {
+		if (argc < 5 || strcasecmp(argv[2], "map"))
+			goto usage;
+
+		for (i = 3; i < (argc & ~1U); i += 2) {
+			int prio, band;
+
+			prio = rtnl_str2prio(argv[i]);
+			if (prio < 0 || prio > sizeof(map)/sizeof(map[0])) {
+				fprintf(stderr, "Invalid priority \"%s\"\n",
+					argv[i]);
+				return -1;
+			}
+
+			band = strtoul(argv[i+1], NULL, 0);
+
+			map[prio] = band;
+		}
+	}
+
+	err = rtnl_qdisc_prio_set_priomap(qdisc, map, sizeof(map));
+	if (err < 0) {
+		fprintf(stderr, "%s\n", nl_geterror());
+		return -1;
+	}
+
+	return 0;
+usage:
+	fprintf(stderr, "Usage: ... prio bands <nbands> map MAP\n"
+			"MAP := <prio> <band>\n");
+	return -1;
+}
+
+int main(int argc, char *argv[])
+{
+	struct nl_sock *nlh;
+	struct rtnl_qdisc *qdisc;
+	uint32_t handle, parent;
+	int err = 1;
+
+	if (nltool_init(argc, argv) < 0)
+		return -1;
+
+	if (argc < 5 || !strcmp(argv[1], "-h"))
+		print_usage();
+
+	nlh = nltool_alloc_handle();
+	if (!nlh)
+		goto errout;
+
+	qdisc = rtnl_qdisc_alloc();
+	if (!qdisc)
+		goto errout_free_handle;
+
+	rtnl_qdisc_set_ifindex(qdisc, strtoul(argv[1], NULL, 0));
+
+	if (rtnl_tc_str2handle(argv[2], &handle) < 0) {
+		fprintf(stderr, "%s\n", nl_geterror());
+		goto errout_free_qdisc;
+	}
+
+	if (rtnl_tc_str2handle(argv[3], &parent) < 0) {
+		fprintf(stderr, "%s\n", nl_geterror());
+		goto errout_free_qdisc;
+	}
+
+	rtnl_qdisc_set_handle(qdisc, handle);
+	rtnl_qdisc_set_parent(qdisc, parent);
+	rtnl_qdisc_set_kind(qdisc, argv[4]);
+
+	if (!strcasecmp(argv[4], "blackhole"))
+		err = parse_blackhole_opts(qdisc, &argv[5], argc-5);
+	else if (!strcasecmp(argv[4], "pfifo"))
+		err = parse_pfifo_opts(qdisc, &argv[5], argc-5);
+	else if (!strcasecmp(argv[4], "bfifo"))
+		err = parse_bfifo_opts(qdisc, &argv[5], argc-5);
+	else if (!strcasecmp(argv[4], "prio"))
+		err = parse_prio_opts(qdisc, &argv[5], argc-5);
+	else {
+		fprintf(stderr, "Unknown qdisc \"%s\"\n", argv[4]);
+		goto errout_free_qdisc;
+	}
+
+	if (err < 0)
+		goto errout_free_qdisc;
+
+	if (nltool_connect(nlh, NETLINK_ROUTE) < 0)
+		goto errout_free_qdisc;
+
+	if (rtnl_qdisc_add(nlh, qdisc, NLM_F_REPLACE) < 0) {
+		fprintf(stderr, "Unable to add Qdisc: %s\n", nl_geterror());
+		goto errout_close;
+	}
+
+	err = 0;
+errout_close:
+	nl_close(nlh);
+errout_free_qdisc:
+	rtnl_qdisc_put(qdisc);
+errout_free_handle:
+	nl_handle_destroy(nlh);
+errout:
+	return err;
+}
diff -uNr libnl_kk/src/genl-ctrl-list.c libnl/src/genl-ctrl-list.c
--- libnl_kk/src/genl-ctrl-list.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/genl-ctrl-list.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,69 @@
+/*
+ * src/genl-ctrl-list.c	List Generic Netlink Controller
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#include <netlink/cli/utils.h>
+
+static struct nl_cache *alloc_genl_family_cache(struct nl_sock *sk)
+{
+	return nl_cli_alloc_cache(sk, "generic netlink family",
+			   genl_ctrl_alloc_cache);
+}
+
+static void print_usage(void)
+{
+	printf(
+	"Usage: genl-ctrl-list [OPTION]...\n"
+	"\n"
+	"Options\n"
+	" -f, --format=TYPE     Output format { brief | details | stats }\n"
+	" -h, --help            Show this help\n"
+	" -v, --version         Show versioning information\n"
+	);
+	exit(0);
+}
+
+int main(int argc, char *argv[])
+{
+	struct nl_sock *sock;
+	struct nl_cache *family_cache;
+	struct nl_dump_params params = {
+		.dp_type = NL_DUMP_LINE,
+		.dp_fd = stdout,
+	};
+ 
+	sock = nl_cli_alloc_socket();
+	nl_cli_connect(sock, NETLINK_GENERIC);
+	family_cache = alloc_genl_family_cache(sock);
+ 
+	for (;;) {
+		int c, optidx = 0;
+		static struct option long_opts[] = {
+			{ "format", 1, 0, 'f' },
+			{ "help", 0, 0, 'h' },
+			{ "version", 0, 0, 'v' },
+			{ 0, 0, 0, 0 }
+		};
+	
+		c = getopt_long(argc, argv, "f:hv", long_opts, &optidx);
+		if (c == -1)
+			break;
+
+		switch (c) {
+		case 'f': params.dp_type = nl_cli_parse_dumptype(optarg); break;
+		case 'h': print_usage(); break;
+		case 'v': nl_cli_print_version(); break;
+		}
+ 	}
+
+	nl_cache_dump(family_cache, &params);
+
+	return 0;
+}
diff -uNr libnl_kk/src/.gitignore libnl/src/.gitignore
--- libnl_kk/src/.gitignore	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/.gitignore	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,31 @@
+genl-ctrl-list
+nf-ct-list
+nf-log
+nf-monitor
+nl-addr-add
+nl-addr-delete
+nl-addr-list
+nl-fib-lookup
+nl-link-list
+nl-link-ifindex2name
+nl-link-name2ifindex
+nl-link-set
+nl-link-stats
+nl-list-caches
+nl-list-sockets
+nl-monitor
+nl-neigh-add
+nl-neigh-delete
+nl-neigh-list
+nl-neightbl-list
+nl-qdisc-add
+nl-qdisc-delete
+nl-qdisc-list
+nl-route-add
+nl-route-delete
+nl-route-list
+nl-route-get
+nl-rule-list
+nl-tctree-list
+nl-util-addr
+nf-queue
diff -uNr libnl_kk/src/lib/addr.c libnl/src/lib/addr.c
--- libnl_kk/src/lib/addr.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/lib/addr.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,135 @@
+/*
+ * src/lib/addr.c     Address Helpers
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2008-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup cli
+ * @defgroup cli_addr Addresses
+ *
+ * @{
+ */
+
+#include <netlink/cli/utils.h>
+#include <netlink/cli/addr.h>
+
+struct rtnl_addr *nl_cli_addr_alloc(void)
+{
+	struct rtnl_addr *addr;
+
+	addr = rtnl_addr_alloc();
+	if (!addr)
+		nl_cli_fatal(ENOMEM, "Unable to allocate address object");
+
+	return addr;
+}
+
+void nl_cli_addr_parse_family(struct rtnl_addr *addr, char *arg)
+{
+	int family;
+
+	if ((family = nl_str2af(arg)) != AF_UNSPEC)
+		rtnl_addr_set_family(addr, family);
+}
+
+void nl_cli_addr_parse_local(struct rtnl_addr *addr, char *arg)
+{
+	struct nl_addr *a;
+	int err;
+
+	a = nl_cli_addr_parse(arg, rtnl_addr_get_family(addr));
+	if ((err = rtnl_addr_set_local(addr, a)) < 0)
+		nl_cli_fatal(err, "Unable to set local address: %s",
+			     nl_geterror(err));
+
+	nl_addr_put(a);
+}
+
+void nl_cli_addr_parse_dev(struct rtnl_addr *addr, struct nl_cache *link_cache,
+			   char *arg)
+{
+	int ival;
+
+	if (!(ival = rtnl_link_name2i(link_cache, arg)))
+		nl_cli_fatal(ENOENT, "Link \"%s\" does not exist", arg);
+
+	rtnl_addr_set_ifindex(addr, ival);
+}
+
+void nl_cli_addr_parse_label(struct rtnl_addr *addr, char *arg)
+{
+	int err;
+
+	if ((err = rtnl_addr_set_label(addr, arg)) < 0)
+		nl_cli_fatal(err, "Unable to set address label: %s",
+			     nl_geterror(err));
+}
+
+void nl_cli_addr_parse_peer(struct rtnl_addr *addr, char *arg)
+{
+	struct nl_addr *a;
+	int err;
+
+	a = nl_cli_addr_parse(arg, rtnl_addr_get_family(addr));
+	if ((err = rtnl_addr_set_peer(addr, a)) < 0)
+		nl_cli_fatal(err, "Unable to set peer address: %s",
+			     nl_geterror(err));
+
+	nl_addr_put(a);
+}
+
+void nl_cli_addr_parse_scope(struct rtnl_addr *addr, char *arg)
+{
+	int ival;
+
+	if ((ival = rtnl_str2scope(arg)) < 0)
+		nl_cli_fatal(EINVAL, "Unknown address scope \"%s\"", arg);
+
+	rtnl_addr_set_scope(addr, ival);
+}
+
+void nl_cli_addr_parse_broadcast(struct rtnl_addr *addr, char *arg)
+{
+	struct nl_addr *a;
+	int err;
+
+	a = nl_cli_addr_parse(arg, rtnl_addr_get_family(addr));
+	if ((err = rtnl_addr_set_broadcast(addr, a)) < 0)
+		nl_cli_fatal(err, "Unable to set broadcast address: %s",
+			     nl_geterror(err));
+
+	nl_addr_put(a);
+}
+
+static uint32_t parse_lifetime(const char *arg)
+{
+	uint64_t msecs;
+	int err;
+
+	if (!strcasecmp(arg, "forever"))
+		return 0xFFFFFFFFU;
+
+	if ((err = nl_str2msec(arg, &msecs)) < 0)
+		nl_cli_fatal(err, "Unable to parse time string \"%s\": %s",
+			     arg, nl_geterror(err));
+
+	return (msecs / 1000);
+}
+
+void nl_cli_addr_parse_preferred(struct rtnl_addr *addr, char *arg)
+{
+	rtnl_addr_set_preferred_lifetime(addr, parse_lifetime(arg));
+}
+
+void nl_cli_addr_parse_valid(struct rtnl_addr *addr, char *arg)
+{
+	rtnl_addr_set_valid_lifetime(addr, parse_lifetime(arg));
+}
+
+/** @} */
diff -uNr libnl_kk/src/lib/ct.c libnl/src/lib/ct.c
--- libnl_kk/src/lib/ct.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/lib/ct.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,162 @@
+/*
+ * src/lib/ct.c		CLI Conntrack Helpers
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2008-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup cli
+ * @defgroup cli_ct Connection Tracking
+ *
+ * @{
+ */
+
+#include <netlink/cli/utils.h>
+#include <netlink/cli/ct.h>
+
+struct nfnl_ct *nl_cli_ct_alloc(void)
+{
+	struct nfnl_ct *ct;
+
+	ct = nfnl_ct_alloc();
+	if (!ct)
+		nl_cli_fatal(ENOMEM, "Unable to allocate conntrack object");
+
+	return ct;
+}
+
+struct nl_cache *nl_cli_ct_alloc_cache(struct nl_sock *sk)
+{
+	return nl_cli_alloc_cache(sk, "conntrack", nfnl_ct_alloc_cache);
+}
+
+void nl_cli_ct_parse_family(struct nfnl_ct *ct, char *arg)
+{
+	int family;
+
+	if ((family = nl_str2af(arg)) == AF_UNSPEC)
+		nl_cli_fatal(EINVAL,
+			     "Unable to nl_cli_ct_parse family \"%s\": %s",
+			     arg, nl_geterror(NLE_INVAL));
+
+	nfnl_ct_set_family(ct, family);
+}
+
+void nl_cli_ct_parse_protocol(struct nfnl_ct *ct, char *arg)
+{
+	int proto;
+
+	if ((proto = nl_str2ip_proto(arg)) < 0)
+		nl_cli_fatal(proto,
+			     "Unable to nl_cli_ct_parse protocol \"%s\": %s",
+			     arg, nl_geterror(proto));
+
+	nfnl_ct_set_proto(ct, proto);
+}
+
+void nl_cli_ct_parse_mark(struct nfnl_ct *ct, char *arg)
+{
+	uint32_t mark = nl_cli_parse_u32(arg);
+	nfnl_ct_set_mark(ct, mark);
+}
+
+void nl_cli_ct_parse_timeout(struct nfnl_ct *ct, char *arg)
+{
+	uint32_t timeout = nl_cli_parse_u32(arg);
+	nfnl_ct_set_timeout(ct, timeout);
+}
+
+void nl_cli_ct_parse_id(struct nfnl_ct *ct, char *arg)
+{
+	uint32_t id = nl_cli_parse_u32(arg);
+	nfnl_ct_set_id(ct, id);
+}
+
+void nl_cli_ct_parse_use(struct nfnl_ct *ct, char *arg)
+{
+	uint32_t use = nl_cli_parse_u32(arg);
+	nfnl_ct_set_use(ct, use);
+}
+
+void nl_cli_ct_parse_src(struct nfnl_ct *ct, int reply, char *arg)
+{
+	int err;
+	struct nl_addr *a = nl_cli_addr_parse(arg, nfnl_ct_get_family(ct));
+	if ((err = nfnl_ct_set_src(ct, reply, a)) < 0)
+		nl_cli_fatal(err, "Unable to set source address: %s",
+			     nl_geterror(err));
+}
+
+void nl_cli_ct_parse_dst(struct nfnl_ct *ct, int reply, char *arg)
+{
+	int err;
+	struct nl_addr *a = nl_cli_addr_parse(arg, nfnl_ct_get_family(ct));
+	if ((err = nfnl_ct_set_dst(ct, reply, a)) < 0)
+		nl_cli_fatal(err, "Unable to set destination address: %s",
+			     nl_geterror(err));
+}
+
+void nl_cli_ct_parse_src_port(struct nfnl_ct *ct, int reply, char *arg)
+{
+	uint32_t port = nl_cli_parse_u32(arg);
+	nfnl_ct_set_src_port(ct, reply, port);
+}
+
+void nl_cli_ct_parse_dst_port(struct nfnl_ct *ct, int reply, char *arg)
+{
+	uint32_t port = nl_cli_parse_u32(arg);
+	nfnl_ct_set_dst_port(ct, reply, port);
+}
+
+void nl_cli_ct_parse_tcp_state(struct nfnl_ct *ct, char *arg)
+{
+	int state;
+
+	if ((state = nfnl_ct_str2tcp_state(arg)) < 0)
+		nl_cli_fatal(state,
+			     "Unable to nl_cli_ct_parse tcp state \"%s\": %s",
+			     arg, nl_geterror(state));
+
+	nfnl_ct_set_tcp_state(ct, state);
+}
+
+void nl_cli_ct_parse_status(struct nfnl_ct *ct, char *arg)
+{
+	int status;
+
+	if ((status = nfnl_ct_str2status(arg)) < 0)
+		nl_cli_fatal(status,
+			     "Unable to nl_cli_ct_parse flags \"%s\": %s",
+			     arg, nl_geterror(status));
+
+	nfnl_ct_set_status(ct, status);
+}
+
+#if 0
+		} else if (arg_match("origicmpid")) {
+			if (argc > ++idx)
+				nfnl_ct_set_icmp_id(ct, 0, strtoul(argv[idx++], NULL, 0));
+		} else if (arg_match("origicmptype")) {
+			if (argc > ++idx)
+				nfnl_ct_set_icmp_type(ct, 0, strtoul(argv[idx++], NULL, 0));
+		} else if (arg_match("origicmpcode")) {
+			if (argc > ++idx)
+				nfnl_ct_set_icmp_code(ct, 0, strtoul(argv[idx++], NULL, 0));
+		} else if (arg_match("replyicmpid")) {
+			if (argc > ++idx)
+				nfnl_ct_set_icmp_id(ct, 1, strtoul(argv[idx++], NULL, 0));
+		} else if (arg_match("replyicmptype")) {
+			if (argc > ++idx)
+				nfnl_ct_set_icmp_type(ct, 1, strtoul(argv[idx++], NULL, 0));
+		} else if (arg_match("replyicmpcode")) {
+			if (argc > ++idx)
+				nfnl_ct_set_icmp_code(ct, 1, strtoul(argv[idx++], NULL, 0));
+		}
+#endif
+
+/** @} */
diff -uNr libnl_kk/src/lib/link.c libnl/src/lib/link.c
--- libnl_kk/src/lib/link.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/lib/link.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,73 @@
+/*
+ * src/lib/link.c     CLI Link Helpers
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2008-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup cli
+ * @defgroup cli_link Links
+ *
+ * @{
+ */
+
+#include <netlink/cli/utils.h>
+#include <netlink/cli/link.h>
+
+struct rtnl_link *nl_cli_link_alloc(void)
+{
+	struct rtnl_link *link;
+
+	link = rtnl_link_alloc();
+	if (!link)
+		nl_cli_fatal(ENOMEM, "Unable to allocate link object");
+
+	return link;
+}
+
+void nl_cli_link_parse_family(struct rtnl_link *link, char *arg)
+{
+	int family;
+
+	if ((family = nl_str2af(arg)) == AF_UNSPEC)
+		nl_cli_fatal(EINVAL,
+			     "Unable to translate address family \"%s\"", arg);
+
+	rtnl_link_set_family(link, family);
+}
+
+void nl_cli_link_parse_name(struct rtnl_link *link, char *arg)
+{
+	rtnl_link_set_name(link, arg);
+}
+
+void nl_cli_link_parse_mtu(struct rtnl_link *link, char *arg)
+{
+	uint32_t mtu = nl_cli_parse_u32(arg);
+	rtnl_link_set_mtu(link, mtu);
+}
+
+void nl_cli_link_parse_ifindex(struct rtnl_link *link, char *arg)
+{
+	uint32_t index = nl_cli_parse_u32(arg);
+	rtnl_link_set_ifindex(link, index);
+}
+
+void nl_cli_link_parse_txqlen(struct rtnl_link *link, char *arg)
+{
+	uint32_t qlen = nl_cli_parse_u32(arg);
+	rtnl_link_set_txqlen(link, qlen);
+}
+
+void nl_cli_link_parse_weight(struct rtnl_link *link, char *arg)
+{
+	uint32_t weight = nl_cli_parse_u32(arg);
+	rtnl_link_set_weight(link, weight);
+}
+
+/** @} */
diff -uNr libnl_kk/src/lib/Makefile.am libnl/src/lib/Makefile.am
--- libnl_kk/src/lib/Makefile.am	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/lib/Makefile.am	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,41 @@
+# -*- Makefile -*-
+
+AM_CPPFLAGS  = -Wall -I${top_srcdir}/include -I${top_builddir}/include -D_GNU_SOURCE -DPKGLIBDIR=\"$(pkglibdir)\" -DSYSCONFDIR=\"$(sysconfdir)\" -rdynamic
+AM_LDFLAGS = -L${top_builddir}/lib -ldl
+
+#nobase_pkglib_LTLIBRARIES = cls/basic.la cls/ematch/cmp.la
+#cls_basic_la_LDFLAGS = -module -version-info 2:0:0
+#cls_ematch_cmp_la_LDFLAGS = -module -version-info 2:0:0
+
+#cls/ematch_grammar.c: cls/ematch_grammar.l
+#	$(LEX) --header-file=cls/ematch_grammar.h $(LFLAGS) -o $@ $^
+
+#cls/ematch_syntax.c: cls/ematch_syntax.y
+#	$(YACC) -d $(YFLAGS) -o $@ $^
+
+#cls/pktloc_grammar.c: cls/pktloc_grammar.l
+#	$(LEX) --header-file=cls/pktloc_grammar.h $(LFLAGS) -o $@ $^
+
+#cls/pktloc_syntax.c: cls/pktloc_syntax.y
+#	$(YACC) -d $(YFLAGS) -o $@ $^
+
+#CLEANFILES = \
+#	cls/ematch_grammar.c cls/ematch_grammar.h \
+#	cls/ematch_syntax.c cls/ematch_syntax.h \
+#	cls/pktloc_grammar.c cls/pktloc_grammar.h \
+#	cls/pktloc_syntax.c cls/pktloc_syntax.h
+
+lib_LTLIBRARIES = \
+	libnl-cli.la
+
+libnl_cli_la_LDFLAGS = -version-info 2:0:0
+
+libnl_cli_la_LIBADD  = ${top_builddir}/lib/libnl.la \
+		       ${top_builddir}/lib/libnl-route.la \
+		       ${top_builddir}/lib/libnl-nf.la \
+		       ${top_builddir}/lib/libnl-genl.la
+
+libnl_cli_la_SOURCES = \
+	utils.c addr.c ct.c link.c neigh.c qdisc.c rule.c route.c
+#	cls/ematch_syntax.c cls/ematch_grammar.c cls/ematch.c
+#	cls/pktloc_syntax.c cls/pktloc_grammar.c cls/utils.c
diff -uNr libnl_kk/src/lib/neigh.c libnl/src/lib/neigh.c
--- libnl_kk/src/lib/neigh.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/lib/neigh.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,88 @@
+/*
+ * src/lib/neigh.c     CLI Neighbour Helpers
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2008-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup cli
+ * @defgroup cli_neigh Neighbour
+ *
+ * @{
+ */
+
+#include <netlink/cli/utils.h>
+#include <netlink/cli/neigh.h>
+
+struct rtnl_neigh *nl_cli_neigh_alloc(void)
+{
+	struct rtnl_neigh *neigh;
+
+	neigh = rtnl_neigh_alloc();
+	if (!neigh)
+		nl_cli_fatal(ENOMEM, "Unable to allocate neighbout object");
+
+	return neigh;
+}
+
+void nl_cli_neigh_parse_dst(struct rtnl_neigh *neigh, char *arg)
+{
+	struct nl_addr *a;
+	int err;
+
+	a = nl_cli_addr_parse(arg, rtnl_neigh_get_family(neigh));
+	if ((err = rtnl_neigh_set_dst(neigh, a)) < 0)
+		nl_cli_fatal(err, "Unable to set local address: %s",
+			nl_geterror(err));
+
+	nl_addr_put(a);
+}
+
+void nl_cli_neigh_parse_lladdr(struct rtnl_neigh *neigh, char *arg)
+{
+	struct nl_addr *a;
+
+	a = nl_cli_addr_parse(arg, AF_UNSPEC);
+	rtnl_neigh_set_lladdr(neigh, a);
+	nl_addr_put(a);
+}
+
+void nl_cli_neigh_parse_dev(struct rtnl_neigh *neigh,
+			    struct nl_cache *link_cache, char *arg)
+{
+	int ival;
+
+	if (!(ival = rtnl_link_name2i(link_cache, arg)))
+		nl_cli_fatal(ENOENT, "Link \"%s\" does not exist", arg);
+
+	rtnl_neigh_set_ifindex(neigh, ival);
+}
+
+void nl_cli_neigh_parse_family(struct rtnl_neigh *neigh, char *arg)
+{
+	int family;
+
+	if ((family = nl_str2af(arg)) == AF_UNSPEC)
+		nl_cli_fatal(EINVAL,
+			     "Unable to translate address family \"%s\"", arg);
+
+	rtnl_neigh_set_family(neigh, family);
+}
+
+void nl_cli_neigh_parse_state(struct rtnl_neigh *neigh, char *arg)
+{
+	int state;
+	
+	if ((state = rtnl_neigh_str2state(arg)) < 0)
+		nl_cli_fatal(state, "Unable to translate state \"%s\": %s",
+			arg, state);
+
+	rtnl_neigh_set_state(neigh, state);
+}
+
+/** @} */
diff -uNr libnl_kk/src/lib/qdisc.c libnl/src/lib/qdisc.c
--- libnl_kk/src/lib/qdisc.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/lib/qdisc.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,72 @@
+/*
+ * src/lib/qdisc.c     CLI QDisc Helpers
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2008-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup cli
+ * @defgroup cli_qdisc Queueing Disciplines
+ *
+ * @{
+ */
+
+#include <netlink/cli/utils.h>
+#include <netlink/cli/qdisc.h>
+
+struct rtnl_qdisc *nl_cli_qdisc_alloc(void)
+{
+	struct rtnl_qdisc *qdisc;
+
+	qdisc = rtnl_qdisc_alloc();
+	if (!qdisc)
+		nl_cli_fatal(ENOMEM, "Unable to allocate qdisc object");
+
+	return qdisc;
+}
+
+void nl_cli_qdisc_parse_dev(struct rtnl_qdisc *qdisc, struct nl_cache *link_cache, char *arg)
+{
+	int ival;
+
+	if (!(ival = rtnl_link_name2i(link_cache, arg)))
+		nl_cli_fatal(ENOENT, "Link \"%s\" does not exist", arg);
+
+	rtnl_qdisc_set_ifindex(qdisc, ival);
+}
+
+void nl_cli_qdisc_parse_parent(struct rtnl_qdisc *qdisc, char *arg)
+{
+	uint32_t parent;
+	int err;
+
+	if ((err = rtnl_tc_str2handle(arg, &parent)) < 0)
+		nl_cli_fatal(err, "Unable to parse handle \"%s\": %s",
+		      arg, nl_geterror(err));
+
+	rtnl_qdisc_set_parent(qdisc, parent);
+}
+
+void nl_cli_qdisc_parse_handle(struct rtnl_qdisc *qdisc, char *arg)
+{
+	uint32_t handle;
+	int err;
+
+	if ((err = rtnl_tc_str2handle(arg, &handle)) < 0)
+		nl_cli_fatal(err, "Unable to parse handle \"%s\": %s",
+		      arg, nl_geterror(err));
+
+	rtnl_qdisc_set_handle(qdisc, handle);
+}
+
+void nl_cli_qdisc_parse_kind(struct rtnl_qdisc *qdisc, char *arg)
+{
+	rtnl_qdisc_set_kind(qdisc, arg);
+}
+
+/** @} */
diff -uNr libnl_kk/src/lib/route.c libnl/src/lib/route.c
--- libnl_kk/src/lib/route.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/lib/route.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,270 @@
+/*
+ * src/lib/route.c     CLI Route Helpers
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2008-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup cli
+ * @defgroup cli_route Routing
+ *
+ * @{
+ */
+
+#include <netlink/cli/utils.h>
+#include <netlink/cli/route.h>
+
+struct rtnl_route *nl_cli_route_alloc(void)
+{
+	struct rtnl_route *route;
+
+	route = rtnl_route_alloc();
+	if (!route)
+		nl_cli_fatal(ENOMEM, "Unable to allocate route object");
+
+	return route;
+}
+
+struct nl_cache *nl_cli_route_alloc_cache(struct nl_sock *sk, int flags)
+{
+	struct nl_cache *cache;
+	int err;
+
+	if ((err = rtnl_route_alloc_cache(sk, AF_UNSPEC, flags, &cache)) < 0)
+		nl_cli_fatal(err, "Unable to allocate route cache: %s\n",
+			     nl_geterror(err));
+
+	nl_cache_mngt_provide(cache);
+
+	return cache;
+}
+
+void nl_cli_route_parse_family(struct rtnl_route *route, char *arg)
+{
+	int family;
+
+	if ((family = nl_str2af(arg)) != AF_UNSPEC)
+		rtnl_route_set_family(route, family);
+}
+
+void nl_cli_route_parse_dst(struct rtnl_route *route, char *arg)
+{
+	struct nl_addr *addr;
+	int err;
+
+	addr = nl_cli_addr_parse(arg, rtnl_route_get_family(route));
+	if ((err = rtnl_route_set_dst(route, addr)) < 0)
+		nl_cli_fatal(err, "Unable to set destination address: %s",
+		      nl_geterror(err));
+
+	nl_addr_put(addr);
+}
+
+void nl_cli_route_parse_src(struct rtnl_route *route, char *arg)
+{
+	struct nl_addr *addr;
+	int err;
+
+	addr = nl_cli_addr_parse(arg, rtnl_route_get_family(route));
+	if ((err = rtnl_route_set_src(route, addr)) < 0)
+		nl_cli_fatal(err, "Unable to set source address: %s",
+		      nl_geterror(err));
+
+	nl_addr_put(addr);
+}
+
+void nl_cli_route_parse_pref_src(struct rtnl_route *route, char *arg)
+{
+	struct nl_addr *addr;
+	int err;
+
+	addr = nl_cli_addr_parse(arg, rtnl_route_get_family(route));
+	if ((err = rtnl_route_set_pref_src(route, addr)) < 0)
+		nl_cli_fatal(err, "Unable to set preferred source address: %s",
+		      nl_geterror(err));
+
+	nl_addr_put(addr);
+}
+
+void nl_cli_route_parse_metric(struct rtnl_route *route, char *subopts)
+{
+	/* strict equal order to RTAX_* */
+	static char *const tokens[] = {
+		"unspec",
+		"lock",
+		"mtu",
+		"window",
+		"rtt",
+		"rttvar",
+		"sstresh",
+		"cwnd",
+		"advmss",
+		"reordering",
+		"hoplimit",
+		"initcwnd",
+		"features",
+		NULL,
+	};
+	unsigned long lval;
+	char *arg, *endptr;
+
+	while (*subopts != '\0') {
+		int ret = getsubopt(&subopts, tokens, &arg);
+		if (ret == -1)
+			nl_cli_fatal(EINVAL, "Unknown metric token \"%s\"", arg);
+
+		if (ret == 0)
+			nl_cli_fatal(EINVAL, "Invalid metric \"%s\"", tokens[ret]);
+
+		if (arg == NULL)
+			nl_cli_fatal(EINVAL, "Metric \"%s\", no value given", tokens[ret]);
+
+		lval = strtoul(arg, &endptr, 0);
+		if (endptr == arg)
+			nl_cli_fatal(EINVAL, "Metric \"%s\", value not numeric", tokens[ret]);
+
+		if ((ret = rtnl_route_set_metric(route, ret, lval)) < 0)
+			nl_cli_fatal(ret, "Unable to set metric: %s",
+			      nl_geterror(ret));
+	}
+}
+
+void nl_cli_route_parse_nexthop(struct rtnl_route *route, char *subopts,
+		   struct nl_cache *link_cache)
+{
+	enum {
+		NH_DEV,
+		NH_VIA,
+		NH_WEIGHT,
+	};
+	static char *const tokens[] = {
+		"dev",
+		"via",
+		"weight",
+		NULL,
+	};
+	struct rtnl_nexthop *nh;
+	unsigned long lval;
+	struct nl_addr *addr;
+	int ival;
+	char *arg, *endptr;
+
+	if (!(nh = rtnl_route_nh_alloc()))
+		nl_cli_fatal(ENOMEM, "Out of memory");
+
+	while (*subopts != '\0') {
+		int ret = getsubopt(&subopts, tokens, &arg);
+		if (ret == -1)
+			nl_cli_fatal(EINVAL, "Unknown nexthop token \"%s\"", arg);
+
+		if (arg == NULL)
+			nl_cli_fatal(EINVAL, "Missing argument to option \"%s\"\n",
+				tokens[ret]);
+
+		switch (ret) {
+		case NH_DEV:
+			if (!(ival = rtnl_link_name2i(link_cache, arg)))
+				nl_cli_fatal(ENOENT,"Link \"%s\" does not exist", arg);
+
+			rtnl_route_nh_set_ifindex(nh, ival);
+			break;
+
+		case NH_VIA:
+			addr = nl_cli_addr_parse(arg,rtnl_route_get_family(route));
+			rtnl_route_nh_set_gateway(nh, addr);
+			nl_addr_put(addr);
+			break;
+
+		case NH_WEIGHT:
+			lval = strtoul(arg, &endptr, 0);
+			if (endptr == arg)
+				nl_cli_fatal(EINVAL,
+					     "Invalid weight \"%s\", not numeric",
+					     arg);
+			rtnl_route_nh_set_weight(nh, lval);
+			break;
+		}
+	}
+
+	rtnl_route_add_nexthop(route, nh);
+}
+
+void nl_cli_route_parse_table(struct rtnl_route *route, char *arg)
+{
+	unsigned long lval;
+	char *endptr;
+
+	lval = strtoul(arg, &endptr, 0);
+	if (endptr == arg) {
+		if ((lval = rtnl_route_str2table(arg)) < 0)
+			nl_cli_fatal(EINVAL, "Unknown table name \"%s\"", arg);
+	}
+
+	rtnl_route_set_table(route, lval);
+}
+
+void nl_cli_route_parse_prio(struct rtnl_route *route, char *arg)
+{
+	unsigned long lval;
+	char *endptr;
+
+	lval = strtoul(arg, &endptr, 0);
+	if (endptr == arg)
+		nl_cli_fatal(EINVAL, "Invalid priority value, not numeric");
+	rtnl_route_set_priority(route, lval);
+}
+
+void nl_cli_route_parse_scope(struct rtnl_route *route, char *arg)
+{
+	int ival;
+
+	if ((ival = rtnl_str2scope(arg)) < 0)
+		nl_cli_fatal(EINVAL, "Unknown routing scope \"%s\"", arg);
+
+	rtnl_route_set_scope(route, ival);
+}
+
+void nl_cli_route_parse_protocol(struct rtnl_route *route, char *arg)
+{
+	unsigned long lval;
+	char *endptr;
+
+	lval = strtoul(arg, &endptr, 0);
+	if (endptr == arg) {
+		if ((lval = rtnl_route_str2proto(arg)) < 0)
+			nl_cli_fatal(EINVAL,
+				     "Unknown routing protocol name \"%s\"",
+				     arg);
+	}
+
+	rtnl_route_set_protocol(route, lval);
+}
+
+void nl_cli_route_parse_type(struct rtnl_route *route, char *arg)
+{
+	int ival;
+
+	if ((ival = nl_str2rtntype(arg)) < 0)
+		nl_cli_fatal(EINVAL, "Unknown routing type \"%s\"", arg);
+
+	if ((ival = rtnl_route_set_type(route, ival)) < 0)
+		nl_cli_fatal(ival, "Unable to set routing type: %s",
+		      nl_geterror(ival));
+}
+
+void nl_cli_route_parse_iif(struct rtnl_route *route, char *arg, struct nl_cache *link_cache)
+{
+	int ival;
+
+	if (!(ival = rtnl_link_name2i(link_cache, arg)))
+		nl_cli_fatal(ENOENT, "Link \"%s\" does not exist", arg);
+
+	rtnl_route_set_iif(route, ival);
+}
+
+/** @} */
diff -uNr libnl_kk/src/lib/rule.c libnl/src/lib/rule.c
--- libnl_kk/src/lib/rule.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/lib/rule.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,55 @@
+/*
+ * src/lib/rule.c     CLI Routing Rule Helpers
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2008-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @ingroup cli
+ * @defgroup cli_rule Routing Rules
+ *
+ * @{
+ */
+
+#include <netlink/cli/utils.h>
+#include <netlink/cli/rule.h>
+
+struct rtnl_rule *nl_cli_rule_alloc(void)
+{
+	struct rtnl_rule *rule;
+
+	rule = rtnl_rule_alloc();
+	if (!rule)
+		nl_cli_fatal(ENOMEM, "Unable to allocate rule object");
+
+	return rule;
+}
+
+struct nl_cache *nl_cli_rule_alloc_cache(struct nl_sock *sk)
+{
+	struct nl_cache *cache;
+	int err;
+
+	if ((err = rtnl_rule_alloc_cache(sk, AF_UNSPEC, &cache)) < 0)
+		nl_cli_fatal(err, "Unable to allocate routing rule cache: %s\n",
+			     nl_geterror(err));
+
+	nl_cache_mngt_provide(cache);
+
+	return cache;
+}
+
+void nl_cli_rule_parse_family(struct rtnl_rule *rule, char *arg)
+{
+	int family;
+
+	if ((family = nl_str2af(arg)) != AF_UNSPEC)
+		rtnl_rule_set_family(rule, family);
+}
+
+/** @} */
diff -uNr libnl_kk/src/lib/utils.c libnl/src/lib/utils.c
--- libnl_kk/src/lib/utils.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/lib/utils.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,147 @@
+/*
+ * src/utils.c		Utilities
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+/**
+ * @defgroup cli Command Line Interface API
+ *
+ * @{
+ */
+
+#include <netlink/cli/utils.h>
+
+uint32_t nl_cli_parse_u32(const char *arg)
+{
+	unsigned long lval;
+	char *endptr;
+
+	lval = strtoul(arg, &endptr, 0);
+	if (endptr == arg || lval == ULONG_MAX)
+		nl_cli_fatal(EINVAL, "Unable to parse \"%s\", not a number.",
+			     arg);
+
+	return (uint32_t) lval;
+}
+
+void nl_cli_print_version(void)
+{
+	printf("libnl tools version %s\n", LIBNL_VERSION);
+	printf(
+	"Copyright (C) 2003-2009 Thomas Graf <tgraf@redhat.com>\n"
+	"\n"
+	"This program comes with ABSOLUTELY NO WARRANTY. This is free \n"
+	"software, and you are welcome to redistribute it under certain\n"
+	"conditions. See the GNU General Public License for details.\n"
+	);
+
+	exit(0);
+}
+
+void nl_cli_fatal(int err, const char *fmt, ...)
+{
+	va_list ap;
+
+	fprintf(stderr, "Error: ");
+
+	if (fmt) {
+		va_start(ap, fmt);
+		vfprintf(stderr, fmt, ap);
+		va_end(ap);
+		fprintf(stderr, "\n");
+	} else
+		fprintf(stderr, "%s\n", strerror(err));
+
+	exit(abs(err));
+}
+
+int nl_cli_connect(struct nl_sock *sk, int protocol)
+{
+	int err;
+
+	if ((err = nl_connect(sk, protocol)) < 0)
+		nl_cli_fatal(err, "Unable to connect netlink socket: %s",
+			     nl_geterror(err));
+
+	return err;
+}
+
+struct nl_sock *nl_cli_alloc_socket(void)
+{
+	struct nl_sock *sock;
+
+	if (!(sock = nl_socket_alloc()))
+		nl_cli_fatal(ENOBUFS, "Unable to allocate netlink socket");
+
+	return sock;
+}
+
+struct nl_addr *nl_cli_addr_parse(const char *str, int family)
+{
+	struct nl_addr *addr;
+	int err;
+
+	if ((err = nl_addr_parse(str, family, &addr)) < 0)
+		nl_cli_fatal(err, "Unable to parse address \"%s\": %s",
+			     str, nl_geterror(err));
+
+	return addr;
+}
+
+int nl_cli_parse_dumptype(const char *str)
+{
+	if (!strcasecmp(str, "brief"))
+		return NL_DUMP_LINE;
+	else if (!strcasecmp(str, "details") || !strcasecmp(str, "detailed"))
+		return NL_DUMP_DETAILS;
+	else if (!strcasecmp(str, "stats"))
+		return NL_DUMP_STATS;
+	else if (!strcasecmp(str, "env"))
+		return NL_DUMP_ENV;
+	else
+		nl_cli_fatal(EINVAL, "Invalid dump type \"%s\".\n", str);
+
+	return 0;
+}
+
+int nl_cli_confirm(struct nl_object *obj, struct nl_dump_params *params,
+		   int default_yes)
+{
+	int answer;
+
+	nl_object_dump(obj, params);
+	printf("Delete? (%c/%c) ",
+		default_yes ? 'Y' : 'y',
+		default_yes ? 'n' : 'N');
+
+	do {
+		answer = tolower(getchar());
+		if (answer == '\n')
+			answer = default_yes ? 'y' : 'n';
+	} while (answer != 'y' && answer != 'n');
+
+	return answer == 'y';
+}
+
+struct nl_cache *nl_cli_alloc_cache(struct nl_sock *sock, const char *name,
+			    int (*ac)(struct nl_sock *, struct nl_cache **))
+{
+	struct nl_cache *cache;
+	int err;
+
+	if ((err = ac(sock, &cache)) < 0)
+		nl_cli_fatal(err, "Unable to allocate %s cache: %s",
+			     name, nl_geterror(err));
+
+	nl_cache_mngt_provide(cache);
+
+	return cache;
+}
+
+/** @} */
diff -uNr libnl_kk/src/Makefile.am libnl/src/Makefile.am
--- libnl_kk/src/Makefile.am	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/Makefile.am	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,101 @@
+# -*- Makefile -*-
+
+SUBDIRS = lib
+
+AM_CPPFLAGS  = -Wall -I${top_srcdir}/include -I${top_builddir}/include -D_GNU_SOURCE
+AM_LDFLAGS = -L${top_builddir}/lib -L${top_builddir}/src/lib -lnl-cli
+
+noinst_PROGRAMS = \
+	genl-ctrl-list \
+	nf-ct-list nf-log nf-queue nf-monitor \
+	nl-addr-add nl-addr-delete nl-addr-list \
+	nl-link-list nl-link-set nl-link-stats \
+	nl-link-ifindex2name nl-link-name2ifindex \
+	nl-neigh-add nl-neigh-delete nl-neigh-list \
+	nl-qdisc-delete nl-qdisc-list \
+	nl-rule-list \
+	nl-neightbl-list \
+	nl-monitor \
+	nl-tctree-list \
+	nl-route-add nl-route-delete nl-route-get nl-route-list \
+	nl-fib-lookup \
+	nl-list-caches nl-list-sockets \
+	nl-util-addr \
+	nl-pktloc-lookup
+
+genl_ctrl_list_SOURCES = genl-ctrl-list.c 
+genl_ctrl_list_LDADD = -lnl-genl -lnl-route
+
+nf_ct_list_SOURCES = nf-ct-list.c 
+nf_ct_list_LDADD = -lnl-nf
+nf_log_SOURCES = nf-log.c
+nf_log_LDADD = -lnl-nf
+nf_queue_SOURCES = nf-queue.c 
+nf_queue_LDADD = -lnl-nf
+nf_monitor_SOURCES = nf-monitor.c
+nf_monitor_LDADD = -lnl-nf
+
+nl_addr_add_SOURCES = nl-addr-add.c
+nl_addr_add_LDADD = -lnl-route
+nl_addr_delete_SOURCES = nl-addr-delete.c
+nl_addr_delete_LDADD = -lnl-route
+nl_addr_list_SOURCES = nl-addr-list.c
+nl_addr_list_LDADD = -lnl-route
+
+nl_link_list_SOURCES = nl-link-list.c
+nl_link_list_LDADD = -lnl-route
+nl_link_set_SOURCES = nl-link-set.c
+nl_link_set_LDADD = -lnl-route
+nl_link_stats_SOURCES = nl-link-stats.c
+nl_link_stats_LDADD = -lnl-route
+nl_link_ifindex2name_SOURCES = nl-link-ifindex2name.c
+nl_link_ifindex2name_LDADD = -lnl-route
+nl_link_name2ifindex_SOURCES = nl-link-name2ifindex.c
+nl_link_name2ifindex_LDADD = -lnl-route
+
+nl_monitor_SOURCES = nl-monitor.c
+nl_monitor_LDADD = -lnl-route
+
+nl_neigh_add_SOURCES = nl-neigh-add.c
+nl_neigh_add_LDADD = -lnl-route
+nl_neigh_delete_SOURCES = nl-neigh-delete.c
+nl_neigh_delete_LDADD = -lnl-route
+nl_neigh_list_SOURCES = nl-neigh-list.c
+nl_neigh_list_LDADD = -lnl-route
+
+nl_neightbl_list_SOURCES = nl-neightbl-list.c
+nl_neightbl_list_LDADD = -lnl-route
+
+nl_qdisc_delete_SOURCES = nl-qdisc-delete.c
+nl_qdisc_delete_LDADD = -lnl-route
+nl_qdisc_list_SOURCES = nl-qdisc-list.c
+nl_qdisc_list_LDADD = -lnl-route
+
+nl_route_add_SOURCES = nl-route-add.c
+nl_route_add_LDADD = -lnl-route
+nl_route_delete_SOURCES = nl-route-delete.c
+nl_route_delete_LDADD = -lnl-route
+nl_route_get_SOURCES = nl-route-get.c
+nl_route_get_LDADD = -lnl-route
+nl_route_list_SOURCES = nl-route-list.c
+nl_route_list_LDADD = -lnl-route
+
+nl_rule_list_SOURCES = nl-rule-list.c
+nl_rule_list_LDADD = -lnl-route
+
+nl_tctree_list_SOURCES = nl-tctree-list.c
+nl_tctree_list_LDADD = -lnl-route
+
+nl_fib_lookup_SOURCES = nl-fib-lookup.c
+nl_fib_lookup_LDADD = -lnl-route
+
+nl_list_caches_SOURCES = nl-list-caches.c
+nl_list_caches_LDADD = -lnl-route
+nl_list_sockets_SOURCES = nl-list-sockets.c
+nl_list_sockets_LDADD = -lnl-route
+
+nl_util_addr_SOURCES = nl-util-addr.c
+nl_util_addr_LDADD = -lnl-route
+
+nl_pktloc_lookup_SOURCES = nl-pktloc-lookup.c
+nl_pktloc_lookup_LDADD = -lnl-route
diff -uNr libnl_kk/src/nf-ct-list.c libnl/src/nf-ct-list.c
--- libnl_kk/src/nf-ct-list.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/nf-ct-list.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,136 @@
+/*
+ * src/nf-ct-list.c     List Conntrack Entries
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2009 Thomas Graf <tgraf@suug.ch>
+ * Copyright (c) 2007 Philip Craig <philipc@snapgear.com>
+ * Copyright (c) 2007 Secure Computing Corporation
+ */
+
+#include <netlink/cli/utils.h>
+#include <netlink/cli/ct.h>
+
+static void print_usage(void)
+{
+	printf(
+	"Usage: nf-ct-list [OPTION]... [CONNTRACK ENTRY]\n"
+	"\n"
+	"Options\n"
+	" -f, --format=TYPE     Output format { brief | details | stats }\n"
+	" -h, --help            Show this help\n"
+	" -v, --version         Show versioning information\n"
+	"\n"
+	"Conntrack Selection\n"
+	" -i, --id=NUM            Identifier\n"
+	" -p, --proto=PROTOCOL    Protocol\n"
+	"     --tcp-state=STATE   TCP connection state\n"
+	"     --orig-src=ADDR     Original source address\n"
+	"     --orig-sport=PORT   Original source port\n"
+	"     --orig-dst=ADDR     Original destination address\n"
+	"     --orig-dport=PORT   Original destination port\n"
+	"     --reply-src=ADDR    Reply source address\n"
+	"     --reply-sport=PORT  Reply source port\n"
+	"     --reply-dst=ADDR    Reply destination address\n"
+	"     --reply-dport=PORT  Reply destination port\n"
+	" -F, --family=FAMILY     Address family\n"
+	"     --mark=NUM          Mark value\n"
+	"     --timeout=NUM       Timeout value\n"
+	"     --refcnt=NUM        Use counter value\n"
+	"     --flags             Flags\n"
+	);
+	exit(0);
+}
+
+int main(int argc, char *argv[])
+{
+	struct nl_sock *sock;
+	struct nl_cache *ct_cache;
+	struct nfnl_ct *ct;
+	struct nl_dump_params params = {
+		.dp_type = NL_DUMP_LINE,
+		.dp_fd = stdout,
+	};
+ 
+ 	ct = nl_cli_ct_alloc();
+ 
+	for (;;) {
+		int c, optidx = 0;
+		enum {
+			ARG_MARK = 257,
+			ARG_TCP_STATE = 258,
+			ARG_ORIG_SRC,
+			ARG_ORIG_SPORT,
+			ARG_ORIG_DST,
+			ARG_ORIG_DPORT,
+			ARG_REPLY_SRC,
+			ARG_REPLY_SPORT,
+			ARG_REPLY_DST,
+			ARG_REPLY_DPORT,
+			ARG_TIMEOUT,
+			ARG_REFCNT,
+			ARG_FLAGS,
+		};
+		static struct option long_opts[] = {
+			{ "format", 1, 0, 'f' },
+			{ "help", 0, 0, 'h' },
+			{ "version", 0, 0, 'v' },
+			{ "id", 1, 0, 'i' },
+			{ "proto", 1, 0, 'p' },
+			{ "tcp-state", 1, 0, ARG_TCP_STATE },
+			{ "orig-src", 1, 0, ARG_ORIG_SRC },
+			{ "orig-sport", 1, 0, ARG_ORIG_SPORT },
+			{ "orig-dst", 1, 0, ARG_ORIG_DST },
+			{ "orig-dport", 1, 0, ARG_ORIG_DPORT },
+			{ "reply-src", 1, 0, ARG_REPLY_SRC },
+			{ "reply-sport", 1, 0, ARG_REPLY_SPORT },
+			{ "reply-dst", 1, 0, ARG_REPLY_DST },
+			{ "reply-dport", 1, 0, ARG_REPLY_DPORT },
+			{ "family", 1, 0, 'F' },
+			{ "mark", 1, 0, ARG_MARK },
+			{ "timeout", 1, 0, ARG_TIMEOUT },
+			{ "refcnt", 1, 0, ARG_REFCNT },
+			{ 0, 0, 0, 0 }
+		};
+	
+		c = getopt_long(argc, argv, "46f:hvi:p:F:", long_opts, &optidx);
+		if (c == -1)
+			break;
+
+		switch (c) {
+		case '?': exit(NLE_INVAL);
+		case '4': nfnl_ct_set_family(ct, AF_INET); break;
+		case '6': nfnl_ct_set_family(ct, AF_INET6); break;
+		case 'f': params.dp_type = nl_cli_parse_dumptype(optarg); break;
+		case 'h': print_usage(); break;
+		case 'v': nl_cli_print_version(); break;
+		case 'i': nl_cli_ct_parse_id(ct, optarg); break;
+		case 'p': nl_cli_ct_parse_protocol(ct, optarg); break;
+		case ARG_TCP_STATE: nl_cli_ct_parse_tcp_state(ct, optarg); break;
+		case ARG_ORIG_SRC: nl_cli_ct_parse_src(ct, 0, optarg); break;
+		case ARG_ORIG_SPORT: nl_cli_ct_parse_src_port(ct, 0, optarg); break;
+		case ARG_ORIG_DST: nl_cli_ct_parse_dst(ct, 0, optarg); break;
+		case ARG_ORIG_DPORT: nl_cli_ct_parse_dst_port(ct, 0, optarg); break;
+		case ARG_REPLY_SRC: nl_cli_ct_parse_src(ct, 1, optarg); break;
+		case ARG_REPLY_SPORT: nl_cli_ct_parse_src_port(ct, 1, optarg); break;
+		case ARG_REPLY_DST: nl_cli_ct_parse_dst(ct, 1, optarg); break;
+		case ARG_REPLY_DPORT: nl_cli_ct_parse_dst_port(ct, 1, optarg); break;
+		case 'F': nl_cli_ct_parse_family(ct, optarg); break;
+		case ARG_MARK: nl_cli_ct_parse_mark(ct, optarg); break;
+		case ARG_TIMEOUT: nl_cli_ct_parse_timeout(ct, optarg); break;
+		case ARG_REFCNT: nl_cli_ct_parse_use(ct, optarg); break;
+		case ARG_FLAGS: nl_cli_ct_parse_status(ct, optarg); break;
+		}
+ 	}
+
+	sock = nl_cli_alloc_socket();
+	nl_cli_connect(sock, NETLINK_NETFILTER);
+	ct_cache = nl_cli_ct_alloc_cache(sock);
+
+	nl_cache_dump_filter(ct_cache, &params, OBJ_CAST(ct));
+
+	return 0;
+}
diff -uNr libnl_kk/src/nf-log.c libnl/src/nf-log.c
--- libnl_kk/src/nf-log.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/nf-log.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,147 @@
+/*
+ * src/nf-log.c     Monitor netfilter log events
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ * Copyright (c) 2007 Philip Craig <philipc@snapgear.com>
+ * Copyright (c) 2007 Secure Computing Corporation
+ */
+
+#include <netlink/cli/utils.h>
+#include <netlink/cli/link.h>
+#include <linux/netfilter/nfnetlink_log.h>
+#include <netlink/netfilter/nfnl.h>
+#include <netlink/netfilter/log.h>
+
+static struct nfnl_log *alloc_log(void)
+{
+	struct nfnl_log *log;
+
+	log = nfnl_log_alloc();
+	if (!log)
+		nl_cli_fatal(ENOMEM, "Unable to allocate log object");
+
+	return log;
+}
+
+static void obj_input(struct nl_object *obj, void *arg)
+{
+	struct nl_dump_params dp = {
+		.dp_type = NL_DUMP_STATS,
+		.dp_fd = stdout,
+		.dp_dump_msgtype = 1,
+	};
+
+	nl_object_dump(obj, &dp);
+}
+
+static int event_input(struct nl_msg *msg, void *arg)
+{
+	if (nl_msg_parse(msg, &obj_input, NULL) < 0)
+		fprintf(stderr, "<<EVENT>> Unknown message type\n");
+
+	/* Exit nl_recvmsgs_def() and return to the main select() */
+	return NL_STOP;
+}
+
+int main(int argc, char *argv[])
+{
+	struct nl_sock *nf_sock;
+	struct nl_sock *rt_sock;
+        struct nl_cache *link_cache;
+	struct nfnl_log *log;
+	enum nfnl_log_copy_mode copy_mode;
+	uint32_t copy_range;
+	int err;
+	int family;
+
+	nf_sock = nl_cli_alloc_socket();
+	nl_socket_disable_seq_check(nf_sock);
+	nl_socket_modify_cb(nf_sock, NL_CB_VALID, NL_CB_CUSTOM, event_input, NULL);
+
+	if ((argc > 1 && !strcasecmp(argv[1], "-h")) || argc < 3) {
+		printf("Usage: nf-log family group [ copy_mode ] "
+		       "[copy_range] \n");
+		return 2;
+	}
+
+	nl_cli_connect(nf_sock, NETLINK_NETFILTER);
+
+	family = nl_str2af(argv[1]);
+	if (family == AF_UNSPEC)
+		nl_cli_fatal(NLE_INVAL, "Unknown family \"%s\": %s",
+			     argv[1], nl_geterror(family));
+
+	nfnl_log_pf_unbind(nf_sock, family);
+	if ((err = nfnl_log_pf_bind(nf_sock, family)) < 0)
+		nl_cli_fatal(err, "Unable to bind logger: %s",
+			     nl_geterror(err));
+
+	log = alloc_log();
+	nfnl_log_set_group(log, atoi(argv[2]));
+
+	copy_mode = NFNL_LOG_COPY_META;
+	if (argc > 3) {
+		copy_mode = nfnl_log_str2copy_mode(argv[3]);
+		if (copy_mode < 0)
+			nl_cli_fatal(copy_mode,
+				     "Unable to parse copy mode \"%s\": %s",
+				     argv[3], nl_geterror(copy_mode));
+	}
+	nfnl_log_set_copy_mode(log, copy_mode);
+
+	copy_range = 0xFFFF;
+	if (argc > 4)
+		copy_mode = atoi(argv[4]);
+	nfnl_log_set_copy_range(log, copy_range);
+
+	if ((err = nfnl_log_create(nf_sock, log)) < 0)
+		nl_cli_fatal(err, "Unable to bind instance: %s",
+			     nl_geterror(err));
+
+	{
+		struct nl_dump_params dp = {
+			.dp_type = NL_DUMP_STATS,
+			.dp_fd = stdout,
+			.dp_dump_msgtype = 1,
+		};
+
+		printf("log params: ");
+		nl_object_dump((struct nl_object *) log, &dp);
+	}
+
+	rt_sock = nl_cli_alloc_socket();
+	nl_cli_connect(rt_sock, NETLINK_ROUTE);
+	link_cache = nl_cli_link_alloc_cache(rt_sock);
+
+	while (1) {
+		fd_set rfds;
+		int nffd, rtfd, maxfd, retval;
+
+		FD_ZERO(&rfds);
+
+		maxfd = nffd = nl_socket_get_fd(nf_sock);
+		FD_SET(nffd, &rfds);
+
+		rtfd = nl_socket_get_fd(rt_sock);
+		FD_SET(rtfd, &rfds);
+		if (maxfd < rtfd)
+			maxfd = rtfd;
+
+		/* wait for an incoming message on the netlink nf_socket */
+		retval = select(maxfd+1, &rfds, NULL, NULL, NULL);
+
+		if (retval) {
+			if (FD_ISSET(nffd, &rfds))
+				nl_recvmsgs_default(nf_sock);
+			if (FD_ISSET(rtfd, &rfds))
+				nl_recvmsgs_default(rt_sock);
+		}
+	}
+
+	return 0;
+}
diff -uNr libnl_kk/src/nf-monitor.c libnl/src/nf-monitor.c
--- libnl_kk/src/nf-monitor.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/nf-monitor.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,105 @@
+/*
+ * src/nf-monitor.c     Monitor netfilter events
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ * Copyright (c) 2007 Philip Craig <philipc@snapgear.com>
+ * Copyright (c) 2007 Secure Computing Corporation
+ */
+
+#include <netlink/cli/utils.h>
+#include <netlink/netfilter/nfnl.h>
+
+static void obj_input(struct nl_object *obj, void *arg)
+{
+	struct nl_dump_params dp = {
+		.dp_type = NL_DUMP_STATS,
+		.dp_fd = stdout,
+		.dp_dump_msgtype = 1,
+	};
+
+	nl_object_dump(obj, &dp);
+}
+
+static int event_input(struct nl_msg *msg, void *arg)
+{
+	if (nl_msg_parse(msg, &obj_input, NULL) < 0)
+		fprintf(stderr, "<<EVENT>> Unknown message type\n");
+
+	/* Exit nl_recvmsgs_def() and return to the main select() */
+	return NL_STOP;
+}
+
+int main(int argc, char *argv[])
+{
+	struct nl_sock *sock;
+	int err;
+	int i, idx;
+
+	static const struct {
+		enum nfnetlink_groups gr_id;
+		const char* gr_name;
+	} groups[] = {
+		{ NFNLGRP_CONNTRACK_NEW, "ct-new" },
+		{ NFNLGRP_CONNTRACK_UPDATE, "ct-update" },
+		{ NFNLGRP_CONNTRACK_DESTROY, "ct-destroy" },
+		{ NFNLGRP_NONE, NULL }
+	};
+
+	sock = nl_cli_alloc_socket();
+	nl_socket_disable_seq_check(sock);
+	nl_socket_modify_cb(sock, NL_CB_VALID, NL_CB_CUSTOM, event_input, NULL);
+
+	if (argc > 1 && !strcasecmp(argv[1], "-h")) {
+		printf("Usage: nf-monitor [<groups>]\n");
+
+		printf("Known groups:");
+		for (i = 0; groups[i].gr_id != NFNLGRP_NONE; i++)
+			printf(" %s", groups[i].gr_name);
+		printf("\n");
+		return 2;
+	}
+
+	nl_cli_connect(sock, NETLINK_NETFILTER);
+
+	for (idx = 1; argc > idx; idx++) {
+		for (i = 0; groups[i].gr_id != NFNLGRP_NONE; i++) {
+			if (strcmp(argv[idx], groups[i].gr_name))
+				continue;
+
+			err = nl_socket_add_membership(sock, groups[i].gr_id);
+			if (err < 0)
+				nl_cli_fatal(err,
+					     "Unable to add membership: %s",
+					     nl_geterror(err));
+			break;
+		}
+
+		if (groups[i].gr_id == NFNLGRP_NONE)
+			nl_cli_fatal(NLE_OBJ_NOTFOUND, "Unknown group: \"%s\"",
+				     argv[idx]);
+	}
+
+	while (1) {
+		fd_set rfds;
+		int fd, retval;
+
+		fd = nl_socket_get_fd(sock);
+
+		FD_ZERO(&rfds);
+		FD_SET(fd, &rfds);
+		/* wait for an incoming message on the netlink socket */
+		retval = select(fd+1, &rfds, NULL, NULL, NULL);
+
+		if (retval) {
+			/* FD_ISSET(fd, &rfds) will be true */
+			nl_recvmsgs_default(sock);
+		}
+	}
+
+	return 0;
+}
diff -uNr libnl_kk/src/nf-queue.c libnl/src/nf-queue.c
--- libnl_kk/src/nf-queue.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/nf-queue.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,172 @@
+/*
+ * src/nf-queue.c     Monitor netfilter queue events
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2007, 2008 Patrick McHardy <kaber@trash.net>
+ * Copyright (c) 2010  Karl Hiramoto <karl@hiramoto.org>
+ */
+
+
+#include <netlink/cli/utils.h>
+#include <netlink/cli/link.h>
+#include <linux/netfilter.h>
+#include <linux/netfilter/nfnetlink_queue.h>
+#include <netlink/netfilter/nfnl.h>
+#include <netlink/netfilter/queue.h>
+#include <netlink/netfilter/queue_msg.h>
+
+static struct nl_sock *nf_sock;
+
+static struct nfnl_queue *alloc_queue(void)
+{
+	struct nfnl_queue *queue;
+
+	queue = nfnl_queue_alloc();
+	if (!queue)
+		nl_cli_fatal(ENOMEM, "Unable to allocate queue object");
+
+	return queue;
+}
+
+
+static void obj_input(struct nl_object *obj, void *arg)
+{
+	struct nfnl_queue_msg *msg = (struct nfnl_queue_msg *) obj;
+	struct nl_dump_params dp = {
+		.dp_type = NL_DUMP_STATS,
+		.dp_fd = stdout,
+		.dp_dump_msgtype = 1,
+	};
+	uint32_t packet_id = nfnl_queue_msg_get_packetid(msg);
+	static uint32_t next_packet_id = 0;
+	struct nfnl_queue_msg *lost_msg = NULL;
+	uint8_t family;
+	uint16_t group;
+
+	if (packet_id > next_packet_id) {
+		printf("Warning: %d Out of order packets.  Queue or socket overload \n", packet_id - next_packet_id);
+		group = nfnl_queue_msg_get_group(msg);
+		family = nfnl_queue_msg_get_family(msg);
+		lost_msg = nfnl_queue_msg_alloc();
+
+		do {
+			nfnl_queue_msg_set_group(lost_msg, group);
+			nfnl_queue_msg_set_family(lost_msg, family);
+			nfnl_queue_msg_set_packetid(lost_msg, next_packet_id);
+			nfnl_queue_msg_set_verdict(lost_msg, NF_ACCEPT);
+			nfnl_queue_msg_send_verdict(nf_sock, lost_msg);
+			next_packet_id++;
+		} while (packet_id > next_packet_id);
+
+		nfnl_queue_msg_put(lost_msg);
+	}
+
+	next_packet_id = packet_id + 1;
+	nfnl_queue_msg_set_verdict(msg, NF_ACCEPT);
+	nl_object_dump(obj, &dp);
+	nfnl_queue_msg_send_verdict(nf_sock, msg);
+}
+
+static int event_input(struct nl_msg *msg, void *arg)
+{
+	if (nl_msg_parse(msg, &obj_input, NULL) < 0)
+		fprintf(stderr, "<<EVENT>> Unknown message type\n");
+
+	/* Exit nl_recvmsgs_def() and return to the main select() */
+	return NL_STOP;
+}
+
+int main(int argc, char *argv[])
+{
+	struct nl_sock *rt_sock;
+	struct nl_cache *link_cache;
+	struct nfnl_queue *queue;
+	enum nfnl_queue_copy_mode copy_mode;
+	uint32_t copy_range;
+	int err = 1;
+	int family;
+
+	nf_sock = nfnl_queue_socket_alloc();
+	if (nf_sock == NULL)
+		nl_cli_fatal(ENOBUFS, "Unable to allocate netlink socket");
+
+	nl_socket_disable_seq_check(nf_sock);
+	nl_socket_modify_cb(nf_sock, NL_CB_VALID, NL_CB_CUSTOM, event_input, NULL);
+
+	if ((argc > 1 && !strcasecmp(argv[1], "-h")) || argc < 3) {
+		printf("Usage: nf-queue family group [ copy_mode ] "
+		       "[ copy_range ]\n");
+		printf("family: [ inet | inet6 | ... ] \n");
+		printf("group: the --queue-num arg that you gave to iptables\n");
+		printf("copy_mode: [ none | meta | packet ] \n");
+		return 2;
+	}
+
+	nl_cli_connect(nf_sock, NETLINK_NETFILTER);
+
+	if ((family = nl_str2af(argv[1])) == AF_UNSPEC)
+		nl_cli_fatal(NLE_INVAL, "Unknown family \"%s\"", argv[1]);
+
+	nfnl_queue_pf_unbind(nf_sock, family);
+	if ((err = nfnl_queue_pf_bind(nf_sock, family)) < 0)
+		nl_cli_fatal(err, "Unable to bind logger: %s",
+			     nl_geterror(err));
+
+	queue = alloc_queue();
+	nfnl_queue_set_group(queue, atoi(argv[2]));
+
+	copy_mode = NFNL_QUEUE_COPY_PACKET;
+	if (argc > 3) {
+		copy_mode = nfnl_queue_str2copy_mode(argv[3]);
+		if (copy_mode < 0)
+			nl_cli_fatal(copy_mode,
+				     "Unable to parse copy mode \"%s\": %s",
+				     argv[3], nl_geterror(copy_mode));
+	}
+	nfnl_queue_set_copy_mode(queue, copy_mode);
+
+	copy_range = 0xFFFF;
+	if (argc > 4)
+		copy_range = atoi(argv[4]);
+	nfnl_queue_set_copy_range(queue, copy_range);
+
+	if ((err = nfnl_queue_create(nf_sock, queue)) < 0)
+		nl_cli_fatal(err, "Unable to bind queue: %s", nl_geterror(err));
+
+	rt_sock = nl_cli_alloc_socket();
+	nl_cli_connect(rt_sock, NETLINK_ROUTE);
+	link_cache = nl_cli_link_alloc_cache(rt_sock);
+
+	nl_socket_set_buffer_size(nf_sock, 1024*127, 1024*127);
+
+	while (1) {
+		fd_set rfds;
+		int nffd, rtfd, maxfd, retval;
+
+		FD_ZERO(&rfds);
+
+		maxfd = nffd = nl_socket_get_fd(nf_sock);
+		FD_SET(nffd, &rfds);
+
+		rtfd = nl_socket_get_fd(rt_sock);
+		FD_SET(rtfd, &rfds);
+		if (maxfd < rtfd)
+			maxfd = rtfd;
+
+		/* wait for an incoming message on the netlink socket */
+		retval = select(maxfd+1, &rfds, NULL, NULL, NULL);
+
+		if (retval) {
+			if (FD_ISSET(nffd, &rfds))
+				nl_recvmsgs_default(nf_sock);
+			if (FD_ISSET(rtfd, &rfds))
+				nl_recvmsgs_default(rt_sock);
+		}
+	}
+
+	return 0;
+}
diff -uNr libnl_kk/src/nl-addr-add.c libnl/src/nl-addr-add.c
--- libnl_kk/src/nl-addr-add.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/nl-addr-add.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,120 @@
+/*
+ * src/nl-addr-add.c     Add addresses
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation version 2 of the License.
+ *
+ * Copyright (c) 2003-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#include <netlink/cli/utils.h>
+#include <netlink/cli/addr.h>
+#include <netlink/cli/link.h>
+
+static int quiet = 0;
+
+static void print_usage(void)
+{
+	printf(
+"Usage: nl-addr-add [OPTION]... [ADDRESS]\n"
+"\n"
+"Options\n"
+"     --replace             Replace the address if it exists.\n"
+" -q, --quiet               Do not print informal notifications.\n"
+" -h, --help                Show this help.\n"
+" -v, --version             Show versioning information.\n"
+"\n"
+"Address Options\n"
+" -a, --local=ADDR          Address to be considered local.\n"
+" -d, --dev=DEV             Device the address should be assigned to.\n"
+"     --family=FAMILY       Address family (normally autodetected).\n"
+"     --broadcast=ADDR      Broadcast address of network (IPv4).\n"
+"     --peer=ADDR           Peer address (IPv4).\n"
+"     --label=STRING        Additional address label (IPv4).\n"
+"     --scope=SCOPE         Scope of local address (IPv4).\n"
+"     --preferred=TIME      Preferred lifetime (IPv6).\n"
+"     --valid=TIME          Valid lifetime (IPv6).\n"
+	);
+
+	exit(0);
+}
+
+int main(int argc, char *argv[])
+{
+	struct nl_sock *sock;
+	struct rtnl_addr *addr;
+	struct nl_cache *link_cache;
+	struct nl_dump_params dp = {
+		.dp_type = NL_DUMP_LINE,
+		.dp_fd = stdout,
+	};
+	int err, nlflags = NLM_F_CREATE;
+ 
+	sock = nl_cli_alloc_socket();
+	nl_cli_connect(sock, NETLINK_ROUTE);
+	link_cache = nl_cli_link_alloc_cache(sock);
+ 	addr = nl_cli_addr_alloc();
+ 
+	for (;;) {
+		int c, optidx = 0;
+		enum {
+			ARG_FAMILY = 257,
+			ARG_LABEL = 258,
+			ARG_PEER,
+			ARG_SCOPE,
+			ARG_BROADCAST,
+			ARG_REPLACE,
+			ARG_PREFERRED,
+			ARG_VALID,
+		};
+		static struct option long_opts[] = {
+			{ "replace", 0, 0, ARG_REPLACE },
+			{ "quiet", 0, 0, 'q' },
+			{ "help", 0, 0, 'h' },
+			{ "version", 0, 0, 'v' },
+			{ "local", 1, 0, 'a' },
+			{ "dev", 1, 0, 'd' },
+			{ "family", 1, 0, ARG_FAMILY },
+			{ "label", 1, 0, ARG_LABEL },
+			{ "peer", 1, 0, ARG_PEER },
+			{ "scope", 1, 0, ARG_SCOPE },
+			{ "broadcast", 1, 0, ARG_BROADCAST },
+			{ "preferred", 1, 0, ARG_PREFERRED },
+			{ "valid", 1, 0, ARG_VALID },
+			{ 0, 0, 0, 0 }
+		};
+	
+		c = getopt_long(argc, argv, "qhva:d:", long_opts, &optidx);
+		if (c == -1)
+			break;
+
+		switch (c) {
+		case '?': exit(NLE_INVAL);
+		case ARG_REPLACE: nlflags |= NLM_F_REPLACE; break;
+		case 'q': quiet = 1; break;
+		case 'h': print_usage(); break;
+		case 'v': nl_cli_print_version(); break;
+		case 'a': nl_cli_addr_parse_local(addr, optarg); break;
+		case 'd': nl_cli_addr_parse_dev(addr, link_cache, optarg); break;
+		case ARG_FAMILY: nl_cli_addr_parse_family(addr, optarg); break;
+		case ARG_LABEL: nl_cli_addr_parse_label(addr, optarg); break;
+		case ARG_PEER: nl_cli_addr_parse_peer(addr, optarg); break;
+		case ARG_SCOPE: nl_cli_addr_parse_scope(addr, optarg); break;
+		case ARG_BROADCAST: nl_cli_addr_parse_broadcast(addr, optarg); break;
+		case ARG_PREFERRED: nl_cli_addr_parse_preferred(addr, optarg); break;
+		case ARG_VALID: nl_cli_addr_parse_valid(addr, optarg); break;
+		}
+ 	}
+
+	if ((err = rtnl_addr_add(sock, addr, nlflags)) < 0)
+		nl_cli_fatal(err, "Unable to add address: %s",
+			     nl_geterror(err));
+
+	if (!quiet) {
+		printf("Added ");
+		nl_object_dump(OBJ_CAST(addr), &dp);
+ 	}
+
+	return 0;
+}
diff -uNr libnl_kk/src/nl-addr-delete.c libnl/src/nl-addr-delete.c
--- libnl_kk/src/nl-addr-delete.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/nl-addr-delete.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,140 @@
+/*
+ * src/nl-addr-delete.c     Delete addresses
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation version 2 of the License.
+ *
+ * Copyright (c) 2003-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#include <netlink/cli/utils.h>
+#include <netlink/cli/addr.h>
+#include <netlink/cli/link.h>
+
+static struct nl_sock *sock;
+static int interactive = 0, default_yes = 0, quiet = 0;
+static int deleted = 0;
+
+static void print_usage(void)
+{
+	printf(
+"Usage: nl-addr-delete [OPTION]... [ADDRESS]\n"
+"\n"
+"Options\n"
+" -i, --interactive         Run interactively.\n"
+"     --yes                 Set default answer to yes.\n"
+" -q, --quiet               Do not print informal notifications.\n"
+" -h, --help                Show this help.\n"
+" -v, --version             Show versioning information.\n"
+"\n"
+"Address Options\n"
+" -a, --local=ADDR          Local address.\n"
+" -d, --dev=DEV             Associated network device.\n"
+"     --family=FAMILY       Family of local address.\n"
+"     --label=STRING        Address label (IPv4).\n"
+"     --peer=ADDR           Peer address (IPv4).\n"
+"     --scope=SCOPE         Address scope (IPv4).\n"
+"     --broadcast=ADDR      Broadcast address of network (IPv4).\n"
+"     --valid-lifetime=TS   Valid lifetime before route expires (IPv6).\n"
+"     --preferred=TIME      Preferred lifetime (IPv6).\n"
+"     --valid=TIME          Valid lifetime (IPv6).\n"
+	);
+
+	exit(0);
+}
+
+static void delete_cb(struct nl_object *obj, void *arg)
+{
+	struct rtnl_addr *addr = nl_object_priv(obj);
+	struct nl_dump_params params = {
+		.dp_type = NL_DUMP_LINE,
+		.dp_fd = stdout,
+	};
+	int err;
+
+	if (interactive && !nl_cli_confirm(obj, &params, default_yes))
+		return;
+
+	if ((err = rtnl_addr_delete(sock, addr, 0)) < 0)
+		nl_cli_fatal(err, "Unable to delete address: %s\n",
+			     nl_geterror(err));
+
+	if (!quiet) {
+		printf("Deleted ");
+		nl_object_dump(obj, &params);
+	}
+
+	deleted++;
+}
+
+int main(int argc, char *argv[])
+{
+	struct rtnl_addr *addr;
+	struct nl_cache *link_cache, *addr_cache;
+
+	sock = nl_cli_alloc_socket();
+	nl_cli_connect(sock, NETLINK_ROUTE);
+	link_cache = nl_cli_link_alloc_cache(sock);
+	addr_cache = nl_cli_addr_alloc_cache(sock);
+	addr = nl_cli_addr_alloc();
+
+	for (;;) {
+		int c, optidx = 0;
+		enum {
+			ARG_FAMILY = 257,
+			ARG_LABEL = 258,
+			ARG_YES,
+			ARG_PEER,
+			ARG_SCOPE,
+			ARG_BROADCAST,
+			ARG_PREFERRED,
+			ARG_VALID,
+		};
+		static struct option long_opts[] = {
+			{ "interactive", 0, 0, 'i' },
+			{ "yes", 0, 0, ARG_YES },
+			{ "quiet", 0, 0, 'q' },
+			{ "help", 0, 0, 'h' },
+			{ "version", 0, 0, 'v' },
+			{ "local", 1, 0, 'a' },
+			{ "dev", 1, 0, 'd' },
+			{ "family", 1, 0, ARG_FAMILY },
+			{ "label", 1, 0, ARG_LABEL },
+			{ "peer", 1, 0, ARG_PEER },
+			{ "scope", 1, 0, ARG_SCOPE },
+			{ "broadcast", 1, 0, ARG_BROADCAST },
+			{ "preferred", 1, 0, ARG_PREFERRED },
+			{ "valid", 1, 0, ARG_VALID },
+			{ 0, 0, 0, 0 }
+		};
+	
+		c = getopt_long(argc, argv, "iqhva:d:", long_opts, &optidx);
+		if (c == -1)
+			break;
+
+		switch (c) {
+		case 'i': interactive = 1; break;
+		case ARG_YES: default_yes = 1; break;
+		case 'q': quiet = 1; break;
+		case 'h': print_usage(); break;
+		case 'v': nl_cli_print_version(); break;
+		case 'a': nl_cli_addr_parse_local(addr, optarg); break;
+		case 'd': nl_cli_addr_parse_dev(addr, link_cache, optarg); break;
+		case ARG_FAMILY: nl_cli_addr_parse_family(addr, optarg); break;
+		case ARG_LABEL: nl_cli_addr_parse_label(addr, optarg); break;
+		case ARG_PEER: nl_cli_addr_parse_peer(addr, optarg); break;
+		case ARG_SCOPE: nl_cli_addr_parse_scope(addr, optarg); break;
+		case ARG_BROADCAST: nl_cli_addr_parse_broadcast(addr, optarg); break;
+		case ARG_PREFERRED: nl_cli_addr_parse_preferred(addr, optarg); break;
+		case ARG_VALID: nl_cli_addr_parse_valid(addr, optarg); break;
+		}
+ 	}
+
+	nl_cache_foreach_filter(addr_cache, OBJ_CAST(addr), delete_cb, NULL);
+
+	if (!quiet)
+		printf("Deleted %d addresses\n", deleted);
+
+	return 0;
+}
diff -uNr libnl_kk/src/nl-addr-list.c libnl/src/nl-addr-list.c
--- libnl_kk/src/nl-addr-list.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/nl-addr-list.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,193 @@
+/*
+ * src/nl-addr-list.c     List addresses
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation version 2 of the License.
+ *
+ * Copyright (c) 2003-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#include <netlink/cli/utils.h>
+#include <netlink/cli/addr.h>
+#include <netlink/cli/link.h>
+
+static void print_usage(void)
+{
+	printf(
+"Usage: nl-addr-list [OPTION]... [ADDRESS]\n"
+"\n"
+"Options\n"
+"     --details             Show details on multiple lines.\n"
+"     --env                 Print address details in sh env variable syntax.\n"
+"     --prefix=STRING       Prefix each printed line.\n"
+" -h, --help                Show this help.\n"
+" -v, --version             Show versioning information.\n"
+"\n"
+"Address Selection\n"
+" -a, --local=ADDR          Local address.\n"
+" -d, --dev=DEV             Associated network device.\n"
+"     --family=FAMILY       Family of local address.\n"
+"     --label=STRING        Address label (IPv4).\n"
+"     --peer=ADDR           Peer address (IPv4).\n"
+"     --scope=SCOPE         Address scope (IPv4).\n"
+"     --broadcast=ADDR      Broadcast address of network (IPv4).\n"
+"     --valid-lifetime=TS   Valid lifetime before route expires (IPv6).\n"
+"     --preferred=TIME      Preferred lifetime (IPv6).\n"
+"     --valid=TIME          Valid lifetime (IPv6).\n"
+	);
+	exit(0);
+}
+
+static char *prefix;
+
+void print_prefix(struct nl_dump_params *p, int line)
+{
+	if (prefix)
+		nl_dump(p, "%s", prefix);
+}
+
+static void env_dump(struct nl_object *obj, void *arg)
+{
+	struct nl_dump_params *p = arg;
+	struct rtnl_addr *addr = (struct rtnl_addr *) obj;
+	struct nl_cache *link_cache;
+	struct nl_addr *a;
+	static int index = 0;
+	char buf[128], pfx[32], *s;
+
+	snprintf(pfx, sizeof(pfx), "ADDR%d", index++);
+
+	nl_dump_line(p, "%s_FAMILY=%s\n", pfx,
+		     nl_af2str(rtnl_addr_get_family(addr), buf, sizeof(buf)));
+
+	nl_dump_line(p, "%s_LOCAL=%s\n", pfx,
+		     nl_addr2str(rtnl_addr_get_local(addr), buf, sizeof(buf)));
+
+	nl_dump_line(p, "%s_IFINDEX=%u\n", pfx, rtnl_addr_get_ifindex(addr));
+	link_cache = nl_cache_mngt_require("route/link");
+	if (link_cache)
+		nl_dump_line(p, "%s_IFNAME=%s\n", pfx,
+			     rtnl_link_i2name(link_cache,
+			     		      rtnl_addr_get_ifindex(addr),
+			     		      buf, sizeof(buf)));
+
+	if ((a = rtnl_addr_get_peer(addr)))
+		nl_dump_line(p, "%s_PEER=%s\n", pfx,
+			     nl_addr2str(a, buf, sizeof(buf)));
+
+	if ((a = rtnl_addr_get_broadcast(addr)))
+		nl_dump_line(p, "%s_BROADCAST=%s\n", pfx,
+			     nl_addr2str(a, buf, sizeof(buf)));
+
+	nl_dump_line(p, "%s_SCOPE=%s\n", pfx,
+		     rtnl_scope2str(rtnl_addr_get_scope(addr),
+				    buf, sizeof(buf)));
+
+	if ((s = rtnl_addr_get_label(addr)))
+		nl_dump_line(p, "%s_LABEL=%s\n", pfx, s);
+
+	rtnl_addr_flags2str(rtnl_addr_get_flags(addr), buf, sizeof(buf));
+	if (buf[0])
+		nl_dump_line(p, "%s_FLAGS=%s\n", pfx, buf);
+
+	nl_dump_line(p, "%s_CACHEINFO_VALID=%u\n", pfx,
+		     rtnl_addr_get_valid_lifetime(addr));
+
+#if 0
+	if (addr->ce_mask & ADDR_ATTR_CACHEINFO) {
+		struct rtnl_addr_cacheinfo *ci = &addr->a_cacheinfo;
+
+		nl_dump_line(p, "ADDR_CACHEINFO_PREFERRED=%u\n",
+			     ci->aci_prefered);
+
+		nl_dump_line(p, "ADDR_CACHEINFO_CREATED=%u\n", ci->aci_cstamp);
+		nl_dump_line(p, "ADDR_CACHEINFO_LASTUPDATE=%u\n",
+			     ci->aci_tstamp);
+	}
+#endif
+}
+
+int main(int argc, char *argv[])
+{
+	struct nl_sock *sock;
+	struct rtnl_addr *addr;
+	struct nl_cache *link_cache, *addr_cache;
+	struct nl_dump_params params = {
+		.dp_type = NL_DUMP_LINE,
+		.dp_nl_cb = print_prefix,
+		.dp_fd = stdout,
+	};
+	int dump_env = 0;
+
+	sock = nl_cli_alloc_socket();
+	nl_cli_connect(sock, NETLINK_ROUTE);
+	link_cache = nl_cli_link_alloc_cache(sock);
+	addr_cache = nl_cli_addr_alloc_cache(sock);
+	addr = nl_cli_addr_alloc();
+
+	for (;;) {
+		int c, optidx = 0;
+		enum {
+			ARG_FAMILY = 257,
+			ARG_LABEL = 258,
+			ARG_PEER,
+			ARG_SCOPE,
+			ARG_BROADCAST,
+			ARG_DETAILS,
+			ARG_ENV,
+			ARG_PREFIX,
+			ARG_PREFERRED,
+			ARG_VALID,
+		};
+		static struct option long_opts[] = {
+			{ "details", 0, 0, ARG_DETAILS },
+			{ "env", 0, 0, ARG_ENV },
+			{ "prefix", 1, 0, ARG_PREFIX },
+			{ "help", 0, 0, 'h' },
+			{ "version", 0, 0, 'v' },
+			{ "local", 1, 0, 'a' },
+			{ "dev", 1, 0, 'd' },
+			{ "family", 1, 0, ARG_FAMILY },
+			{ "label", 1, 0, ARG_LABEL },
+			{ "peer", 1, 0, ARG_PEER },
+			{ "scope", 1, 0, ARG_SCOPE },
+			{ "broadcast", 1, 0, ARG_BROADCAST },
+			{ "preferred", 1, 0, ARG_PREFERRED },
+			{ "valid", 1, 0, ARG_VALID },
+			{ 0, 0, 0, 0 }
+		};
+
+		c = getopt_long(argc, argv, "46hva:d:", long_opts, &optidx);
+		if (c == -1)
+			break;
+
+		switch (c) {
+		case '?': exit(NLE_INVAL);
+		case '4': rtnl_addr_set_family(addr, AF_INET); break;
+		case '6': rtnl_addr_set_family(addr, AF_INET6); break;
+		case ARG_DETAILS: params.dp_type = NL_DUMP_DETAILS; break;
+		case ARG_ENV: dump_env = 1; break;
+		case ARG_PREFIX: prefix = strdup(optarg); break;
+		case 'h': print_usage(); break;
+		case 'v': nl_cli_print_version(); break;
+		case 'a': nl_cli_addr_parse_local(addr, optarg); break;
+		case 'd': nl_cli_addr_parse_dev(addr, link_cache, optarg); break;
+		case ARG_FAMILY: nl_cli_addr_parse_family(addr, optarg); break;
+		case ARG_LABEL: nl_cli_addr_parse_label(addr, optarg); break;
+		case ARG_PEER: nl_cli_addr_parse_peer(addr, optarg); break;
+		case ARG_SCOPE: nl_cli_addr_parse_scope(addr, optarg); break;
+		case ARG_BROADCAST: nl_cli_addr_parse_broadcast(addr, optarg); break;
+		case ARG_PREFERRED: nl_cli_addr_parse_preferred(addr, optarg); break;
+		case ARG_VALID: nl_cli_addr_parse_valid(addr, optarg); break;
+		}
+	}
+
+	if (dump_env)
+		nl_cache_foreach_filter(addr_cache, OBJ_CAST(addr), env_dump,
+					&params);
+	else
+		nl_cache_dump_filter(addr_cache, &params, OBJ_CAST(addr));
+
+	return 0;
+}
diff -uNr libnl_kk/src/nl-cls-add.c libnl/src/nl-cls-add.c
--- libnl_kk/src/nl-cls-add.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/nl-cls-add.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,117 @@
+/*
+ * src/nl-cls-add.c     Add classifier
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation version 2 of the License.
+ *
+ * Copyright (c) 2003-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#include "cls/utils.h"
+
+static int quiet = 0;
+
+static void print_usage(void)
+{
+	printf(
+"Usage: nl-cls-add [OPTION]... [CLASSIFIER] TYPE [TYPE OPTIONS]...\n"
+"\n"
+"Options\n"
+" -q, --quiet               Do not print informal notifications.\n"
+" -h, --help                Show this help.\n"
+" -v, --version             Show versioning information.\n"
+"\n"
+"Classifier Options\n"
+" -d, --dev=DEV             Device the classifier should be assigned to.\n"
+" -p, --parent=HANDLE       Parent QDisc\n"
+"     --proto=PROTO         Protocol (default=IPv4)\n"
+"     --prio=NUM            Priority (0..256)\n"
+"     --id=HANDLE           Unique identifier\n"
+	);
+	exit(0);
+}
+
+int main(int argc, char *argv[])
+{
+	struct nl_sock *sock;
+	struct rtnl_cls *cls;
+	struct nl_cache *link_cache;
+	struct rtnl_cls_ops *ops;
+	struct cls_module *mod;
+	struct nl_dump_params dp = {
+		.dp_type = NL_DUMP_DETAILS,
+		.dp_fd = stdout,
+	};
+	char *kind;
+	int err, nlflags = NLM_F_CREATE;
+ 
+	sock = nlt_alloc_socket();
+	nlt_connect(sock, NETLINK_ROUTE);
+	link_cache = nlt_alloc_link_cache(sock);
+	cls = nlt_alloc_cls();
+
+	for (;;) {
+		int c, optidx = 0;
+		enum {
+			ARG_PROTO = 257,
+			ARG_PRIO = 258,
+			ARG_ID,
+		};
+		static struct option long_opts[] = {
+			{ "quiet", 0, 0, 'q' },
+			{ "help", 0, 0, 'h' },
+			{ "version", 0, 0, 'v' },
+			{ "dev", 1, 0, 'd' },
+			{ "parent", 1, 0, 'p' },
+			{ "proto", 1, 0, ARG_PROTO },
+			{ "prio", 1, 0, ARG_PRIO },
+			{ "id", 1, 0, ARG_ID },
+			{ 0, 0, 0, 0 }
+		};
+	
+		c = getopt_long(argc, argv, "+qhva:d:", long_opts, &optidx);
+		if (c == -1)
+			break;
+
+		switch (c) {
+		case '?': exit(NLE_INVAL);
+		case 'q': quiet = 1; break;
+		case 'h': print_usage(); break;
+		case 'v': nlt_print_version(); break;
+		case 'd': parse_dev(cls, link_cache, optarg); break;
+		case 'p': parse_parent(cls, optarg); break;
+		case ARG_PRIO: parse_prio(cls, optarg); break;
+		case ARG_ID: parse_handle(cls, optarg); break;
+		case ARG_PROTO: parse_proto(cls, optarg); break;
+		}
+ 	}
+
+	if (optind >= argc) {
+		print_usage();
+		fatal(EINVAL, "Missing classifier type");
+	}
+
+	kind = argv[optind++];
+	if ((err = rtnl_cls_set_kind(cls, kind)) < 0)
+		fatal(ENOENT, "Unknown classifier type \"%s\".", kind);
+	
+	ops = rtnl_cls_get_ops(cls);
+	if (!(mod = lookup_cls_mod(ops)))
+		fatal(ENOTSUP, "Classifier type \"%s\" not supported.", kind);
+
+	mod->parse_argv(cls, argc, argv);
+
+	printf("Adding ");
+	nl_object_dump(OBJ_CAST(cls), &dp);
+
+	if ((err = rtnl_cls_add(sock, cls, nlflags)) < 0)
+		fatal(err, "Unable to add classifier: %s", nl_geterror(err));
+
+	if (!quiet) {
+		printf("Added ");
+		nl_object_dump(OBJ_CAST(cls), &dp);
+ 	}
+
+	return 0;
+}
diff -uNr libnl_kk/src/nl-cls-delete.c libnl/src/nl-cls-delete.c
--- libnl_kk/src/nl-cls-delete.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/nl-cls-delete.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,133 @@
+/*
+ * src/nl-cls-delete.c     Delete Classifier
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+#include "cls/utils.h"
+
+static int interactive = 0, default_yes = 0, quiet = 0;
+static int deleted = 0;
+static struct nl_sock *sock;
+
+static void print_usage(void)
+{
+	printf(
+	"Usage: nl-cls-list [OPTION]... [CLASSIFIER]\n"
+	"\n"
+	"Options\n"
+	" -i, --interactive     Run interactively\n"
+	"     --yes             Set default answer to yes\n"
+	" -q, --quiet		Do not print informal notifications\n"
+	" -h, --help            Show this help\n"
+	" -v, --version		Show versioning information\n"
+	"\n"
+	"Classifier Options\n"
+	" -d, --dev=DEV         Device the classifier should be assigned to.\n"
+	" -p, --parent=HANDLE   Parent qdisc/class\n"
+	"     --proto=PROTO     Protocol\n"
+	"     --prio=NUM        Priority (0..256)\n"
+	"     --id=HANDLE       Unique identifier\n"
+	);
+	exit(0);
+}
+
+static void delete_cb(struct nl_object *obj, void *arg)
+{
+	struct rtnl_cls *cls = (struct rtnl_cls *) obj;
+	struct nl_dump_params params = {
+		.dp_type = NL_DUMP_LINE,
+		.dp_fd = stdout,
+	};
+	int err;
+
+	if (interactive && !nlt_confirm(obj, &params, default_yes))
+		return;
+
+	if ((err = rtnl_cls_delete(sock, cls, 0)) < 0)
+		fatal(err, "Unable to delete classifier: %s",
+		      nl_geterror(err));
+
+	if (!quiet) {
+		printf("Deleted ");
+		nl_object_dump(obj, &params);
+	}
+
+	deleted++;
+}
+
+int main(int argc, char *argv[])
+{
+	struct nl_cache *link_cache, *cls_cache;
+	struct rtnl_cls *cls;
+	int nf = 0, err;
+
+	sock = nlt_alloc_socket();
+	nlt_connect(sock, NETLINK_ROUTE);
+	link_cache = nlt_alloc_link_cache(sock);
+	cls = nlt_alloc_cls();
+
+	for (;;) {
+		int c, optidx = 0;
+		enum {
+			ARG_PRIO = 257,
+			ARG_PROTO = 258,
+			ARG_ID,
+			ARG_YES,
+		};
+		static struct option long_opts[] = {
+			{ "interactive", 0, 0, 'i' },
+			{ "yes", 0, 0, ARG_YES },
+			{ "quiet", 0, 0, 'q' },
+			{ "help", 0, 0, 'h' },
+			{ "version", 0, 0, 'v' },
+			{ "dev", 1, 0, 'd' },
+			{ "parent", 1, 0, 'p' },
+			{ "proto", 1, 0, ARG_PROTO },
+			{ "prio", 1, 0, ARG_PRIO },
+			{ "id", 1, 0, ARG_ID },
+			{ 0, 0, 0, 0 }
+		};
+	
+		c = getopt_long(argc, argv, "iqhvd:p:", long_opts, &optidx);
+		if (c == -1)
+			break;
+
+		switch (c) {
+		case 'i': interactive = 1; break;
+		case ARG_YES: default_yes = 1; break;
+		case 'q': quiet = 1; break;
+		case 'h': print_usage(); break;
+		case 'v': nlt_print_version(); break;
+		case 'd': nf++; parse_dev(cls, link_cache, optarg); break;
+		case 'p': nf++; parse_parent(cls, optarg); break;
+		case ARG_PRIO: nf++; parse_prio(cls, optarg); break;
+		case ARG_ID: nf++; parse_handle(cls, optarg); break;
+		case ARG_PROTO: nf++; parse_proto(cls, optarg); break;
+		}
+	}
+
+	if (nf == 0 && !interactive && !default_yes) {
+		fprintf(stderr, "You attempted to delete all classifiers in "
+			"non-interactive mode, aborting.\n");
+		exit(0);
+	}
+
+	err = rtnl_cls_alloc_cache(sock, rtnl_cls_get_ifindex(cls),
+				   rtnl_cls_get_parent(cls), &cls_cache);
+	if (err < 0)
+		fatal(err, "Unable to allocate classifier cache: %s",
+		      nl_geterror(err));
+
+	nl_cache_foreach_filter(cls_cache, OBJ_CAST(cls), delete_cb, NULL);
+
+	if (!quiet)
+		printf("Deleted %d classifiers\n", deleted);
+
+	return 0;
+}
diff -uNr libnl_kk/src/nl-cls-list.c libnl/src/nl-cls-list.c
--- libnl_kk/src/nl-cls-list.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/nl-cls-list.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,113 @@
+/*
+ * src/nl-cls-list.c     	List classifiers
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+#include "cls/utils.h"
+
+static struct nl_sock *sock;
+static struct rtnl_cls *cls;
+static struct nl_dump_params params = {
+	.dp_type = NL_DUMP_LINE,
+};
+
+static void print_usage(void)
+{
+	printf(
+	"Usage: nl-cls-list [OPTION]... [CLASSIFIER]\n"
+	"\n"
+	"Options\n"
+	" -f, --format=TYPE     Output format { brief | details | stats }\n"
+	" -h, --help            Show this help text.\n"
+	" -v, --version         Show versioning information.\n"
+	"\n"
+	"Classifier Options\n"
+	" -d, --dev=DEV         Device the classifier should be assigned to.\n"
+	" -p, --parent=HANDLE   Parent qdisc/class\n"
+	"     --proto=PROTO     Protocol\n"
+	"     --prio=NUM        Priority\n"
+	"     --id=NUM          Identifier\n"
+	);
+	exit(0);
+}
+
+static void print_cls(struct nl_object *obj, void *arg)
+{
+	struct nl_cache *cls_cache;
+	int err, ifindex;
+
+	if (obj)
+		ifindex = rtnl_link_get_ifindex((struct rtnl_link *) obj);
+	else
+		ifindex = rtnl_cls_get_ifindex(cls);
+
+	err = rtnl_cls_alloc_cache(sock, ifindex, rtnl_cls_get_parent(cls),
+				   &cls_cache);
+	if (err < 0)
+		fatal(err, "Unable to allocate classifier cache: %s",
+		      nl_geterror(err));
+
+	nl_cache_dump_filter(cls_cache, &params, OBJ_CAST(cls));
+	nl_cache_free(cls_cache);
+}
+
+int main(int argc, char *argv[])
+{
+	struct nl_cache *link_cache;
+	int dev = 0;
+
+	params.dp_fd = stdout;
+	sock = nlt_alloc_socket();
+	nlt_connect(sock, NETLINK_ROUTE);
+	link_cache = nlt_alloc_link_cache(sock);
+	cls = nlt_alloc_cls();
+
+	for (;;) {
+		int c, optidx = 0;
+		enum {
+			ARG_PROTO = 257,
+			ARG_PRIO = 258,
+			ARG_ID,
+		};
+		static struct option long_opts[] = {
+			{ "format", 1, 0, 'f' },
+			{ "help", 0, 0, 'h' },
+			{ "version", 0, 0, 'v' },
+			{ "dev", 1, 0, 'd' },
+			{ "parent", 1, 0, 'p' },
+			{ "proto", 1, 0, ARG_PROTO },
+			{ "prio", 1, 0, ARG_PRIO },
+			{ "id", 1, 0, ARG_ID },
+			{ 0, 0, 0, 0 }
+		};
+	
+		c = getopt_long(argc, argv, "+f:qhva:d:", long_opts, &optidx);
+		if (c == -1)
+			break;
+
+		switch (c) {
+		case '?': exit(NLE_INVAL);
+		case 'f': params.dp_type = nlt_parse_dumptype(optarg); break;
+		case 'h': print_usage(); break;
+		case 'v': nlt_print_version(); break;
+		case 'd': dev = 1; parse_dev(cls, link_cache, optarg); break;
+		case 'p': parse_parent(cls, optarg); break;
+		case ARG_PRIO: parse_prio(cls, optarg); break;
+		case ARG_ID: parse_handle(cls, optarg); break;
+		case ARG_PROTO: parse_proto(cls, optarg); break;
+		}
+ 	}
+
+	if (!dev)
+		nl_cache_foreach(link_cache, print_cls, NULL);
+	else
+		print_cls(NULL, NULL);
+
+	return 0;
+}
diff -uNr libnl_kk/src/nl-fib-lookup.c libnl/src/nl-fib-lookup.c
--- libnl_kk/src/nl-fib-lookup.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/nl-fib-lookup.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,109 @@
+/*
+ * src/nl-fib-lookup.c		FIB Route Lookup
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#include <netlink/cli/utils.h>
+
+static void print_usage(void)
+{
+	printf(
+	"Usage: nl-fib-lookup [options] <addr>\n"
+	"Options:\n"
+	"   -t, --table <table>		Table id\n"
+	"   -f, --fwmark <int>		Firewall mark\n"
+	"   -s, --scope <scope>		Routing scope\n"
+	"   -T, --tos <int>		Type of Service\n");
+	exit(1);
+}
+
+int main(int argc, char *argv[])
+{
+	struct nl_sock *nlh;
+	struct nl_cache *result;
+	struct flnl_request *request;
+	struct nl_addr *addr;
+	struct nl_dump_params params = {
+		.dp_fd = stdout,
+		.dp_type = NL_DUMP_DETAILS,
+	};
+	int table = RT_TABLE_UNSPEC, scope = RT_SCOPE_UNIVERSE;
+	int tos = 0, err = 1;
+	uint64_t fwmark = 0;
+
+	while (1) {
+		static struct option long_opts[] = {
+			{"table", 1, 0, 't'},
+			{"fwmark", 1, 0, 'f'},
+			{"scope", 1, 0, 's'},
+			{"tos", 1, 0, 'T'},
+			{"help", 0, 0, 'h'},
+			{0, 0, 0, 0},
+		};
+		int c, idx = 0;
+
+		c = getopt_long(argc, argv, "t:f:s:T:h", long_opts, &idx);
+		if (c == -1)
+			break;
+
+		switch (c) {
+		case 't':
+			table = strtoul(optarg, NULL, 0);
+			break;
+		case 'f':
+			fwmark = strtoul(optarg, NULL, 0);
+			break;
+		case 's':
+			scope = strtoul(optarg, NULL, 0);
+			break;
+		case 'T':
+			tos = strtoul(optarg, NULL, 0);
+			break;
+		default:
+			print_usage();
+		}
+	}
+
+	if (optind >= argc)
+		print_usage();
+
+	nlh = nl_cli_alloc_socket();
+
+	if ((err = nl_addr_parse(argv[optind], AF_INET, &addr)) < 0)
+		nl_cli_fatal(err, "Unable to parse address \"%s\": %s\n",
+			argv[optind], nl_geterror(err));
+
+	result = flnl_result_alloc_cache();
+	if (!result)
+		nl_cli_fatal(ENOMEM, "Unable to allocate cache");
+
+	request = flnl_request_alloc();
+	if (!request)
+		nl_cli_fatal(ENOMEM, "Unable to allocate request");
+
+	flnl_request_set_table(request, table);
+	flnl_request_set_fwmark(request, fwmark);
+	flnl_request_set_scope(request, scope);
+	flnl_request_set_tos(request, tos);
+
+	err = flnl_request_set_addr(request, addr);
+	nl_addr_put(addr);
+	if (err < 0)
+		nl_cli_fatal(err, "Unable to send request: %s", nl_geterror(err));
+
+	nl_cli_connect(nlh, NETLINK_FIB_LOOKUP);
+
+	err = flnl_lookup(nlh, request, result);
+	if (err < 0)
+		nl_cli_fatal(err, "Unable to lookup: %s\n", nl_geterror(err));
+
+	nl_cache_dump(result, &params);
+
+	return 0;
+}
diff -uNr libnl_kk/src/nl-link-ifindex2name.c libnl/src/nl-link-ifindex2name.c
--- libnl_kk/src/nl-link-ifindex2name.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/nl-link-ifindex2name.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,44 @@
+/*
+ * src/nl-link-ifindex2name.c     Transform a interface index to its name
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#include <netlink/cli/utils.h>
+#include <netlink/cli/link.h>
+
+static void print_usage(void)
+{
+	printf("Usage: nl-link-ifindex2name <ifindex>\n");
+	exit(0);
+}
+
+int main(int argc, char *argv[])
+{
+	struct nl_sock *sock;
+	struct nl_cache *link_cache;
+	char name[IFNAMSIZ];
+	uint32_t ifindex;
+
+	if (argc < 2)
+		print_usage();
+
+	sock = nl_cli_alloc_socket();
+	nl_cli_connect(sock, NETLINK_ROUTE);
+	link_cache = nl_cli_link_alloc_cache(sock);
+
+	ifindex = nl_cli_parse_u32(argv[1]);
+
+	if (!rtnl_link_i2name(link_cache, ifindex, name, sizeof(name)))
+		nl_cli_fatal(ENOENT, "Interface index %d does not exist",
+			     ifindex);
+
+	printf("%s\n", name);
+
+	return 0;
+}
diff -uNr libnl_kk/src/nl-link-list.c libnl/src/nl-link-list.c
--- libnl_kk/src/nl-link-list.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/nl-link-list.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,106 @@
+/*
+ * src/nl-link-dump.c	Dump link attributes
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#if 0
+static void print_usage(void)
+{
+	printf(
+	"Usage: nl-link-dump <mode> [<filter>]\n"
+	"  mode := { brief | detailed | stats | xml }\n"
+	"  filter := [dev DEV] [mtu MTU] [txqlen TXQLEN] [weight WEIGHT] [link LINK]\n"
+	"            [master MASTER] [qdisc QDISC] [addr ADDR] [broadcast BRD]\n"
+	"            [{ up | down }] [{ arp | noarp }] [{ promisc | nopromisc }]\n"
+	"            [{ dynamic | nodynamic }] [{ multicast | nomulticast }]\n"
+	"            [{ trailers | notrailers }] [{ allmulticast | noallmulticast }]\n");
+	exit(1);
+}
+#endif
+
+#include <netlink/cli/utils.h>
+#include <netlink/cli/link.h>
+
+static void print_usage(void)
+{
+	printf(
+	"Usage: nl-link-list [OPTION]... [Link]\n"
+	"\n"
+	"Options\n"
+	" -f, --format=TYPE     Output format { brief | details | stats }\n"
+	" -h, --help            Show this help\n"
+	" -v, --version         Show versioning information\n"
+	"\n"
+	"Link Options\n"
+	" -n, --name=NAME	link name\n"
+	" -i, --index           interface index\n"
+	"     --mtu=NUM         MTU value\n"
+	"     --txqlen=NUM      TX queue length\n"
+	"     --weight=NUM      weight\n"
+	);
+	exit(0);
+}
+
+int main(int argc, char *argv[])
+{
+	struct nl_sock *sock;
+	struct nl_cache *link_cache;
+	struct rtnl_link *link;
+	struct nl_dump_params params = {
+		.dp_type = NL_DUMP_LINE,
+		.dp_fd = stdout,
+	};
+
+	sock = nl_cli_alloc_socket();
+	nl_cli_connect(sock, NETLINK_ROUTE);
+	link_cache = nl_cli_link_alloc_cache(sock);
+	link = nl_cli_link_alloc();
+
+	for (;;) {
+		int c, optidx = 0;
+		enum {
+			ARG_FAMILY = 257,
+			ARG_MTU = 258,
+			ARG_TXQLEN,
+			ARG_WEIGHT,
+		};
+		static struct option long_opts[] = {
+			{ "format", 1, 0, 'f' },
+			{ "help", 0, 0, 'h' },
+			{ "version", 0, 0, 'v' },
+			{ "name", 1, 0, 'n' },
+			{ "index", 1, 0, 'i' },
+			{ "family", 1, 0, ARG_FAMILY },
+			{ "mtu", 1, 0, ARG_MTU },
+			{ "txqlen", 1, 0, ARG_TXQLEN },
+			{ "weight", 1, 0, ARG_WEIGHT },
+			{ 0, 0, 0, 0 }
+		};
+
+		c = getopt_long(argc, argv, "f:hvn:i:", long_opts, &optidx);
+		if (c == -1)
+			break;
+
+		switch (c) {
+		case 'f': params.dp_type = nl_cli_parse_dumptype(optarg); break;
+		case 'h': print_usage(); break;
+		case 'v': nl_cli_print_version(); break;
+		case 'n': nl_cli_link_parse_name(link, optarg); break;
+		case 'i': nl_cli_link_parse_ifindex(link, optarg); break;
+		case ARG_FAMILY: nl_cli_link_parse_family(link, optarg); break;
+		case ARG_MTU: nl_cli_link_parse_mtu(link, optarg); break;
+		case ARG_TXQLEN: nl_cli_link_parse_txqlen(link, optarg); break;
+		case ARG_WEIGHT: nl_cli_link_parse_weight(link, optarg); break;
+		}
+	}
+
+	nl_cache_dump_filter(link_cache, &params, OBJ_CAST(link));
+
+	return 0;
+}
diff -uNr libnl_kk/src/nl-link-name2ifindex.c libnl/src/nl-link-name2ifindex.c
--- libnl_kk/src/nl-link-name2ifindex.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/nl-link-name2ifindex.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,41 @@
+/*
+ * src/nl-link-name2ifindex.c     Transform a interface name to its index
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2008 Thomas Graf <tgraf@suug.ch>
+ */
+
+#include <netlink/cli/utils.h>
+#include <netlink/cli/link.h>
+
+static void print_usage(void)
+{
+	printf("Usage: nl-link-ifindex2name <ifindex>\n");
+	exit(0);
+}
+
+int main(int argc, char *argv[])
+{
+	struct nl_sock *sock;
+	struct nl_cache *link_cache;
+	uint32_t ifindex;
+
+	if (argc < 2)
+		print_usage();
+
+	sock = nl_cli_alloc_socket();
+	nl_cli_connect(sock, NETLINK_ROUTE);
+	link_cache = nl_cli_link_alloc_cache(sock);
+
+	if (!(ifindex = rtnl_link_name2i(link_cache, argv[1])))
+		nl_cli_fatal(ENOENT, "Interface \"%s\" does not exist",
+			     argv[1]);
+
+	printf("%u\n", ifindex);
+
+	return 0;
+}
diff -uNr libnl_kk/src/nl-link-set.c libnl/src/nl-link-set.c
--- libnl_kk/src/nl-link-set.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/nl-link-set.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,124 @@
+/*
+ * src/nl-link-set.c     Set link attributes
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#include <netlink/cli/utils.h>
+#include <netlink/cli/link.h>
+
+static struct nl_sock *sock;
+static int quiet = 0;
+
+#if 0
+	"  changes := [link LINK]\n"
+	"             [master MASTER] [qdisc QDISC] [addr ADDR] [broadcast BRD]\n"
+	"             [{ up | down }] [{ arp | noarp }] [{ promisc | nopromisc }]\n"
+	"             [{ dynamic | nodynamic }] [{ multicast | nomulticast }]\n"
+	"             [{ trailers | notrailers }] [{ allmulticast | noallmulticast }]\n");
+#endif
+
+static void print_usage(void)
+{
+	printf(
+	"Usage: nl-link-set [OPTION]... [LINK]\n"
+	"\n"
+	"Options\n"
+	" -q, --quiet		Do not print informal notifications\n"
+	" -h, --help            Show this help\n"
+	" -v, --version         Show versioning information\n"
+	"\n"
+	"Selecting the Link\n"
+	" -n, --name=NAME	link name\n"
+	" -i, --index           interface index\n"
+	"Change Options\n"
+	"     --rename=NAME     rename interface\n"
+	"     --mtu=NUM         MTU value\n"
+	"     --txqlen=NUM      TX queue length\n"
+	"     --weight=NUM      weight\n"
+	);
+	exit(0);
+}
+
+static void set_cb(struct nl_object *obj, void *arg)
+{
+	struct rtnl_link *link = nl_object_priv(obj);
+	struct rtnl_link *change = arg;
+	struct nl_dump_params params = {
+		.dp_type = NL_DUMP_LINE,
+		.dp_fd = stdout,
+	};
+	int err;
+
+	if ((err = rtnl_link_change(sock, link, change, 0) < 0))
+		nl_cli_fatal(err, "Unable to change link: %s",
+			     nl_geterror(err));
+
+	if (!quiet) {
+		printf("Changed ");
+		nl_object_dump(OBJ_CAST(link), &params);
+	}
+}
+
+int main(int argc, char *argv[])
+{
+	struct nl_cache *link_cache;
+	struct rtnl_link *link, *change;
+	int ok = 0;
+
+	sock = nl_cli_alloc_socket();
+	nl_cli_connect(sock, NETLINK_ROUTE);
+	link_cache = nl_cli_link_alloc_cache(sock);
+	link = nl_cli_link_alloc();
+	change = nl_cli_link_alloc();
+
+	for (;;) {
+		int c, optidx = 0;
+		enum {
+			ARG_RENAME = 257,
+			ARG_MTU = 258,
+			ARG_TXQLEN,
+			ARG_WEIGHT,
+		};
+		static struct option long_opts[] = {
+			{ "quiet", 0, 0, 'q' },
+			{ "help", 0, 0, 'h' },
+			{ "version", 0, 0, 'v' },
+			{ "name", 1, 0, 'n' },
+			{ "index", 1, 0, 'i' },
+			{ "rename", 1, 0, ARG_RENAME },
+			{ "mtu", 1, 0, ARG_MTU },
+			{ "txqlen", 1, 0, ARG_TXQLEN },
+			{ "weight", 1, 0, ARG_WEIGHT },
+			{ 0, 0, 0, 0 }
+		};
+
+		c = getopt_long(argc, argv, "qhvn:i:", long_opts, &optidx);
+		if (c == -1)
+			break;
+
+		switch (c) {
+		case 'q': quiet = 1; break;
+		case 'h': print_usage(); break;
+		case 'v': nl_cli_print_version(); break;
+		case 'n': ok++; nl_cli_link_parse_name(link, optarg); break;
+		case 'i': ok++; nl_cli_link_parse_ifindex(link, optarg); break;
+		case ARG_RENAME: nl_cli_link_parse_name(change, optarg); break;
+		case ARG_MTU: nl_cli_link_parse_mtu(link, optarg); break;
+		case ARG_TXQLEN: nl_cli_link_parse_txqlen(link, optarg); break;
+		case ARG_WEIGHT: nl_cli_link_parse_weight(link, optarg); break;
+		}
+	}
+
+	if (!ok)
+		print_usage();
+
+	nl_cache_foreach_filter(link_cache, OBJ_CAST(link), set_cb, change);
+
+	return 0;
+}
diff -uNr libnl_kk/src/nl-link-stats.c libnl/src/nl-link-stats.c
--- libnl_kk/src/nl-link-stats.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/nl-link-stats.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,119 @@
+/*
+ * src/nl-link-stats.c     Retrieve link statistics
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#include <netlink/cli/utils.h>
+#include <netlink/cli/link.h>
+
+static void print_usage(void)
+{
+	printf(
+	"Usage: nl-link-stats [OPTION]... [LINK] [ListOfStats]\n"
+	"\n"
+	"Options\n"
+	" -l, --list            List available statistic names\n"
+	" -h, --help            Show this help\n"
+	" -v, --version         Show versioning information\n"
+	"\n"
+	"Link Options\n"
+	" -n, --name=NAME	link name\n"
+	" -i, --index=NUM       interface index\n"
+	);
+	exit(0);
+}
+
+static void list_stat_names(void)
+{
+	char buf[64];
+	int i;
+
+	for (i = 0; i < RTNL_LINK_STATS_MAX; i++)
+		printf("%s\n", rtnl_link_stat2str(i, buf, sizeof(buf)));
+
+	exit(0);
+}
+
+static int gargc;
+
+static void dump_stat(struct rtnl_link *link, int id)
+{
+	uint64_t st = rtnl_link_get_stat(link, id);
+	char buf[64];
+
+	printf("%s.%s %" PRIu64 "\n", rtnl_link_get_name(link),
+	       rtnl_link_stat2str(id, buf, sizeof(buf)), st);
+}
+
+static void dump_stats(struct nl_object *obj, void *arg)
+{
+	struct rtnl_link *link = (struct rtnl_link *) obj;
+	char **argv = arg;
+
+	if (optind >= gargc) {
+		int i;
+
+		for (i = 0; i < RTNL_LINK_STATS_MAX; i++)
+			dump_stat(link, i);
+	} else {
+		while (optind < gargc) {
+			int id = rtnl_link_str2stat(argv[optind]);
+
+			if (id < 0)
+				fprintf(stderr, "Warning: Unknown statistic "
+					"\"%s\"\n", argv[optind]);
+			else
+				dump_stat(link, id);
+
+			optind++;
+		}
+	}
+}
+
+int main(int argc, char *argv[])
+{
+	struct nl_sock *sock;
+	struct nl_cache *link_cache;
+	struct rtnl_link *link;
+
+	sock = nl_cli_alloc_socket();
+	nl_cli_connect(sock, NETLINK_ROUTE);
+	link_cache = nl_cli_link_alloc_cache(sock);
+	link = nl_cli_link_alloc();
+
+	for (;;) {
+		int c, optidx = 0;
+		static struct option long_opts[] = {
+			{ "list", 0, 0, 'l' },
+			{ "help", 0, 0, 'h' },
+			{ "version", 0, 0, 'v' },
+			{ "name", 1, 0, 'n' },
+			{ "index", 1, 0, 'i' },
+			{ 0, 0, 0, 0 }
+		};
+
+		c = getopt_long(argc, argv, "lhvn:i:", long_opts, &optidx);
+		if (c == -1)
+			break;
+
+		switch (c) {
+		case 'l': list_stat_names(); break;
+		case 'h': print_usage(); break;
+		case 'v': nl_cli_print_version(); break;
+		case 'n': nl_cli_link_parse_name(link, optarg); break;
+		case 'i': nl_cli_link_parse_ifindex(link, optarg); break;
+		}
+	}
+
+	gargc = argc;
+	nl_cache_foreach_filter(link_cache, OBJ_CAST(link), dump_stats, argv);
+
+	return 0;
+}
+
diff -uNr libnl_kk/src/nl-list-caches.c libnl/src/nl-list-caches.c
--- libnl_kk/src/nl-list-caches.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/nl-list-caches.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,118 @@
+/*
+ * nl-list-caches.c	List registered cache types
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#include <netlink-local.h>
+#include <netlink/cli/utils.h>
+
+static void print_usage(void)
+{
+	fprintf(stderr, "Usage: nl-list-caches\n");
+	exit(1);
+}
+
+static char *id_attr_list(struct nl_object_ops *ops, char *buf, size_t len)
+{
+	if (ops->oo_attrs2str != NULL)
+		return ops->oo_attrs2str(ops->oo_id_attrs, buf, len);
+	else {
+		memset(buf, 0, len);
+		return buf;
+	}
+}
+
+static void print(struct nl_cache_ops *ops, void *arg)
+{
+	char buf[64];
+
+	printf("%s:\n" \
+	       "    hdrsize: %d bytes\n" \
+	       "    protocol: %s\n" \
+	       "    request-update: %s\n" \
+	       "    msg-parser: %s\n",
+	       ops->co_name, ops->co_hdrsize,
+	       nl_nlfamily2str(ops->co_protocol, buf, sizeof(buf)),
+	       ops->co_request_update ? "yes" : "no",
+	       ops->co_msg_parser ? "yes" : "no");
+
+	if (ops->co_obj_ops) {
+		struct nl_object_ops *obj_ops = ops->co_obj_ops;
+		const char *dump_names[NL_DUMP_MAX+1] = {
+			"brief",
+			"detailed",
+			"stats",
+			"env",
+		};
+		int i;
+
+		printf("    cacheable object:\n" \
+		       "        name: %s:\n" \
+		       "        size: %zu bytes\n" \
+		       "        constructor: %s\n" \
+		       "        free-data: %s\n" \
+		       "        clone: %s\n" \
+		       "        compare: %s\n" \
+		       "        id attributes: %s\n" \
+		       "        dump: ",
+		       obj_ops->oo_name, obj_ops->oo_size,
+		       obj_ops->oo_constructor ? "yes" : "no",
+		       obj_ops->oo_free_data ? "yes" : "no",
+		       obj_ops->oo_clone ? "yes" : "no",
+		       obj_ops->oo_compare ? "yes" : "no",
+		       id_attr_list(obj_ops, buf, sizeof(buf)));
+
+		for (i = 0; i <= NL_DUMP_MAX; i++)
+			if (obj_ops->oo_dump[i])
+				printf("%s%s",
+				i == 0 ? "" : ", ",
+				dump_names[i]);
+
+		printf("\n");
+	}
+
+	if (ops->co_genl) {
+		struct genl_ops *genl_ops = ops->co_genl;
+
+		printf("    genl:\n" \
+		       "        name: %s\n" \
+		       "        family: %d\n" \
+		       "        id: %d\n",
+		       genl_ops->o_name, genl_ops->o_family, genl_ops->o_id);
+
+		if (genl_ops->o_ncmds) {
+			int i;
+
+			printf("        cmds:\n");
+
+			for (i = 0; i < genl_ops->o_ncmds; i++) {
+				struct genl_cmd *cmd = &genl_ops->o_cmds[i];
+
+				printf("            %s:\n"
+				       "                id: %d\n" \
+				       "                maxattr: %d\n" \
+				       "                msg-parser: %s\n" \
+				       "                attr-policy: %s\n",
+				       cmd->c_name, cmd->c_id, cmd->c_maxattr,
+				       cmd->c_msg_parser ? "yes" : "no",
+				       cmd->c_attr_policy ? "yes" : "no");
+			}
+		}
+	}
+}
+
+int main(int argc, char *argv[])
+{
+	if (argc > 1 && !strcasecmp(argv[1], "-h"))
+		print_usage();
+
+	nl_cache_ops_foreach(print, NULL);
+
+	return 0;
+}
diff -uNr libnl_kk/src/nl-list-sockets.c libnl/src/nl-list-sockets.c
--- libnl_kk/src/nl-list-sockets.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/nl-list-sockets.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,49 @@
+/*
+ * nl-list-sockets.c	Pretty-print /proc/net/netlink
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#include <netlink/cli/utils.h>
+
+#define PROC_NETLINK "/proc/net/netlink"
+
+int main(int argc, char *argv[])
+{
+	FILE *fd;
+	char buf[2048], p[64];
+
+	fd = fopen(PROC_NETLINK, "r");
+	if (fd == NULL) {
+		perror("fopen");
+		return -1;
+	}
+
+	printf("Address            Family           PID    Groups   rmem   "
+	       "wmem   CB         refcnt\n");
+
+	while (fgets(buf, sizeof(buf), fd)) {
+		unsigned long sk, cb;
+		int ret, proto, pid, rmem, wmem, refcnt;
+		uint32_t groups;
+		
+		ret = sscanf(buf, "%lx %d %d %08x %d %d %lx %d\n",
+			     &sk, &proto, &pid, &groups, &rmem, &wmem,
+			     &cb, &refcnt);
+		if (ret != 8)
+			continue;
+		
+		printf("0x%016lx %-16s %-6d %08x %-6d %-6d 0x%08lx %d\n",
+			sk, nl_nlfamily2str(proto, p, sizeof(p)), pid,
+			groups, rmem, wmem, cb, refcnt);
+	}
+
+	fclose(fd);
+
+	return 0;
+}
diff -uNr libnl_kk/src/nl-monitor.c libnl/src/nl-monitor.c
--- libnl_kk/src/nl-monitor.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/nl-monitor.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,115 @@
+/*
+ * src/nl-monitor.c     Monitor events
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#include <netlink/cli/utils.h>
+#include <netlink/cli/link.h>
+
+static void obj_input(struct nl_object *obj, void *arg)
+{
+	struct nl_dump_params dp = {
+		.dp_type = NL_DUMP_STATS,
+		.dp_fd = stdout,
+		.dp_dump_msgtype = 1,
+	};
+
+	nl_object_dump(obj, &dp);
+}
+
+static int event_input(struct nl_msg *msg, void *arg)
+{
+	if (nl_msg_parse(msg, &obj_input, NULL) < 0)
+		fprintf(stderr, "<<EVENT>> Unknown message type\n");
+
+	/* Exit nl_recvmsgs_def() and return to the main select() */
+	return NL_STOP;
+}
+
+int main(int argc, char *argv[])
+{
+	struct nl_sock *sock;
+	struct nl_cache *link_cache;
+	int err = 1;
+	int i, idx;
+
+	static const struct {
+		enum rtnetlink_groups gr_id;
+		const char* gr_name;
+	} known_groups[] = {
+		{ RTNLGRP_LINK, "link" },
+		{ RTNLGRP_NOTIFY, "notify" },
+		{ RTNLGRP_NEIGH, "neigh" },
+		{ RTNLGRP_TC, "tc" },
+		{ RTNLGRP_IPV4_IFADDR, "ipv4-ifaddr" },
+		{ RTNLGRP_IPV4_MROUTE, "ipv4-mroute" },
+		{ RTNLGRP_IPV4_ROUTE, "ipv4-route" },
+		{ RTNLGRP_IPV6_IFADDR, "ipv6-ifaddr" },
+		{ RTNLGRP_IPV6_MROUTE, "ipv6-mroute" },
+		{ RTNLGRP_IPV6_ROUTE, "ipv6-route" },
+		{ RTNLGRP_IPV6_IFINFO, "ipv6-ifinfo" },
+		{ RTNLGRP_DECnet_IFADDR, "decnet-ifaddr" },
+		{ RTNLGRP_DECnet_ROUTE, "decnet-route" },
+		{ RTNLGRP_IPV6_PREFIX, "ipv6-prefix" },
+		{ RTNLGRP_NONE, NULL }
+	};
+
+	sock = nl_cli_alloc_socket();
+	nl_socket_disable_seq_check(sock);
+	nl_socket_modify_cb(sock, NL_CB_VALID, NL_CB_CUSTOM, event_input, NULL);
+
+	if (argc > 1 && !strcasecmp(argv[1], "-h")) {
+		printf("Usage: nl-monitor [<groups>]\n");
+
+		printf("Known groups:");
+		for (i = 0; known_groups[i].gr_id != RTNLGRP_NONE; i++)
+			printf(" %s", known_groups[i].gr_name);
+		printf("\n");
+		return 2;
+	}
+
+	nl_cli_connect(sock, NETLINK_ROUTE);
+
+	for (idx = 1; argc > idx; idx++) {
+		for (i = 0; known_groups[i].gr_id != RTNLGRP_NONE; i++) {
+			if (!strcmp(argv[idx], known_groups[i].gr_name)) {
+
+				if ((err = nl_socket_add_membership(sock, known_groups[i].gr_id)) < 0) {
+					nl_cli_fatal(err, "%s: %s\n", argv[idx],
+						     nl_geterror(err));
+				}
+
+				break;
+			}
+		}
+		if (known_groups[i].gr_id == RTNLGRP_NONE)
+			fprintf(stderr, "Warning: Unknown group: %s\n", argv[idx]);
+	}
+
+	link_cache = nl_cli_link_alloc_cache(sock);
+
+	while (1) {
+		fd_set rfds;
+		int fd, retval;
+
+		fd = nl_socket_get_fd(sock);
+
+		FD_ZERO(&rfds);
+		FD_SET(fd, &rfds);
+		/* wait for an incoming message on the netlink socket */
+		retval = select(fd+1, &rfds, NULL, NULL, NULL);
+
+		if (retval) {
+			/* FD_ISSET(fd, &rfds) will be true */
+			nl_recvmsgs_default(sock);
+		}
+	}
+
+	return 0;
+}
diff -uNr libnl_kk/src/nl-neigh-add.c libnl/src/nl-neigh-add.c
--- libnl_kk/src/nl-neigh-add.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/nl-neigh-add.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,110 @@
+/*
+ * src/ nl-neigh-add.c     Add a neighbour
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#include <netlink/cli/utils.h>
+#include <netlink/cli/neigh.h>
+#include <netlink/cli/link.h>
+
+static int quiet = 0;
+
+static void print_usage(void)
+{
+	printf(
+	"Usage: nl-neigh-add [OPTION]... NEIGHBOUR\n"
+	"\n"
+	"Options\n"
+	"     --update-only     Do not create neighbour, updates exclusively\n"
+	"     --create-only     Do not update neighbour if it exists already.\n"
+	" -q, --quiet           Do not print informal notifications\n"
+	" -h, --help            Show this help\n"
+	" -v, --version         Show versioning information\n"
+	"\n"
+	"Neighbour Options\n"
+	" -a, --addr=ADDR       Destination address of neighbour\n"
+	" -l, --lladdr=ADDR     Link layer address of neighbour\n"
+	" -d, --dev=DEV         Device the neighbour is connected to\n"
+	"     --state=STATE     Neighbour state, (default = permanent)\n"
+	"\n"
+	"Example\n"
+	"  nl-neigh-add --create-only --addr=10.0.0.1 --dev=eth0 \\\n"
+	"               --lladdr=AA:BB:CC:DD:EE:FF\n"
+	);
+
+	exit(0);
+}
+
+int main(int argc, char *argv[])
+{
+	struct nl_sock *sock;
+	struct rtnl_neigh *neigh;
+	struct nl_cache *link_cache;
+	struct nl_dump_params dp = {
+		.dp_type = NL_DUMP_LINE,
+		.dp_fd = stdout,
+	};
+	int err, ok = 0, nlflags = NLM_F_REPLACE | NLM_F_CREATE;
+ 
+	sock = nl_cli_alloc_socket();
+	nl_cli_connect(sock, NETLINK_ROUTE);
+	link_cache = nl_cli_link_alloc_cache(sock);
+ 	neigh = nl_cli_neigh_alloc();
+ 
+	for (;;) {
+		int c, optidx = 0;
+		enum {
+			ARG_UPDATE_ONLY = 257,
+			ARG_CREATE_ONLY = 258,
+			ARG_STATE,
+		};
+		static struct option long_opts[] = {
+			{ "update-only", 0, 0, ARG_UPDATE_ONLY },
+			{ "create-only", 0, 0, ARG_CREATE_ONLY },
+			{ "quiet", 0, 0, 'q' },
+			{ "help", 0, 0, 'h' },
+			{ "version", 0, 0, 'v' },
+			{ "addr", 1, 0, 'a' },
+			{ "lladdr", 1, 0, 'l' },
+			{ "dev", 1, 0, 'd' },
+			{ "state", 1, 0, ARG_STATE },
+			{ 0, 0, 0, 0 }
+		};
+	
+		c = getopt_long(argc, argv, "qhva:l:d:", long_opts, &optidx);
+		if (c == -1)
+			break;
+
+		switch (c) {
+		case ARG_UPDATE_ONLY: nlflags &= ~NLM_F_CREATE; break;
+		case ARG_CREATE_ONLY: nlflags |= NLM_F_EXCL; break;
+		case 'q': quiet = 1; break;
+		case 'h': print_usage(); break;
+		case 'v': nl_cli_print_version(); break;
+		case 'a': ok++; nl_cli_neigh_parse_dst(neigh, optarg); break;
+		case 'l': nl_cli_neigh_parse_lladdr(neigh, optarg); break;
+		case 'd': nl_cli_neigh_parse_dev(neigh, link_cache, optarg); break;
+		case ARG_STATE: nl_cli_neigh_parse_state(neigh, optarg); break;
+		}
+ 	}
+
+	if (!ok)
+		print_usage();
+
+	if ((err = rtnl_neigh_add(sock, neigh, nlflags)) < 0)
+		nl_cli_fatal(err, "Unable to add neighbour: %s",
+			     nl_geterror(err));
+
+	if (!quiet) {
+		printf("Added ");
+		nl_object_dump(OBJ_CAST(neigh), &dp);
+ 	}
+
+	return 0;
+}
diff -uNr libnl_kk/src/nl-neigh-delete.c libnl/src/nl-neigh-delete.c
--- libnl_kk/src/nl-neigh-delete.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/nl-neigh-delete.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,122 @@
+/*
+ * src/nl-neigh-delete.c     Delete a neighbour
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#include <netlink/cli/utils.h>
+#include <netlink/cli/neigh.h>
+#include <netlink/cli/link.h>
+
+static int quiet = 0, default_yes = 0, deleted = 0, interactive = 0;
+struct nl_sock *sock;
+
+static void print_usage(void)
+{
+	printf(
+	"Usage: nl-neigh-delete [OPTION]... [NEIGHBOUR]\n"
+	"\n"
+	"Options\n"
+	" -i, --interactive     Run interactively\n"
+	"     --yes             Set default answer to yes\n"
+	" -q, --quiet           Do not print informal notifications\n"
+	" -h, --help            Show this help\n"
+	" -v, --version         Show versioning information\n"
+	"\n"
+	"Neighbour Options\n"
+	" -a, --addr=ADDR       Destination address of neighbour\n"
+	" -l, --lladdr=ADDR     Link layer address of neighbour\n"
+	" -d, --dev=DEV         Device the neighbour is connected to\n"
+	"     --family=FAMILY   Destination address family\n"
+	"     --state=STATE     Neighbour state, (default = permanent)\n"
+	);
+
+	exit(0);
+}
+
+static void delete_cb(struct nl_object *obj, void *arg)
+{
+	struct rtnl_neigh *neigh = nl_object_priv(obj);
+	struct nl_dump_params params = {
+		.dp_type = NL_DUMP_LINE,
+		.dp_fd = stdout,
+	};
+	int err;
+
+	if (interactive && !nl_cli_confirm(obj, &params, default_yes))
+		return;
+
+	if ((err = rtnl_neigh_delete(sock, neigh, 0)) < 0)
+		nl_cli_fatal(err, "Unable to delete neighbour: %s\n",
+			     nl_geterror(err));
+
+	if (!quiet) {
+		printf("Deleted ");
+		nl_object_dump(obj, &params);
+	}
+
+	deleted++;
+}
+
+int main(int argc, char *argv[])
+{
+	struct rtnl_neigh *neigh;
+	struct nl_cache *link_cache, *neigh_cache;
+ 
+	sock = nl_cli_alloc_socket();
+	nl_cli_connect(sock, NETLINK_ROUTE);
+	link_cache = nl_cli_link_alloc_cache(sock);
+	neigh_cache = nl_cli_neigh_alloc_cache(sock);
+ 	neigh = nl_cli_neigh_alloc();
+ 
+	for (;;) {
+		int c, optidx = 0;
+		enum {
+			ARG_FAMILY = 257,
+			ARG_STATE = 258,
+			ARG_YES,
+		};
+		static struct option long_opts[] = {
+			{ "interactive", 0, 0, 'i' },
+			{ "yes", 0, 0, ARG_YES },
+			{ "quiet", 0, 0, 'q' },
+			{ "help", 0, 0, 'h' },
+			{ "version", 0, 0, 'v' },
+			{ "addr", 1, 0, 'a' },
+			{ "lladdr", 1, 0, 'l' },
+			{ "dev", 1, 0, 'd' },
+			{ "family", 1, 0, ARG_FAMILY },
+			{ "state", 1, 0, ARG_STATE },
+			{ 0, 0, 0, 0 }
+		};
+	
+		c = getopt_long(argc, argv, "qhva:l:d:", long_opts, &optidx);
+		if (c == -1)
+			break;
+
+		switch (c) {
+		case 'i': interactive = 1; break;
+		case ARG_YES: default_yes = 1; break;
+		case 'q': quiet = 1; break;
+		case 'h': print_usage(); break;
+		case 'v': nl_cli_print_version(); break;
+		case 'a': nl_cli_neigh_parse_dst(neigh, optarg); break;
+		case 'l': nl_cli_neigh_parse_lladdr(neigh, optarg); break;
+		case 'd': nl_cli_neigh_parse_dev(neigh, link_cache, optarg); break;
+		case ARG_FAMILY: nl_cli_neigh_parse_family(neigh, optarg); break;
+		case ARG_STATE: nl_cli_neigh_parse_state(neigh, optarg); break;
+		}
+ 	}
+
+	nl_cache_foreach_filter(neigh_cache, OBJ_CAST(neigh), delete_cb, NULL);
+
+	if (!quiet)
+		printf("Deleted %d neighbours\n", deleted);
+
+	return 0;
+}
diff -uNr libnl_kk/src/nl-neigh-list.c libnl/src/nl-neigh-list.c
--- libnl_kk/src/nl-neigh-list.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/nl-neigh-list.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,89 @@
+/*
+ * src/nl-neigh-list.c      List Neighbours
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#include <netlink/cli/utils.h>
+#include <netlink/cli/neigh.h>
+#include <netlink/cli/link.h>
+
+static void print_usage(void)
+{
+	printf(
+	"Usage: nl-neigh-list [OPTION]... [NEIGHBOUR]\n"
+	"\n"
+	"Options\n"
+	" -f, --format=TYPE     Output format { brief | details | stats }\n"
+	" -h, --help            Show this help\n"
+	" -v, --version         Show versioning information\n"
+	"\n"
+	"Neighbour Options\n"
+	" -a, --addr=ADDR       Destination address of neighbour\n"
+	" -l, --lladdr=ADDR     Link layer address of neighbour\n"
+	" -d, --dev=DEV         Device the neighbour is connected to\n"
+	"     --family=FAMILY   Destination address family\n"
+	"     --state=STATE     Neighbour state, (default = permanent)\n"
+	);
+	exit(0);
+}
+
+int main(int argc, char *argv[])
+{
+	struct nl_sock *sock;
+	struct rtnl_neigh *neigh;
+	struct nl_cache *link_cache, *neigh_cache;
+	struct nl_dump_params params = {
+		.dp_type = NL_DUMP_LINE,
+		.dp_fd = stdout,
+	};
+ 
+	sock = nl_cli_alloc_socket();
+	nl_cli_connect(sock, NETLINK_ROUTE);
+	link_cache = nl_cli_link_alloc_cache(sock);
+	neigh_cache = nl_cli_neigh_alloc_cache(sock);
+ 	neigh = nl_cli_neigh_alloc();
+ 
+	for (;;) {
+		int c, optidx = 0;
+		enum {
+			ARG_FAMILY = 257,
+			ARG_STATE = 258,
+		};
+		static struct option long_opts[] = {
+			{ "format", 1, 0, 'f' },
+			{ "help", 0, 0, 'h' },
+			{ "version", 0, 0, 'v' },
+			{ "addr", 1, 0, 'a' },
+			{ "lladdr", 1, 0, 'l' },
+			{ "dev", 1, 0, 'd' },
+			{ "family", 1, 0, ARG_FAMILY },
+			{ "state", 1, 0, ARG_STATE },
+			{ 0, 0, 0, 0 }
+		};
+	
+		c = getopt_long(argc, argv, "f:hva:l:d:", long_opts, &optidx);
+		if (c == -1)
+			break;
+
+		switch (c) {
+		case 'f': params.dp_type = nl_cli_parse_dumptype(optarg); break;
+		case 'h': print_usage(); break;
+		case 'v': nl_cli_print_version(); break;
+		case 'a': nl_cli_neigh_parse_dst(neigh, optarg); break;
+		case 'l': nl_cli_neigh_parse_lladdr(neigh, optarg); break;
+		case 'd': nl_cli_neigh_parse_dev(neigh, link_cache, optarg); break;
+		case ARG_FAMILY: nl_cli_neigh_parse_family(neigh, optarg); break;
+		case ARG_STATE: nl_cli_neigh_parse_state(neigh, optarg); break;
+		}
+ 	}
+
+	nl_cache_dump_filter(neigh_cache, &params, OBJ_CAST(neigh));
+
+	return 0;
+}
diff -uNr libnl_kk/src/nl-neightbl-list.c libnl/src/nl-neightbl-list.c
--- libnl_kk/src/nl-neightbl-list.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/nl-neightbl-list.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,66 @@
+/*
+ * src/nl-neightbl-list.c     Dump neighbour tables
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#include <netlink/cli/utils.h>
+#include <netlink/cli/link.h>
+
+static void print_usage(void)
+{
+	printf(
+	"Usage: nl-neightbl-list [OPTION]...\n"
+	"\n"
+	"Options\n"
+	" -f, --format=TYPE     Output format { brief | details | stats }\n"
+	" -h, --help            Show this help\n"
+	" -v, --version         Show versioning information\n"
+	);
+	exit(0);
+}
+
+int main(int argc, char *argv[])
+{
+	struct nl_sock *sock;
+	struct nl_cache *link_cache, *neightbl_cache;
+	struct nl_dump_params params = {
+		.dp_type = NL_DUMP_LINE,
+		.dp_fd = stdout,
+	};
+ 
+	sock = nl_cli_alloc_socket();
+	nl_cli_connect(sock, NETLINK_ROUTE);
+	link_cache = nl_cli_link_alloc_cache(sock);
+	neightbl_cache = nl_cli_alloc_cache(sock, "neighbour table",
+					    rtnl_neightbl_alloc_cache);
+ 
+	for (;;) {
+		int c, optidx = 0;
+		static struct option long_opts[] = {
+			{ "format", 1, 0, 'f' },
+			{ "help", 0, 0, 'h' },
+			{ "version", 0, 0, 'v' },
+			{ 0, 0, 0, 0 }
+		};
+	
+		c = getopt_long(argc, argv, "f:hv", long_opts, &optidx);
+		if (c == -1)
+			break;
+
+		switch (c) {
+		case 'f': params.dp_type = nl_cli_parse_dumptype(optarg); break;
+		case 'h': print_usage(); break;
+		case 'v': nl_cli_print_version(); break;
+		}
+ 	}
+
+	nl_cache_dump(neightbl_cache, &params);
+
+	return 0;
+}
diff -uNr libnl_kk/src/nl-pktloc-lookup.c libnl/src/nl-pktloc-lookup.c
--- libnl_kk/src/nl-pktloc-lookup.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/nl-pktloc-lookup.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,37 @@
+/*
+ * src/nl-pktloc-lookup.c     Lookup packet location alias
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2010 Thomas Graf <tgraf@suug.ch>
+ */
+
+#include <netlink/cli/utils.h>
+#include <netlink/route/pktloc.h>
+
+static void print_usage(void)
+{
+	printf("Usage: nl-pktloc-lookup <name>\n");
+	exit(0);
+}
+
+int main(int argc, char *argv[])
+{
+	struct rtnl_pktloc *loc;
+	int err;
+
+	if (argc < 2)
+		print_usage();
+
+	if ((err = rtnl_pktloc_lookup(argv[1], &loc)) < 0)
+		nl_cli_fatal(err, "Unable to lookup packet location: %s",
+			nl_geterror(err));
+
+	printf("%s: %u %u+%u 0x%x %u\n", loc->name, loc->align,
+		loc->layer, loc->offset, loc->mask, loc->flags);
+
+	return 0;
+}
diff -uNr libnl_kk/src/nl-qdisc-delete.c libnl/src/nl-qdisc-delete.c
--- libnl_kk/src/nl-qdisc-delete.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/nl-qdisc-delete.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,116 @@
+/*
+ * src/nl-qdisc-delete.c     Delete Queuing Disciplines
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#include <netlink/cli/utils.h>
+#include <netlink/cli/qdisc.h>
+#include <netlink/cli/link.h>
+
+static int quiet = 0, default_yes = 0, deleted = 0, interactive = 0;
+struct nl_sock *sock;
+
+static void print_usage(void)
+{
+	printf(
+	"Usage: nl-qdisc-delete [OPTION]... [QDISC]\n"
+	"\n"
+	"Options\n"
+	" -i, --interactive     Run interactively\n"
+	"     --yes             Set default answer to yes\n"
+	" -q, --quiet           Do not print informal notifications\n"
+	" -h, --help            Show this help\n"
+	" -v, --version         Show versioning information\n"
+	"\n"
+	"QDisc Options\n"
+	" -d, --dev=DEV         Device the qdisc is attached to\n"
+	" -p, --parent=HANDLE   Identifier of parent qdisc\n"
+	" -H, --handle=HANDLE   Identifier\n"
+	" -k, --kind=NAME       Kind of qdisc (e.g. pfifo_fast)\n"
+	);
+
+	exit(0);
+}
+
+static void delete_cb(struct nl_object *obj, void *arg)
+{
+	struct rtnl_qdisc *qdisc = nl_object_priv(obj);
+	struct nl_dump_params params = {
+		.dp_type = NL_DUMP_LINE,
+		.dp_fd = stdout,
+	};
+	int err;
+
+	if (interactive && !nl_cli_confirm(obj, &params, default_yes))
+		return;
+
+	if ((err = rtnl_qdisc_delete(sock, qdisc)) < 0)
+		nl_cli_fatal(err, "Unable to delete qdisc: %s\n", nl_geterror(err));
+
+	if (!quiet) {
+		printf("Deleted ");
+		nl_object_dump(obj, &params);
+	}
+
+	deleted++;
+}
+
+int main(int argc, char *argv[])
+{
+	struct rtnl_qdisc *qdisc;
+	struct nl_cache *link_cache, *qdisc_cache;
+ 
+	sock = nl_cli_alloc_socket();
+	nl_cli_connect(sock, NETLINK_ROUTE);
+	link_cache = nl_cli_link_alloc_cache(sock);
+	qdisc_cache = nl_cli_qdisc_alloc_cache(sock);
+ 	qdisc = nl_cli_qdisc_alloc();
+ 
+	for (;;) {
+		int c, optidx = 0;
+		enum {
+			ARG_YES = 257,
+		};
+		static struct option long_opts[] = {
+			{ "interactive", 0, 0, 'i' },
+			{ "yes", 0, 0, ARG_YES },
+			{ "quiet", 0, 0, 'q' },
+			{ "help", 0, 0, 'h' },
+			{ "version", 0, 0, 'v' },
+			{ "dev", 1, 0, 'd' },
+			{ "parent", 1, 0, 'p' },
+			{ "handle", 1, 0, 'H' },
+			{ "kind", 1, 0, 'k' },
+			{ 0, 0, 0, 0 }
+		};
+	
+		c = getopt_long(argc, argv, "iqhvd:p:H:k:", long_opts, &optidx);
+		if (c == -1)
+			break;
+
+		switch (c) {
+		case 'i': interactive = 1; break;
+		case ARG_YES: default_yes = 1; break;
+		case 'q': quiet = 1; break;
+		case 'h': print_usage(); break;
+		case 'v': nl_cli_print_version(); break;
+		case 'd': nl_cli_qdisc_parse_dev(qdisc, link_cache, optarg); break;
+		case 'p': nl_cli_qdisc_parse_parent(qdisc, optarg); break;
+		case 'H': nl_cli_qdisc_parse_handle(qdisc, optarg); break;
+		case 'k': nl_cli_qdisc_parse_kind(qdisc, optarg); break;
+		}
+ 	}
+
+	nl_cache_foreach_filter(qdisc_cache, OBJ_CAST(qdisc), delete_cb, NULL);
+
+	if (!quiet)
+		printf("Deleted %d qdiscs\n", deleted);
+
+	return 0;
+}
diff -uNr libnl_kk/src/nl-qdisc-list.c libnl/src/nl-qdisc-list.c
--- libnl_kk/src/nl-qdisc-list.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/nl-qdisc-list.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,90 @@
+/*
+ * src/nl-qdisc-list.c     List Qdiscs
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#include <netlink/cli/utils.h>
+#include <netlink/cli/qdisc.h>
+#include <netlink/cli/link.h>
+
+static int quiet = 0;
+
+static void print_usage(void)
+{
+	printf(
+	"Usage: nl-qdisc-list [OPTION]... [QDISC]\n"
+	"\n"
+	"Options\n"
+	" -f, --format=TYPE     Output format { brief | details | stats }\n"
+	" -h, --help            Show this help\n"
+	" -v, --version         Show versioning information\n"
+	"\n"
+	"QDisc Options\n"
+	" -d, --dev=DEV         Device the qdisc is attached to\n"
+	" -p, --parent=HANDLE   Identifier of parent qdisc\n"
+	" -H, --handle=HANDLE   Identifier\n"
+	" -k, --kind=NAME       Kind of qdisc (e.g. pfifo_fast)\n"
+	);
+	exit(0);
+}
+
+int main(int argc, char *argv[])
+{
+	struct nl_sock *sock;
+	struct rtnl_qdisc *qdisc;
+	struct nl_cache *link_cache, *qdisc_cache;
+	struct nl_dump_params params = {
+		.dp_type = NL_DUMP_LINE,
+		.dp_fd = stdout,
+	};
+ 
+	sock = nl_cli_alloc_socket();
+	nl_cli_connect(sock, NETLINK_ROUTE);
+	link_cache = nl_cli_link_alloc_cache(sock);
+	qdisc_cache = nl_cli_qdisc_alloc_cache(sock);
+ 	qdisc = nl_cli_qdisc_alloc();
+ 
+	for (;;) {
+		int c, optidx = 0;
+		enum {
+			ARG_YES = 257,
+		};
+		static struct option long_opts[] = {
+			{ "format", 1, 0, 'f' },
+			{ "quiet", 0, 0, 'q' },
+			{ "help", 0, 0, 'h' },
+			{ "version", 0, 0, 'v' },
+			{ "dev", 1, 0, 'd' },
+			{ "parent", 1, 0, 'p' },
+			{ "handle", 1, 0, 'H' },
+			{ "kind", 1, 0, 'k' },
+			{ 0, 0, 0, 0 }
+		};
+	
+		c = getopt_long(argc, argv, "f:qhvd:p:H:k:",
+				long_opts, &optidx);
+		if (c == -1)
+			break;
+
+		switch (c) {
+		case 'f': params.dp_type = nl_cli_parse_dumptype(optarg); break;
+		case 'q': quiet = 1; break;
+		case 'h': print_usage(); break;
+		case 'v': nl_cli_print_version(); break;
+		case 'd': nl_cli_qdisc_parse_dev(qdisc, link_cache, optarg); break;
+		case 'p': nl_cli_qdisc_parse_parent(qdisc, optarg); break;
+		case 'H': nl_cli_qdisc_parse_handle(qdisc, optarg); break;
+		case 'k': nl_cli_qdisc_parse_kind(qdisc, optarg); break;
+		}
+ 	}
+
+	nl_cache_dump_filter(qdisc_cache, &params, OBJ_CAST(qdisc));
+
+	return 0;
+}
diff -uNr libnl_kk/src/nl-route-add.c libnl/src/nl-route-add.c
--- libnl_kk/src/nl-route-add.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/nl-route-add.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,132 @@
+/*
+ * src/nl-route-add.c     Route addition utility
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#include <netlink/cli/utils.h>
+#include <netlink/cli/route.h>
+#include <netlink/cli/link.h>
+
+static int quiet = 0;
+static struct nl_cache *link_cache, *route_cache;
+
+static void print_usage(void)
+{
+	printf(
+	"Usage: nl-route-add [OPTION]... [ROUTE]\n"
+	"\n"
+	"Options\n"
+	" -q, --quiet		Do not print informal notifications\n"
+	" -h, --help            Show this help\n"
+	" -v, --version		Show versioning information\n"
+	"\n"
+	"Route Options\n"
+	" -d, --dst=ADDR        destination prefix, e.g. 10.10.0.0/16\n"
+	" -n, --nexthop=NH      nexthop configuration:\n"
+	"                         dev=DEV         route via device\n"
+	"                         weight=WEIGHT   weight of nexthop\n"
+	"                         flags=FLAGS\n"
+	"                         via=GATEWAY     route via other node\n"
+	"                         realms=REALMS\n"
+	"                         e.g. dev=eth0,via=192.168.1.12\n"
+	" -t, --table=TABLE     Routing table\n"
+	"     --family=FAMILY	Address family\n"
+	"     --src=ADDR        Source prefix\n"
+	"     --iif=DEV         Incomming interface\n"
+	"     --pref-src=ADDR   Preferred source address\n"
+	"     --metrics=OPTS    Metrics configurations\n"
+	"     --priority=NUM    Priotity\n"
+	"     --scope=SCOPE     Scope\n"
+	"     --protocol=PROTO  Protocol\n"
+	"     --type=TYPE       { unicast | local | broadcast | multicast }\n"
+	);
+	exit(0);
+}
+
+int main(int argc, char *argv[])
+{
+	struct nl_sock *sock;
+	struct rtnl_route *route;
+	struct nl_dump_params dp = {
+		.dp_type = NL_DUMP_LINE,
+		.dp_fd = stdout,
+	};
+	int err = 1;
+
+	sock = nl_cli_alloc_socket();
+	nl_cli_connect(sock, NETLINK_ROUTE);
+	link_cache = nl_cli_link_alloc_cache(sock);
+	route_cache = nl_cli_route_alloc_cache(sock, 0);
+	route = nl_cli_route_alloc();
+
+	for (;;) {
+		int c, optidx = 0;
+		enum {
+			ARG_FAMILY = 257,
+			ARG_SRC = 258,
+			ARG_IIF,
+			ARG_PREF_SRC,
+			ARG_METRICS,
+			ARG_PRIORITY,
+			ARG_SCOPE,
+			ARG_PROTOCOL,
+			ARG_TYPE,
+		};
+		static struct option long_opts[] = {
+			{ "quiet", 0, 0, 'q' },
+			{ "help", 0, 0, 'h' },
+			{ "version", 0, 0, 'v' },
+			{ "dst", 1, 0, 'd' },
+			{ "nexthop", 1, 0, 'n' },
+			{ "table", 1, 0, 't' },
+			{ "family", 1, 0, ARG_FAMILY },
+			{ "src", 1, 0, ARG_SRC },
+			{ "iif", 1, 0, ARG_IIF },
+			{ "pref-src", 1, 0, ARG_PREF_SRC },
+			{ "metrics", 1, 0, ARG_METRICS },
+			{ "priority", 1, 0, ARG_PRIORITY },
+			{ "scope", 1, 0, ARG_SCOPE },
+			{ "protocol", 1, 0, ARG_PROTOCOL },
+			{ "type", 1, 0, ARG_TYPE },
+			{ 0, 0, 0, 0 }
+		};
+
+		c = getopt_long(argc, argv, "qhvd:n:t:", long_opts, &optidx);
+		if (c == -1)
+			break;
+
+		switch (c) {
+		case 'q': quiet = 1; break;
+		case 'h': print_usage(); break;
+		case 'v': nl_cli_print_version(); break;
+		case 'd': nl_cli_route_parse_dst(route, optarg); break;
+		case 'n': nl_cli_route_parse_nexthop(route, optarg, link_cache); break;
+		case 't': nl_cli_route_parse_table(route, optarg); break;
+		case ARG_FAMILY: nl_cli_route_parse_family(route, optarg); break;
+		case ARG_SRC: nl_cli_route_parse_src(route, optarg); break;
+		case ARG_IIF: nl_cli_route_parse_iif(route, optarg, link_cache); break;
+		case ARG_PREF_SRC: nl_cli_route_parse_pref_src(route, optarg); break;
+		case ARG_METRICS: nl_cli_route_parse_metric(route, optarg); break;
+		case ARG_PRIORITY: nl_cli_route_parse_prio(route, optarg); break;
+		case ARG_SCOPE: nl_cli_route_parse_scope(route, optarg); break;
+		case ARG_PROTOCOL: nl_cli_route_parse_protocol(route, optarg); break;
+		case ARG_TYPE: nl_cli_route_parse_type(route, optarg); break;
+		}
+	}
+
+	if ((err = rtnl_route_add(sock, route, 0)) < 0)
+		nl_cli_fatal(err, "Unable to add route: %s", nl_geterror(err));
+
+	if (!quiet) {
+		printf("Added ");
+		nl_object_dump(OBJ_CAST(route), &dp);
+	}
+
+	return 0;
+}
diff -uNr libnl_kk/src/nl-route-delete.c libnl/src/nl-route-delete.c
--- libnl_kk/src/nl-route-delete.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/nl-route-delete.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,168 @@
+/*
+ * src/nl-route-delete.c     Delete Routes
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#include <netlink/cli/utils.h>
+#include <netlink/cli/route.h>
+#include <netlink/cli/link.h>
+
+static int interactive = 0, default_yes = 0, quiet = 0;
+static int deleted = 0;
+static struct nl_sock *sock;
+
+static void print_version(void)
+{
+	fprintf(stderr, "%s\n", LIBNL_STRING);
+	exit(0);
+}
+
+static void print_usage(void)
+{
+	printf(
+	"Usage: nl-route-delete [OPTION]... [ROUTE]\n"
+	"\n"
+	"Options\n"
+	" -i, --interactive     Run interactively\n"
+	"     --yes             Set default answer to yes\n"
+	" -q, --quiet		Do not print informal notifications\n"
+	" -h, --help            Show this help\n"
+	" -v, --version		Show versioning information\n"
+	"\n"
+	"Route Options\n"
+	" -d, --dst=ADDR        destination prefix, e.g. 10.10.0.0/16\n"
+	" -n, --nexthop=NH      nexthop configuration:\n"
+	"                         dev=DEV         route via device\n"
+	"                         weight=WEIGHT   weight of nexthop\n"
+	"                         flags=FLAGS\n"
+	"                         via=GATEWAY     route via other node\n"
+	"                         realms=REALMS\n"
+	"                         e.g. dev=eth0,via=192.168.1.12\n"
+	" -t, --table=TABLE     Routing table\n"
+	"     --family=FAMILY	Address family\n"
+	"     --src=ADDR        Source prefix\n"
+	"     --iif=DEV         Incomming interface\n"
+	"     --pref-src=ADDR   Preferred source address\n"
+	"     --metrics=OPTS    Metrics configurations\n"
+	"     --priority=NUM    Priotity\n"
+	"     --scope=SCOPE     Scope\n"
+	"     --protocol=PROTO  Protocol\n"
+	"     --type=TYPE       { unicast | local | broadcast | multicast }\n"
+	);
+	exit(0);
+}
+
+static void delete_cb(struct nl_object *obj, void *arg)
+{
+	struct rtnl_route *route = (struct rtnl_route *) obj;
+	struct nl_dump_params params = {
+		.dp_type = NL_DUMP_LINE,
+		.dp_fd = stdout,
+	};
+	int err;
+
+	if (interactive && !nl_cli_confirm(obj, &params, default_yes))
+		return;
+
+	if ((err = rtnl_route_delete(sock, route, 0)) < 0)
+		nl_cli_fatal(err, "Unable to delete route: %s", nl_geterror(err));
+
+	if (!quiet) {
+		printf("Deleted ");
+		nl_object_dump(obj, &params);
+	}
+
+	deleted++;
+}
+
+int main(int argc, char *argv[])
+{
+	struct nl_cache *link_cache, *route_cache;
+	struct rtnl_route *route;
+	int nf = 0;
+
+	sock = nl_cli_alloc_socket();
+	nl_cli_connect(sock, NETLINK_ROUTE);
+	link_cache = nl_cli_link_alloc_cache(sock);
+	route_cache = nl_cli_route_alloc_cache(sock, 0);
+	route = nl_cli_route_alloc();
+
+	for (;;) {
+		int c, optidx = 0;
+		enum {
+			ARG_FAMILY = 257,
+			ARG_SRC = 258,
+			ARG_IIF,
+			ARG_PREF_SRC,
+			ARG_METRICS,
+			ARG_PRIORITY,
+			ARG_SCOPE,
+			ARG_PROTOCOL,
+			ARG_TYPE,
+			ARG_YES,
+		};
+		static struct option long_opts[] = {
+			{ "interactive", 0, 0, 'i' },
+			{ "yes", 0, 0, ARG_YES },
+			{ "quiet", 0, 0, 'q' },
+			{ "help", 0, 0, 'h' },
+			{ "version", 0, 0, 'v' },
+			{ "dst", 1, 0, 'd' },
+			{ "nexthop", 1, 0, 'n' },
+			{ "table", 1, 0, 't' },
+			{ "family", 1, 0, ARG_FAMILY },
+			{ "src", 1, 0, ARG_SRC },
+			{ "iif", 1, 0, ARG_IIF },
+			{ "pref-src", 1, 0, ARG_PREF_SRC },
+			{ "metrics", 1, 0, ARG_METRICS },
+			{ "priority", 1, 0, ARG_PRIORITY },
+			{ "scope", 1, 0, ARG_SCOPE },
+			{ "protocol", 1, 0, ARG_PROTOCOL },
+			{ "type", 1, 0, ARG_TYPE },
+			{ 0, 0, 0, 0 }
+		};
+
+		c = getopt_long(argc, argv, "iqhvd:n:t:", long_opts, &optidx);
+		if (c == -1)
+			break;
+
+		switch (c) {
+		case 'i': interactive = 1; break;
+		case ARG_YES: default_yes = 1; break;
+		case 'q': quiet = 1; break;
+		case 'h': print_usage(); break;
+		case 'v': print_version(); break;
+		case 'd': nf++; nl_cli_route_parse_dst(route, optarg); break;
+		case 'n': nf++; nl_cli_route_parse_nexthop(route, optarg, link_cache); break;
+		case 't': nf++; nl_cli_route_parse_table(route, optarg); break;
+		case ARG_FAMILY: nf++; nl_cli_route_parse_family(route, optarg); break;
+		case ARG_SRC: nf++; nl_cli_route_parse_src(route, optarg); break;
+		case ARG_IIF: nf++; nl_cli_route_parse_iif(route, optarg, link_cache); break;
+		case ARG_PREF_SRC: nf++; nl_cli_route_parse_pref_src(route, optarg); break;
+		case ARG_METRICS: nf++; nl_cli_route_parse_metric(route, optarg); break;
+		case ARG_PRIORITY: nf++; nl_cli_route_parse_prio(route, optarg); break;
+		case ARG_SCOPE: nf++; nl_cli_route_parse_scope(route, optarg); break;
+		case ARG_PROTOCOL: nf++; nl_cli_route_parse_protocol(route, optarg); break;
+		case ARG_TYPE: nf++; nl_cli_route_parse_type(route, optarg); break;
+		}
+	}
+
+	if (nf == 0 && !interactive && !default_yes) {
+		fprintf(stderr, "You attempted to delete all routes in "
+			"non-interactive mode, aborting.\n");
+		exit(0);
+	}
+
+	nl_cache_foreach_filter(route_cache, OBJ_CAST(route), delete_cb, NULL);
+
+	if (!quiet)
+		printf("Deleted %d routes\n", deleted);
+
+	return 0;
+}
diff -uNr libnl_kk/src/nl-route-get.c libnl/src/nl-route-get.c
--- libnl_kk/src/nl-route-get.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/nl-route-get.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,85 @@
+/*
+ * src/nl-route-get.c     Get Route Attributes
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#include <netlink/cli/utils.h>
+#include <netlink/cli/route.h>
+#include <netlink/cli/link.h>
+
+static void print_usage(void)
+{
+	printf("Usage: nl-route-get <addr>\n");
+	exit(1);
+}
+
+static void parse_cb(struct nl_object *obj, void *arg)
+{
+	//struct rtnl_route *route = (struct rtnl_route *) obj;
+	struct nl_dump_params params = {
+		.dp_fd = stdout,
+		.dp_type = NL_DUMP_DETAILS,
+	};
+
+	nl_object_dump(obj, &params);
+}
+
+static int cb(struct nl_msg *msg, void *arg)
+{
+	int err;
+
+	if ((err = nl_msg_parse(msg, &parse_cb, NULL)) < 0)
+		nl_cli_fatal(err, "Unable to parse object: %s", nl_geterror(err));
+
+	return 0;
+}
+
+int main(int argc, char *argv[])
+{
+	struct nl_sock *sock;
+	struct nl_cache *link_cache, *route_cache;
+	struct nl_addr *dst;
+	int err = 1;
+
+	if (argc < 2 || !strcmp(argv[1], "-h"))
+		print_usage();
+
+	sock = nl_cli_alloc_socket();
+	nl_cli_connect(sock, NETLINK_ROUTE);
+	link_cache = nl_cli_link_alloc_cache(sock);
+	route_cache = nl_cli_route_alloc_cache(sock, 0);
+
+	dst = nl_cli_addr_parse(argv[1], AF_INET);
+
+	{
+		struct nl_msg *m;
+		struct rtmsg rmsg = {
+			.rtm_family = nl_addr_get_family(dst),
+			.rtm_dst_len = nl_addr_get_prefixlen(dst),
+		};
+
+		m = nlmsg_alloc_simple(RTM_GETROUTE, 0);
+		nlmsg_append(m, &rmsg, sizeof(rmsg), NLMSG_ALIGNTO);
+		nla_put_addr(m, RTA_DST, dst);
+
+		err = nl_send_auto_complete(sock, m);
+		nlmsg_free(m);
+		if (err < 0)
+			nl_cli_fatal(err, "%s", nl_geterror(err));
+
+		nl_socket_modify_cb(sock, NL_CB_VALID, NL_CB_CUSTOM, cb, NULL);
+
+		if (nl_recvmsgs_default(sock) < 0)
+			nl_cli_fatal(err, "%s", nl_geterror(err));
+	}
+
+	//nl_cache_dump(route_cache, &params);
+
+	return 0;
+}
diff -uNr libnl_kk/src/nl-route-list.c libnl/src/nl-route-list.c
--- libnl_kk/src/nl-route-list.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/nl-route-list.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,129 @@
+/*
+ * src/nl-route-list.c     List route attributes
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#include <netlink/cli/utils.h>
+#include <netlink/cli/route.h>
+#include <netlink/cli/link.h>
+
+static void print_usage(void)
+{
+	printf(
+	"Usage: nl-route-list [OPTION]... [ROUTE]\n"
+	"\n"
+	"Options\n"
+	" -c, --cache           List the contents of the route cache\n"
+	" -f, --format=TYPE	Output format { brief | details | stats }\n"
+	" -h, --help            Show this help\n"
+	" -v, --version		Show versioning information\n"
+	"\n"
+	"Route Options\n"
+	" -d, --dst=ADDR        destination prefix, e.g. 10.10.0.0/16\n"
+	" -n, --nexthop=NH      nexthop configuration:\n"
+	"                         dev=DEV         route via device\n"
+	"                         weight=WEIGHT   weight of nexthop\n"
+	"                         flags=FLAGS\n"
+	"                         via=GATEWAY     route via other node\n"
+	"                         realms=REALMS\n"
+	"                         e.g. dev=eth0,via=192.168.1.12\n"
+	" -t, --table=TABLE     Routing table\n"
+	"     --family=FAMILY	Address family\n"
+	"     --src=ADDR        Source prefix\n"
+	"     --iif=DEV         Incomming interface\n"
+	"     --pref-src=ADDR   Preferred source address\n"
+	"     --metrics=OPTS    Metrics configurations\n"
+	"     --priority=NUM    Priotity\n"
+	"     --scope=SCOPE     Scope\n"
+	"     --protocol=PROTO  Protocol\n"
+	"     --type=TYPE       { unicast | local | broadcast | multicast }\n"
+	);
+	exit(0);
+}
+
+int main(int argc, char *argv[])
+{
+	struct nl_sock *sock;
+	struct nl_cache *link_cache, *route_cache;
+	struct rtnl_route *route;
+	struct nl_dump_params params = {
+		.dp_fd = stdout,
+		.dp_type = NL_DUMP_LINE,
+	};
+	int print_cache = 0;
+
+	sock = nl_cli_alloc_socket();
+	nl_cli_connect(sock, NETLINK_ROUTE);
+	link_cache = nl_cli_link_alloc_cache(sock);
+	route = nl_cli_route_alloc();
+
+	for (;;) {
+		int c, optidx = 0;
+		enum {
+			ARG_FAMILY = 257,
+			ARG_SRC = 258,
+			ARG_IIF,
+			ARG_PREF_SRC,
+			ARG_METRICS,
+			ARG_PRIORITY,
+			ARG_SCOPE,
+			ARG_PROTOCOL,
+			ARG_TYPE,
+		};
+		static struct option long_opts[] = {
+			{ "cache", 0, 0, 'c' },
+			{ "format", 1, 0, 'f' },
+			{ "help", 0, 0, 'h' },
+			{ "version", 0, 0, 'v' },
+			{ "dst", 1, 0, 'd' },
+			{ "nexthop", 1, 0, 'n' },
+			{ "table", 1, 0, 't' },
+			{ "family", 1, 0, ARG_FAMILY },
+			{ "src", 1, 0, ARG_SRC },
+			{ "iif", 1, 0, ARG_IIF },
+			{ "pref-src", 1, 0, ARG_PREF_SRC },
+			{ "metrics", 1, 0, ARG_METRICS },
+			{ "priority", 1, 0, ARG_PRIORITY },
+			{ "scope", 1, 0, ARG_SCOPE },
+			{ "protocol", 1, 0, ARG_PROTOCOL },
+			{ "type", 1, 0, ARG_TYPE },
+			{ 0, 0, 0, 0 }
+		};
+
+		c = getopt_long(argc, argv, "cf:hvd:n:t:", long_opts, &optidx);
+		if (c == -1)
+			break;
+
+		switch (c) {
+		case 'c': print_cache = 1; break;
+		case 'f': params.dp_type = nl_cli_parse_dumptype(optarg); break;
+		case 'h': print_usage(); break;
+		case 'v': nl_cli_print_version(); break;
+		case 'd': nl_cli_route_parse_dst(route, optarg); break;
+		case 'n': nl_cli_route_parse_nexthop(route, optarg, link_cache); break;
+		case 't': nl_cli_route_parse_table(route, optarg); break;
+		case ARG_FAMILY: nl_cli_route_parse_family(route, optarg); break;
+		case ARG_SRC: nl_cli_route_parse_src(route, optarg); break;
+		case ARG_IIF: nl_cli_route_parse_iif(route, optarg, link_cache); break;
+		case ARG_PREF_SRC: nl_cli_route_parse_pref_src(route, optarg); break;
+		case ARG_METRICS: nl_cli_route_parse_metric(route, optarg); break;
+		case ARG_PRIORITY: nl_cli_route_parse_prio(route, optarg); break;
+		case ARG_SCOPE: nl_cli_route_parse_scope(route, optarg); break;
+		case ARG_PROTOCOL: nl_cli_route_parse_protocol(route, optarg); break;
+		case ARG_TYPE: nl_cli_route_parse_type(route, optarg); break;
+		}
+	}
+
+	route_cache = nl_cli_route_alloc_cache(sock,
+				print_cache ? ROUTE_CACHE_CONTENT : 0);
+
+	nl_cache_dump_filter(route_cache, &params, OBJ_CAST(route));
+
+	return 0;
+}
diff -uNr libnl_kk/src/nl-rule-list.c libnl/src/nl-rule-list.c
--- libnl_kk/src/nl-rule-list.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/nl-rule-list.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,77 @@
+/*
+ * src/nl-rule-dump.c     Dump rule attributes
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#include <netlink/cli/utils.h>
+#include <netlink/cli/rule.h>
+#include <netlink/cli/link.h>
+
+static void print_usage(void)
+{
+	printf(
+	"Usage: nl-rule-list [OPTION]... [ROUTE]\n"
+	"\n"
+	"Options\n"
+	" -c, --cache           List the contents of the route cache\n"
+	" -f, --format=TYPE	Output format { brief | details | stats }\n"
+	" -h, --help            Show this help\n"
+	" -v, --version		Show versioning information\n"
+	"\n"
+	"Rule Options\n"
+	"     --family          Address family\n"
+	);
+	exit(0);
+}
+
+int main(int argc, char *argv[])
+{
+	struct nl_sock *sock;
+	struct rtnl_rule *rule;
+	struct nl_cache *link_cache, *rule_cache;
+	struct nl_dump_params params = {
+		.dp_fd = stdout,
+		.dp_type = NL_DUMP_LINE,
+	};
+
+	sock = nl_cli_alloc_socket();
+	nl_cli_connect(sock, NETLINK_ROUTE);
+	link_cache = nl_cli_link_alloc_cache(sock);
+	rule_cache = nl_cli_rule_alloc_cache(sock);
+	rule = nl_cli_rule_alloc();
+
+	for (;;) {
+		int c, optidx = 0;
+		enum {
+			ARG_FAMILY = 257,
+		};
+		static struct option long_opts[] = {
+			{ "format", 1, 0, 'f' },
+			{ "help", 0, 0, 'h' },
+			{ "version", 0, 0, 'v' },
+			{ "family", 1, 0, ARG_FAMILY },
+			{ 0, 0, 0, 0 }
+		};
+
+		c = getopt_long(argc, argv, "f:hv", long_opts, &optidx);
+		if (c == -1)
+			break;
+
+		switch (c) {
+		case 'f': params.dp_type = nl_cli_parse_dumptype(optarg); break;
+		case 'h': print_usage(); break;
+		case 'v': nl_cli_print_version(); break;
+		case ARG_FAMILY: nl_cli_rule_parse_family(rule, optarg); break;
+		}
+	}
+
+	nl_cache_dump_filter(rule_cache, &params, OBJ_CAST(rule));
+
+	return 0;
+}
diff -uNr libnl_kk/src/nl-tctree-list.c libnl/src/nl-tctree-list.c
--- libnl_kk/src/nl-tctree-list.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/nl-tctree-list.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,149 @@
+/*
+ * src/nl-tctree-list.c		List Traffic Control Tree
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#include <netlink/cli/utils.h>
+#include <netlink/cli/link.h>
+#include <netlink/cli/qdisc.h>
+#include <linux/pkt_sched.h>
+
+static struct nl_sock *sock;
+static struct nl_cache *qdisc_cache, *class_cache;
+static struct nl_dump_params params = {
+	.dp_type = NL_DUMP_DETAILS,
+};
+
+static int ifindex;
+static void print_qdisc(struct nl_object *, void *);
+
+static void print_usage(void)
+{
+	printf(
+	"Usage: nl-tctree-list [OPTION]...\n"
+	"\n"
+	"Options\n"
+	" -f, --format=TYPE	Output format { brief | details | stats }\n"
+	" -h, --help            Show this help\n"
+	" -v, --version		Show versioning information\n"
+	);
+	exit(0);
+}
+
+static void print_class(struct nl_object *obj, void *arg)
+{
+	struct rtnl_qdisc *leaf;
+	struct rtnl_class *class = (struct rtnl_class *) obj;
+	struct nl_cache *cls_cache;
+	uint32_t parent = rtnl_class_get_handle(class);
+
+	params.dp_prefix = (int)(long) arg;
+	nl_object_dump(obj, &params);
+
+	leaf = rtnl_class_leaf_qdisc(class, qdisc_cache);
+	if (leaf)
+		print_qdisc((struct nl_object *) leaf, arg + 2);
+
+	rtnl_class_foreach_child(class, class_cache, &print_class, arg + 2);
+
+	if (rtnl_cls_alloc_cache(sock, ifindex, parent, &cls_cache) < 0)
+		return;
+
+	params.dp_prefix = (int)(long) arg + 2;
+	nl_cache_dump(cls_cache, &params);
+	nl_cache_free(cls_cache);
+}
+
+static void print_qdisc(struct nl_object *obj, void *arg)
+{
+	struct rtnl_qdisc *qdisc = (struct rtnl_qdisc *) obj;
+	struct nl_cache *cls_cache;
+	uint32_t parent = rtnl_qdisc_get_handle(qdisc);
+
+	params.dp_prefix = (int)(long) arg;
+	nl_object_dump(obj, &params);
+
+	rtnl_qdisc_foreach_child(qdisc, class_cache, &print_class, arg + 2);
+
+	if (rtnl_cls_alloc_cache(sock, ifindex, parent, &cls_cache) < 0)
+		return;
+
+	params.dp_prefix = (int)(long) arg + 2;
+	nl_cache_dump(cls_cache, &params);
+	nl_cache_free(cls_cache);
+}
+
+static void print_link(struct nl_object *obj, void *arg)
+{
+	struct rtnl_link *link = (struct rtnl_link *) obj;
+	struct rtnl_qdisc *qdisc;
+
+	ifindex = rtnl_link_get_ifindex(link);
+	params.dp_prefix = 0;
+	nl_object_dump(obj, &params);
+
+	if (rtnl_class_alloc_cache(sock, ifindex, &class_cache) < 0)
+		return;
+
+	qdisc = rtnl_qdisc_get_by_parent(qdisc_cache, ifindex, TC_H_ROOT);
+	if (qdisc) {
+		print_qdisc((struct nl_object *) qdisc, (void *) 2);
+		rtnl_qdisc_put(qdisc);
+	}
+
+	qdisc = rtnl_qdisc_get_by_parent(qdisc_cache, ifindex, 0);
+	if (qdisc) {
+		print_qdisc((struct nl_object *) qdisc, (void *) 2);
+		rtnl_qdisc_put(qdisc);
+	}
+
+	qdisc = rtnl_qdisc_get_by_parent(qdisc_cache, ifindex, TC_H_INGRESS);
+	if (qdisc) {
+		print_qdisc((struct nl_object *) qdisc, (void *) 2);
+		rtnl_qdisc_put(qdisc);
+	}
+
+	nl_cache_free(class_cache);
+}
+
+int main(int argc, char *argv[])
+{
+	struct nl_cache *link_cache;
+
+	sock = nl_cli_alloc_socket();
+	nl_cli_connect(sock, NETLINK_ROUTE);
+	link_cache = nl_cli_link_alloc_cache(sock);
+	qdisc_cache = nl_cli_qdisc_alloc_cache(sock);
+
+	params.dp_fd = stdout;
+
+	for (;;) {
+		int c, optidx = 0;
+		static struct option long_opts[] = {
+			{ "format", 1, 0, 'f' },
+			{ "help", 0, 0, 'h' },
+			{ "version", 0, 0, 'v' },
+			{ 0, 0, 0, 0 }
+		};
+
+		c = getopt_long(argc, argv, "f:hv", long_opts, &optidx);
+		if (c == -1)
+			break;
+
+		switch (c) {
+		case 'f': params.dp_type = nl_cli_parse_dumptype(optarg); break;
+		case 'h': print_usage(); break;
+		case 'v': nl_cli_print_version(); break;
+		}
+	}
+
+	nl_cache_foreach(link_cache, &print_link, NULL);
+
+	return 0;
+}
diff -uNr libnl_kk/src/nl-util-addr.c libnl/src/nl-util-addr.c
--- libnl_kk/src/nl-util-addr.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/src/nl-util-addr.c	2015-09-10 13:39:33.039778085 +0800
@@ -0,0 +1,34 @@
+/*
+ * src/nl-util-addr.c     Address Helper
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2009 Thomas Graf <tgraf@suug.ch>
+ */
+
+#include <netlink/cli/utils.h>
+
+int main(int argc, char *argv[])
+{
+	int err;
+	char host[256];
+	struct nl_addr *a;
+
+	if (argc < 2) {
+		fprintf(stderr, "Usage: nl-util-addr <address>\n");
+		return -1;
+	}
+
+	a = nl_cli_addr_parse(argv[1], AF_UNSPEC);
+	err = nl_addr_resolve(a, host, sizeof(host));
+	if (err != 0)
+		nl_cli_fatal(err, "Unable to resolve address \"%s\": %s",
+		      argv[1], nl_geterror(err));
+
+	printf("%s\n", host);
+
+	return 0;
+}
diff -uNr libnl_kk/tests/.gitignore libnl/tests/.gitignore
--- libnl_kk/tests/.gitignore	1970-01-01 08:00:00.000000000 +0800
+++ libnl/tests/.gitignore	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,4 @@
+test-cache-mngr
+test-genl
+test-nf-cache-mngr
+test-socket-creation
diff -uNr libnl_kk/tests/Makefile libnl/tests/Makefile
--- libnl_kk/tests/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ libnl/tests/Makefile	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,37 @@
+#
+# src/Makefile
+#
+# 	This library is free software; you can redistribute it and/or
+#	modify it under the terms of the GNU Lesser General Public
+#	License as published by the Free Software Foundation version 2.1
+#	of the License.
+#
+# Copyright (c) 2003-2006 Thomas Graf <tgraf@suug.ch>
+#
+
+ifeq ($(shell [ ! -r ../Makefile.opts ] && echo 1),)
+    include ../Makefile.opts
+endif
+
+LDFLAGS	+= -L../lib -lnl ../src/utils.o
+CIN 	:= $(wildcard test-*.c)
+TOOLS	:= $(CIN:%.c=%)
+
+all: $(TOOLS)
+
+$(TOOLS): ../src/utils.o
+
+test-%: test-%.c
+	@echo "  LD $@"; \
+	$(CC) $(CFLAGS) -o $@ $< $(LDFLAGS) -lnl-genl -lnl-route
+
+clean:
+	@echo "  CLEAN src"; \
+	rm -f $(TOOLS)
+
+distclean: clean
+
+install:
+	@true
+
+include ../Makefile.rules
diff -uNr libnl_kk/tests/test-cache-mngr.c libnl/tests/test-cache-mngr.c
--- libnl_kk/tests/test-cache-mngr.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/tests/test-cache-mngr.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,71 @@
+#include "../src/utils.h"
+#include <signal.h>
+
+static int quit = 0;
+
+static void change_cb(struct nl_cache *cache, struct nl_object *obj,
+		      int action)
+{
+	struct nl_dump_params dp = {
+		.dp_type = NL_DUMP_LINE,
+		.dp_fd = stdout,
+	};
+
+	if (action == NL_ACT_NEW)
+		printf("NEW ");
+	else if (action == NL_ACT_DEL)
+		printf("DEL ");
+	else if (action == NL_ACT_CHANGE)
+		printf("CHANGE ");
+
+	nl_object_dump(obj, &dp);
+}
+
+static void sigint(int arg)
+{
+	quit = 1;
+}
+
+int main(int argc, char *argv[])
+{
+	struct nl_cache_mngr *mngr;
+	struct nl_cache *lc, *nc, *ac, *rc;
+	struct nl_sock *sock;
+	int err;
+
+	signal(SIGINT, sigint);
+
+	sock = nlt_alloc_socket();
+	err = nl_cache_mngr_alloc(sock, NETLINK_ROUTE, NL_AUTO_PROVIDE, &mngr);
+	if (err < 0)
+		fatal(err, "Unable to allocate cache manager: %s",
+		      nl_geterror(err));
+
+	if ((err = nl_cache_mngr_add(mngr, "route/link", &change_cb, &lc)) < 0)
+		fatal(err, "Unable to add cache route/link: %s",
+		      nl_geterror(err));
+
+	if ((err = nl_cache_mngr_add(mngr, "route/neigh", &change_cb, &nc)) < 0)
+		fatal(err, "Unable to add cache route/neigh: %s",
+		      nl_geterror(err));
+
+	if ((err = nl_cache_mngr_add(mngr, "route/addr", &change_cb, &ac)) < 0)
+		fatal(err, "Unable to add cache route/addr: %s",
+		      nl_geterror(err));
+
+	if ((err = nl_cache_mngr_add(mngr, "route/route", &change_cb, &rc)) < 0)
+		fatal(err, "Unable to add cache route/route: %s",
+		      nl_geterror(err));
+
+	while (!quit) {
+		int err = nl_cache_mngr_poll(mngr, 5000);
+		if (err < 0 && err != -NLE_INTR)
+			fatal(err, "Polling failed: %s", nl_geterror(err));
+
+	}
+
+	nl_cache_mngr_free(mngr);
+	nl_socket_free(sock);
+
+	return 0;
+}
diff -uNr libnl_kk/tests/test-genl.c libnl/tests/test-genl.c
--- libnl_kk/tests/test-genl.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/tests/test-genl.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,36 @@
+#include "../src/utils.h"
+
+int main(int argc, char *argv[])
+{
+	struct nl_sock *sock;
+	struct nl_msg *msg;
+	void *hdr;
+	int err;
+
+	sock = nlt_alloc_socket();
+	nlt_connect(sock, NETLINK_GENERIC);
+
+	msg = nlmsg_alloc();
+	if (msg == NULL)
+		fatal(NLE_NOMEM, "Unable to allocate netlink message");
+
+	hdr = genlmsg_put(msg, NL_AUTO_PID, NL_AUTO_SEQ, GENL_ID_CTRL,
+			  0, 0, CTRL_CMD_GETFAMILY, 1);
+	if (hdr == NULL)
+		fatal(ENOMEM, "Unable to write genl header");
+
+	if ((err = nla_put_u32(msg, CTRL_ATTR_FAMILY_ID, GENL_ID_CTRL)) < 0)
+		fatal(err, "Unable to add attribute: %s", nl_geterror(err));
+
+	if ((err = nl_send_auto_complete(sock, msg)) < 0)
+		fatal(err, "Unable to send message: %s", nl_geterror(err));
+
+	if ((err = nl_recvmsgs_default(sock)) < 0)
+		fatal(err, "Unable to receive message: %s", nl_geterror(err));
+
+	nlmsg_free(msg);
+	nl_close(sock);
+	nl_socket_free(sock);
+
+	return 0;
+}
diff -uNr libnl_kk/tests/test-nf-cache-mngr.c libnl/tests/test-nf-cache-mngr.c
--- libnl_kk/tests/test-nf-cache-mngr.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/tests/test-nf-cache-mngr.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,56 @@
+#include "../src/utils.h"
+
+static void change_cb(struct nl_cache *cache, struct nl_object *obj,
+		      int action)
+{
+	struct nfnl_ct *ct = (struct nfnl_ct *) obj;
+	static struct nl_addr *hack = NULL;
+
+	if (!hack)
+		hack = nl_addr_parse("194.88.212.233", AF_INET);
+
+	if (!nl_addr_cmp(hack, nfnl_ct_get_src(ct, 1)) ||
+	    !nl_addr_cmp(hack, nfnl_ct_get_dst(ct, 1))) {
+		struct nl_dump_params dp = {
+			.dp_type = NL_DUMP_LINE,
+			.dp_fd = stdout,
+		};
+
+		printf("UPDATE ");
+		nl_object_dump(obj, &dp);
+	}
+}
+
+int main(int argc, char *argv[])
+{
+	struct nl_cache_mngr *mngr;
+	struct nl_sock *sock;
+	struct nl_cache *ct;
+
+	sock = nlt_socket_alloc();
+
+	mngr = nl_cache_mngr_alloc(sock, NETLINK_NETFILTER, NL_AUTO_PROVIDE);
+	if (!mngr) {
+		nl_perror("nl_cache_mngr_alloc");
+		return -1;
+	}
+
+	ct = nl_cache_mngr_add(mngr, "netfilter/ct", &change_cb);
+	if (ct == NULL) {
+		nl_perror("nl_cache_mngr_add(netfilter/ct)");
+		return -1;
+	}
+
+	for (;;) {
+		int err = nl_cache_mngr_poll(mngr, 5000);
+		if (err < 0) {
+			nl_perror("nl_cache_mngr_poll()");
+			return -1;
+		}
+
+	}
+
+	nl_cache_mngr_free(mngr);
+
+	return 0;
+}
diff -uNr libnl_kk/tests/test-socket-creation.c libnl/tests/test-socket-creation.c
--- libnl_kk/tests/test-socket-creation.c	1970-01-01 08:00:00.000000000 +0800
+++ libnl/tests/test-socket-creation.c	2015-09-10 13:39:33.043778085 +0800
@@ -0,0 +1,27 @@
+#include "../src/utils.h"
+
+int main(int argc, char *argv[])
+{
+	struct nl_sock *h[1025];
+	int i;
+
+	h[0] = nl_handle_alloc();
+	printf("Created handle with port 0x%x\n",
+			nl_socket_get_local_port(h[0]));
+	nl_handle_destroy(h[0]);
+	h[0] = nl_handle_alloc();
+	printf("Created handle with port 0x%x\n",
+			nl_socket_get_local_port(h[0]));
+	nl_handle_destroy(h[0]);
+
+	for (i = 0; i < 1025; i++) {
+		h[i] = nl_handle_alloc();
+		if (h[i] == NULL)
+			nl_perror("Unable to allocate socket");
+		else
+			printf("Created handle with port 0x%x\n",
+				nl_socket_get_local_port(h[i]));
+	}
+
+	return 0;
+}
