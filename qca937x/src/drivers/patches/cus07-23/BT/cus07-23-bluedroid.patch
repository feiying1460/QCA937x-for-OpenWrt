diff -Naur '--exclude=.git' bluedroid-orig/audio_a2dp_hw/audio_a2dp_hw.h bluedroid/audio_a2dp_hw/audio_a2dp_hw.h
--- bluedroid-orig/audio_a2dp_hw/audio_a2dp_hw.h	2015-09-24 16:33:43.520227643 +0800
+++ bluedroid/audio_a2dp_hw/audio_a2dp_hw.h	2015-09-24 16:31:36.000000000 +0800
@@ -48,7 +48,8 @@
     A2DP_CTRL_CMD_CHECK_STREAM_STARTED,
     A2DP_CTRL_CMD_START,
     A2DP_CTRL_CMD_STOP,
-    A2DP_CTRL_CMD_SUSPEND
+    A2DP_CTRL_CMD_SUSPEND,
+    A2DP_CTRL_GET_AUDIO_CONFIG
 } tA2DP_CTRL_CMD;
 
 typedef enum {
diff -Naur '--exclude=.git' bluedroid-orig/bta/3d/bta_3d_api.c bluedroid/bta/3d/bta_3d_api.c
--- bluedroid-orig/bta/3d/bta_3d_api.c	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/bta/3d/bta_3d_api.c	2015-09-24 16:31:36.000000000 +0800
@@ -0,0 +1,261 @@
+//XXX copyright header?
+/******************************************************************************
+ *
+ *  This file contains the 3D Sync API in the subsystem of BTA.
+ *
+ ******************************************************************************/
+
+#include "bt_target.h"
+
+#if defined(BTA_3D_INCLUDED) && (BTA_3D_INCLUDED == TRUE)
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+
+#include "bta_3d_api.h"
+#include "bta_3d_int.h"
+#include "l2c_api.h"
+
+/*****************************************************************************
+ **  Constants
+ *****************************************************************************/
+
+static const tBTA_SYS_REG bta_3d_reg =
+{
+    bta_3d_hdl_event,
+    BTA_3dDisable
+};
+
+/*******************************************************************************
+ **
+ ** Function         BTA_3dEnable
+ **
+ ** Description      This function enable 3D Display and registers the Dislpay with
+ **                  lower layers.
+ **
+ ** Returns          void
+ **
+ *******************************************************************************/
+void BTA_3dEnable(tBTA_3D_CBACK *p_cback, char *p_service_name)
+{
+    tBTA_3D_API_ENABLE *p_buf;
+
+    APPL_TRACE_API1("%s: Enter", __FUNCTION__);
+
+    /* Register with BTA */
+    GKI_sched_lock();
+    bta_sys_register(BTA_ID_3D, &bta_3d_reg);
+    GKI_sched_unlock();
+    
+
+    if((p_buf = (tBTA_3D_API_ENABLE *)GKI_getbuf(sizeof(tBTA_3D_API_ENABLE))) != NULL)
+    {
+        p_buf->hdr.event = BTA_3D_API_ENABLE_EVT;
+        p_buf->p_cback   = p_cback;
+
+        if(p_service_name)
+            BCM_STRNCPY_S(p_buf->p_name, BTA_SERVICE_NAME_LEN+1, p_service_name, BTA_SERVICE_NAME_LEN);
+
+        bta_sys_sendmsg(p_buf);
+    }
+    APPL_TRACE_API1("%s: Exit", __FUNCTION__);
+}
+
+/*******************************************************************************
+ **
+ ** Function         BTA_3dDisable
+ **
+ ** Description      This function is called when the host is about power down.
+ **
+ ** Returns          void
+ **
+ *******************************************************************************/
+void BTA_3dDisable(void)
+{
+    BT_HDR *p_buf;
+
+    APPL_TRACE_API1("%s: Enter", __FUNCTION__);
+    if((p_buf = (BT_HDR *)GKI_getbuf(sizeof(BT_HDR))) != NULL)
+    {
+        p_buf->event = BTA_3D_API_DISABLE_EVT;
+
+        bta_sys_sendmsg(p_buf);
+    }
+
+    GKI_sched_lock();
+    bta_sys_deregister(BTA_ID_3D);
+    GKI_sched_unlock();
+
+    APPL_TRACE_API1("%s: Exit", __FUNCTION__);
+}
+
+/*******************************************************************************
+ **
+ ** Function         BTA_3dWriteSyncParams
+ **
+ ** Description      This function writes the Synchronization Train Parameters.
+ **                  Note, for spec-compliance the Interval is coded to 80ms internally.
+ **
+ ** Returns          void
+ **
+ *******************************************************************************/
+void BTA_3dWriteSyncTrainParams(UINT32 timeout, UINT8 service_data)
+{
+    tBTA_3D_API_WRITE_SYNC_TRAIN_PARAMS *p_buf;
+
+    APPL_TRACE_API1("%s: Enter", __FUNCTION__);
+    if((p_buf = (tBTA_3D_API_WRITE_SYNC_TRAIN_PARAMS *)GKI_getbuf(sizeof(tBTA_3D_API_WRITE_SYNC_TRAIN_PARAMS))) != NULL)
+    {
+        p_buf->hdr.event    = BTA_3D_API_WRITE_SYNC_PARAM_EVT;
+        p_buf->timeout      = timeout;
+        p_buf->service_data = service_data;
+
+        bta_sys_sendmsg(p_buf);
+    }
+    APPL_TRACE_API1("%s: Exit", __FUNCTION__);
+}
+
+/*******************************************************************************
+ **
+ ** Function         BTA_3dStartSyncTrain
+ **
+ ** Description      This function start the synchronization train.
+ **
+ ** Returns          void
+ **
+ *******************************************************************************/
+void BTA_3dStartSyncTrain(void)
+{
+    BT_HDR *p_buf;
+
+    APPL_TRACE_API1("%s: Enter", __FUNCTION__);
+    if((p_buf = (BT_HDR *)GKI_getbuf(sizeof(BT_HDR))) != NULL)
+    {
+        p_buf->event = BTA_3D_API_START_SYNC_TRAIN_EVT;
+
+        bta_sys_sendmsg(p_buf);
+    }
+    APPL_TRACE_API1("%s: Exit", __FUNCTION__);
+}
+
+/*******************************************************************************
+ **
+ ** Function         BTA_3dSetBroadcastData
+ **
+ ** Description      This function sets the data being broadcast.
+ **
+ ** Returns          void
+ **
+ *******************************************************************************/
+void BTA_3dSetBroadcastData(tBTA_3D_BCAST_DATA *p_bcast_data)
+{
+    tBTA_3D_API_SET_BCAST_DATA *p_buf;
+
+    APPL_TRACE_API1("%s: Enter", __FUNCTION__);
+    if((p_bcast_data) && ((p_buf = (tBTA_3D_API_SET_BCAST_DATA *)GKI_getbuf(sizeof(tBTA_3D_API_SET_BCAST_DATA))) != NULL))
+    {
+        p_buf->hdr.event  = BTA_3D_API_SET_BCAST_DATA_EVT;
+        p_buf->bcast_data = *p_bcast_data;
+
+        bta_sys_sendmsg(p_buf);
+    }
+    APPL_TRACE_API1("%s: Exit", __FUNCTION__);
+}
+
+/*******************************************************************************
+ **
+ ** Function         BTA_3dEnableBroadcasts
+ **
+ ** Description      This function enables 3D broadcasts.
+ **
+ ** Returns          void
+ **
+ *******************************************************************************/
+void BTA_3dEnableBroadcasts(UINT16 timeout, BOOLEAN low_power)
+{
+    tBTA_3D_API_ENABLE_BCAST *p_buf;
+
+    APPL_TRACE_API1("%s: Enter", __FUNCTION__);
+    if((p_buf = (tBTA_3D_API_ENABLE_BCAST *)GKI_getbuf(sizeof(tBTA_3D_API_ENABLE_BCAST))) != NULL)
+    {
+        p_buf->hdr.event = BTA_3D_API_ENABLE_BCAST_EVT;
+        p_buf->timeout   = timeout;
+        p_buf->low_power = low_power;
+
+        bta_sys_sendmsg(p_buf);
+    }
+    APPL_TRACE_API1("%s: Exit", __FUNCTION__);
+}
+
+/*******************************************************************************
+ **
+ ** Function         BTA_3dDisableBroadcasts
+ **
+ ** Description      This function disables 3D broadcasts.
+ **
+ ** Returns          void
+ **
+ *******************************************************************************/
+void BTA_3dDisableBroadcasts(void)
+{
+    BT_HDR *p_buf;
+
+    APPL_TRACE_API1("%s: Enter", __FUNCTION__);
+    if((p_buf = (BT_HDR *)GKI_getbuf(sizeof(BT_HDR))) != NULL)
+    {
+        p_buf->event = BTA_3D_API_DISABLE_BCAST_EVT;
+
+        bta_sys_sendmsg(p_buf);
+    }
+    APPL_TRACE_API1("%s: Exit", __FUNCTION__);
+}
+
+/*******************************************************************************
+ **
+ ** Function         BTA_3dEnableClockCapture
+ **
+ ** Description      This function enabled Triggered Clock Capture.
+ **
+ ** Returns          void
+ **
+ *******************************************************************************/
+void BTA_3dEnableClockCapture(UINT8 filter_count)
+{
+    tBTA_3D_API_ENABLE_CLK_CAP *p_buf;
+
+    APPL_TRACE_API1("%s: Enter", __FUNCTION__);
+    if((p_buf = (tBTA_3D_API_ENABLE_CLK_CAP *)GKI_getbuf(sizeof(tBTA_3D_API_ENABLE_CLK_CAP))) != NULL)
+    {
+        p_buf->hdr.event    = BTA_3D_API_ENABLE_CLK_CAP_EVT;
+        p_buf->filter_count = filter_count;
+
+        bta_sys_sendmsg(p_buf);
+    }
+    APPL_TRACE_API1("%s: Exit", __FUNCTION__);
+}
+
+/*******************************************************************************
+ **
+ ** Function         BTA_3dDisableClockCapture
+ **
+ ** Description      This function disabled Triggered Clock Capture.
+ **
+ ** Returns          void
+ **
+ *******************************************************************************/
+void BTA_3dDisableClockCapture(void)
+{
+    BT_HDR *p_buf;
+
+    APPL_TRACE_API1("%s: Enter", __FUNCTION__);
+    if((p_buf = (BT_HDR *)GKI_getbuf(sizeof(BT_HDR))) != NULL)
+    {
+        p_buf->event = BTA_3D_API_DISABLE_CLK_CAP_EVT;
+
+        bta_sys_sendmsg(p_buf);
+    }
+    APPL_TRACE_API1("%s: Exit", __FUNCTION__);
+}
+
+#endif
diff -Naur '--exclude=.git' bluedroid-orig/bta/3d/bta_3d_int.h bluedroid/bta/3d/bta_3d_int.h
--- bluedroid-orig/bta/3d/bta_3d_int.h	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/bta/3d/bta_3d_int.h	2015-09-24 16:31:36.000000000 +0800
@@ -0,0 +1,200 @@
+/******************************************************************************
+ *
+ *  This file contains BTA 3D Sync internal definitions
+ *
+ ******************************************************************************/
+
+#ifndef BTA_3D_INT_H
+#define BTA_3D_INT_H
+
+#include "bta_sys.h"
+#include "bd.h"
+#include "utl.h"
+#include "bta_3d_api.h"
+
+#define PSM_3D_SYNC                0x0021
+#define BTA_3D_LT_ADDR             1
+
+#define BTA_3D_BCAST_DATA_BUF_SIZE 17
+
+#define BTA_3D_BCAST_INSTANT_BITMASK 0x03FFFFFF
+#define BTA_3D_BCAST_VMODE_BITMASK   0x40000000
+
+#define BTA_3D_BCAST_VMODE_3D        0x00000000
+#define BTA_3D_BCAST_VMODE_DUAL_VIEW 0x40000000
+
+#define BTA_3D_LEGACY_VS_ASSOC_CMD_OCF 0x0013
+
+#define BTA_3D_LEGACY_VS_ASSOC_EVT_CODE 0x14
+#define BTA_3D_LEGACY_VS_ASSOC_EVT_LEN  18
+
+#define BTA_3D_CLB_BR_PACKETS        (BTM_ACL_PKT_TYPES_MASK_DM1 | \
+                                      BTM_ACL_PKT_TYPES_MASK_NO_2_DH1 | \
+                                      BTM_ACL_PKT_TYPES_MASK_NO_3_DH1 | \
+                                      BTM_ACL_PKT_TYPES_MASK_NO_2_DH3 | \
+                                      BTM_ACL_PKT_TYPES_MASK_NO_3_DH3 | \
+                                      BTM_ACL_PKT_TYPES_MASK_NO_2_DH5 | \
+                                      BTM_ACL_PKT_TYPES_MASK_NO_3_DH5)
+
+#define BTA_3D_LEGACY_INTERVAL_MIN_MAX 80
+
+#define CONVERT_TO_BASEBAND_SLOTS(_x)                             ((UINT32)((((8000L * ((unsigned long)(_x))) / 500L) + 5L)/10L))
+#define CONVERT_FROM_BASEBAND_SLOTS(_x)                           ((UINT32)((((5000L * (_x)) / 800L) + 5L)/10L))
+
+#define BTA_3D_LEGACY_INTERVAL_MIN_MAX_SLOTS (CONVERT_TO_BASEBAND_SLOTS(BTA_3D_LEGACY_INTERVAL_MIN_MAX))
+
+#define BTA_3D_UCD_CONN_MSG_SIZE 3
+
+#define BTA_3D_UCD_OPCODE_CONN_ANN 0
+/* Events for the main mailbox. */
+enum
+{
+    /* API events */
+    BTA_3D_API_ENABLE_EVT = BTA_SYS_EVT_START(BTA_ID_3D),
+    BTA_3D_API_DISABLE_EVT,
+    BTA_3D_API_WRITE_SYNC_PARAM_EVT,
+    BTA_3D_API_START_SYNC_TRAIN_EVT,
+    BTA_3D_API_SET_BCAST_DATA_EVT,
+    BTA_3D_API_ENABLE_BCAST_EVT,
+    BTA_3D_API_DISABLE_BCAST_EVT,
+    BTA_3D_API_ENABLE_CLK_CAP_EVT,
+    BTA_3D_API_DISABLE_CLK_CAP_EVT,
+
+    /* Callback events */
+    BTA_3D_BTM_CLB_CMD_CMPL_EVT,
+    BTA_3D_BTM_SYNC_TRAIN_CMPL_EVT,
+    BTA_3D_BTM_TRG_CLK_CAP_EVT,
+    BTA_3D_BTM_SLV_PAGE_RSP_TO_EVT,
+    BTA_3D_L2CA_UCD_DATA_EVT,
+    BTA_3D_BTM_TX_PWR_EVT,
+    BTA_3D_BTM_VS_EVT,
+    BTA_3D_BTM_CLB_CHANNEL_CHANGE_EVT
+};
+
+typedef struct
+{
+    BT_HDR         hdr;
+    tBTA_3D_CBACK *p_cback;
+    char           p_name[BTA_SERVICE_NAME_LEN+1];
+
+} tBTA_3D_API_ENABLE;
+
+typedef struct
+{
+    BT_HDR hdr;
+    UINT32 timeout;
+    UINT8  service_data;
+
+} tBTA_3D_API_WRITE_SYNC_TRAIN_PARAMS;
+
+typedef struct
+{
+    BT_HDR             hdr;
+    tBTA_3D_BCAST_DATA bcast_data;
+
+} tBTA_3D_API_SET_BCAST_DATA;
+
+typedef struct
+{
+    BT_HDR  hdr;
+    UINT16  timeout;
+    BOOLEAN low_power;
+
+} tBTA_3D_API_ENABLE_BCAST;
+
+typedef struct
+{
+    BT_HDR hdr;
+    UINT8  filter_count;
+
+} tBTA_3D_API_ENABLE_CLK_CAP;
+
+typedef struct
+{
+    BT_HDR            hdr;
+    tBTM_CLB_CMD_CMPL data;
+} tBTA_3D_BTM_CLB_CMD_CMPL;
+
+typedef struct
+{
+    BT_HDR hdr;
+    UINT8  status;
+} tBTA_3D_BTM_SYNC_TRAIN_CMPL;
+
+typedef struct
+{
+    BT_HDR           hdr;
+    tBTM_TRG_CLK_CAP data;
+} tBTA_3D_BTM_TRG_CLK_CAP;
+
+typedef struct
+{
+    BT_HDR  hdr;
+    BD_ADDR bd;
+    UINT16  len;
+    UINT8   data[1];
+} tBTA_3D_L2CA_UCD_DATA;
+
+typedef struct
+{
+    BT_HDR      hdr;
+    tBTM_STATUS status;
+    INT8        tx_power;
+} tBTA_3D_BTM_TX_PWR;
+
+typedef struct
+{
+    BT_HDR hdr;
+    UINT8  len;
+    UINT8  data[1];
+} tBTA_3D_BTM_VS_EVT;
+
+typedef union
+{
+    BT_HDR                              hdr;
+    tBTA_3D_API_ENABLE                  api_enable;
+    tBTA_3D_API_WRITE_SYNC_TRAIN_PARAMS api_write_train_params;
+    tBTA_3D_API_SET_BCAST_DATA          api_set_bcast_data;
+    tBTA_3D_API_ENABLE_BCAST            api_enable_bcast;
+    tBTA_3D_API_ENABLE_CLK_CAP          api_enable_clk_cap;
+    tBTA_3D_BTM_CLB_CMD_CMPL            clb_cmd_cmpl;
+    tBTA_3D_BTM_SYNC_TRAIN_CMPL         sync_train_cmpl;
+    tBTA_3D_BTM_TRG_CLK_CAP             trg_clk_cap;
+    tBTA_3D_L2CA_UCD_DATA               ucd_data;
+    tBTA_3D_BTM_TX_PWR                  tx_power;
+    tBTA_3D_BTM_VS_EVT                  vs_evt;
+} tBTA_3D_DATA;
+
+extern BOOLEAN bta_3d_hdl_event(BT_HDR *p_msg);
+
+/******************************************************************************
+** Main Control Block
+*******************************************************************************/
+enum
+{
+    BTA_3D_DISABLED,
+    BTA_3D_ENABLING,
+    BTA_3D_ENABLED,
+    BTA_3D_DISABLING
+};
+
+typedef UINT8 tBTA_3D_STATE;
+
+typedef struct
+{
+    tBTA_3D_STATE  state;
+    tBTA_3D_CBACK *p_cback;
+    UINT32         sdp_handle;
+    UINT8          lt_addr;
+    UINT16         psm;
+}
+tBTA_3D_CB;
+
+#if BTA_DYNAMIC_MEMORY == FALSE
+extern tBTA_3D_CB bta_3d_cb;
+#else
+extern tBTA_3D_CB *bta_3d_cb_ptr;
+#define bta_3d_cb (*bta_3d_cb_ptr)
+#endif
+
+#endif
diff -Naur '--exclude=.git' bluedroid-orig/bta/3d/bta_3d_main.c bluedroid/bta/3d/bta_3d_main.c
--- bluedroid-orig/bta/3d/bta_3d_main.c	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/bta/3d/bta_3d_main.c	2015-09-24 16:31:36.000000000 +0800
@@ -0,0 +1,800 @@
+/******************************************************************************
+ *
+ *  This file contains the 3D Sync main functions and state machine.
+ *
+ ******************************************************************************/
+
+#include "bt_target.h"
+
+#if defined(BTA_3D_INCLUDED) && (BTA_3D_INCLUDED == TRUE)
+
+#include <string.h>
+
+#include "bta_3d_api.h"
+#include "bta_3d_int.h"
+#include "gki.h"
+#include "l2c_api.h"
+#include "btm_api.h"
+#include "sdp_api.h"
+
+/*****************************************************************************
+** Global data
+*****************************************************************************/
+#if BTA_DYNAMIC_MEMORY == FALSE
+tBTA_3D_CB  bta_3d_cb;
+#endif
+
+
+/*****************************************************************************
+** Internal function definitions
+*****************************************************************************/
+static void bta_3d_api_enable(tBTA_3D_DATA *p_data);
+static void bta_3d_api_disable(void);
+static void bta_3d_api_write_params(tBTA_3D_DATA *p_data);
+static void bta_3d_api_start_train(void);
+static void bta_3d_api_set_bcast_data(tBTA_3D_DATA *p_data);
+static void bta_3d_api_enable_bcast(tBTA_3D_DATA *p_data);
+static void bta_3d_api_disable_bcast(void);
+static void bta_3d_api_enable_clk_cap(tBTA_3D_DATA *p_data);
+static void bta_3d_api_disable_clk_cap(void);
+
+static void bta_3d_btm_clb_cmd_cmpl(tBTA_3D_DATA *p_data);
+static void bta_3d_btm_sync_train_cmpl(tBTA_3D_DATA *p_data);
+static void bta_3d_btm_trg_clk_cap(tBTA_3D_DATA *p_data);
+static void bta_3d_btm_slv_page_rsp_to(void);
+static void bta_3d_btm_tx_pwr(tBTA_3D_DATA *p_data);
+static void bta_3d_l2ca_ucd_data(tBTA_3D_DATA *p_data);
+static void bta_3d_btm_vs_evt(tBTA_3D_DATA *p_data);
+static void bta_3d_btm_clb_channel_change_evt(void);
+
+static void btm_clb_cmd_cmpl(void *result);
+static void btm_sync_train_cmpl(UINT8 status);
+static void btm_trg_clk_cap(tBTM_TRG_CLK_CAP *p);
+static void btm_slave_page_response_to(void);
+static void btm_read_inq_rsp_tx_pwr_cmpl(void *p_buf);
+static void btm_vs_cmpl(tBTM_VSC_CMPL *p_buf);
+static void btm_vs_evt(UINT8 len, UINT8 *p);
+static void btm_clb_channel_change(void);
+
+static void l2ca_ucd_disc_cb(BD_ADDR bd, UINT8 type, UINT32 data);
+static void l2ca_ucd_data_cb(BD_ADDR bd, BT_HDR *p_buf);
+static void l2ca_ucd_cong_status_cb(BD_ADDR bd, BOOLEAN cong);
+
+static void l2ca_connect_ind(BD_ADDR bd, UINT16 lcid, UINT16 psm, UINT8 id);
+static void l2ca_connect_cfm(UINT16 lcid, UINT16 result);
+static void l2ca_connect_pnd_cb(UINT16 lcid);
+static void l2ca_config_ind(UINT16 lcid, tL2CAP_CFG_INFO *info);
+static void l2ca_config_cfm(UINT16 lcid, tL2CAP_CFG_INFO *info);
+static void l2ca_disc_ind(UINT16 lcid, BOOLEAN ack);
+static void l2ca_disc_cfm(UINT16 lcid, UINT16 result);
+static void l2ca_qos_violation_ind(BD_ADDR bd);
+static void l2ca_data_ind(UINT16 lcid, BT_HDR *p_buf);
+static void l2ca_cong_status(UINT16 lcid, BOOLEAN cong);
+static void l2ca_tx_cmpl(UINT16 lcid, UINT16 num);
+/*****************************************************************************
+** Constants and Types
+*****************************************************************************/
+static const tBTM_CLB_CB_INFO btm_clb_cb_info =
+{
+    btm_clb_cmd_cmpl,
+    btm_trg_clk_cap,
+    btm_sync_train_cmpl,
+    btm_slave_page_response_to,
+    btm_clb_channel_change
+};
+
+static const tL2CAP_UCD_CB_INFO l2ca_cb_info =
+{
+    l2ca_ucd_disc_cb,
+    l2ca_ucd_data_cb,
+    l2ca_ucd_cong_status_cb
+};
+
+static const tL2CAP_APPL_INFO l2ca_appl_info =
+{
+    l2ca_connect_ind,
+    l2ca_connect_cfm,
+    l2ca_connect_pnd_cb,
+    l2ca_config_ind,
+    l2ca_config_cfm,
+    l2ca_disc_ind,
+    l2ca_disc_cfm,
+    l2ca_qos_violation_ind,
+    l2ca_data_ind,
+    l2ca_cong_status,
+    l2ca_tx_cmpl,
+};
+
+
+/*****************************************************************************
+** Utilities
+*****************************************************************************/
+static tBTA_3D_STATUS convert_btm_to_3d(tBTM_STATUS btm_status)
+{
+    switch(btm_status)
+    {
+        case BTM_SUCCESS:
+            return (BTA_3D_OK);
+        case BTM_BUSY:
+            return (BTA_3D_ERR_BUSY);
+        case BTM_NO_RESOURCES:
+            return (BTA_3D_ERR_NO_RES);
+        default:
+            return (BTA_3D_ERR);
+    }
+}
+
+static void bta_3d_cmd_status(tBTA_3D_CMD cmd, tBTA_3D_STATUS status)
+{
+    tBTA_3D evt;
+    tBTA_3D_CBACK *p_cb = bta_3d_cb.p_cback;
+
+    if(p_cb)
+    {
+        evt.cmd_status.cmd    = cmd;
+        evt.cmd_status.status = status;
+
+        (*p_cb)(BTA_3D_COMMAND_STATUS_EVT, &evt);
+    }
+}
+
+static BOOLEAN bta_3d_create_record(char *service_name)
+{
+    APPL_TRACE_DEBUG1("%s: Enter", __FUNCTION__);
+    BOOLEAN result       = TRUE;
+    UINT16  service_uuid = UUID_SERVCLASS_3D_DISPLAY;
+
+    bta_3d_cb.sdp_handle = SDP_CreateRecord();
+
+    result &= SDP_AddServiceClassIdList(bta_3d_cb.sdp_handle, 1, &service_uuid);
+    result &= SDP_AddProfileDescriptorList(bta_3d_cb.sdp_handle, UUID_SERVCLASS_3D_SYNC, 0x0100);
+
+    if(service_name && service_name[0] != '\0')
+        result &= SDP_AddAttribute(bta_3d_cb.sdp_handle, ATTR_ID_SERVICE_NAME, TEXT_STR_DESC_TYPE,
+                         (UINT32)(strlen(service_name)+1), (UINT8 *)service_name);
+
+    if(!result)
+    {
+        SDP_DeleteRecord(bta_3d_cb.sdp_handle);
+        bta_3d_cb.sdp_handle = 0;
+    }
+
+    APPL_TRACE_DEBUG2("%s: Exit(%d)", __FUNCTION__,result);
+    return (result);
+}
+
+static void bta_3d_cleanup()
+{
+    APPL_TRACE_DEBUG1("%s: Enter", __FUNCTION__);
+    BTA_Set3DEIREnabled(FALSE, 0);
+    SDP_DeleteRecord(bta_3d_cb.sdp_handle);
+    BTM_DeleteReservedLTADDR(bta_3d_cb.lt_addr);
+    BTM_DeregisterCLB();
+    L2CA_UcdDeregister(bta_3d_cb.psm);
+    L2CA_Deregister(bta_3d_cb.psm);
+    bta_3d_cb.state = BTA_3D_DISABLED;
+    APPL_TRACE_DEBUG1("%s: Exit", __FUNCTION__);
+}
+
+BOOLEAN bta_3d_hdl_event(BT_HDR *p_msg)
+{
+    APPL_TRACE_DEBUG2("%s: Enter(%04X)", __FUNCTION__,p_msg->event);
+    switch(p_msg->event)
+    {
+        case BTA_3D_API_ENABLE_EVT:
+            bta_3d_api_enable((tBTA_3D_DATA *)p_msg);
+            break;
+        case BTA_3D_API_DISABLE_EVT:
+            bta_3d_api_disable();
+            break;
+        case BTA_3D_API_WRITE_SYNC_PARAM_EVT:
+            bta_3d_api_write_params((tBTA_3D_DATA *)p_msg);
+            break;
+        case BTA_3D_API_START_SYNC_TRAIN_EVT:
+            bta_3d_api_start_train();
+            break;
+        case BTA_3D_API_SET_BCAST_DATA_EVT:
+            bta_3d_api_set_bcast_data((tBTA_3D_DATA *)p_msg);
+            break;
+        case BTA_3D_API_ENABLE_BCAST_EVT:
+            bta_3d_api_enable_bcast((tBTA_3D_DATA *)p_msg);
+            break;
+        case BTA_3D_API_DISABLE_BCAST_EVT:
+            bta_3d_api_disable_bcast();
+            break;
+        case BTA_3D_API_ENABLE_CLK_CAP_EVT:
+            bta_3d_api_enable_clk_cap((tBTA_3D_DATA *)p_msg);
+            break;
+        case BTA_3D_API_DISABLE_CLK_CAP_EVT:
+            bta_3d_api_disable_clk_cap();
+            break;
+        case BTA_3D_BTM_CLB_CMD_CMPL_EVT:
+            bta_3d_btm_clb_cmd_cmpl((tBTA_3D_DATA *)p_msg);
+            break;
+        case BTA_3D_BTM_SYNC_TRAIN_CMPL_EVT:
+            bta_3d_btm_sync_train_cmpl((tBTA_3D_DATA *)p_msg);
+            break;
+        case BTA_3D_BTM_TRG_CLK_CAP_EVT:
+            bta_3d_btm_trg_clk_cap((tBTA_3D_DATA *)p_msg);
+            break;
+        case BTA_3D_BTM_SLV_PAGE_RSP_TO_EVT:
+            bta_3d_btm_slv_page_rsp_to();
+            break;
+        case BTA_3D_L2CA_UCD_DATA_EVT:
+            bta_3d_l2ca_ucd_data((tBTA_3D_DATA *)p_msg);
+            break;
+        case BTA_3D_BTM_TX_PWR_EVT:
+            bta_3d_btm_tx_pwr((tBTA_3D_DATA *)p_msg);
+            break;
+        case BTA_3D_BTM_VS_EVT:
+            bta_3d_btm_vs_evt((tBTA_3D_DATA *)p_msg);
+            break;
+        case BTA_3D_BTM_CLB_CHANNEL_CHANGE_EVT:
+            bta_3d_btm_clb_channel_change_evt();
+            break;
+        default:
+            ;//unknown
+    }
+
+    APPL_TRACE_DEBUG1("%s: Exit", __FUNCTION__);
+    return (TRUE);
+}
+
+/*****************************************************************************
+** API Action Handlers
+*****************************************************************************/
+static void bta_3d_api_enable(tBTA_3D_DATA *p_data)
+{
+    tBTA_3D             evt;
+    tBTM_STATUS         btm_status;
+    tBTA_3D_STATUS      status   = BTA_3D_OK;
+    tBTA_3D_API_ENABLE *p_enable = (tBTA_3D_API_ENABLE *)p_data;
+
+    if(bta_3d_cb.state != BTA_3D_DISABLED)
+    {
+        evt.status = BTA_3D_ERR_BUSY;
+        if(p_data->api_enable.p_cback)
+            (*p_data->api_enable.p_cback)(BTA_3D_ENABLE_EVT, &evt);
+    }
+
+    memset(&bta_3d_cb, 0, sizeof(bta_3d_cb));
+
+    bta_3d_cb.state = BTA_3D_ENABLING;
+
+    APPL_TRACE_DEBUG1("%s: Enter", __FUNCTION__);
+    if(p_enable->p_cback)
+    {
+        bta_3d_cb.p_cback = p_enable->p_cback;
+        
+        /* Add the SDP record */
+        if(bta_3d_create_record(p_enable->p_name))
+        {
+            /* Register callbacks. */
+            if(BTM_RegisterCLB((tBTM_CLB_CB_INFO *)&btm_clb_cb_info) == BTM_SUCCESS)
+            {
+                if(((bta_3d_cb.psm = L2CA_Register(PSM_3D_SYNC, (tL2CAP_APPL_INFO *)&l2ca_appl_info)) > 0) && (L2CA_UcdRegister(bta_3d_cb.psm, (tL2CAP_UCD_CB_INFO *)&l2ca_cb_info)) && (BTM_SetUCDSecurityLevel(FALSE, "", BTM_SEC_SERVICE_3D_SYNC, BTM_SEC_NONE, PSM_3D_SYNC, 0, 0)))
+                {
+                    /* Attempt to reserve the lt_addr. The cmd_cmpl callback 
+                     * will be used to complete the enable. */ 
+                    if((btm_status = BTM_SetReservedLTADDR(BTA_3D_LT_ADDR)) != BTM_CMD_STARTED)
+                    {
+                        status = convert_btm_to_3d(btm_status);
+                    }
+                }
+                else
+                    status = BTA_3D_ERR;
+            }
+            else
+                status = BTA_3D_ERR_BUSY;
+        }
+        else
+            status = BTA_3D_ERR_SDP;
+
+        if(status != BTA_3D_OK)
+        {
+            bta_3d_cleanup();
+
+            evt.status = status;
+
+            (*bta_3d_cb.p_cback)(BTA_3D_ENABLE_EVT, &evt);
+
+            bta_3d_cb.p_cback = NULL;
+        }
+    }
+}
+
+static void bta_3d_api_disable(void)
+{
+    tBTA_3D        evt;
+    tBTA_3D_CBACK *p_cb = bta_3d_cb.p_cback;
+
+    if(p_cb == NULL)
+        return;
+
+    bta_3d_cleanup();
+
+    evt.status = BTA_3D_OK;
+
+    (*p_cb)(BTA_3D_DISABLE_EVT, &evt);
+}
+
+static void bta_3d_api_write_params(tBTA_3D_DATA *p_data)
+{
+    tBTM_STATUS                          status;
+    tBTA_3D_API_WRITE_SYNC_TRAIN_PARAMS *p_write_params = (tBTA_3D_API_WRITE_SYNC_TRAIN_PARAMS *)p_data;
+
+    if((status = BTM_WriteSyncTrainParams(BTA_3D_LEGACY_INTERVAL_MIN_MAX_SLOTS, BTA_3D_LEGACY_INTERVAL_MIN_MAX_SLOTS, CONVERT_TO_BASEBAND_SLOTS(p_write_params->timeout), p_write_params->service_data)) != BTM_CMD_STARTED)
+        bta_3d_cmd_status(BTA_3D_CMD_WRITE_PARAMS, convert_btm_to_3d(status));
+}
+
+static void bta_3d_api_start_train(void)
+{
+    tBTM_STATUS status;
+
+    if((status = BTM_StartSyncTrain()) != BTM_CMD_STARTED)
+        bta_3d_cmd_status(BTA_3D_CMD_START_TRAIN, convert_btm_to_3d(status));
+}
+
+static void bta_3d_api_set_bcast_data(tBTA_3D_DATA *p_data)
+{
+    UINT8                       buf[BTA_3D_BCAST_DATA_BUF_SIZE];
+    UINT8                      *p_buf                           = buf;
+    UINT32                      sync_mode;
+    tBTM_STATUS                 status;
+    tBTA_3D_API_SET_BCAST_DATA *p_set_data                      = (tBTA_3D_API_SET_BCAST_DATA *)p_data;
+
+    sync_mode = p_set_data->bcast_data.instant & BTA_3D_BCAST_INSTANT_BITMASK;
+    
+    APPL_TRACE_DEBUG1("Dual View: %d", p_set_data->bcast_data.dual_view);
+    if(p_set_data->bcast_data.dual_view)
+        sync_mode |= BTA_3D_BCAST_VMODE_DUAL_VIEW;
+
+    UINT32_TO_STREAM(p_buf, sync_mode);
+    UINT16_TO_STREAM(p_buf, p_set_data->bcast_data.phase);
+    UINT16_TO_STREAM(p_buf, p_set_data->bcast_data.left_open_off);
+    UINT16_TO_STREAM(p_buf, p_set_data->bcast_data.left_close_off);
+    UINT16_TO_STREAM(p_buf, p_set_data->bcast_data.right_open_off);
+    UINT16_TO_STREAM(p_buf, p_set_data->bcast_data.right_close_off);
+    UINT16_TO_STREAM(p_buf, p_set_data->bcast_data.period);
+    UINT8_TO_STREAM (p_buf, p_set_data->bcast_data.fraction);
+
+    APPL_TRACE_DEBUG1("Sync: %d", p_set_data->bcast_data.instant & BTA_3D_BCAST_INSTANT_BITMASK);
+    APPL_TRACE_DEBUG1("Sync_Mode: %08X", sync_mode);
+    APPL_TRACE_DEBUG1("LLO: %d", p_set_data->bcast_data.left_open_off);
+    APPL_TRACE_DEBUG1("LLC: %d", p_set_data->bcast_data.left_close_off);
+    APPL_TRACE_DEBUG1("RLO: %d", p_set_data->bcast_data.right_open_off);
+    APPL_TRACE_DEBUG1("RLC: %d", p_set_data->bcast_data.right_close_off);
+    APPL_TRACE_DEBUG1("Period: %d", p_set_data->bcast_data.period);
+
+    if((status = BTM_SetCLBData(bta_3d_cb.lt_addr, HCI_CLB_FRAGMENT_SINGLE, BTA_3D_BCAST_DATA_BUF_SIZE, buf)) != BTM_CMD_STARTED)
+        bta_3d_cmd_status(BTA_3D_CMD_SET_BROADCAST_DATA, convert_btm_to_3d(status));
+}
+
+static void bta_3d_api_enable_bcast(tBTA_3D_DATA *p_data)
+{
+    tBTM_STATUS               status;
+    tBTA_3D_API_ENABLE_BCAST *p_enable = (tBTA_3D_API_ENABLE_BCAST *)p_data;
+
+    status = BTM_SetCLB(HCI_CLB_ENABLE, 
+                        bta_3d_cb.lt_addr,
+                        p_enable->low_power?HCI_CLB_LPO_ALLOWED:HCI_CLB_LPO_DISALLOWED,
+                        BTA_3D_CLB_BR_PACKETS,
+                        BTA_3D_LEGACY_INTERVAL_MIN_MAX_SLOTS,
+                        BTA_3D_LEGACY_INTERVAL_MIN_MAX_SLOTS,
+                        CONVERT_TO_BASEBAND_SLOTS(p_enable->timeout));
+
+    if(status != BTM_CMD_STARTED)
+        bta_3d_cmd_status(BTA_3D_CMD_SET_BROADCAST, convert_btm_to_3d(status));
+}
+
+static void bta_3d_api_disable_bcast(void)
+{
+    tBTM_STATUS status;
+
+    if((status = BTM_SetCLB(HCI_CLB_DISABLE, bta_3d_cb.lt_addr, 0, 0, 0, 0, 0)) != BTM_CMD_STARTED)
+        bta_3d_cmd_status(BTA_3D_CMD_SET_BROADCAST, convert_btm_to_3d(status));
+}
+
+static void bta_3d_api_enable_clk_cap(tBTA_3D_DATA *p_data)
+{
+    tBTM_STATUS                 status;
+    tBTA_3D_API_ENABLE_CLK_CAP *p_enable = (tBTA_3D_API_ENABLE_CLK_CAP *)p_data;
+
+    if((status = BTM_SetTrigClkCapture(0, HCI_CLB_ENABLE, HCI_WHICH_CLOCK_LOCAL, HCI_CLB_LPO_DISALLOWED, p_enable->filter_count)) != BTM_CMD_STARTED)
+        bta_3d_cmd_status(BTA_3D_CMD_SET_CLK_CAP, convert_btm_to_3d(status));
+}
+
+static void bta_3d_api_disable_clk_cap(void)
+{
+    tBTM_STATUS status;
+
+    if((status = BTM_SetTrigClkCapture(0, HCI_CLB_DISABLE, HCI_WHICH_CLOCK_LOCAL, 0, 0)) != BTM_CMD_STARTED)
+        bta_3d_cmd_status(BTA_3D_CMD_SET_CLK_CAP, convert_btm_to_3d(status));
+}
+
+/*****************************************************************************
+** Lower Level Callback Action Handlers
+*****************************************************************************/
+static void bta_3d_btm_clb_cmd_cmpl(tBTA_3D_DATA *p_data)
+{
+    UINT8                     cmd_status = HCI_ERR_UNSPECIFIED;
+    tBTA_3D                   evt;
+    tBTA_3D_CBACK            *p_cb       = bta_3d_cb.p_cback;
+    tBTA_3D_STATUS            status     = BTA_3D_ERR;
+    tBTA_3D_BTM_CLB_CMD_CMPL *p_cmd_cmpl = (tBTA_3D_BTM_CLB_CMD_CMPL *)p_data;
+
+    APPL_TRACE_DEBUG2("%s: Enter(%d)", __FUNCTION__, p_cmd_cmpl->data.command_type);
+    if((p_cmd_cmpl->data.command_type == BTM_SET_RESERVED_LT_ADDR_CMPL) && (bta_3d_cb.state == BTA_3D_ENABLING))
+    {
+    APPL_TRACE_DEBUG1("LT ADDR cmpl: %d",p_cmd_cmpl->data.data.set_reserved.status);
+        if((!p_cmd_cmpl->data.timeout) && (p_cmd_cmpl->data.data.set_reserved.status == HCI_SUCCESS)
+                && (BTM_ReadInquiryRspTxPower(btm_read_inq_rsp_tx_pwr_cmpl) == BTM_CMD_STARTED))
+        {
+            bta_3d_cb.lt_addr = p_cmd_cmpl->data.data.set_reserved.lt_addr;
+        }
+        else
+        {
+            bta_3d_cleanup();
+            evt.status = BTA_3D_ERR;
+
+            if(p_cb)
+                (*p_cb)(BTA_3D_ENABLE_EVT, &evt);
+        }
+
+
+    }
+    else
+    {
+        if(!p_cmd_cmpl->data.timeout)
+        {
+            switch(p_cmd_cmpl->data.command_type)
+            {
+                case BTM_SET_CLB_CMPL:
+                    cmd_status = p_cmd_cmpl->data.data.set_clb.status;
+                    break;
+                case BTM_START_SYNC_TRAIN_CMPL:
+                    cmd_status = p_cmd_cmpl->data.data.status;
+                    break;
+                case BTM_SET_CLB_DATA_CMPL:
+                    cmd_status = p_cmd_cmpl->data.data.set_clb_data.status;
+                    break;
+                case BTM_WRITE_SYNC_TRAIN_PARAM_CMPL:
+                    cmd_status = p_cmd_cmpl->data.data.write_param.status;
+                    break;
+                case BTM_SET_TRG_CLK_CAP_CMPL:
+                    cmd_status = p_cmd_cmpl->data.data.status;
+                    break;
+                default:
+                    //Unexpected cmd result, so break out
+                    return;
+            }
+
+            status = (cmd_status == HCI_SUCCESS)?BTA_3D_OK:BTA_3D_ERR;
+        }
+        else
+            status = BTA_3D_ERR_CMD_TIMEOUT;
+
+        bta_3d_cmd_status(p_cmd_cmpl->data.command_type, status);
+    }
+}
+
+static void bta_3d_btm_sync_train_cmpl(tBTA_3D_DATA *p_data)
+{
+    tBTA_3D                      evt;
+    tBTA_3D_CBACK               *p_cb   = bta_3d_cb.p_cback;
+    tBTA_3D_BTM_SYNC_TRAIN_CMPL *p_cmpl = (tBTA_3D_BTM_SYNC_TRAIN_CMPL *)p_data;
+
+    if(p_cb)
+    {
+        evt.train_status = p_cmpl->status;
+
+        (*p_cb)(BTA_3D_SYNC_TRAIN_CMPL_EVT, &evt);
+    }
+}
+
+static void bta_3d_btm_trg_clk_cap(tBTA_3D_DATA *p_data)
+{
+    tBTA_3D                  evt;
+    tBTA_3D_CBACK           *p_cb  = bta_3d_cb.p_cback;
+    tBTA_3D_BTM_TRG_CLK_CAP *p_cap = (tBTA_3D_BTM_TRG_CLK_CAP *)p_data;
+
+    if(p_cb)
+    {
+        evt.clk_cap.clock  = p_cap->data.clock;
+        evt.clk_cap.offset = p_cap->data.offset;
+
+        (*p_cb)(BTA_3D_CLK_CAP_EVT, &evt);
+    }
+}
+
+static void bta_3d_btm_slv_page_rsp_to(void)
+{
+    tBTA_3D_CBACK *p_cb = bta_3d_cb.p_cback;
+
+    if(p_cb)
+        (*p_cb)(BTA_3D_SLV_PAGE_RSP_TO_EVT, NULL);
+}
+
+static void bta_3d_btm_tx_pwr(tBTA_3D_DATA *p_data)
+{
+    tBTA_3D        evt;
+    UINT8          enable;
+    tBTA_3D_CBACK *p_cb   = bta_3d_cb.p_cback;
+    
+    if(p_data->tx_power.status == BTM_SUCCESS)
+    {
+        BTA_Set3DEIREnabled(TRUE, p_data->tx_power.tx_power);
+
+        //Enable Legacy Association
+        enable = 1;
+        BTM_VendorSpecificCommand(BTA_3D_LEGACY_VS_ASSOC_CMD_OCF | HCI_GRP_VENDOR_SPECIFIC, 1, &enable, btm_vs_cmpl);
+        BTM_RegisterForVSEvents(btm_vs_evt, TRUE);
+
+        evt.status      = BTA_3D_OK;
+
+        bta_3d_cb.state = BTA_3D_ENABLED;
+    }
+    else
+    {
+        evt.status = BTA_3D_ERR;
+
+        bta_3d_cleanup();
+    }
+
+    if(p_cb)
+        (*p_cb)(BTA_3D_ENABLE_EVT, &evt);
+}
+
+static void bta_3d_l2ca_ucd_data(tBTA_3D_DATA *p_data)
+{
+    UINT8         *p      = p_data->ucd_data.data;
+    UINT8          opcode;
+    tBTA_3D        evt;
+    tBTA_3D_CBACK *p_cb   = bta_3d_cb.p_cback;
+
+    STREAM_TO_UINT8(opcode, p);
+
+    switch(opcode)
+    {
+        case BTA_3D_UCD_OPCODE_CONN_ANN:
+            if(p_data->ucd_data.len >= BTA_3D_UCD_CONN_MSG_SIZE)
+            {
+                bdcpy(evt.association.bd, p_data->ucd_data.bd);
+                STREAM_TO_UINT8(evt.association.flags, p);
+                STREAM_TO_UINT8(evt.association.battery, p);
+                evt.association.legacy = FALSE;
+
+                if(p_cb)
+                    (*p_cb)(BTA_3D_ASSOCIATION_EVT, &evt);
+            }
+
+            break;
+        default:
+            APPL_TRACE_WARNING1("Unknown UCD opcode: %d", opcode);
+    }
+}
+
+static void bta_3d_btm_vs_evt(tBTA_3D_DATA *p_data)
+{
+    tBTA_3D_CBACK *p_cb = bta_3d_cb.p_cback;
+    tBTA_3D evt;
+    UINT8 *p = p_data->vs_evt.data;
+    UINT8 evt_code;
+
+    STREAM_TO_UINT8(evt_code, p);
+
+    switch(evt_code)
+    {
+        case BTA_3D_LEGACY_VS_ASSOC_EVT_CODE:
+            if(p_data->vs_evt.len >= BTA_3D_LEGACY_VS_ASSOC_EVT_LEN)
+            {
+                STREAM_TO_BDADDR(evt.association.bd, p);
+                evt.association.legacy = TRUE;
+
+                if(p_cb)
+                    (*p_cb)(BTA_3D_ASSOCIATION_EVT, &evt);
+            }
+            break;
+        default:
+            ;
+    }
+}
+
+static void bta_3d_btm_clb_channel_change_evt(void)
+{
+    tBTA_3D_CBACK *p_cb = bta_3d_cb.p_cback;
+
+    if(p_cb)
+        (*p_cb) (BTA_3D_CHANNEL_CHANGE_EVT, NULL);
+}
+
+/*****************************************************************************
+** BTM Callbacks
+*****************************************************************************/
+static void btm_clb_cmd_cmpl(void *result)
+{
+    tBTM_CLB_CMD_CMPL        *p_cmpl = (tBTM_CLB_CMD_CMPL *)result;
+    tBTA_3D_BTM_CLB_CMD_CMPL *p_buf;
+
+    if(p_cmpl)
+    {
+        if((p_buf = (tBTA_3D_BTM_CLB_CMD_CMPL *)GKI_getbuf(sizeof(tBTA_3D_BTM_CLB_CMD_CMPL))) != NULL)
+        {
+            p_buf->hdr.event = BTA_3D_BTM_CLB_CMD_CMPL_EVT;
+            p_buf->data      = *p_cmpl;
+
+            bta_sys_sendmsg(p_buf);
+        }
+    }
+}
+
+static void btm_sync_train_cmpl(UINT8 status)
+{
+    tBTA_3D_BTM_SYNC_TRAIN_CMPL *p_buf;
+
+    if((p_buf = (tBTA_3D_BTM_SYNC_TRAIN_CMPL *)GKI_getbuf(sizeof(tBTA_3D_BTM_SYNC_TRAIN_CMPL))) != NULL)
+    {
+        p_buf->hdr.event = BTA_3D_BTM_SYNC_TRAIN_CMPL_EVT;
+        p_buf->status    = status;
+
+        bta_sys_sendmsg(p_buf);
+    }
+}
+
+static void btm_trg_clk_cap(tBTM_TRG_CLK_CAP *p_cap)
+{
+    tBTA_3D_BTM_TRG_CLK_CAP *p_buf;
+
+    if((p_buf = (tBTA_3D_BTM_TRG_CLK_CAP *)GKI_getbuf(sizeof(tBTA_3D_BTM_TRG_CLK_CAP))) != NULL)
+    {
+        p_buf->hdr.event = BTA_3D_BTM_TRG_CLK_CAP_EVT;
+        p_buf->data      = *p_cap;
+
+        bta_sys_sendmsg(p_buf);
+    }
+}
+
+static void btm_slave_page_response_to(void)
+{
+    BT_HDR *p_buf;
+
+    if((p_buf = (BT_HDR *)GKI_getbuf(sizeof(BT_HDR))) != NULL)
+    {
+        p_buf->event = BTA_3D_BTM_SLV_PAGE_RSP_TO_EVT;
+
+        bta_sys_sendmsg(p_buf);
+    }
+}
+
+static void btm_read_inq_rsp_tx_pwr_cmpl(void *p)
+{
+    tBTA_3D_BTM_TX_PWR     *p_buf;
+    tBTM_INQ_TXPWR_RESULTS *p_results = (tBTM_INQ_TXPWR_RESULTS *)p;
+
+    if((p_buf = (tBTA_3D_BTM_TX_PWR *)GKI_getbuf(sizeof(tBTA_3D_BTM_TX_PWR))) != NULL)
+    {
+        p_buf->hdr.event = BTA_3D_BTM_TX_PWR_EVT;
+        p_buf->status    = p_results->status;
+        p_buf->tx_power  = p_results->tx_power;
+
+        bta_sys_sendmsg(p_buf);
+    }
+}
+
+static void btm_vs_cmpl(tBTM_VSC_CMPL *p_buf)
+{
+    int i;
+
+    APPL_TRACE_DEBUG1("vs_cmpl: %04X", p_buf->opcode);
+
+    for(i=0;i<p_buf->param_len;i++)
+        APPL_TRACE_DEBUG2("vs_cmpl[%d]=%02X", i, p_buf->p_param_buf[i]);
+}
+
+static void btm_vs_evt(UINT8 len, UINT8 *p)
+{
+    tBTA_3D_BTM_VS_EVT *p_buf;
+
+    if((p_buf = (tBTA_3D_BTM_VS_EVT *)GKI_getbuf(sizeof(tBTA_3D_BTM_VS_EVT) + len)) != NULL)
+    {
+        p_buf->hdr.event = BTA_3D_BTM_VS_EVT;
+        p_buf->len       = len;
+        memcpy(p_buf->data, p, len);
+
+        bta_sys_sendmsg(p_buf);
+    }
+}
+
+static void btm_clb_channel_change(void)
+{
+    BT_HDR *p_buf;
+
+    if((p_buf = (BT_HDR *)GKI_getbuf(sizeof(BT_HDR))) != NULL)
+    {
+        p_buf->event = BTA_3D_BTM_CLB_CHANNEL_CHANGE_EVT;
+
+        bta_sys_sendmsg(p_buf);
+    }
+}
+/*****************************************************************************
+** UCD L2CAP Callbacks
+*****************************************************************************/
+static void l2ca_ucd_disc_cb(BD_ADDR bd, UINT8 type, UINT32 data)
+{
+    //We are only a UCD server
+}
+
+static void l2ca_ucd_data_cb(BD_ADDR bd, BT_HDR *p_buf)
+{
+    UINT8                 *p         = (UINT8 *)(p_buf + 1) + p_buf->offset;
+    tBTA_3D_L2CA_UCD_DATA *p_bta_buf;
+
+    if((p_bta_buf = (tBTA_3D_L2CA_UCD_DATA *)GKI_getbuf(sizeof(tBTA_3D_L2CA_UCD_DATA) + p_buf->len)) != NULL)
+    {
+        p_bta_buf->hdr.event = BTA_3D_L2CA_UCD_DATA_EVT;
+        bdcpy(p_bta_buf->bd, bd);
+        p_bta_buf->len = p_buf->len;
+        memcpy(p_bta_buf->data, p, p_buf->len);
+
+        bta_sys_sendmsg(p_bta_buf);
+    }
+}
+
+static void l2ca_ucd_cong_status_cb(BD_ADDR bd, BOOLEAN cong)
+{
+}
+
+/*****************************************************************************
+** Dummy L2CAP Callbacks
+*****************************************************************************/
+//XXX Note we only use UCD data, so these are all empty;
+//XXX however, we are still required to call L2CA_Register before we can
+//XXX call L2CA_UcdRegister
+static void l2ca_connect_ind(BD_ADDR bd, UINT16 lcid, UINT16 psm, UINT8 id)
+{
+}
+
+static void l2ca_connect_cfm(UINT16 lcid, UINT16 result)
+{
+}
+
+static void l2ca_connect_pnd_cb(UINT16 lcid)
+{
+}
+
+static void l2ca_config_ind(UINT16 lcid, tL2CAP_CFG_INFO *info)
+{
+}
+
+static void l2ca_config_cfm(UINT16 lcid, tL2CAP_CFG_INFO *info)
+{
+}
+
+static void l2ca_disc_ind(UINT16 lcid, BOOLEAN ack)
+{
+}
+
+static void l2ca_disc_cfm(UINT16 lcid, UINT16 result)
+{
+}
+
+static void l2ca_qos_violation_ind(BD_ADDR bd)
+{
+}
+
+static void l2ca_data_ind(UINT16 lcid, BT_HDR *p_buf)
+{
+}
+
+static void l2ca_cong_status(UINT16 lcid, BOOLEAN cong)
+{
+}
+
+static void l2ca_tx_cmpl(UINT16 lcid, UINT16 num)
+{
+}
+
+
+
+
+#endif
diff -Naur '--exclude=.git' bluedroid-orig/bta/ar/bta_ar.c bluedroid/bta/ar/bta_ar.c
--- bluedroid-orig/bta/ar/bta_ar.c	2015-09-24 16:33:43.520227643 +0800
+++ bluedroid/bta/ar/bta_ar.c	2015-09-24 16:31:36.000000000 +0800
@@ -243,7 +243,7 @@
 **
 ******************************************************************************/
 void bta_ar_reg_avrc(UINT16 service_uuid, char *service_name, char *provider_name,
-					 UINT16 categories, tBTA_SYS_ID sys_id)
+                     UINT16 categories, tBTA_SYS_ID sys_id, BOOLEAN browse_supported)
 {
     UINT8   mask = bta_ar_id (sys_id);
     UINT8   temp[8], *p;
@@ -257,7 +257,8 @@
         {
             bta_ar_cb.tg_registered = mask;
             bta_ar_cb.sdp_tg_handle = SDP_CreateRecord();
-            AVRC_AddRecord(service_uuid, service_name, provider_name, categories, bta_ar_cb.sdp_tg_handle);
+            AVRC_AddRecord(service_uuid, service_name, provider_name, categories,
+                                             bta_ar_cb.sdp_tg_handle, browse_supported);
 #if ( BTM_EIR_SERVER_INCLUDED == TRUE )&&(BTA_EIR_CANNED_UUID_LIST != TRUE)
             bta_sys_add_uuid(service_uuid);
 #endif
@@ -265,14 +266,16 @@
         /* only one TG is allowed (first-come, first-served).
          * If sdp_tg_handle is non-0, ignore this request */
     }
-    else if ((service_uuid == UUID_SERVCLASS_AV_REMOTE_CONTROL) || (service_uuid == UUID_SERVCLASS_AV_REM_CTRL_CONTROL))
+    else if ((service_uuid == UUID_SERVCLASS_AV_REMOTE_CONTROL)||
+             (service_uuid == UUID_SERVCLASS_AV_REM_CTRL_CONTROL))
     {
         bta_ar_cb.ct_categories [mask - 1] = categories;
         categories = bta_ar_cb.ct_categories[0]|bta_ar_cb.ct_categories[1];
         if (bta_ar_cb.sdp_ct_handle == 0)
         {
             bta_ar_cb.sdp_ct_handle = SDP_CreateRecord();
-            AVRC_AddRecord(service_uuid, service_name, provider_name, categories, bta_ar_cb.sdp_ct_handle);
+            AVRC_AddRecord(service_uuid, service_name, provider_name, categories,
+                                              bta_ar_cb.sdp_ct_handle, browse_supported);
 #if ( BTM_EIR_SERVER_INCLUDED == TRUE )&&(BTA_EIR_CANNED_UUID_LIST != TRUE)
             bta_sys_add_uuid(service_uuid);
 #endif
diff -Naur '--exclude=.git' bluedroid-orig/bta/av/bta_av_aact.c bluedroid/bta/av/bta_av_aact.c
--- bluedroid-orig/bta/av/bta_av_aact.c	2015-09-24 16:33:43.520227643 +0800
+++ bluedroid/bta/av/bta_av_aact.c	2015-09-24 16:31:36.000000000 +0800
@@ -38,6 +38,13 @@
 #include "bta_ar_api.h"
 #endif
 
+#if (A2DP_KERNEL_DIRECT == TRUE)
+#include "a2d_sbc.h"
+#endif
+#include <cutils/properties.h>
+
+#define UNUSED(x) (void)(x)
+
 /*****************************************************************************
 **  Constants
 *****************************************************************************/
@@ -57,6 +64,14 @@
 #define BTA_AV_RECONFIG_RETRY       6
 #endif
 
+#ifndef BTA_AV_CO_SBC_MAX_BITPOOL_OFF
+#define BTA_AV_CO_SBC_MAX_BITPOOL_OFF  6
+#endif
+
+#ifndef BTA_AV_CO_SBC_MAX_BITPOOL
+#define BTA_AV_CO_SBC_MAX_BITPOOL  53
+#endif
+
 /* state machine states */
 enum
 {
@@ -331,15 +346,14 @@
 *******************************************************************************/
 void bta_av_st_rc_timer(tBTA_AV_SCB *p_scb, tBTA_AV_DATA *p_data)
 {
+    UNUSED(p_data);
 
     APPL_TRACE_DEBUG2("bta_av_st_rc_timer rc_handle:%d, use_rc: %d",
         p_scb->rc_handle, p_scb->use_rc);
     /* for outgoing RC connection as INT/CT */
     if( (p_scb->rc_handle == BTA_AV_RC_HANDLE_NONE) &&
         /*(bta_av_cb.features & BTA_AV_FEAT_RCCT) &&*/
-        (p_scb->use_rc == TRUE || (p_scb->role & BTA_AV_ROLE_AD_ACP)) &&
-        /* Only in case of SRC initiate AVRCP Connection */
-        (p_scb->seps[p_scb->sep_idx].tsep == AVDT_TSEP_SRC) )
+        (p_scb->use_rc == TRUE || (p_scb->role & BTA_AV_ROLE_AD_ACP)) )
     {
         if ((p_scb->wait & BTA_AV_WAIT_ROLE_SW_BITS) == 0)
             bta_sys_start_timer(&p_scb->timer, BTA_AV_AVRC_TIMER_EVT, BTA_AV_RC_DISC_TIME_VAL);
@@ -364,12 +378,20 @@
     int     i;
     tAVDT_GETCAP_REQ    *p_req;
     BOOLEAN     sent_cmd = FALSE;
+    UINT16 uuid_int = p_scb->uuid_int;
+    UINT8 sep_requested = 0;
+
+    if(uuid_int == UUID_SERVCLASS_AUDIO_SOURCE)
+       sep_requested = AVDT_TSEP_SNK;
+    else if(uuid_int == UUID_SERVCLASS_AUDIO_SINK)
+       sep_requested = AVDT_TSEP_SRC;
 
     for (i = p_scb->sep_info_idx; i < p_scb->num_seps; i++)
     {
         /* steam not in use, is a sink, and is the right media type (audio/video) */
+        //Qualcomm : TODO check why SEP info is not updated properly
         if ((p_scb->sep_info[i].in_use == FALSE) &&
-            (p_scb->sep_info[i].tsep == AVDT_TSEP_SNK) &&
+            (p_scb->sep_info[i].tsep == sep_requested) &&
             (p_scb->sep_info[i].media_type == p_scb->media_type))
         {
             p_scb->sep_info_idx = i;
@@ -384,7 +406,7 @@
                 i = p_scb->num_seps;
                 break;
             }
-            if ((p_scb->avdt_version >= AVDT_VERSION_SYNC) && (a2d_get_avdt_sdp_ver() >= AVDT_VERSION_SYNC) )
+            if ((p_scb->avdt_version >= AVDT_VERSION_SYNC))
             {
                 p_req = AVDT_GetAllCapReq;
             }
@@ -548,7 +570,14 @@
 /* coverity[var_deref_model] */
 /* false-positive: bta_av_conn_cback only processes AVDT_CONNECT_IND_EVT and AVDT_DISCONNECT_IND_EVT event
  *                 these 2 events always have associated p_data */
-    bta_av_conn_cback(handle, bd_addr, event, p_data);
+    if (p_data)
+    {
+        bta_av_conn_cback(handle, bd_addr, event, p_data);
+    }
+    else
+    {
+        APPL_TRACE_ERROR0("bta_av_proc_stream_evt: p_data is null");
+    }
 }
 
 /*******************************************************************************
@@ -564,11 +593,6 @@
 {
     int index = 0;
     tBTA_AV_SCB         *p_scb ;
-    if (p_pkt == NULL )
-    {
-        APPL_TRACE_ERROR0("bta_av_stream_data_cback: Not a valid packet");
-        return;
-    }
     APPL_TRACE_DEBUG3("bta_av_stream_data_cback avdt_handle: %d pkt_len=0x%x  ofst = 0x%x", handle,p_pkt->len,p_pkt->offset);
     APPL_TRACE_DEBUG1(" Number of frames 0x%x",*((UINT8*)(p_pkt + 1) + p_pkt->offset));
     APPL_TRACE_DEBUG1("Sequence Number 0x%x",p_pkt->layer_specific);
@@ -576,15 +600,11 @@
     for(index = 0; index < BTA_AV_NUM_STRS;index ++ )
     {
         p_scb = bta_av_cb.p_scb[index];
-        if (p_scb == NULL)
-            continue;
-        if ((p_scb->avdt_handle == handle) && (p_scb->seps[p_scb->sep_idx].tsep == AVDT_TSEP_SNK)
-                                                             && (p_scb->state == BTA_AV_OPEN_SST))
+        if((p_scb->avdt_handle == handle)&&(p_scb->seps[p_scb->sep_idx].tsep == AVDT_TSEP_SNK))
             break;
     }
     if(index == BTA_AV_NUM_STRS) /* cannot find correct handler */
     {
-        APPL_TRACE_ERROR0("bta_av_stream_data_cback: Could not find matching Streaming Channel");
         GKI_freebuf(p_pkt);
         return;
     }
@@ -690,7 +710,141 @@
     bta_av_proc_stream_evt(handle, bd_addr, event, p_data, 5);
 }
 #endif
+#if (A2DP_KERNEL_DIRECT == TRUE)
+
+#define DEFAULT_SBC_BITRATE 237
+
+#ifndef BTIF_A2DP_NON_EDR_MAX_RATE
+#define BTIF_A2DP_NON_EDR_MAX_RATE 237
+#endif
+
+#define MAX_2MBPS_AVDTP_MTU 675
+static tBTA_AV_BTLITE_INFO  btlite_info;
+void BTLITE_respose_cback(tBTM_BTLITE_CMPL *p_info)
+{
+    APPL_TRACE_DEBUG2("## BTLITE_respose_cback ## event = %x opcode = %d",p_info->event,p_info->opcode);
+    if (p_info->event == BT_EVT_BTU_IPC_BTM_EVT)
+    {
+        switch (p_info->opcode)
+        {
+            case BTA_AV_SYNC_TO_LITE_RESP:
+               btlite_send_l2c_sync_req(BTLITE_respose_cback);
+               break;
+            case BTA_AV_STR_START_TO_LITE_RESP:
+            case BTA_AV_STR_SUSPEND_TO_LITE_RESP:
+            case BTA_AV_STR_STOP_TO_LITE_RESP:
+               APPL_TRACE_DEBUG0("BTLITE_respose_cback rsp success");
+               break;
+            case BTA_AV_STR_CLEANUP_TO_LITE_RESP:
+               APPL_TRACE_DEBUG0("AV Sync cleanup rsp: call AVDT cleanup");
+               btlite_send_avdt_remove_req(BTLITE_respose_cback);
+               break;
+            default:
+               APPL_TRACE_ERROR0("Unknown lite response");
+        }
+    }
+    else if(p_info->event == BT_EVT_BTU_IPC_L2C_EVT)
+    {
+       if (p_info->opcode == L2C_SYNC_TO_LITE_RESP)
+       {
+           btlite_send_avdt_sync_req(BTLITE_respose_cback);
+           //  bta_send_btlite_start_req(1);
+       }
+       else if (p_info->opcode == L2C_REMOVE_TO_LITE_RESP)
+           APPL_TRACE_DEBUG0("BTLITE Remvoe req complete !!!");
+    }
+    else if(p_info->event == BT_EVT_BTU_IPC_AVDT_EVT)
+    {
+       if (p_info->opcode == AVDT_SYNC_TO_LITE_RESP)
+       {
+           APPL_TRACE_DEBUG0("BTLITE AVDT SYNC Done!!!");
+       }
+       else if(p_info->opcode == AVDT_REMOVE_TO_LITE_RESP)
+       {
+           APPL_TRACE_DEBUG0("AVDT removed, call l2c remove");
+           btlite_send_l2c_remove_req(BTLITE_respose_cback);
+       }
+    }
+}
+void bta_send_btlite_sync_req(tBTA_AV_OPEN *p_AV)
+{
+    APPL_TRACE_EVENT0("## ON A2DP OPENED ##");
+
+    tBTA_AV_SYNC_INFO_REQ av_sync_info_req;
+
+    av_sync_info_req.sync_info.avdt_handle = p_AV->avdt_handle;
+    av_sync_info_req.sync_info.chnl        = p_AV->chnl;
+    av_sync_info_req.sync_info.codec_type  = p_AV->codec_type;
+    av_sync_info_req.sync_info.cong        = p_AV->cong;
+    av_sync_info_req.sync_info.hdi         = p_AV->hdi;
+    av_sync_info_req.sync_info.hndl        = p_AV->hndl;
+    av_sync_info_req.sync_info.l2c_bufs    = p_AV->l2c_bufs;
+    av_sync_info_req.sync_info.l2c_cid     = p_AV->l2c_cid;
+    bdcpy(av_sync_info_req.sync_info.peer_addr, p_AV->bd_addr);
+//    av_sync_info_req.curr_mtu              = p_AV->curr_mtu;
+    av_sync_info_req.multi_av_supported    = 0; //0 not supported
+/*    if (!(p_AV->edr & BTA_AV_EDR_3MBPS))
+    {
+        if (p_AV->curr_mtu > MAX_2MBPS_AVDTP_MTU)
+            av_sync_info_req.curr_mtu = MAX_2MBPS_AVDTP_MTU;
+    }*/
+    av_sync_info_req.curr_mtu = MAX_2MBPS_AVDTP_MTU;// limit MTU size to max 2DH5 packet
+    APPL_TRACE_EVENT0("[BTLITE_REQ] Send SYNC Req");
+
+    BTA_DMSendBTLiteReq(BTA_AV_SYNC_TO_LITE_REQ,(void *)&av_sync_info_req,BTLITE_respose_cback);
+
+}
+void bta_send_btlite_start_req(UINT8 audio_open_cnt)
+{
+    APPL_TRACE_EVENT0("## btif_send_btlite_sync_req ##");
+    UINT16 minmtu;
+    tA2D_SBC_CIE sbc_config;
+    tBTA_AV_SCB_REQ sbc_req;
+    UINT16 bitrate = DEFAULT_SBC_BITRATE;
+    BOOLEAN edr =  btif_av_is_peer_edr();
+    memset(&sbc_req,0,sizeof(tBTA_AV_SCB_REQ));
+    //btif_av_get_codec_config(&sbc_req,audio_open_cnt);
+    if (!edr) bitrate = BTIF_A2DP_NON_EDR_MAX_RATE;
+
+    /* Retrieve the current SBC configuration (default if currently not used) */
+    bta_av_co_audio_get_sbc_config(&sbc_config, &minmtu);
+    sbc_req.event = BTA_AV_STR_START_TO_LITE_REQ;
+    sbc_req.audio_open_cnt = audio_open_cnt;
+    sbc_req.scb_idx = 0;
+    sbc_req.start_stop_flag = FALSE;
+    sbc_req.streaming_type = 0; //0 for SBC
+    sbc_req.p_codec_cfg.bit_rate = bitrate;
+    sbc_req.p_codec_cfg.bit_rate_busy = bitrate; //TODO: Should be changed later based on customer input
+    sbc_req.p_codec_cfg.bit_rate_swampd = bitrate; //TODO: Should be changed later based on customer input
+    sbc_req.p_codec_cfg.busy_level = 0; //TODO: Should be changed later based on customer input
+    sbc_req.p_codec_cfg.codec_type = A2D_MEDIA_CT_SBC; //for SBC
+    A2D_BldSbcInfo(A2D_MEDIA_TYPE_AUDIO,&sbc_config,(void *)&sbc_req.p_codec_cfg.codec_info);
+    BTA_DMSendBTLiteReq(BTA_AV_STR_START_TO_LITE_REQ, (void *)&sbc_req, BTLITE_respose_cback);
+}
+void bta_send_btlite_suspend_req(UINT8 scb_idx, UINT8 audio_open_cnt)
+{
+    APPL_TRACE_EVENT0("## btif_send_btlite_suspend_req ##");
+    btlite_info.scb_idx = scb_idx;
+    btlite_info.audio_open_cnt = audio_open_cnt;
+    BTA_DMSendBTLiteReq(BTA_AV_STR_SUSPEND_TO_LITE_REQ, (void*)&btlite_info, BTLITE_respose_cback);
+}
+void bta_send_btlite_stop_req(UINT8 scb_idx, UINT8 audio_open_cnt)
+{
+    APPL_TRACE_EVENT0("## btif_send_btlite_stop_req ##");
+    btlite_info.scb_idx = scb_idx;
+    btlite_info.audio_open_cnt = audio_open_cnt;
+    BTA_DMSendBTLiteReq(BTA_AV_STR_STOP_TO_LITE_REQ, (void*)&btlite_info, BTLITE_respose_cback);
+}
+void bta_send_btlite_cleanup_req(UINT8 scb_idx, UINT8 audio_open_cnt, UINT16 mtu)
+{
+    APPL_TRACE_EVENT0("## btif_send_btlite_cleanup_req ##");
+    btlite_info.scb_idx = scb_idx;
+    btlite_info.audio_open_cnt = audio_open_cnt;
+    btlite_info.curr_mtu = mtu;
+    BTA_DMSendBTLiteReq(BTA_AV_STR_CLEANUP_TO_LITE_REQ, (void*)&btlite_info, BTLITE_respose_cback);
+}
 
+#endif
 /*******************************************************************************
 **
 ** Function         bta_av_a2d_sdp_cback
@@ -772,6 +926,7 @@
 {
     tBTA_AV_RS_RES      switch_res = BTA_AV_RS_NONE;
     tBTA_AV_API_OPEN  *p_buf = &p_scb->q_info.open;
+    UNUSED(p_data);
 
     APPL_TRACE_DEBUG1("bta_av_switch_role wait:x%x", p_scb->wait);
     if (p_scb->wait & BTA_AV_WAIT_ROLE_SW_RES_START)
@@ -923,6 +1078,7 @@
     UINT16              attr_list[] = {ATTR_ID_SERVICE_CLASS_ID_LIST,
                                        ATTR_ID_PROTOCOL_DESC_LIST,
                                        ATTR_ID_BT_PROFILE_DESC_LIST};
+    UINT16 sdp_uuid = 0; /* UUID for which SDP has to be done */
 
     APPL_TRACE_DEBUG3("bta_av_do_disc_a2d use_rc: %d rs:%d, oc:%d",
         p_data->api_open.use_rc, p_data->api_open.switch_res, bta_av_cb.audio_open_cnt);
@@ -984,13 +1140,13 @@
 
     if (bta_av_cb.features & BTA_AV_FEAT_MASTER)
     {
-    L2CA_SetDesireRole(L2CAP_ROLE_DISALLOW_SWITCH);
+        L2CA_SetDesireRole(L2CAP_ROLE_DISALLOW_SWITCH);
 
-    if (bta_av_cb.audio_open_cnt == 1)
-    {
-        /* there's already an A2DP connection. do not allow switch */
-        bta_sys_clear_default_policy(BTA_ID_AV, HCI_ENABLE_MASTER_SLAVE_SWITCH);
-    }
+        if (bta_av_cb.audio_open_cnt == 1)
+        {
+            /* there's already an A2DP connection. do not allow switch */
+            bta_sys_clear_default_policy(BTA_ID_AV, HCI_ENABLE_MASTER_SLAVE_SWITCH);
+        }
     }
     /* store peer addr other parameters */
     bta_av_save_addr(p_scb, p_data->api_open.bd_addr);
@@ -999,33 +1155,53 @@
 
     bta_sys_conn_open(BTA_ID_AV, p_scb->app_id, p_scb->peer_addr);
 
-    /* allocate discovery database */
-    if (p_scb->p_disc_db == NULL)
+    if (p_scb->skip_sdp == TRUE)
     {
-        p_scb->p_disc_db = (tSDP_DISCOVERY_DB *) GKI_getbuf(BTA_AV_DISC_BUF_SIZE);
+        tA2D_Service a2d_ser;
+        a2d_ser.avdt_version = AVDT_VERSION;
+        p_scb->skip_sdp = FALSE;
+        p_scb->uuid_int = p_data->api_open.uuid;
+        /* only one A2D find service is active at a time */
+        bta_av_cb.handle = p_scb->hndl;
+        APPL_TRACE_IMP0("Skip Sdp for incoming A2dp connection");
+        bta_av_a2d_sdp_cback(TRUE, &a2d_ser);
     }
-
-    /* only one A2D find service is active at a time */
-    bta_av_cb.handle = p_scb->hndl;
-
-    if(p_scb->p_disc_db)
+    else
     {
-        /* set up parameters */
-        db_params.db_len = BTA_AV_DISC_BUF_SIZE;
-        db_params.num_attr = 3;
-        db_params.p_db = p_scb->p_disc_db;
-        db_params.p_attrs = attr_list;
+        /* allocate discovery database */
+        if (p_scb->p_disc_db == NULL)
+        {
+            p_scb->p_disc_db = (tSDP_DISCOVERY_DB *) GKI_getbuf(BTA_AV_DISC_BUF_SIZE);
+        }
+
+        /* only one A2D find service is active at a time */
+        bta_av_cb.handle = p_scb->hndl;
 
-        if(A2D_FindService(UUID_SERVCLASS_AUDIO_SINK, p_scb->peer_addr, &db_params,
-                        bta_av_a2d_sdp_cback) == A2D_SUCCESS)
+        if(p_scb->p_disc_db)
         {
-            return;
+            /* set up parameters */
+            db_params.db_len = BTA_AV_DISC_BUF_SIZE;
+            db_params.num_attr = 3;
+            db_params.p_db = p_scb->p_disc_db;
+            db_params.p_attrs = attr_list;
+            p_scb->uuid_int = p_data->api_open.uuid;
+            if (p_scb->uuid_int == UUID_SERVCLASS_AUDIO_SINK)
+                sdp_uuid = UUID_SERVCLASS_AUDIO_SOURCE;
+            else if (p_scb->uuid_int == UUID_SERVCLASS_AUDIO_SOURCE)
+                sdp_uuid = UUID_SERVCLASS_AUDIO_SINK;
+
+            APPL_TRACE_DEBUG2("uuid_int 0x%x, Doing SDP For 0x%x", p_scb->uuid_int, sdp_uuid);
+            if(A2D_FindService(sdp_uuid, p_scb->peer_addr, &db_params,
+                            bta_av_a2d_sdp_cback) == A2D_SUCCESS)
+            {
+                return;
+            }
         }
-    }
 
-    /* when the code reaches here, either the DB is NULL
-     * or A2D_FindService is not successful */
-    bta_av_a2d_sdp_cback(FALSE, NULL);
+        /* when the code reaches here, either the DB is NULL
+         * or A2D_FindService is not successful */
+        bta_av_a2d_sdp_cback(FALSE, NULL);
+    }
 }
 
 /*******************************************************************************
@@ -1042,6 +1218,7 @@
     tBTA_AV_CONN_CHG msg;
     int             xx;
     UINT8           role = BTA_AV_ROLE_AD_INT;
+    UNUSED(p_data);
 
     APPL_TRACE_DEBUG0("bta_av_cleanup");
 
@@ -1061,6 +1238,8 @@
     p_scb->cur_psc_mask = 0;
     p_scb->wait = 0;
     p_scb->num_disc_snks = 0;
+    p_scb->coll_mask = 0;
+    p_scb->skip_sdp = FALSE;
     bta_sys_stop_timer(&p_scb->timer);
     if (p_scb->deregistring)
     {
@@ -1094,6 +1273,7 @@
 *******************************************************************************/
 void bta_av_free_sdb(tBTA_AV_SCB *p_scb, tBTA_AV_DATA *p_data)
 {
+    UNUSED(p_data);
     utl_freebuf((void **) &p_scb->p_disc_db);
 }
 
@@ -1114,10 +1294,8 @@
     UINT8   psc_mask = (p_evt_cfg->psc_mask | p_scb->cfg.psc_mask);
     UINT8 local_sep;    /* sep type of local handle on which connection was received */
     UINT8 count = 0;
-    UINT8 i = 0;
-    UINT8 ret = 0;
     tBTA_AV_STR_MSG  *p_msg = (tBTA_AV_STR_MSG *)p_data;
-    BT_HDR *p_msg_media;
+    UNUSED(p_data);
 
     local_sep = bta_av_get_scb_sep_type(p_scb, p_msg->handle);
     p_scb->avdt_label = p_data->str_msg.msg.hdr.label;
@@ -1164,20 +1342,7 @@
 
         p_scb->role      |= BTA_AV_ROLE_AD_ACP;
         p_scb->cur_psc_mask = p_evt_cfg->psc_mask;
-        if (local_sep == AVDT_TSEP_SNK)
-        {
-            for (i=0; i<BTA_AV_NUM_RCB; i++)
-            {
-                if ((bta_av_cb.rcb[i].handle != BTA_AV_RC_HANDLE_NONE) &&
-                    (bta_av_cb.rcb[i].status & BTA_AV_RC_CONN_MASK))
-                {
-                    ret = AVRC_Close(bta_av_cb.rcb[i].handle);
-                    APPL_TRACE_WARNING2(" Found existing AVRCP Connection %d returned %d",
-                                                            bta_av_cb.rcb[i].handle, ret);
-                }
-            }
-        }
-        if ((bta_av_cb.features & BTA_AV_FEAT_RCTG) && (local_sep != AVDT_TSEP_SNK))
+        if (bta_av_cb.features & BTA_AV_FEAT_RCTG)
             p_scb->use_rc = TRUE;
         else
             p_scb->use_rc = FALSE;
@@ -1223,9 +1388,10 @@
 void bta_av_disconnect_req (tBTA_AV_SCB *p_scb, tBTA_AV_DATA *p_data)
 {
     tBTA_AV_RCB *p_rcb;
+    UNUSED(p_data);
+
     APPL_TRACE_DEBUG1("bta_av_disconnect_req conn_lcb: 0x%x", bta_av_cb.conn_lcb);
 
-    bta_av_cb.retry_attempt = 0;
     bta_sys_stop_timer(&bta_av_cb.sig_tmr);
     bta_sys_stop_timer(&p_scb->timer);
     if(bta_av_cb.conn_lcb)
@@ -1312,7 +1478,6 @@
     AVDT_ConfigRsp(p_scb->avdt_handle, p_scb->avdt_label, p_data->ci_setconfig.err_code,
                    p_data->ci_setconfig.category);
 
-    bta_av_cb.retry_attempt = 0;
     bta_sys_stop_timer(&bta_av_cb.sig_tmr);
 
     if(p_data->ci_setconfig.err_code == AVDT_SUCCESS)
@@ -1320,7 +1485,7 @@
         p_scb->wait = BTA_AV_WAIT_ACP_CAPS_ON;
         if(p_data->ci_setconfig.recfg_needed)
             p_scb->role |= BTA_AV_ROLE_SUSPEND_OPT;
-        APPL_TRACE_ERROR3("bta_av_setconfig_rsp recfg_needed:%d role:x%x num:%d",
+        APPL_TRACE_DEBUG3("bta_av_setconfig_rsp recfg_needed:%d role:x%x num:%d",
             p_data->ci_setconfig.recfg_needed, p_scb->role, num);
         /* callout module tells BTA the number of "good" SEPs and their SEIDs.
          * getcap on these SEID */
@@ -1336,7 +1501,8 @@
                        * call disc_res now */
            /* this is called in A2DP SRC path only, In case of SINK we don't need it  */
             if (local_sep == AVDT_TSEP_SRC)
-                p_scb->p_cos->disc_res(p_scb->hndl, num, num, p_scb->peer_addr);
+                p_scb->p_cos->disc_res(p_scb->hndl, num, num, 0, p_scb->peer_addr,
+                                                      UUID_SERVCLASS_AUDIO_SOURCE);
         }
         else
         {
@@ -1357,7 +1523,12 @@
         }
         /* only in case of local sep as SRC we need to look for other SEPs, In case of SINK we don't */
         if (local_sep == AVDT_TSEP_SRC)
+        {
+            /* Make sure UUID has been initialized... */
+            if (p_scb->uuid_int == 0)
+                p_scb->uuid_int = p_scb->open_api.uuid;
             bta_av_next_getcap(p_scb, p_data);
+        }
     }
 }
 
@@ -1434,7 +1605,21 @@
             open.sep = AVDT_TSEP_SNK;
         else if (p_scb->seps[p_scb->sep_idx].tsep == AVDT_TSEP_SNK )
             open.sep = AVDT_TSEP_SRC;
-
+#if (A2DP_KERNEL_DIRECT == TRUE)
+        open.avdt_handle = p_scb->avdt_handle;
+        open.hdi         = p_scb->hdi;
+        open.l2c_cid     = p_scb->l2c_cid;
+        open.l2c_bufs    = p_scb->l2c_bufs;
+        open.cong        = p_scb->cong;
+        open.codec_type  = p_scb->codec_type;
+        open.curr_mtu     = p_scb->stream_mtu;
+        if (open.sep == AVDT_TSEP_SNK)
+        {
+            bta_send_btlite_sync_req(&open);
+            fill_l2c_sync_req(p_scb->l2c_cid,open.bd_addr,p_scb->stream_mtu);
+            fill_avdt_sync_req(p_scb->l2c_cid,p_scb->avdt_handle,p_scb->peer_addr,p_scb->stream_mtu);
+        }
+#endif //A2DP_KERNEL_DIRECT
         (*bta_av_cb.p_cback)(BTA_AV_OPEN_EVT, (tBTA_AV *) &open);
         if(open.starting)
         {
@@ -1513,12 +1698,13 @@
 *******************************************************************************/
 void bta_av_do_close (tBTA_AV_SCB *p_scb, tBTA_AV_DATA *p_data)
 {
+    UNUSED(p_data);
+
     /* stop stream if started */
     if (p_scb->co_started)
     {
         bta_av_str_stopped(p_scb, NULL);
     }
-    bta_av_cb.retry_attempt = 0;
     bta_sys_stop_timer(&bta_av_cb.sig_tmr);
 
     /* close stream */
@@ -1549,6 +1735,8 @@
 *******************************************************************************/
 void bta_av_connect_req (tBTA_AV_SCB *p_scb, tBTA_AV_DATA *p_data)
 {
+    UNUSED(p_data);
+
     utl_freebuf((void **) &p_scb->p_disc_db);
 
     if (p_scb->coll_mask & BTA_AV_COLL_INC_TMR)
@@ -1593,8 +1781,11 @@
 *******************************************************************************/
 void bta_av_disc_results (tBTA_AV_SCB *p_scb, tBTA_AV_DATA *p_data)
 {
-    UINT8 num_snks = 0, i;
+    UINT8 num_snks = 0, num_srcs =0, i;
+    /* our uuid in case we initiate connection */
+    UINT16 uuid_int = p_scb->uuid_int;
 
+    APPL_TRACE_DEBUG1(" initiator UUID 0x%x", uuid_int);
     /* store number of stream endpoints returned */
     p_scb->num_seps = p_data->str_msg.msg.discover_cfm.num_seps;
 
@@ -1602,15 +1793,23 @@
     {
         /* steam not in use, is a sink, and is audio */
         if ((p_scb->sep_info[i].in_use == FALSE) &&
-            (p_scb->sep_info[i].tsep == AVDT_TSEP_SNK) &&
             (p_scb->sep_info[i].media_type == p_scb->media_type))
         {
-            num_snks++;
+            if((p_scb->sep_info[i].tsep == AVDT_TSEP_SNK) &&
+               (uuid_int == UUID_SERVCLASS_AUDIO_SOURCE))
+                num_snks++;
+
+            if((p_scb->sep_info[i].tsep == AVDT_TSEP_SRC) &&
+               (uuid_int == UUID_SERVCLASS_AUDIO_SINK))
+                num_srcs++;
+
         }
     }
 
-    p_scb->p_cos->disc_res(p_scb->hndl, p_scb->num_seps, num_snks, p_scb->peer_addr);
+    p_scb->p_cos->disc_res(p_scb->hndl, p_scb->num_seps, num_snks, num_srcs, p_scb->peer_addr,
+                                                                                    uuid_int);
     p_scb->num_disc_snks = num_snks;
+    p_scb->num_disc_srcs = num_srcs;
 
     /* if we got any */
     if (p_scb->num_seps > 0)
@@ -1658,8 +1857,10 @@
             num_snks++;
         }
     }
-    p_scb->p_cos->disc_res(p_scb->hndl, p_scb->num_seps, num_snks, p_scb->peer_addr);
+    p_scb->p_cos->disc_res(p_scb->hndl, p_scb->num_seps, num_snks, 0, p_scb->peer_addr,
+                                                          UUID_SERVCLASS_AUDIO_SOURCE);
     p_scb->num_disc_snks = num_snks;
+    p_scb->num_disc_srcs = 0;
 
     /* if we got any */
     if (p_scb->num_seps > 0)
@@ -1737,6 +1938,8 @@
 *******************************************************************************/
 void bta_av_set_use_rc (tBTA_AV_SCB *p_scb, tBTA_AV_DATA *p_data)
 {
+    UNUSED(p_data);
+
     p_scb->use_rc = TRUE;
 }
 
@@ -1752,6 +1955,8 @@
 void bta_av_cco_close (tBTA_AV_SCB *p_scb, tBTA_AV_DATA *p_data)
 {
     UINT16 mtu;
+    UNUSED(p_data);
+
     mtu = bta_av_chk_mtu(p_scb, BTA_AV_MAX_A2DP_MTU);
 
     p_scb->p_cos->close(p_scb->hndl, p_scb->codec_type, mtu);
@@ -1831,6 +2036,7 @@
     tAVDT_CFG   cfg;
     UINT8       media_type;
     tAVDT_SEP_INFO  *p_info = &p_scb->sep_info[p_scb->sep_info_idx];
+    UINT16 uuid_int; /* UUID for which connection was initiatied */
 
     memcpy(&cfg, &p_scb->cfg, sizeof(tAVDT_CFG));
     cfg.num_codec = 1;
@@ -1859,13 +2065,34 @@
         /* save copy of codec type and configuration */
         p_scb->codec_type = cfg.codec_info[BTA_AV_CODEC_TYPE_IDX];
         memcpy(&p_scb->cfg, &cfg, sizeof(tAVDT_CFG));
-        /* A2DP SINK does not call getcaps, consequently this will not be called in SINK path. Connect from A2DP SINK is not going to happen*/
-        bta_av_adjust_seps_idx(p_scb, bta_av_get_scb_handle(p_scb, AVDT_TSEP_SRC));
+
+        uuid_int = p_scb->uuid_int;
+        APPL_TRACE_DEBUG1(" initiator UUID = 0x%x ", uuid_int);
+        if (uuid_int == UUID_SERVCLASS_AUDIO_SOURCE)
+            bta_av_adjust_seps_idx(p_scb, bta_av_get_scb_handle(p_scb, AVDT_TSEP_SRC));
+        else if (uuid_int == UUID_SERVCLASS_AUDIO_SINK)
+            bta_av_adjust_seps_idx(p_scb, bta_av_get_scb_handle(p_scb, AVDT_TSEP_SNK));
+
         /* use only the services peer supports */
         cfg.psc_mask &= p_scb->p_cap->psc_mask;
         p_scb->cur_psc_mask = cfg.psc_mask;
 
+        if ((uuid_int == UUID_SERVCLASS_AUDIO_SINK) &&
+            (p_scb->seps[p_scb->sep_idx].p_app_data_cback != NULL))
+        {
+            APPL_TRACE_DEBUG0(" Configure Deoder for Sink Connection ");
+            p_scb->seps[p_scb->sep_idx].p_app_data_cback(BTA_AV_MEDIA_SINK_CFG_EVT,
+                     (tBTA_AV_MEDIA*)p_scb->cfg.codec_info);
+        }
+
         /* open the stream */
+        if ((uuid_int == UUID_SERVCLASS_AUDIO_SOURCE) &&
+            (cfg.codec_info[BTA_AV_CO_SBC_MAX_BITPOOL_OFF] > BTA_AV_CO_SBC_MAX_BITPOOL))
+        {
+            APPL_TRACE_WARNING2("SetConfigReq: Change Max bitpool from %d to %d",
+                cfg.codec_info[BTA_AV_CO_SBC_MAX_BITPOOL_OFF], BTA_AV_CO_SBC_MAX_BITPOOL);
+            cfg.codec_info[BTA_AV_CO_SBC_MAX_BITPOOL_OFF] = BTA_AV_CO_SBC_MAX_BITPOOL;
+        }
         AVDT_OpenReq(p_scb->seps[p_scb->sep_idx].av_handle, p_scb->peer_addr,
                      p_scb->sep_info[p_scb->sep_info_idx].seid, &cfg);
 
@@ -1918,6 +2145,8 @@
 *******************************************************************************/
 void bta_av_discover_req (tBTA_AV_SCB *p_scb, tBTA_AV_DATA *p_data)
 {
+    UNUSED(p_data);
+
     /* send avdtp discover request */
 
     AVDT_DiscoverReq(p_scb->peer_addr, p_scb->sep_info, BTA_AV_NUM_SEPS, bta_av_dt_cback[p_scb->hdi]);
@@ -2173,6 +2402,7 @@
     BOOLEAN new_buf = FALSE;
     UINT8   m_pt = 0x60 | p_scb->codec_type;
     tAVDT_DATA_OPT_MASK     opt;
+    UNUSED(p_data);
 
     if (!p_scb->cong)
     {
@@ -2416,6 +2646,13 @@
         start.chnl   = p_scb->chnl;
         start.status = BTA_AV_SUCCESS;
         start.hndl   = p_scb->hndl;
+#if (A2DP_KERNEL_DIRECT == TRUE)
+        start.audio_open_cnt = bta_av_cb.audio_open_cnt;
+        APPL_TRACE_DEBUG6("bta_av_start_ok %d,%d,%d,%d,%d,%d",p_scb->cfg.codec_info[0],p_scb->cfg.codec_info[1],p_scb->cfg.codec_info[2],
+        p_scb->cfg.codec_info[3],p_scb->cfg.codec_info[4],p_scb->cfg.codec_info[5]);
+        if (btif_av_get_peer_sep() == AVDT_TSEP_SNK)
+            bta_send_btlite_start_req(start.audio_open_cnt);
+#endif
         (*bta_av_cb.p_cback)(BTA_AV_START_EVT, (tBTA_AV *) &start);
 
         if(suspend)
@@ -2443,6 +2680,8 @@
 *******************************************************************************/
 void bta_av_start_failed (tBTA_AV_SCB *p_scb, tBTA_AV_DATA *p_data)
 {
+    UNUSED(p_data);
+
     if(p_scb->started == FALSE && p_scb->co_started == FALSE)
     {
         bta_sys_idle(BTA_ID_AV, bta_av_cb.audio_open_cnt, p_scb->peer_addr);
@@ -2517,6 +2756,8 @@
 
             bta_sys_conn_close(BTA_ID_AV, bta_av_cb.audio_open_cnt, p_scb->peer_addr);
             bta_av_cleanup(p_scb, p_data);
+            if (btif_av_get_peer_sep() == AVDT_TSEP_SNK)
+                bta_send_btlite_cleanup_req(0, bta_av_cb.audio_open_cnt, BTA_AV_MAX_A2DP_MTU);
             (*bta_av_cb.p_cback)(event, &data);
         }
     }
@@ -2533,6 +2774,8 @@
 *******************************************************************************/
 void bta_av_clr_cong (tBTA_AV_SCB *p_scb, tBTA_AV_DATA *p_data)
 {
+    UNUSED(p_data);
+
     if(p_scb->co_started)
         p_scb->cong = FALSE;
 }
@@ -2613,6 +2856,8 @@
         suspend_rsp.chnl = p_scb->chnl;
         suspend_rsp.hndl = p_scb->hndl;
         suspend_rsp.initiator = p_data->str_msg.initiator;
+        if (btif_av_get_peer_sep() == AVDT_TSEP_SNK)
+            bta_send_btlite_suspend_req(0,bta_av_cb.audio_open_cnt);
         (*bta_av_cb.p_cback)(BTA_AV_SUSPEND_EVT, (tBTA_AV *) &suspend_rsp);
     }
 }
@@ -2629,6 +2874,7 @@
 void bta_av_rcfg_str_ok (tBTA_AV_SCB *p_scb, tBTA_AV_DATA *p_data)
 {
     tBTA_AV_RECONFIG    evt;
+    UNUSED(p_data);
 
     p_scb->l2c_cid      = AVDT_GetL2CapChannel(p_scb->avdt_handle);
     APPL_TRACE_DEBUG1("bta_av_rcfg_str_ok: l2c_cid: %d", p_scb->l2c_cid);
@@ -2703,6 +2949,8 @@
 *******************************************************************************/
 void bta_av_rcfg_connect (tBTA_AV_SCB *p_scb, tBTA_AV_DATA *p_data)
 {
+    UNUSED(p_data);
+
     p_scb->cong    = FALSE;
     p_scb->num_recfg++;
     APPL_TRACE_DEBUG1("bta_av_rcfg_connect num_recfg: %d", p_scb->num_recfg);
@@ -2727,6 +2975,7 @@
 void bta_av_rcfg_discntd (tBTA_AV_SCB *p_scb, tBTA_AV_DATA *p_data)
 {
     tBTA_AV_RECONFIG    evt;
+    UNUSED(p_data);
 
     APPL_TRACE_DEBUG1("bta_av_rcfg_discntd num_recfg: %d", p_scb->num_recfg);
     p_scb->num_recfg++;
@@ -2844,8 +3093,9 @@
 *******************************************************************************/
 void bta_av_rcfg_open (tBTA_AV_SCB *p_scb, tBTA_AV_DATA *p_data)
 {
-    tBTA_AV_STR_MSG  *p_msg = (tBTA_AV_STR_MSG *)p_data;
-    APPL_TRACE_DEBUG1("bta_av_rcfg_open, num_disc_snks = %d", p_scb->num_disc_snks);
+    UNUSED(p_data);
+
+	APPL_TRACE_DEBUG1("bta_av_rcfg_open, num_disc_snks = %d", p_scb->num_disc_snks);
 
     if (p_scb->num_disc_snks == 0)
     {
@@ -2882,6 +3132,8 @@
 *******************************************************************************/
 void bta_av_security_rej (tBTA_AV_SCB *p_scb, tBTA_AV_DATA *p_data)
 {
+    UNUSED(p_data);
+
     AVDT_SecurityRsp(p_scb->avdt_handle, p_scb->avdt_label, AVDT_ERR_BAD_STATE,
                      NULL, 0);
 }
@@ -2972,8 +3224,7 @@
         return;
     }
 
-    if (((p_scb->use_rc == TRUE) || (p_scb->role & BTA_AV_ROLE_AD_ACP)) &&
-                    (p_scb->seps[p_scb->sep_idx].tsep == AVDT_TSEP_SRC) )
+    if(p_scb->use_rc == TRUE || (p_scb->role & BTA_AV_ROLE_AD_ACP) )
     {
         if(bta_av_cb.disc)
         {
@@ -3018,6 +3269,12 @@
 {
     tBTA_AV_API_OPEN  *p_buf;
 
+    if (!p_scb)
+    {
+        APPL_TRACE_WARNING0("scb is NULL, bailing out!");
+        return;
+    }
+
     memcpy (&(p_scb->open_api), &(p_data->api_open), sizeof(tBTA_AV_API_OPEN));
 
     if (p_scb->coll_mask & BTA_AV_COLL_SETCONFIG_IND)
@@ -3046,6 +3303,7 @@
         if ((p_buf = (tBTA_AV_API_OPEN *) GKI_getbuf(sizeof(tBTA_AV_API_OPEN))) != NULL)
         {
             memcpy(p_buf, &(p_scb->open_api), sizeof(tBTA_AV_API_OPEN));
+            p_scb->skip_sdp = TRUE;
             bta_sys_sendmsg(p_buf);
         }
     }
diff -Naur '--exclude=.git' bluedroid-orig/bta/av/bta_av_act.c bluedroid/bta/av/bta_av_act.c
--- bluedroid-orig/bta/av/bta_av_act.c	2015-09-24 16:33:43.520227643 +0800
+++ bluedroid/bta/av/bta_av_act.c	2015-09-24 16:31:36.000000000 +0800
@@ -1,5 +1,6 @@
 /******************************************************************************
  *
+ *  Copyright (c) 2015, The Linux Foundation. All rights reserved.
  *  Copyright (C) 2004-2012 Broadcom Corporation
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
@@ -36,10 +37,14 @@
 #if( defined BTA_AR_INCLUDED ) && (BTA_AR_INCLUDED == TRUE)
 #include "bta_ar_api.h"
 #endif
-
+#if (AVRC_CTLR_INCLUDED == TRUE)
+#include <cutils/properties.h>
+#endif
 /*****************************************************************************
 **  Constants
 *****************************************************************************/
+#define UNUSED(x) (void)(x)
+
 /* the timer in milliseconds to wait for open req after setconfig for incoming connections */
 #ifndef BTA_AV_SIG_TIME_VAL
 #define BTA_AV_SIG_TIME_VAL 8000
@@ -51,8 +56,6 @@
 #define BTA_AV_ACP_SIG_TIME_VAL 2000
 #endif
 
-/* constant for scb state machine, need to check in avrcp*/
-#define AV_SCB_INIT_STATE 0
 static void bta_av_acp_sig_timer_cback (TIMER_LIST_ENT *p_tle);
 
 /*******************************************************************************
@@ -95,11 +98,16 @@
     tBTA_AV_SCB  *p_scb;
     UINT8        rc_handle;      /* connected AVRCP handle */
 
+    p_scb = NULL;
     if(p_rcb->handle != BTA_AV_RC_HANDLE_NONE)
     {
         if(p_rcb->shdl)
         {
-            p_scb = bta_av_cb.p_scb[p_rcb->shdl - 1];
+            /* Validate array index*/
+            if ((p_rcb->shdl - 1) < BTA_AV_NUM_STRS)
+            {
+                p_scb = bta_av_cb.p_scb[p_rcb->shdl - 1];
+            }
             if(p_scb)
             {
                 APPL_TRACE_DEBUG3("bta_av_del_rc shdl:%d, srch:%d rc_handle:%d", p_rcb->shdl,
@@ -183,6 +191,7 @@
 static void bta_av_avrc_sdp_cback(UINT16 status)
 {
     BT_HDR *p_msg;
+    UNUSED(status);
 
     if ((p_msg = (BT_HDR *) GKI_getbuf(sizeof(BT_HDR))) != NULL)
     {
@@ -204,6 +213,7 @@
 {
     tBTA_AV_RC_CONN_CHG *p_msg;
     UINT16 msg_event = 0;
+    UNUSED(result);
 
 #if (defined(BTA_AV_MIN_DEBUG_TRACES) && BTA_AV_MIN_DEBUG_TRACES == TRUE)
     APPL_TRACE_EVENT2("rc_ctrl handle: %d event=0x%x", handle, event);
@@ -248,7 +258,6 @@
 {
     tBTA_AV_RC_MSG  *p_buf;
     UINT8           *p_data = NULL;
-    UINT8           **p_p_data = NULL;
     UINT16          data_len = 0;
 
 #if (defined(BTA_AV_MIN_DEBUG_TRACES) && BTA_AV_MIN_DEBUG_TRACES == TRUE)
@@ -260,20 +269,17 @@
     if (opcode == AVRC_OP_VENDOR && p_msg->vendor.p_vendor_data != NULL)
     {
         p_data = p_msg->vendor.p_vendor_data;
-        p_p_data = &p_msg->vendor.p_vendor_data;
         data_len = (UINT16) p_msg->vendor.vendor_len;
     }
     else if (opcode == AVRC_OP_PASS_THRU && p_msg->pass.p_pass_data != NULL)
     {
         p_data = p_msg->pass.p_pass_data;
-        p_p_data = &p_msg->pass.p_pass_data;
         data_len = (UINT16) p_msg->pass.pass_len;
     }
     else if (opcode == AVRC_OP_BROWSE && p_msg->browse.p_browse_data != NULL)
     {
         APPL_TRACE_EVENT0("bta_av_rc_msg_cback Browse Data");
         p_data  = p_msg->browse.p_browse_data;
-        p_p_data = &p_msg->browse.p_browse_data;
         data_len = (UINT16) p_msg->browse.browse_len;
     }
     if ((p_buf = (tBTA_AV_RC_MSG *) GKI_getbuf((UINT16) (sizeof(tBTA_AV_RC_MSG) + data_len))) != NULL)
@@ -285,8 +291,23 @@
         memcpy(&p_buf->msg, p_msg, sizeof(tAVRC_MSG));
         if (p_data != NULL)
         {
+            tAVRC_MSG *p_avrc_msg = (tAVRC_MSG*)&p_buf->msg;
+
+            switch (opcode)
+            {
+                case AVRC_OP_VENDOR:
+                    p_avrc_msg->vendor.p_vendor_data = (UINT8 *)(p_buf + 1);
+                    break;
+
+                case AVRC_OP_BROWSE:
+                    p_avrc_msg->browse.p_browse_data = (UINT8 *)(p_buf + 1);
+                    break;
+
+                case AVRC_OP_PASS_THRU:
+                    p_avrc_msg->pass.p_pass_data = (UINT8 *)(p_buf + 1);
+                    break;
+            }
             memcpy((UINT8 *)(p_buf + 1), p_data, data_len);
-            *p_p_data = (UINT8 *)(p_buf + 1);
         }
         bta_sys_sendmsg(p_buf);
     }
@@ -501,15 +522,6 @@
     for(i=0; i<BTA_AV_NUM_STRS; i++)
     {
         p_scb = p_cb->p_scb[i];
-        /*If SCB is created and it is Sink SCB, we don't need AVRCP Connection*/
-        if ((p_scb) && (p_scb->seps[p_scb->sep_idx].tsep == AVDT_TSEP_SNK)
-            && (p_scb->state > AV_SCB_INIT_STATE))
-        {
-            APPL_TRACE_WARNING0(" Has A2DP Sink, rejecting AVRCP ");
-            AVRC_Close(p_data->rc_conn_chg.handle);
-            return;
-        }
-
         if(p_scb && bdcmp(p_scb->peer_addr, p_data->rc_conn_chg.peer_addr) == 0)
         {
             p_scb->rc_handle = p_data->rc_conn_chg.handle;
@@ -580,8 +592,14 @@
     if(rc_open.peer_features == 0)
     {
         /* we have not done SDP on peer RC capabilities.
-         * peer must have initiated the RC connection */
-        rc_open.peer_features = BTA_AV_FEAT_RCCT;
+         * peer must have initiated the RC connection
+         * We Don't have SDP records of Peer, so we by
+         * default will take values depending upon registered
+         * features */
+        if (p_cb->features & BTA_AV_FEAT_RCCT)
+            rc_open.peer_features |= BTA_AV_FEAT_RCTG;
+        if (p_cb->features & BTA_AV_FEAT_RCTG)
+            rc_open.peer_features |= BTA_AV_FEAT_RCCT;
         bta_av_rc_disc(disc);
     }
     (*p_cb->p_cback)(BTA_AV_RC_OPEN_EVT, (tBTA_AV *) &rc_open);
@@ -705,6 +723,8 @@
 *******************************************************************************/
 void bta_av_rc_free_rsp (tBTA_AV_CB *p_cb, tBTA_AV_DATA *p_data)
 {
+    UNUSED(p_cb);
+
     GKI_freebuf (p_data->api_meta_rsp.p_pkt);
 }
 
@@ -719,6 +739,8 @@
 *******************************************************************************/
 void bta_av_rc_free_msg (tBTA_AV_CB *p_cb, tBTA_AV_DATA *p_data)
 {
+    UNUSED(p_cb);
+    UNUSED(p_data);
 }
 
 
@@ -852,6 +874,7 @@
                         is_dev_avrcpv_blacklisted = SDP_Dev_Blacklisted_For_Avrcp15(addr);
                         BTIF_TRACE_IMP1("Blacklist for AVRCP1.5 = %d", is_dev_avrcpv_blacklisted);
                     }
+                    BTIF_TRACE_DEBUG1("Blacklist for AVRCP1.5 = %d", is_dev_avrcpv_blacklisted);
                     if (is_dev_avrcpv_blacklisted == TRUE)
                     {
                         for (i = 0; i <= p_bta_av_cfg->num_evt_ids; ++i)
@@ -859,6 +882,7 @@
                            if (p_bta_av_cfg->p_meta_evt_ids[i] == AVRC_EVT_AVAL_PLAYERS_CHANGE)
                               break;
                         }
+                        p_rc_rsp->get_caps.count = i;
                         memcpy(p_rc_rsp->get_caps.param.event_id, p_bta_av_cfg->p_meta_evt_ids, i);
                     }
                     else
@@ -918,10 +942,6 @@
     {
         case AVRC_PDU_GET_FOLDER_ITEMS:
             break;
-
-        case AVRC_PDU_SET_BROWSED_PLAYER:
-            break;
-
         default:
             evt = 0;
             p_rc_rsp->rsp.status = AVRC_STS_BAD_CMD;
@@ -949,8 +969,9 @@
     BOOLEAN is_inquiry = ((p_data->rc_msg.msg.hdr.ctype == AVRC_CMD_SPEC_INQ) || p_data->rc_msg.msg.hdr.ctype == AVRC_CMD_GEN_INQ);
 #if (AVRC_METADATA_INCLUDED == TRUE)
     tAVRC_STS   res;
-    UINT8       ctype;
+    UINT8       ctype = 0;
     tAVRC_RESPONSE  rc_rsp;
+    char value[255];
 
     rc_rsp.rsp.status = BTA_AV_STS_NO_RSP;
 #endif
@@ -975,6 +996,15 @@
                         p_data->rc_msg.msg.pass.p_pass_data, is_inquiry);
 #endif
             }
+#if (AVRC_CTLR_INCLUDED == TRUE)
+            else if (((p_data->rc_msg.msg.pass.op_id == AVRC_ID_VOL_UP)||
+                      (p_data->rc_msg.msg.pass.op_id == AVRC_ID_VOL_DOWN))&&
+                     ((property_get("bluetooth.pts.avrcp_ct.support", value, "false"))&&
+                      (!strcmp(value, "true"))))
+            {
+                p_data->rc_msg.msg.hdr.ctype = BTA_AV_RSP_ACCEPT;
+            }
+#endif
             else
             {
                 p_data->rc_msg.msg.hdr.ctype = bta_av_op_supported(p_data->rc_msg.msg.pass.op_id, is_inquiry);
@@ -999,7 +1029,7 @@
             }
         }
         /* else if this is a pass thru response */
-        else if (p_data->rc_msg.msg.hdr.ctype >= AVRC_RSP_ACCEPT)
+        else if (p_data->rc_msg.msg.hdr.ctype >= AVRC_RSP_NOT_IMPL)
         {
             /* set up for callback */
             evt = BTA_AV_REMOTE_RSP_EVT;
@@ -1042,7 +1072,7 @@
         }
         /* else if configured to support vendor specific and it's a response */
         else if ((p_cb->features & BTA_AV_FEAT_VENDOR) &&
-                 p_data->rc_msg.msg.hdr.ctype >= AVRC_RSP_ACCEPT)
+                 p_data->rc_msg.msg.hdr.ctype >= AVRC_RSP_NOT_IMPL)
         {
 #if (AVRC_METADATA_INCLUDED == TRUE)
             if ((p_cb->features & BTA_AV_FEAT_METADATA) &&
@@ -1261,7 +1291,7 @@
 void bta_av_conn_chg(tBTA_AV_DATA *p_data)
 {
     tBTA_AV_CB   *p_cb = &bta_av_cb;
-    tBTA_AV_SCB     *p_scb;
+    tBTA_AV_SCB     *p_scb = NULL;
     tBTA_AV_SCB     *p_scbi;
     UINT8   mask;
     UINT8   conn_msk;
@@ -1273,8 +1303,11 @@
     tBTA_AV_RCB *p_rcb, *p_rcb2;
     BOOLEAN     chk_restore = FALSE;
 
-    p_scb = p_cb->p_scb[index];
-
+    /* Validate array index*/
+    if (index < BTA_AV_NUM_STRS)
+    {
+        p_scb = p_cb->p_scb[index];
+    }
     mask = BTA_AV_HNDL_TO_MSK(index);
     p_lcb = bta_av_find_lcb(p_data->conn_chg.peer_addr, BTA_AV_LCB_FIND);
     conn_msk = 1 << (index + 1);
@@ -1467,6 +1500,7 @@
 {
     BT_HDR  hdr;
     UINT16  xx;
+    UNUSED(p_data);
 
     p_cb->disabling = TRUE;
 
@@ -1495,7 +1529,6 @@
 void bta_av_api_disconnect(tBTA_AV_DATA *p_data)
 {
     AVDT_DisconnectReq(p_data->api_discnt.bd_addr, bta_av_conn_cback);
-    bta_av_cb.retry_attempt = 0;
     bta_sys_stop_timer(&bta_av_cb.sig_tmr);
 }
 
@@ -1585,7 +1618,6 @@
 #if( defined BTA_AR_INCLUDED ) && (BTA_AR_INCLUDED == TRUE)
     else if (event == BTA_AR_AVDT_CONN_EVT)
     {
-        bta_av_cb.retry_attempt = 0;
         bta_sys_stop_timer(&bta_av_cb.sig_tmr);
     }
 #endif
@@ -1640,6 +1672,7 @@
     UINT8   mask;
     tBTA_AV_LCB *p_lcb = NULL;
     tBTA_AV_PEND pend;
+    UNUSED(p_data);
 
     APPL_TRACE_DEBUG0("bta_av_sig_timer");
     for(xx=0; xx<BTA_AV_NUM_LINKS; xx++)
@@ -1651,15 +1684,6 @@
             p_lcb = &p_cb->lcb[xx];
             if(!p_lcb->conn_msk)
             {
-                if (p_cb->retry_attempt >= BTA_AV_RETRY_ATTEMPT)
-                {
-                    /* Silently close the connection, btif already updated */
-                    APPL_TRACE_DEBUG0("bta_av_sig_timer, Max retry attempt reached");
-                    p_cb->retry_attempt = 0;
-                    AVDT_DisconnectReq(p_lcb->addr, NULL);
-                    return;
-                }
-                p_cb->retry_attempt++;
                 bta_sys_start_timer(&p_cb->sig_tmr, BTA_AV_SIG_TIMER_EVT, BTA_AV_SIG_TIME_VAL);
                 bdcpy(pend.bd_addr, p_lcb->addr);
                 (*p_cb->p_cback)(BTA_AV_PENDING_EVT, (tBTA_AV *) &pend);
@@ -1682,9 +1706,12 @@
 {
     UINT8   inx = (UINT8)p_tle->param;
     tBTA_AV_CB  *p_cb = &bta_av_cb;
-    tBTA_AV_SCB *p_scb = p_cb->p_scb[inx];
+    tBTA_AV_SCB *p_scb = NULL;
     tBTA_AV_API_OPEN  *p_buf;
-
+    if (inx < BTA_AV_NUM_STRS)
+    {
+        p_scb = p_cb->p_scb[inx];
+    }
     if (p_scb)
     {
         APPL_TRACE_DEBUG1("bta_av_acp_sig_timer_cback, coll_mask = 0x%02X", p_scb->coll_mask);
@@ -1802,6 +1829,81 @@
 
 /*******************************************************************************
 **
+** Function         bta_avk_check_peer_features
+**
+** Description      check supported features on the peer device from the SDP record
+**                  and return the feature mask
+**
+** Returns          tBTA_AV_FEAT peer device feature mask
+**
+*******************************************************************************/
+tBTA_AV_FEAT bta_avk_check_peer_features (UINT16 service_uuid)
+{
+    tBTA_AV_FEAT peer_features = 0;
+    tBTA_AV_CB   *p_cb = &bta_av_cb;
+    tSDP_DISC_REC       *p_rec = NULL;
+    tSDP_DISC_ATTR      *p_attr;
+    UINT16              peer_rc_version=0;
+    UINT16              categories = 0;
+    BOOLEAN             val;
+
+    APPL_TRACE_DEBUG1("bta_avk_check_peer_features service_uuid:x%x", service_uuid);
+    /* loop through all records we found */
+    while (TRUE)
+    {
+        /* get next record; if none found, we're done */
+        if ((p_rec = SDP_FindServiceInDb(p_cb->p_disc_db, service_uuid, p_rec)) == NULL)
+        {
+            break;
+        }
+        APPL_TRACE_DEBUG1(" found Service record for x%x", service_uuid);
+
+        if (( SDP_FindAttributeInRec(p_rec, ATTR_ID_SERVICE_CLASS_ID_LIST)) != NULL)
+        {
+            /* find peer features */
+            if (SDP_FindServiceInDb(p_cb->p_disc_db, UUID_SERVCLASS_AV_REMOTE_CONTROL, NULL))
+            {
+                peer_features |= BTA_AV_FEAT_RCCT;
+            }
+            if (SDP_FindServiceInDb(p_cb->p_disc_db, UUID_SERVCLASS_AV_REM_CTRL_TARGET, NULL))
+            {
+                peer_features |= BTA_AV_FEAT_RCTG;
+            }
+        }
+
+        if (( SDP_FindAttributeInRec(p_rec, ATTR_ID_BT_PROFILE_DESC_LIST)) != NULL)
+        {
+            /* get profile version (if failure, version parameter is not updated) */
+            val = SDP_FindProfileVersionInRec(p_rec, UUID_SERVCLASS_AV_REMOTE_CONTROL, &peer_rc_version);
+            APPL_TRACE_DEBUG2("peer_rc_version for TG 0x%x, profile_found %d", peer_rc_version, val);
+
+            if (peer_rc_version >= AVRC_REV_1_3)
+                peer_features |= (BTA_AV_FEAT_VENDOR | BTA_AV_FEAT_METADATA);
+
+            /*
+             * Though Absolute Volume came after in 1.4 and above, but there are few devices
+             * in market which supports absolute Volume and they are still 1.3
+             * TO avoid IOT issuses with those devices, we check for 1.3 as minimum version
+             */
+            if (peer_rc_version >= AVRC_REV_1_3)
+            {
+                /* get supported categories */
+                if ((p_attr = SDP_FindAttributeInRec(p_rec,
+                                ATTR_ID_SUPPORTED_FEATURES)) != NULL)
+                {
+                    categories = p_attr->attr_value.v.u16;
+                    if (categories & AVRC_SUPF_CT_CAT2)
+                        peer_features |= (BTA_AV_FEAT_ADV_CTRL);
+                }
+            }
+        }
+    }
+    APPL_TRACE_DEBUG1("peer_features:x%x", peer_features);
+    return peer_features;
+}
+
+/*******************************************************************************
+**
 ** Function         bta_av_rc_disc_done
 **
 ** Description      Handle AVRCP service discovery results.  If matching
@@ -1818,7 +1920,8 @@
     tBTA_AV_RC_OPEN rc_open;
     tBTA_AV_RC_FEAT rc_feat;
     UINT8               rc_handle;
-    tBTA_AV_FEAT        peer_features;  /* peer features mask */
+    tBTA_AV_FEAT        peer_features = 0;  /* peer features mask */
+    UNUSED(p_data);
 
     APPL_TRACE_DEBUG1("bta_av_rc_disc_done disc:x%x", p_cb->disc);
     if (!p_cb->disc)
@@ -1833,9 +1936,15 @@
     }
     else
     {
-        p_scb = p_cb->p_scb[(p_cb->disc & BTA_AV_HNDL_MSK) - 1];
+        /* Validate array index*/
+        if (((p_cb->disc & BTA_AV_HNDL_MSK) - 1) < BTA_AV_NUM_STRS)
+        {
+            p_scb = p_cb->p_scb[(p_cb->disc & BTA_AV_HNDL_MSK) - 1];
+        }
         if (p_scb)
+        {
             rc_handle = p_scb->rc_handle;
+        }
         else
         {
             p_cb->disc = 0;
@@ -1844,13 +1953,27 @@
     }
 
     APPL_TRACE_DEBUG1("rc_handle %d", rc_handle);
-    /* check peer version and whether support CT and TG role */
-    peer_features = bta_av_check_peer_features (UUID_SERVCLASS_AV_REMOTE_CONTROL);
-    if ((p_cb->features & BTA_AV_FEAT_ADV_CTRL) && ((peer_features&BTA_AV_FEAT_ADV_CTRL) == 0))
-    {
-        /* if we support advance control and peer does not, check their support on TG role
-         * some implementation uses 1.3 on CT ans 1.4 on TG */
-        peer_features |= bta_av_check_peer_features (UUID_SERVCLASS_AV_REM_CTRL_TARGET);
+#if (BTA_AV_SINK_INCLUDED == TRUE)
+    if (p_cb->sdp_a2d_snk_handle)
+    {
+        /* This is Sink + CT + TG(Abs Vol) */
+        peer_features = bta_avk_check_peer_features(UUID_SERVCLASS_AV_REM_CTRL_TARGET);
+        if (BTA_AV_FEAT_ADV_CTRL & bta_avk_check_peer_features(UUID_SERVCLASS_AV_REMOTE_CONTROL))
+            peer_features |= (BTA_AV_FEAT_ADV_CTRL|BTA_AV_FEAT_RCCT);
+    }
+    else if(p_cb->sdp_a2d_handle)
+#else
+    if(p_cb->sdp_a2d_handle)
+#endif
+    {
+        /* check peer version and whether support CT and TG role */
+        peer_features = bta_av_check_peer_features (UUID_SERVCLASS_AV_REMOTE_CONTROL);
+        if ((p_cb->features & BTA_AV_FEAT_ADV_CTRL) && ((peer_features&BTA_AV_FEAT_ADV_CTRL) == 0))
+        {
+            /* if we support advance control and peer does not, check their support on TG role
+             * some implementation uses 1.3 on CT ans 1.4 on TG */
+            peer_features |= bta_av_check_peer_features (UUID_SERVCLASS_AV_REM_CTRL_TARGET);
+        }
     }
 
     p_cb->disc = 0;
@@ -1909,6 +2032,17 @@
         p_cb->rcb[rc_handle].peer_features = peer_features;
         rc_feat.rc_handle =  rc_handle;
         rc_feat.peer_features = peer_features;
+        if (p_scb == NULL)
+        {
+            /*
+             * In case scb is not created by the time we are done with SDP
+             * we still need to send RC feature event. So we need to get BD
+             * from Message
+             */
+            bdcpy(rc_feat.peer_addr, p_cb->lcb[p_cb->rcb[rc_handle].lidx].addr);
+        }
+        else
+            bdcpy(rc_feat.peer_addr, p_scb->peer_addr);
         (*p_cb->p_cback)(BTA_AV_RC_FEAT_EVT, (tBTA_AV *) &rc_feat);
     }
 }
@@ -1934,6 +2068,7 @@
     tBTA_AV_LCB *p_lcb;
 
     rc_close.rc_handle = BTA_AV_RC_HANDLE_NONE;
+    p_scb = NULL;
     APPL_TRACE_DEBUG1("bta_av_rc_closed rc_handle:%d", p_msg->handle);
     for(i=0; i<BTA_AV_NUM_RCB; i++)
     {
@@ -1947,7 +2082,10 @@
             APPL_TRACE_DEBUG2("       shdl:%d, lidx:%d", p_rcb->shdl, p_rcb->lidx);
             if(p_rcb->shdl)
             {
-                p_scb = bta_av_cb.p_scb[p_rcb->shdl - 1];
+                if ((p_rcb->shdl - 1) < BTA_AV_NUM_STRS)
+                {
+                    p_scb = bta_av_cb.p_scb[p_rcb->shdl - 1];
+                }
                 if(p_scb)
                 {
                     bdcpy(rc_close.peer_addr, p_scb->peer_addr);
@@ -2128,12 +2266,20 @@
 #if( defined BTA_AR_INCLUDED ) && (BTA_AR_INCLUDED == TRUE)
                 bta_ar_dereg_avrc (UUID_SERVCLASS_AV_REMOTE_CONTROL, BTA_ID_AV);
 #endif
-                bta_av_del_sdp_rec(&p_cb->sdp_a2d_handle);
-                bta_sys_remove_uuid(UUID_SERVCLASS_AUDIO_SOURCE);
+                if (p_cb->sdp_a2d_handle)
+                {
+                    bta_av_del_sdp_rec(&p_cb->sdp_a2d_handle);
+                    p_cb->sdp_a2d_handle = 0;
+                    bta_sys_remove_uuid(UUID_SERVCLASS_AUDIO_SOURCE);
+                }
 
-#ifdef BTA_AVK_INCLUDED
-                bta_av_del_sdp_rec(&p_cb->sdp_a2d_snk_handle);
-                bta_sys_remove_uuid(UUID_SERVCLASS_AUDIO_SINK);
+#if (BTA_AV_SINK_INCLUDED == TRUE)
+                if (p_cb->sdp_a2d_snk_handle)
+                {
+                    bta_av_del_sdp_rec(&p_cb->sdp_a2d_snk_handle);
+                    p_cb->sdp_a2d_snk_handle = 0;
+                    bta_sys_remove_uuid(UUID_SERVCLASS_AUDIO_SINK);
+                }
 #endif
             }
         }
diff -Naur '--exclude=.git' bluedroid-orig/bta/av/bta_av_api.c bluedroid/bta/av/bta_av_api.c
--- bluedroid-orig/bta/av/bta_av_api.c	2015-09-24 16:33:43.520227643 +0800
+++ bluedroid/bta/av/bta_av_api.c	2015-09-24 16:31:36.000000000 +0800
@@ -63,9 +63,7 @@
     tBTA_AV_API_ENABLE  *p_buf;
 
     /* register with BTA system manager */
-    GKI_sched_lock();
     bta_sys_register(BTA_ID_AV, &bta_av_reg);
-    GKI_sched_unlock();
 
     if ((p_buf = (tBTA_AV_API_ENABLE *) GKI_getbuf(sizeof(tBTA_AV_API_ENABLE))) != NULL)
     {
@@ -111,7 +109,8 @@
 ** Returns          void
 **
 *******************************************************************************/
-void BTA_AvRegister(tBTA_AV_CHNL chnl, const char *p_service_name, UINT8 app_id, tBTA_AV_DATA_CBACK  *p_data_cback)
+void BTA_AvRegister(tBTA_AV_CHNL chnl, const char *p_service_name, UINT8 app_id, tBTA_AV_DATA_CBACK  *p_data_cback,
+                    UINT16 service_uuid)
 {
     tBTA_AV_API_REG  *p_buf;
 
@@ -131,6 +130,7 @@
         }
         p_buf->app_id = app_id;
         p_buf->p_app_data_cback = p_data_cback;
+        p_buf->service_uuid = service_uuid;
         bta_sys_sendmsg(p_buf);
     }
 }
@@ -167,7 +167,8 @@
 ** Returns          void
 **
 *******************************************************************************/
-void BTA_AvOpen(BD_ADDR bd_addr, tBTA_AV_HNDL handle, BOOLEAN use_rc, tBTA_SEC sec_mask)
+void BTA_AvOpen(BD_ADDR bd_addr, tBTA_AV_HNDL handle, BOOLEAN use_rc, tBTA_SEC sec_mask,
+                                                                             UINT16 uuid)
 {
     tBTA_AV_API_OPEN  *p_buf;
 
@@ -179,6 +180,7 @@
         p_buf->use_rc = use_rc;
         p_buf->sec_mask = sec_mask;
         p_buf->switch_res = BTA_AV_RS_NONE;
+        p_buf->uuid = uuid;
         bta_sys_sendmsg(p_buf);
     }
 }
@@ -246,6 +248,31 @@
 }
 
 /*******************************************************************************
+**
+** Function         BTA_AvEnable_Sink
+**
+** Description      Enable/Disable A2DP Sink..
+**
+** Returns          void
+**
+*******************************************************************************/
+void BTA_AvEnable_Sink(int enable)
+{
+    BT_HDR  *p_buf;
+
+#if (BTA_AV_SINK_INCLUDED == TRUE)
+    if ((p_buf = (BT_HDR *) GKI_getbuf(sizeof(BT_HDR))) != NULL)
+    {
+        p_buf->event = BTA_AV_API_SINK_ENABLE_EVT;
+        p_buf->layer_specific = enable;
+        bta_sys_sendmsg(p_buf);
+    }
+#else
+    return;
+#endif
+}
+
+/*******************************************************************************
 **
 ** Function         BTA_AvStop
 **
diff -Naur '--exclude=.git' bluedroid-orig/bta/av/bta_av_cfg.c bluedroid/bta/av/bta_av_cfg.c
--- bluedroid-orig/bta/av/bta_av_cfg.c	2015-09-24 16:33:43.520227643 +0800
+++ bluedroid/bta/av/bta_av_cfg.c	2015-09-24 16:31:36.000000000 +0800
@@ -38,7 +38,16 @@
 };
 
 /* AVRCP cupported categories */
+#if (AVRC_CTLR_INCLUDED == TRUE)
+#define BTA_AV_RC_SUPF_CT       (AVRC_SUPF_CT_CAT1 | AVRC_SUPF_CT_CAT2)
+#else
 #define BTA_AV_RC_SUPF_CT       (AVRC_SUPF_CT_CAT2)
+#endif
+
+#if (AVRC_CTLR_INCLUDED == TRUE)
+#define BTA_AVK_RC_SUPF_CT       (AVRC_SUPF_CT_CAT1)
+#define BTA_AVK_RC_SUPF_TG       (AVRC_SUPF_TG_CAT2)
+#endif
 
 /* Added to modify
 **	1. flush timeout
@@ -89,6 +98,15 @@
 #define BTA_AV_NUM_RC_EVT_IDS   (sizeof(bta_av_meta_caps_evt_ids) / sizeof(bta_av_meta_caps_evt_ids[0]))
 #endif /* BTA_AV_NUM_RC_EVT_IDS */
 
+const UINT8  bta_avk_meta_caps_evt_ids[] = {
+#if AVRC_ADV_CTRL_INCLUDED == TRUE
+    AVRC_EVT_VOLUME_CHANGE,
+#endif
+};
+#ifndef BTA_AVK_NUM_RC_EVT_IDS
+#define BTA_AVK_NUM_RC_EVT_IDS   (sizeof(bta_avk_meta_caps_evt_ids) / sizeof(bta_avk_meta_caps_evt_ids[0]))
+#endif /* BTA_AVK_NUM_RC_EVT_IDS */
+
 #endif /* ANDROID_APP_INCLUDED */
 
 /* the MTU for the AVRCP browsing channel */
@@ -96,6 +114,7 @@
 #define BTA_AV_MAX_RC_BR_MTU      1008
 #endif
 
+/* This configuration to be used when we are Src + TG + CT( only for abs vol) */
 const tBTA_AV_CFG bta_av_cfg =
 {
     AVRC_CO_BROADCOM,       /* AVRCP Company ID */
@@ -119,9 +138,43 @@
     BTA_AV_RC_PASS_RSP_CODE,/* the default response code for pass through commands */
     bta_av_meta_caps_co_ids,/* the metadata Get Capabilities response for company id */
     bta_av_meta_caps_evt_ids,/* the the metadata Get Capabilities response for event id */
+    NULL,                   /* the action function table for VDP stream */
+    NULL,                   /* action function to register VDP */
+    {0},                    /* Default AVRCP controller name */
+    {0},                    /* Default AVRCP target name */
+};
+
+/* This configuration to be used when we are Sink + CT + TG( only for abs vol) */
+const tBTA_AV_CFG bta_avk_cfg =
+{
+    AVRC_CO_METADATA,       /* AVRCP Company ID */
+#if AVRC_METADATA_INCLUDED == TRUE
+    512,                    /* AVRCP MTU at L2CAP for control channel */
+#else
+    48,                     /* AVRCP MTU at L2CAP for control channel */
+#endif
+    BTA_AV_MAX_RC_BR_MTU,   /* AVRCP MTU at L2CAP for browsing channel */
+    BTA_AVK_RC_SUPF_CT,      /* AVRCP controller categories */
+    BTA_AVK_RC_SUPF_TG,      /* AVRCP target categories */
+    672,                    /* AVDTP signaling channel MTU at L2CAP */
+    BTA_AV_MAX_A2DP_MTU,    /* AVDTP audio transport channel MTU at L2CAP */
+    bta_av_audio_flush_to,  /* AVDTP audio transport channel flush timeout */
+    6,                      /* AVDTP audio channel max data queue size */
+    BTA_AV_MAX_VDP_MTU,     /* AVDTP video transport channel MTU at L2CAP */
+    600,                    /* AVDTP video transport channel flush timeout */
+    FALSE,                   /* TRUE, to accept AVRC 1.3 group nevigation command */
+    2,                      /* company id count in p_meta_co_ids */
+    BTA_AVK_NUM_RC_EVT_IDS, /* event id count in p_meta_evt_ids */
+    BTA_AV_RC_PASS_RSP_CODE,/* the default response code for pass through commands */
+    bta_av_meta_caps_co_ids,/* the metadata Get Capabilities response for company id */
+    bta_avk_meta_caps_evt_ids,/* the the metadata Get Capabilities response for event id */
+    NULL,                   /* the action function table for VDP stream */
+    NULL,                   /* action function to register VDP */
+    {0},                    /* Default AVRCP controller name */
+    {0},                    /* Default AVRCP target name */
 };
 
-tBTA_AV_CFG *p_bta_av_cfg = (tBTA_AV_CFG *) &bta_av_cfg;
+tBTA_AV_CFG *p_bta_av_cfg = NULL;
 
 const UINT16 bta_av_rc_id[] =
 {
diff -Naur '--exclude=.git' bluedroid-orig/bta/av/bta_av_int.h bluedroid/bta/av/bta_av_int.h
--- bluedroid-orig/bta/av/bta_av_int.h	2015-09-24 16:33:43.520227643 +0800
+++ bluedroid/bta/av/bta_av_int.h	2015-09-24 16:31:36.000000000 +0800
@@ -96,6 +96,9 @@
     BTA_AV_AVRC_CLOSE_EVT,
     BTA_AV_CONN_CHG_EVT,
     BTA_AV_DEREG_COMP_EVT,
+#if (BTA_AV_SINK_INCLUDED == TRUE)
+    BTA_AV_API_SINK_ENABLE_EVT,
+#endif
 #if (AVDT_REPORTING == TRUE)
     BTA_AV_AVDT_RPT_CONN_EVT,
 #endif
@@ -157,7 +160,7 @@
 typedef BOOLEAN (*tBTA_AV_CO_INIT) (UINT8 *p_codec_type, UINT8 *p_codec_info,
                                    UINT8 *p_num_protect, UINT8 *p_protect_info, UINT8 index);
 typedef void (*tBTA_AV_CO_DISC_RES) (tBTA_AV_HNDL hndl, UINT8 num_seps,
-                                     UINT8 num_snk, BD_ADDR addr);
+                                     UINT8 num_snk, UINT8 num_src, BD_ADDR addr, UINT16 uuid_local);
 typedef UINT8 (*tBTA_AV_CO_GETCFG) (tBTA_AV_HNDL hndl, tBTA_AV_CODEC codec_type,
                                      UINT8 *p_codec_info, UINT8 *p_sep_info_idx, UINT8 seid,
                                      UINT8 *p_num_protect, UINT8 *p_protect_info);
@@ -206,6 +209,7 @@
     char                p_service_name[BTA_SERVICE_NAME_LEN+1];
     UINT8               app_id;
     tBTA_AV_DATA_CBACK       *p_app_data_cback;
+    UINT16              service_uuid;
 } tBTA_AV_API_REG;
 
 
@@ -225,6 +229,7 @@
     BOOLEAN             use_rc;
     tBTA_SEC            sec_mask;
     tBTA_AV_RS_RES      switch_res;
+    UINT16              uuid;  /* uuid of initiator */
 } tBTA_AV_API_OPEN;
 
 /* data type for BTA_AV_API_STOP_EVT */
@@ -487,6 +492,7 @@
     UINT8               hdi;            /* the index to SCB[] */
     UINT8               num_seps;       /* number of seps returned by stream discovery */
     UINT8               num_disc_snks;  /* number of discovered snks */
+    UINT8               num_disc_srcs;  /* number of discovered srcs */
     UINT8               sep_info_idx;   /* current index into sep_info */
     UINT8               sep_idx;        /* current index into local seps[] */
     UINT8               rcfg_idx;       /* reconfig requested index into sep_info */
@@ -509,14 +515,14 @@
     UINT8               wait;           /* set 0x1, when getting Caps as ACP, set 0x2, when started */
     UINT8               q_tag;          /* identify the associated q_info union member */
     BOOLEAN             no_rtp_hdr;     /* TRUE if add no RTP header*/
+    UINT16              uuid_int;       /*intended UUID of Initiator to connect to */
+    BOOLEAN             skip_sdp;       /* Decides if sdp to be done prior to profile connection */
 } tBTA_AV_SCB;
 
 #define BTA_AV_RC_ROLE_MASK     0x10
 #define BTA_AV_RC_ROLE_INT      0x00
 #define BTA_AV_RC_ROLE_ACP      0x10
 
-#define BTA_AV_RETRY_ATTEMPT    0x03
-
 #define BTA_AV_RC_CONN_MASK     0x20
 
 /* type for AV RCP control block */
@@ -560,7 +566,7 @@
     TIMER_LIST_ENT      sig_tmr;        /* link timer */
     TIMER_LIST_ENT      acp_sig_tmr;    /* timer to monitor signalling when accepting */
     UINT32              sdp_a2d_handle; /* SDP record handle for audio src */
-#ifdef BTA_AVK_INCLUDED
+#if (BTA_AV_SINK_INCLUDED == TRUE)
     UINT32              sdp_a2d_snk_handle; /* SDP record handle for audio snk */
 #endif
     UINT32              sdp_vdp_handle; /* SDP record handle for video src */
@@ -583,7 +589,6 @@
     BOOLEAN             sco_occupied;   /* TRUE if SCO is being used or call is in progress */
     UINT8               audio_streams;  /* handle mask of streaming audio channels */
     UINT8               video_streams;  /* handle mask of streaming video channels */
-    UINT8               retry_attempt;  /* number of time we retried Stream Setup */
 } tBTA_AV_CB;
 
 
@@ -602,6 +607,8 @@
 
 /* config struct */
 extern tBTA_AV_CFG *p_bta_av_cfg;
+extern const tBTA_AV_CFG bta_avk_cfg;
+extern const tBTA_AV_CFG bta_av_cfg;
 
 /* rc id config struct */
 extern UINT16 *p_bta_av_rc_id;
diff -Naur '--exclude=.git' bluedroid-orig/bta/av/bta_av_main.c bluedroid/bta/av/bta_av_main.c
--- bluedroid-orig/bta/av/bta_av_main.c	2015-09-24 16:33:43.520227643 +0800
+++ bluedroid/bta/av/bta_av_main.c	2015-09-24 16:31:36.000000000 +0800
@@ -41,6 +41,10 @@
 *****************************************************************************/
 
 /* AVDTP protocol timeout values */
+#define BTIF_AVK_SERVICE_NAME "Advanced Audio Sink"
+
+#define UNUSED(x) (void)(x)
+
 #ifndef BTA_AV_RET_TOUT
 #define BTA_AV_RET_TOUT     4
 #endif
@@ -150,6 +154,9 @@
 typedef void (*tBTA_AV_NSM_ACT)(tBTA_AV_DATA *p_data);
 static void bta_av_api_enable(tBTA_AV_DATA *p_data);
 static void bta_av_api_register(tBTA_AV_DATA *p_data);
+#if (BTA_AV_SINK_INCLUDED == TRUE)
+static void bta_av_api_sink_enable(tBTA_AV_DATA *p_data);
+#endif
 static void bta_av_ci_data(tBTA_AV_DATA *p_data);
 #if (AVDT_REPORTING == TRUE)
 static void bta_av_rpc_conn(tBTA_AV_DATA *p_data);
@@ -175,6 +182,9 @@
     bta_av_rc_closed,       /* BTA_AV_AVRC_CLOSE_EVT */
     bta_av_conn_chg,        /* BTA_AV_CONN_CHG_EVT */
     bta_av_dereg_comp,      /* BTA_AV_DEREG_COMP_EVT */
+#if (BTA_AV_SINK_INCLUDED == TRUE)
+    bta_av_api_sink_enable, /* BTA_AV_API_SINK_ENABLE_EVT */
+#endif
 #if (AVDT_REPORTING == TRUE)
     bta_av_rpc_conn,        /* BTA_AV_AVDT_RPT_CONN_EVT */
 #endif
@@ -392,6 +402,7 @@
     tBTA_AV_STR_MSG     *p_msg;
     UINT16  evt = 0;
     tBTA_AV_SCB *p_scb = NULL;
+    UNUSED(handle);
 
 #if( defined BTA_AR_INCLUDED ) && (BTA_AR_INCLUDED == TRUE)
     if (event == BTA_AR_AVDT_CONN_EVT ||
@@ -450,11 +461,58 @@
 static void bta_av_a2dp_report_cback(UINT8 handle, AVDT_REPORT_TYPE type,
                                     tAVDT_REPORT_DATA *p_data)
 {
+    UNUSED(handle);
+    UNUSED(type);
+    UNUSED(p_data);
     /* Do not need to handle report data for now.
      * This empty function is here for conformance reasons. */
 }
 #endif
 
+#if (BTA_AV_SINK_INCLUDED == TRUE)
+/*******************************************************************************
+**
+** Function         bta_av_api_sink_enable
+**
+** Description      activate, deactive A2DP Sink,
+**
+** Returns          void
+**
+*******************************************************************************/
+
+static void bta_av_api_sink_enable(tBTA_AV_DATA *p_data)
+{
+    UINT16 activate_sink = 0;
+    activate_sink = p_data->hdr.layer_specific;
+    APPL_TRACE_DEBUG1("bta_av_api_sink_enable %d ", activate_sink)
+    char p_service_name[BTA_SERVICE_NAME_LEN+1];
+    BCM_STRNCPY_S(p_service_name, sizeof(p_service_name),
+            BTIF_AVK_SERVICE_NAME, BTA_SERVICE_NAME_LEN);
+
+    if(activate_sink)
+    {
+        /* Activate Sink */
+        AVDT_SINK_Activate();
+        if (bta_av_cb.sdp_a2d_snk_handle == 0)
+        {
+            bta_av_cb.sdp_a2d_snk_handle = SDP_CreateRecord();
+            A2D_AddRecord(UUID_SERVCLASS_AUDIO_SINK, p_service_name, NULL,
+                          A2D_SUPF_PLAYER, bta_av_cb.sdp_a2d_snk_handle);
+            bta_sys_add_uuid(UUID_SERVCLASS_AUDIO_SINK);
+        }
+    }
+    else
+    {
+        AVDT_SINK_Deactivate();
+        if (bta_av_cb.sdp_a2d_snk_handle != 0)
+        {
+            SDP_DeleteRecord(bta_av_cb.sdp_a2d_snk_handle);
+            bta_av_cb.sdp_a2d_snk_handle = 0;
+            bta_sys_remove_uuid(UUID_SERVCLASS_AUDIO_SINK);
+        }
+    }
+}
+#endif
 /*******************************************************************************
 **
 ** Function         bta_av_api_register
@@ -476,12 +534,23 @@
     tBTA_AV_CODEC   codec_type;
     tBTA_UTL_COD    cod;
     UINT8           index = 0;
+    UINT8           xx;
+    UINT16          profile_initialized;
 
     memset(&cs,0,sizeof(tAVDT_CS));
 
     registr.status = BTA_AV_FAIL_RESOURCES;
     registr.app_id = p_data->api_reg.app_id;
     registr.chnl   = (tBTA_AV_CHNL)p_data->hdr.layer_specific;
+    profile_initialized = p_data->api_reg.service_uuid;
+    if(profile_initialized == UUID_SERVCLASS_AUDIO_SINK)
+    {
+        p_bta_av_cfg  = (tBTA_AV_CFG *) &bta_avk_cfg;
+    }
+    else if(profile_initialized == UUID_SERVCLASS_AUDIO_SOURCE)
+    {
+        p_bta_av_cfg  = (tBTA_AV_CFG *) &bta_av_cfg;
+    }
     do
     {
         p_scb = bta_av_alloc_scb(registr.chnl);
@@ -525,23 +594,22 @@
 #endif
 
                 bta_ar_reg_avrc(UUID_SERVCLASS_AV_REM_CTRL_TARGET, "AV Remote Control Target", NULL,
-                                p_bta_av_cfg->avrc_tg_cat, BTA_ID_AV);
+                     p_bta_av_cfg->avrc_tg_cat, BTA_ID_AV,(bta_av_cb.features & BTA_AV_FEAT_BROWSE));
 #endif
             }
 
             /* Set the Capturing service class bit */
-#ifdef BTA_AVK_INCLUDED
-            cod.service = BTM_COD_SERVICE_CAPTURING | BTM_COD_SERVICE_RENDERING;
-#else
-            cod.service = BTM_COD_SERVICE_CAPTURING;
-#endif
+            if (profile_initialized == UUID_SERVCLASS_AUDIO_SOURCE)
+                cod.service = BTM_COD_SERVICE_CAPTURING;
+            else if (profile_initialized == UUID_SERVCLASS_AUDIO_SINK)
+                cod.service = BTM_COD_SERVICE_RENDERING;
             utl_set_device_class(&cod, BTA_UTL_SET_COD_SERVICE_CLASS);
         } /* if 1st channel */
 
         /* get stream configuration and create stream */
         /* memset(&cs.cfg,0,sizeof(tAVDT_CFG)); */
         cs.cfg.num_codec = 1;
-        cs.tsep = AVDT_TSEP_SRC;
+
 
         /*
          * memset of cs takes care setting call back pointers to null.
@@ -563,6 +631,7 @@
 
         p_scb->suspend_sup  = TRUE;
         p_scb->recfg_sup    = TRUE;
+        p_scb->skip_sdp     = FALSE;
 
         cs.p_ctrl_cback  = bta_av_dt_cback[p_scb->hdi];
         if(registr.chnl == BTA_AV_CHNL_AUDIO)
@@ -588,54 +657,62 @@
             if(bta_av_cb.features & BTA_AV_FEAT_DELAY_RPT)
                 cs.cfg.psc_mask |= AVDT_PSC_DELAY_RPT;
 
-            /* keep the configuration in the stream control block */
-            memcpy(&p_scb->cfg, &cs.cfg, sizeof(tAVDT_CFG));
-            while(index < BTA_AV_MAX_SEPS &&
-                (*bta_av_a2d_cos.init)(&codec_type, cs.cfg.codec_info,
-                &cs.cfg.num_protect, cs.cfg.protect_info, index) == TRUE)
+            if (profile_initialized == UUID_SERVCLASS_AUDIO_SOURCE)
             {
-
-#ifdef BTA_AVK_INCLUDED
-            if(index == 1)
+                cs.tsep = AVDT_TSEP_SRC;
+                index = 0;
+            }
+            else if (profile_initialized == UUID_SERVCLASS_AUDIO_SINK)
             {
                 cs.tsep = AVDT_TSEP_SNK;
                 cs.p_data_cback = bta_av_stream_data_cback;
+                index = 1;
             }
-                APPL_TRACE_DEBUG1(" SEP Type = %d",cs.tsep);
-#endif
+            /* Initialize Handles to zero */
+            for(xx=0; xx<BTA_AV_MAX_SEPS; xx++)
+            {
+                p_scb->seps[xx].av_handle = 0;
+            }
+            /* keep the configuration in the stream control block */
+            memcpy(&p_scb->cfg, &cs.cfg, sizeof(tAVDT_CFG));
+            if ((*bta_av_a2d_cos.init)(&codec_type, cs.cfg.codec_info,
+                &cs.cfg.num_protect, cs.cfg.protect_info, index) == TRUE)
+            {
                 if(AVDT_CreateStream(&p_scb->seps[index].av_handle, &cs) == AVDT_SUCCESS)
                 {
                     p_scb->seps[index].codec_type = codec_type;
-
-#ifdef BTA_AVK_INCLUDED
                     p_scb->seps[index].tsep = cs.tsep;
                     if(cs.tsep == AVDT_TSEP_SNK)
                         p_scb->seps[index].p_app_data_cback = p_data->api_reg.p_app_data_cback;
                     else
                         p_scb->seps[index].p_app_data_cback = NULL; /* In case of A2DP SOURCE we don't need a callback to handle media packets */
-#endif
 
-                    APPL_TRACE_DEBUG3("audio[%d] av_handle: %d codec_type: %d",
-                        index, p_scb->seps[index].av_handle, p_scb->seps[index].codec_type);
-                    index++;
                 }
-                else
-                    break;
             }
 
             if(!bta_av_cb.reg_audio)
             {
-                /* create the SDP records on the 1st audio channel */
-                bta_av_cb.sdp_a2d_handle = SDP_CreateRecord();
-                A2D_AddRecord(UUID_SERVCLASS_AUDIO_SOURCE, p_service_name, NULL,
+                /* Initialize Handles to 0 */
+                bta_av_cb.sdp_a2d_handle = 0;
+#if (BTA_AV_SINK_INCLUDED == TRUE)
+                bta_av_cb.sdp_a2d_snk_handle = 0;
+#endif
+                if (profile_initialized == UUID_SERVCLASS_AUDIO_SOURCE)
+                {
+                    /* create the SDP records on the 1st audio channel */
+                    bta_av_cb.sdp_a2d_handle = SDP_CreateRecord();
+                    A2D_AddRecord(UUID_SERVCLASS_AUDIO_SOURCE, p_service_name, NULL,
                                   A2D_SUPF_PLAYER, bta_av_cb.sdp_a2d_handle);
-                bta_sys_add_uuid(UUID_SERVCLASS_AUDIO_SOURCE);
-
-#ifdef BTA_AVK_INCLUDED
-                bta_av_cb.sdp_a2d_snk_handle = SDP_CreateRecord();
-                A2D_AddRecord(UUID_SERVCLASS_AUDIO_SINK, p_service_name, NULL,
+                    bta_sys_add_uuid(UUID_SERVCLASS_AUDIO_SOURCE);
+                }
+#if (BTA_AV_SINK_INCLUDED == TRUE)
+                else if (profile_initialized == UUID_SERVCLASS_AUDIO_SINK)
+                {
+                    bta_av_cb.sdp_a2d_snk_handle = SDP_CreateRecord();
+                    A2D_AddRecord(UUID_SERVCLASS_AUDIO_SINK, p_service_name, NULL,
                                   A2D_SUPF_PLAYER, bta_av_cb.sdp_a2d_snk_handle);
-                bta_sys_add_uuid(UUID_SERVCLASS_AUDIO_SINK);
+                    bta_sys_add_uuid(UUID_SERVCLASS_AUDIO_SINK);
+                }
 #endif
                 /* start listening when A2DP is registered */
                 if (bta_av_cb.features & BTA_AV_FEAT_RCTG)
@@ -660,7 +737,7 @@
 #if( defined BTA_AR_INCLUDED ) && (BTA_AR_INCLUDED == TRUE)
                     /* create an SDP record as AVRC CT. */
                     bta_ar_reg_avrc(UUID_SERVCLASS_AV_REMOTE_CONTROL, NULL, NULL,
-                           p_bta_av_cfg->avrc_ct_cat, BTA_ID_AV);
+                    p_bta_av_cfg->avrc_ct_cat, BTA_ID_AV,(bta_av_cb.features & BTA_AV_FEAT_BROWSE));
 #endif
                 }
             }
@@ -746,6 +823,7 @@
 
 static void bta_av_rpc_conn(tBTA_AV_DATA *p_data)
 {
+    UNUSED(p_data);
 }
 #endif
 
@@ -856,10 +934,11 @@
 static void bta_av_sys_rs_cback (tBTA_SYS_CONN_STATUS status,UINT8 id, UINT8 app_id, BD_ADDR peer_addr)
 {
     int         i;
-    tBTA_AV_SCB *p_scb;
+    tBTA_AV_SCB *p_scb = NULL;
     tBTA_AV_ROLE_RES  *p_buf;
     UINT8       cur_role;
     UINT8       peer_idx = 0;
+    UNUSED(status);
 
     APPL_TRACE_DEBUG1("bta_av_sys_rs_cback: %d", bta_av_cb.rs_idx);
     for(i=0; i<BTA_AV_NUM_STRS; i++)
@@ -899,7 +978,10 @@
     /* we need to continue opening process for the BTA_AvOpen().                                    */
     if ((bta_av_cb.rs_idx != 0) && (bta_av_cb.rs_idx != peer_idx))
     {
-        p_scb = bta_av_cb.p_scb[bta_av_cb.rs_idx - 1];
+        if ((bta_av_cb.rs_idx -1) < BTA_AV_NUM_STRS)
+        {
+            p_scb = bta_av_cb.p_scb[bta_av_cb.rs_idx - 1];
+        }
         if (p_scb && p_scb->q_tag == BTA_AV_Q_TAG_OPEN)
         {
             APPL_TRACE_DEBUG3 ("bta_av_sys_rs_cback: rs_idx(%d), hndl:x%x q_tag: %d",
@@ -935,6 +1017,8 @@
     tBTA_AV_SCB *p_scb;
     int     i;
     tBTA_AV_API_STOP stop;
+    UNUSED(app_id);
+    UNUSED(peer_addr);
 
     APPL_TRACE_DEBUG2("bta_av_sco_chg_cback:%d status:%d", id, status);
     if(id)
@@ -1077,6 +1161,7 @@
     tBTA_AV_SCB *p_scbi;
     int i;
     UINT8   mask;
+    UNUSED(mtu);
 
     /* TODO_MV mess with the mtu according to the number of EDR/non-EDR headsets */
     if(p_scb->chnl == BTA_AV_CHNL_AUDIO)
@@ -1338,6 +1423,9 @@
     case BTA_AV_AVRC_CLOSE_EVT: return "AVRC_CLOSE";
     case BTA_AV_CONN_CHG_EVT: return "CONN_CHG";
     case BTA_AV_DEREG_COMP_EVT: return "DEREG_COMP";
+#if (BTA_AV_SINK_INCLUDED == TRUE)
+    case BTA_AV_API_SINK_ENABLE_EVT: return "SINK_ENABLE";
+#endif
 #if (AVDT_REPORTING == TRUE)
     case BTA_AV_AVDT_RPT_CONN_EVT: return "RPT_CONN";
 #endif
diff -Naur '--exclude=.git' bluedroid-orig/bta/av/bta_av_sbc.c bluedroid/bta/av/bta_av_sbc.c
--- bluedroid-orig/bta/av/bta_av_sbc.c	2015-09-24 16:33:43.520227643 +0800
+++ bluedroid/bta/av/bta_av_sbc.c	2015-09-24 16:31:36.000000000 +0800
@@ -26,6 +26,9 @@
 #include "a2d_api.h"
 #include "a2d_sbc.h"
 #include "bta_av_sbc.h"
+#include "utl.h"
+
+#define UNUSED(x) (void)(x)
 
 typedef int (tBTA_AV_SBC_ACT)(void *p_src, void *p_dst,
                                UINT32 src_samples, UINT32 dst_samples,
@@ -425,6 +428,7 @@
 {
     UINT8           status = A2D_SUCCESS;
     tA2D_SBC_CIE    peer_cie;
+    UNUSED(p_cap);
 
     /* parse peer capabilities */
     if ((status = A2D_ParsSbcInfo(&peer_cie, p_peer, TRUE)) != 0)
@@ -509,6 +513,78 @@
 
 /*******************************************************************************
 **
+** Function         bta_av_sbc_cfg_matches_cap
+**
+** Description      This function checks whether an SBC codec configuration
+**                  matched with capabilities. Here we check subset.
+**
+** Returns          0 if ok, nonzero if error.
+**
+*******************************************************************************/
+UINT8 bta_av_sbc_cfg_matches_cap(UINT8 *p_cfg, tA2D_SBC_CIE *p_cap)
+{
+    UINT8           status = 0;
+    tA2D_SBC_CIE    cfg_cie;
+
+    /* parse configuration */
+    if ((status = A2D_ParsSbcInfo(&cfg_cie, p_cfg, TRUE)) != 0)
+    {
+        APPL_TRACE_ERROR1(" bta_av_sbc_cfg_matches_cap Parsing Failed %d", status);
+        return status;
+    }
+
+    /* verify that each parameter is in range */
+
+    APPL_TRACE_DEBUG2(" FREQ peer: 0%x, capability  0%x", cfg_cie.samp_freq, p_cap->samp_freq);
+    APPL_TRACE_DEBUG2(" CH_MODE peer: 0%x, capability  0%x", cfg_cie.ch_mode, p_cap->ch_mode);
+    APPL_TRACE_DEBUG2(" BLOCK_LEN peer: 0%x, capability  0%x", cfg_cie.block_len, p_cap->block_len);
+    APPL_TRACE_DEBUG2(" SUB_BAND peer: 0%x, capability  0%x", cfg_cie.num_subbands, p_cap->num_subbands);
+    APPL_TRACE_DEBUG2(" ALLOC_MTHD peer: 0%x, capability  0%x", cfg_cie.alloc_mthd, p_cap->alloc_mthd);
+    APPL_TRACE_DEBUG2(" MAX_BitPool peer: 0%x, capability  0%x", cfg_cie.max_bitpool, p_cap->max_bitpool);
+    APPL_TRACE_DEBUG2(" Min_bitpool peer: 0%x, capability  0%x", cfg_cie.min_bitpool, p_cap->min_bitpool);
+
+    /* sampling frequency */
+    if ((cfg_cie.samp_freq & p_cap->samp_freq) == 0)
+    {
+        status = A2D_NS_SAMP_FREQ;
+    }
+    /* channel mode */
+    else if ((cfg_cie.ch_mode & p_cap->ch_mode) == 0)
+    {
+        status = A2D_NS_CH_MODE;
+    }
+    /* block length */
+    else if ((cfg_cie.block_len & p_cap->block_len) == 0)
+    {
+        status = A2D_BAD_BLOCK_LEN;
+    }
+    /* subbands */
+    else if ((cfg_cie.num_subbands & p_cap->num_subbands) == 0)
+    {
+        status = A2D_NS_SUBBANDS;
+    }
+    /* allocation method */
+    else if ((cfg_cie.alloc_mthd & p_cap->alloc_mthd) == 0)
+    {
+        status = A2D_NS_ALLOC_MTHD;
+    }
+    /* max bitpool */
+    else if (cfg_cie.max_bitpool > p_cap->max_bitpool)
+    {
+        status = A2D_NS_MAX_BITPOOL;
+    }
+    /* min bitpool */
+    else if (cfg_cie.min_bitpool < p_cap->min_bitpool)
+    {
+        status = A2D_NS_MIN_BITPOOL;
+    }
+
+    return status;
+}
+
+
+/*******************************************************************************
+**
 ** Function         bta_av_sbc_cfg_in_cap
 **
 ** Description      This function checks whether an SBC codec configuration
@@ -530,6 +606,7 @@
 
     /* verify that each parameter is in range */
 
+
     /* sampling frequency */
     if ((cfg_cie.samp_freq & p_cap->samp_freq) == 0)
     {
diff -Naur '--exclude=.git' bluedroid-orig/bta/av/bta_av_ssm.c bluedroid/bta/av/bta_av_ssm.c
--- bluedroid-orig/bta/av/bta_av_ssm.c	2015-09-24 16:33:43.520227643 +0800
+++ bluedroid/bta/av/bta_av_ssm.c	2015-09-24 16:31:36.000000000 +0800
@@ -182,7 +182,7 @@
 /* STR_RECONFIG_CFM_EVT */  {BTA_AV_SIGNORE,        BTA_AV_SIGNORE,        BTA_AV_INCOMING_SST },
 /* AVRC_TIMER_EVT */        {BTA_AV_SIGNORE,        BTA_AV_SIGNORE,        BTA_AV_INCOMING_SST },
 /* AVDT_CONNECT_EVT */      {BTA_AV_SIGNORE,        BTA_AV_SIGNORE,        BTA_AV_INCOMING_SST },
-/* AVDT_DISCONNECT_EVT */   {BTA_AV_CCO_CLOSE,      BTA_AV_CLEANUP,        BTA_AV_INIT_SST },
+/* AVDT_DISCONNECT_EVT */   {BTA_AV_CCO_CLOSE,      BTA_AV_DISCONNECT_REQ, BTA_AV_CLOSING_SST },
 /* ROLE_CHANGE_EVT*/        {BTA_AV_SIGNORE,        BTA_AV_SIGNORE,        BTA_AV_INCOMING_SST },
 /* AVDT_DELAY_RPT_EVT */    {BTA_AV_DELAY_CO,       BTA_AV_SIGNORE,        BTA_AV_INCOMING_SST },
 /* ACP_CONNECT_EVT */       {BTA_AV_SIGNORE,        BTA_AV_SIGNORE,        BTA_AV_INCOMING_SST }
@@ -204,7 +204,7 @@
 /* CI_SETCONFIG_OK_EVT */   {BTA_AV_SIGNORE,        BTA_AV_SIGNORE,        BTA_AV_OPENING_SST },
 /* CI_SETCONFIG_FAIL_EVT */ {BTA_AV_SIGNORE,        BTA_AV_SIGNORE,        BTA_AV_OPENING_SST },
 /* SDP_DISC_OK_EVT */       {BTA_AV_CONNECT_REQ,    BTA_AV_SIGNORE,        BTA_AV_OPENING_SST },
-/* SDP_DISC_FAIL_EVT */     {BTA_AV_CONN_FAILED,    BTA_AV_SIGNORE,        BTA_AV_INIT_SST },
+/* SDP_DISC_FAIL_EVT */     {BTA_AV_SDP_FAILED,    BTA_AV_SIGNORE,        BTA_AV_INIT_SST },
 /* STR_DISC_OK_EVT */       {BTA_AV_DISC_RESULTS,   BTA_AV_SIGNORE,        BTA_AV_OPENING_SST },
 /* STR_DISC_FAIL_EVT */     {BTA_AV_OPEN_FAILED,    BTA_AV_SIGNORE,        BTA_AV_CLOSING_SST },
 /* STR_GETCAP_OK_EVT */     {BTA_AV_GETCAP_RESULTS, BTA_AV_SIGNORE,        BTA_AV_OPENING_SST },
@@ -450,6 +450,43 @@
 
     event -= BTA_AV_FIRST_SSM_EVT;
 
+    if((p_scb->state != BTA_AV_OPENING_SST) &&
+        (state_table[event][BTA_AV_SNEXT_STATE] == BTA_AV_OPENING_SST))
+    {
+        AVDT_UpdateServiceBusyState(TRUE);
+    }
+    else if(AVDT_GetServiceBusyState() == TRUE)
+    {
+        BOOLEAN keep_busy = TRUE;
+
+        for (xx = 0; xx < BTA_AV_NUM_STRS; xx++)
+        {
+            if (bta_av_cb.p_scb[xx])
+            {
+                if ((bta_av_cb.p_scb[xx]->state == BTA_AV_OPENING_SST) &&
+                    (bta_av_cb.p_scb[xx] != p_scb))
+                {
+                    /* There is other SCB in opening state
+                     * keep the service state in progress
+                     */
+                    APPL_TRACE_IMP0("SCB in opening state. Keep Busy");
+                    keep_busy = TRUE;
+                    break;
+                }
+                else if ((bta_av_cb.p_scb[xx]->state == BTA_AV_OPENING_SST) &&
+                    (bta_av_cb.p_scb[xx] == p_scb) &&
+                    (state_table[event][BTA_AV_SNEXT_STATE] != BTA_AV_OPENING_SST))
+                {
+                    keep_busy = FALSE;
+                }
+            }
+        }
+        if (keep_busy == FALSE)
+        {
+            AVDT_UpdateServiceBusyState(FALSE);
+        }
+    }
+
     /* set next state */
     p_scb->state = state_table[event][BTA_AV_SNEXT_STATE];
 
diff -Naur '--exclude=.git' bluedroid-orig/bta/CMakeLists.txt bluedroid/bta/CMakeLists.txt
--- bluedroid-orig/bta/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/bta/CMakeLists.txt	2015-09-24 16:31:36.000000000 +0800
@@ -0,0 +1,139 @@
+CMAKE_MINIMUM_REQUIRED(VERSION 2.6)
+PROJECT(bt-brcm_bta C)
+
+ADD_DEFINITIONS("-DBUILDCFG")
+
+SET(SRCS
+./dm/bta_dm_ci.c
+./dm/bta_dm_act.c
+./dm/bta_dm_pm.c
+./dm/bta_dm_main.c
+./dm/bta_dm_cfg.c
+./dm/bta_dm_api.c
+./dm/bta_dm_sco.c
+./gatt/bta_gattc_api.c
+./gatt/bta_gatts_act.c
+./gatt/bta_gatts_main.c
+./gatt/bta_gattc_utils.c
+./gatt/bta_gattc_ci.c
+./gatt/bta_gatts_api.c
+./gatt/bta_gattc_main.c
+./gatt/bta_gattc_act.c
+./gatt/bta_gattc_cache.c
+./gatt/bta_gatts_utils.c
+./ag/bta_ag_sdp.c
+./ag/bta_ag_sco.c
+./ag/bta_ag_cfg.c
+./ag/bta_ag_main.c
+./ag/bta_ag_api.c
+./ag/bta_ag_rfc.c
+./ag/bta_ag_act.c
+./ag/bta_ag_cmd.c
+./ag/bta_ag_ci.c
+./ag/bta_ag_at.c
+./hf_client/bta_hf_client_act.c
+./hf_client/bta_hf_client_api.c
+./hf_client/bta_hf_client_main.c
+./hf_client/bta_hf_client_rfc.c
+./hf_client/bta_hf_client_at.c
+./hf_client/bta_hf_client_sdp.c
+./hf_client/bta_hf_client_sco.c
+./hf_client/bta_hf_client_cmd.c
+./hh/bta_hh_cfg.c
+./hh/bta_hh_act.c
+./hh/bta_hh_api.c
+./hh/bta_hh_le.c
+./hh/bta_hh_utils.c
+./hh/bta_hh_main.c
+./hd/bta_hd_act.c
+./hd/bta_hd_api.c
+./hd/bta_hd_main.c 
+./pb/bta_pbs_cfg.c
+./fs/bta_fs_ci.c
+./fs/bta_fs_cfg.c
+./pan/bta_pan_main.c
+./pan/bta_pan_ci.c
+./pan/bta_pan_act.c
+./pan/bta_pan_api.c
+./av/bta_av_act.c
+./av/bta_av_ci.c
+./av/bta_av_api.c
+./av/bta_av_aact.c
+./av/bta_av_main.c
+./av/bta_av_cfg.c
+./av/bta_av_ssm.c
+./av/bta_av_sbc.c
+./ar/bta_ar.c
+./hl/bta_hl_act.c
+./hl/bta_hl_api.c
+./hl/bta_hl_main.c
+./hl/bta_hl_utils.c
+./hl/bta_hl_sdp.c
+./hl/bta_hl_ci.c
+./sys/bta_sys_main.c
+./sys/bta_sys_ci.c
+./sys/bta_sys_conn.c
+./sys/bta_sys_cfg.c
+./sys/ptim.c
+./sys/bd.c
+./sys/utl.c
+./jv/bta_jv_act.c
+./jv/bta_jv_cfg.c
+./jv/bta_jv_main.c
+./jv/bta_jv_api.c
+./mce/bta_mce_api.c
+./mce/bta_mce_main.c
+./mce/bta_mce_act.c
+./mce/bta_mce_cfg.c
+./3d/bta_3d_api.c
+./3d/bta_3d_main.c
+)
+
+SET(PREFIX ${CMAKE_INSTALL_PREFIX})
+SET(EXEC_PREFIX "\${prefix}")
+SET(LIBDIR "\${prefix}/lib")
+SET(INCLUDEDIR "\${prefix}/include")
+SET(VERSION_MAJOR 1)
+SET(VERSION ${VERSION_MAJOR}.0.0)
+
+SET(LOCAL_C_INCLUDES 
+	./include 
+	./sys 
+	./dm 
+	./hh 
+	../gki/common 
+	../gki/ulinux 
+	../include 
+	../stack/include 
+	../stack/btm 
+	../hcis 
+	../hcis/patchram 
+	../udrv/include 
+	../brcm/include 
+	../../../../system/core/include
+	../../../../hardware/libhardware/include	
+	${bdroid_C_INCLUDES})
+include_directories(${LOCAL_C_INCLUDES})
+
+FOREACH(flag ${packages_CFLAGS})
+	SET(EXTRA_CFLAGS "${EXTRA_CFLAGS} ${flag}")
+ENDFOREACH(flag)
+
+#SET(EXTRA_CFLAGS "${EXTRA_CFLAGS} -fvisibility=hidden -Wall")
+SET(EXTRA_CFLAGS "${EXTRA_CFLAGS} -g ")
+SET(EXTRA_CFLAGS "${EXTRA_CFLAGS} -DBUILDCFG ")
+
+SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${EXTRA_CFLAGS} -fPIC")
+
+FIND_PROGRAM(UNAME NAMES uname)
+EXEC_PROGRAM("${UNAME}" ARGS "-m" OUTPUT_VARIABLE "ARCH")
+IF("${ARCH}" STREQUAL "arm")
+	ADD_DEFINITIONS("-DTARGET")
+	MESSAGE("add -DTARGET")
+ENDIF("${ARCH}" STREQUAL "arm")
+
+ADD_LIBRARY(${PROJECT_NAME} STATIC ${SRCS})
+SET_TARGET_PROPERTIES(${PROJECT_NAME} PROPERTIES SOVERSION ${VERSION_MAJOR})
+SET_TARGET_PROPERTIES(${PROJECT_NAME} PROPERTIES VERSION ${VERSION})
+TARGET_LINK_LIBRARIES(${PROJECT_NAME} ${packages_LDFLAGS})
+INSTALL(TARGETS ${PROJECT_NAME} DESTINATION lib)
diff -Naur '--exclude=.git' bluedroid-orig/bta/dm/bta_dm_act.c bluedroid/bta/dm/bta_dm_act.c
--- bluedroid-orig/bta/dm/bta_dm_act.c	2015-09-24 16:33:43.524227643 +0800
+++ bluedroid/bta/dm/bta_dm_act.c	2015-09-24 16:31:36.000000000 +0800
@@ -236,6 +236,9 @@
 #define MAX_DISC_RAW_DATA_BUF       (4096)
 UINT8 g_disc_raw_data_buf[MAX_DISC_RAW_DATA_BUF];
 
+static BOOLEAN include_3d_eir;
+static INT8    ctl_eir_tx_power;
+
 /*******************************************************************************
 **
 ** Function         bta_dm_app_ready_timer_cback
@@ -750,6 +753,64 @@
     BTM_SetAfhChannels(p_data->set_afhchannels.first,p_data->set_afhchannels.last);
 
 }
+
+#if (A2DP_KERNEL_DIRECT == TRUE)
+/*******************************************************************************
+**
+** Function         bta_dm_send_btlite_req
+**
+** Description      This function sends cmd to BTLITE stack
+**
+**
+** Returns          void
+**
+*******************************************************************************/
+void bta_dm_send_btlite_req(tBTA_DM_MSG * p_data)
+{
+    APPL_TRACE_API0("bta_dm_send_btlite_sync_req ");
+    UINT8 cmd = p_data->bta_lite_req.sync.event;
+    APPL_TRACE_API1("bta_dm_send_btlite_req cmd = %d ",cmd);
+    if (cmd == BTA_AV_SYNC_TO_LITE_REQ)
+    {
+        tBTA_AV_SYNC_INFO_REQ sync_info_req;
+        memset(&sync_info_req,0,sizeof(tBTA_AV_SYNC_INFO_REQ));
+        sync_info_req.event = p_data->bta_lite_req.sync.event;
+        memcpy(&sync_info_req.sync_info,&p_data->bta_lite_req.sync.sync_info,sizeof(tBTA_AV_SYNC_INFO));
+        sync_info_req.curr_mtu = p_data->bta_lite_req.sync.curr_mtu;
+        sync_info_req.multi_av_supported = p_data->bta_lite_req.sync.multi_av_supported;
+        BTM_SendBTLiteReq(BT_EVT_BTU_IPC_BTM_EVT,p_data->bta_lite_req.sync.event,(void *)&sync_info_req,p_data->bta_lite_req.sync.p_cb);
+    }
+    else if(cmd == BTA_AV_STR_START_TO_LITE_REQ)
+    {
+        tBTA_AV_SCB_REQ start_req;
+        memset(&start_req,0,sizeof(tBTA_AV_SCB_REQ));
+        memcpy(&start_req,&p_data->bta_lite_req.start.event,sizeof(tBTA_AV_SCB_REQ));
+        BTM_SendBTLiteReq(BT_EVT_BTU_IPC_BTM_EVT,p_data->bta_lite_req.start.event,(void *)&start_req,p_data->bta_lite_req.start.p_cb);
+    }
+    else
+    {
+       if (cmd == BTA_AV_STR_SUSPEND_TO_LITE_REQ || cmd == BTA_AV_STR_STOP_TO_LITE_REQ)
+       {
+           tBTA_AV_SCB_STOP_REQ stop_suspend_req;
+           memset(&stop_suspend_req,0,sizeof(tBTA_AV_SCB_STOP_REQ));
+//           stop_suspend_req.event = p_data->bta_lite_req.stop.event;
+           memcpy(&stop_suspend_req,&p_data->bta_lite_req.stop.event,sizeof(tBTA_AV_SCB_STOP_REQ));
+           BTM_SendBTLiteReq(BT_EVT_BTU_IPC_BTM_EVT,p_data->bta_lite_req.stop.event,(void *)&stop_suspend_req,p_data->bta_lite_req.stop.p_cb);
+       }
+       else if(cmd == BTA_AV_STR_CLEANUP_TO_LITE_REQ)
+       {
+           tBTA_AV_SCB_CLEANUP_REQ cleanup_req;
+           memset(&cleanup_req,0,sizeof(tBTA_AV_SCB_CLEANUP_REQ));
+//           cleanup_req.event = p_data->bta_lite_req.stop.event;
+//           cleanup_req.scb_idx = p_data->bta_lite_req.stop.scb_idx;
+//           cleanup_req.audio_open_cnt = p_data->bta_lite_req.stop.audio_open_cnt;
+//           cleanup_req.curr_mtu = p_data->bta_lite_req.stop.curr_mtu;
+           memcpy(&cleanup_req,&p_data->bta_lite_req.stop.event,sizeof(tBTA_AV_SCB_CLEANUP_REQ));
+           BTM_SendBTLiteReq(BT_EVT_BTU_IPC_BTM_EVT,p_data->bta_lite_req.stop.event,(void *)&cleanup_req,p_data->bta_lite_req.stop.p_cb);
+       }
+    }
+}
+#endif
 /*******************************************************************************
 **
 ** Function         bta_dm_hci_raw_command
@@ -1804,6 +1865,81 @@
 
 /*******************************************************************************
 **
+** Function         bta_get_primary_di_record
+**
+** Description      Get Primary DI Record of remote device from SDP DB
+**
+** Returns          status
+**
+*******************************************************************************/
+static tBTA_STATUS bta_get_primary_di_record(tBTA_DI_GET_RECORD *p_device_info, UINT8 num_rec,
+                                             tSDP_DISCOVERY_DB *p_db)
+{
+    /* copy the information from the SDP record to the DI record */
+    tSDP_DISC_REC *p_curr_record = NULL;
+    tSDP_DISC_ATTR *p_curr_attr = NULL;
+    UINT8 record_index;
+    tBTA_STATUS status = BTA_FAILURE;
+
+    APPL_TRACE_WARNING1("bta_get_primary_di_record: No.of Di records: %d", num_rec);
+
+    for(record_index = 1; record_index <= BTA_DI_NUM_MAX && record_index <= num_rec; record_index++)
+    {
+        p_curr_record = SDP_FindServiceInDb(bta_dm_search_cb.p_sdp_db,
+                                UUID_SERVCLASS_PNP_INFORMATION, p_curr_record);
+        if (p_curr_record)
+        {
+            p_curr_attr = SDP_FindAttributeInRec(p_curr_record, ATTR_ID_PRIMARY_RECORD);
+            if (p_curr_attr)
+            {
+                p_device_info->rec.primary_record = (BOOLEAN)p_curr_attr->attr_value.v.u8;
+                APPL_TRACE_DEBUG2("primary_record: %d, record_index: %d",
+                        p_device_info->rec.primary_record, record_index);
+
+                if (p_device_info->rec.primary_record == TRUE)
+                {
+                    if (BTA_DmGetDiRecord(record_index, p_device_info, p_db) == BTA_SUCCESS)
+                    {
+                        APPL_TRACE_DEBUG0("Successfully fetched primary DI record");
+                        status = BTA_SUCCESS;
+                        break;
+                    }
+                    else
+                    {
+                        APPL_TRACE_ERROR0("failed to get primary DI record");
+                        status = BTA_FAILURE;
+                        break;
+                    }
+                }
+                else
+                {
+                    if (record_index == num_rec || record_index == BTA_DI_NUM_MAX)
+                    {
+                       /* Assumption: Choose 1st record as the primary record,
+                       * If there is no primary record found in below cases
+                       * If Only one DI record is recieved from remote device.
+                       * If multiples DI record is recieved from remote device. */
+                       if (BTA_DmGetDiRecord(1, p_device_info, p_db) == BTA_SUCCESS)
+                       {
+                           APPL_TRACE_WARNING0("Successfully fetched first DI record");
+                           status = BTA_SUCCESS;
+                           break;
+                       }
+                       else
+                       {
+                           APPL_TRACE_ERROR0("failed to get first DI record");
+                           status = BTA_FAILURE;
+                           break;
+                       }
+                    }
+                }
+            }
+        }
+    }
+return status;
+}
+/*******************************************************************************
+**
 ** Function         bta_dm_sdp_result
 **
 ** Description      Process the discovery result from sdp
@@ -1906,10 +2042,30 @@
                 {
                     if (p_sdp_rec)
                     {
+                        APPL_TRACE_ERROR1("%s UUID_SERVCLASS_PNP_INFORMATION found",__func__);
+#ifndef PLATFORM_ANDROID
+                        tBTA_DM_DI_DISC_CMPL    di_disc;
+                        memset(&di_disc, 0, sizeof(tBTA_DM_DI_DISC_CMPL));
+                        bdcpy (di_disc.bd_addr, bta_dm_search_cb.peer_bdaddr);
+                        di_disc.num_record = SDP_GetNumDiRecords(bta_dm_search_cb.p_sdp_db);
+                        di_disc.result = bta_get_primary_di_record(&di_disc.p_device_info,
+                                                 di_disc.num_record, bta_dm_search_cb.p_sdp_db);
+                        if (di_disc.result == BTA_SUCCESS)
+                        {
+                            bta_dm_search_cb.p_search_cback(BTA_DM_DI_DISC_CMPL_EVT,
+                                    (tBTA_DM_SEARCH *) &di_disc);
+                        }
+                        else
+                        {
+                            APPL_TRACE_ERROR1("Valid DI record is not found in %d records",
+                                    di_disc.num_record);
+                        }
+#else
                         if (SDP_FindAttributeInRec (p_sdp_rec, ATTR_ID_EXT_BRCM_VERSION))
                         {
                             service_found = TRUE;
                         }
+#endif
                     }
                 }
                 else
@@ -4286,6 +4442,7 @@
     UINT8    num_uuid;
     UINT8    data_type;
     UINT8    local_name_len;
+    tSDP_DI_GET_RECORD DID;
 
     /* wait until complete to disable */
     if (bta_dm_cb.disable_timer.in_use)
@@ -4349,6 +4506,34 @@
             data_type = BTM_EIR_COMPLETE_LOCAL_NAME_TYPE;
     }
 
+//XXX ifdef?
+    if(include_3d_eir)
+    {
+    APPL_TRACE_DEBUG1("%s: Adding 3d", __FUNCTION__);
+        //XXX make these defines or configures
+        UINT8_TO_STREAM(p, 6);
+        UINT8_TO_STREAM(p, BTM_EIR_MANUFACTURER_SPECIFIC_TYPE);
+        UINT16_TO_STREAM(p, LMP_COMPID_BROADCOM);
+        UINT8_TO_STREAM(p, 0);
+        UINT8_TO_STREAM(p, 1);
+        UINT8_TO_STREAM(p, 100);
+
+        UINT8_TO_STREAM(p, 3);
+        UINT8_TO_STREAM(p, BTM_EIR_3D_INFO_TYPE);
+        UINT8_TO_STREAM(p, 0x07);
+        UINT8_TO_STREAM(p, 100);
+
+        free_eir_length -= 9;
+
+        if(!bta_dm_eir_cfg.bta_dm_eir_inq_tx_power)
+        {
+            UINT8_TO_STREAM(p, 2);      /* Length field */
+            UINT8_TO_STREAM(p, BTM_EIR_TX_POWER_LEVEL_TYPE);
+            UINT8_TO_STREAM(p, ctl_eir_tx_power);
+            free_eir_length -= 3;
+        }
+    }
+
     UINT8_TO_STREAM(p, local_name_len + 1);
     UINT8_TO_STREAM(p, data_type);
 
@@ -4359,6 +4544,25 @@
     }
     free_eir_length -= local_name_len + 2;
 
+    if (free_eir_length > 9)
+    {
+        UINT32 p_handle = 0;
+        UINT8 len = 9;
+        data_type = BTM_EIR_DID_INFO_TYPE;
+
+        if (BTA_DmGetLocalDiRecord(&DID, &p_handle) == BTM_SUCCESS)
+        {
+            UINT8_TO_STREAM(p, len);
+            UINT8_TO_STREAM(p, data_type);
+            UINT16_TO_STREAM(p, DID.rec.vendor_id_source);
+            UINT16_TO_STREAM(p, DID.rec.vendor);
+            UINT16_TO_STREAM(p, DID.rec.product);
+            UINT16_TO_STREAM(p, DID.rec.version);
+            free_eir_length -= (len +1);
+        }
+        else
+            APPL_TRACE_ERROR0("Failed to get Local DID record");
+   }
 #if (BTA_EIR_CANNED_UUID_LIST == TRUE)
     /* if UUID list is provided as static data in configuration */
     if(( p_bta_dm_eir_cfg->bta_dm_eir_uuid16_len > 0 )
@@ -4835,6 +5039,16 @@
     return TRUE;
 }
 
+//XXX ifdef?
+void bta_dm_set_3d_eir_enabled(tBTA_DM_MSG * p_data)
+{
+    APPL_TRACE_DEBUG1("%s: Enter", __FUNCTION__);
+    include_3d_eir   = ((tBTA_DM_API_SET_3D_EIR_ENABLED *)p_data)->enable;
+    ctl_eir_tx_power = ((tBTA_DM_API_SET_3D_EIR_ENABLED *)p_data)->tx_power;
+    bta_dm_set_eir(NULL);
+    APPL_TRACE_DEBUG1("%s: Exit", __FUNCTION__);
+}
+
 #if (BLE_INCLUDED == TRUE)
 /*******************************************************************************
 **
@@ -5332,8 +5546,29 @@
 *******************************************************************************/
 void bta_dm_ble_set_adv_config (tBTA_DM_MSG *p_data)
 {
+#ifndef PLATFORM_ANDROID
+    tBTA_BLE_ADV_DATA *p_adv_cfg = (tBTM_BLE_ADV_DATA *)p_data->ble_set_adv_data.p_adv_cfg;
+    APPL_TRACE_ERROR2("%s manu len = %d",__func__,p_adv_cfg->manu.len);
+
+    BTM_SetManuData(p_adv_cfg->manu.p_val,p_adv_cfg->manu.len);
+    BTM_SetFlag(p_adv_cfg->flag);
+
+    if (p_data->ble_set_adv_data.data_mask & BTM_BLE_AD_BIT_SERVICE_DATA)
+        BTM_SetServiceData(p_adv_cfg->service_data.p_val,p_adv_cfg->service_data.len);
+
+    if (p_data->ble_set_adv_data.data_mask & BTM_BLE_AD_BIT_INT_RANGE)
+        BTM_SetRange(p_adv_cfg->int_range.hi,p_adv_cfg->int_range.low);
+
+    if (p_data->ble_set_adv_data.data_mask & BTM_BLE_AD_BIT_APPEARANCE)
+        BTM_SetAppearance(p_adv_cfg->appearance);
+
+    BTM_write_adv(p_data->ble_set_adv_data.data_mask,
+                   (tBTM_BLE_ADV_DATA *)p_data->ble_set_adv_data.p_adv_cfg);
+    GKI_freebuf(p_adv_cfg);
+#else
     BTM_BleWriteAdvData(p_data->ble_set_adv_data.data_mask,
                         (tBTM_BLE_ADV_DATA *)p_data->ble_set_adv_data.p_adv_cfg);
+#endif
 }
 
 /*******************************************************************************
diff -Naur '--exclude=.git' bluedroid-orig/bta/dm/bta_dm_api.c bluedroid/bta/dm/bta_dm_api.c
--- bluedroid-orig/bta/dm/bta_dm_api.c	2015-09-24 16:33:43.524227643 +0800
+++ bluedroid/bta/dm/bta_dm_api.c	2015-09-24 16:31:36.000000000 +0800
@@ -2122,3 +2122,106 @@
     APPL_TRACE_API1("%s exit\n", __FUNCTION__);
 }
 
+BTA_API extern BOOLEAN BTA_DmIsAclConnectionUp(BD_ADDR remote_bda)
+{
+#ifndef PLATFORM_ANDROID
+    if(BTM_IsAclConnectionUp(remote_bda))
+    {
+        return TRUE;
+    }
+#endif  
+    return FALSE;
+}
+
+#ifdef A2DP_KERNEL_DIRECT
+//BTA_API extern void BTA_DMSendBTLiteReq(UINT8 cmd_type,void *lite_info,tBTA_VENDOR_CMPL_CBACK *p_cback)
+BTA_API extern void BTA_DMSendBTLiteReq(UINT8 cmd_type,void *lite_info,tBTA_BTLITE_CMPL_CBACK *p_cback)
+
+{
+    void *p_pmsg = NULL;
+    APPL_TRACE_API2("%s: start = %d enter\n", __FUNCTION__, cmd_type);
+    if (cmd_type == BTA_AV_SYNC_TO_LITE_REQ)
+    {
+        tBTA_AV_HOST_SYNC_INFO *p_msg;
+        p_msg = (tBTA_AV_HOST_SYNC_INFO*) GKI_getbuf(sizeof(tBTA_AV_HOST_SYNC_INFO));
+
+        if (p_msg != NULL)
+        {
+            tBTA_AV_SYNC_INFO_REQ *ptr = (tBTA_AV_SYNC_INFO_REQ *)lite_info;
+            memset(p_msg,0,sizeof(tBTA_AV_HOST_SYNC_INFO));
+            p_msg->hdr.event = BTA_DM_SEND_BTLITE_REQ;
+            p_msg->event = cmd_type;
+            memcpy(&p_msg->sync_info,&ptr->sync_info,sizeof(tBTA_AV_SYNC_INFO));
+            p_msg->curr_mtu = ptr->curr_mtu;
+            p_msg->multi_av_supported = ptr->multi_av_supported;
+            p_msg->p_cb = p_cback;
+        }
+        p_pmsg = (void *)p_msg;
+    }
+    else if (cmd_type == BTA_AV_STR_START_TO_LITE_REQ)
+    {
+        tBTA_AV_HOST_SCB_REQ *p_msg;
+        p_msg = (tBTA_AV_HOST_SCB_REQ*) GKI_getbuf(sizeof(tBTA_AV_HOST_SCB_REQ));
+        if (p_msg != NULL)
+        {
+            tBTA_AV_SCB_REQ *p = (tBTA_AV_SCB_REQ *)lite_info;
+            memset(p_msg,0,sizeof(tBTA_AV_HOST_SCB_REQ));
+            memcpy(&p_msg->event,p,sizeof(tBTA_AV_SCB_REQ));
+            p_msg->hdr.event = BTA_DM_SEND_BTLITE_REQ;
+            p_msg->event = cmd_type;
+            p_msg->p_cb = p_cback;
+        }
+        p_pmsg = (void *)p_msg;
+    }
+    else if (cmd_type == BTA_AV_STR_SUSPEND_TO_LITE_REQ || cmd_type == BTA_AV_STR_STOP_TO_LITE_REQ ||
+             cmd_type == BTA_AV_STR_CLEANUP_TO_LITE_REQ)
+    {
+        tBTA_AV_HOST_STOP_SUSPEND_REQ *p_msg;
+        p_msg = (tBTA_AV_HOST_STOP_SUSPEND_REQ *) GKI_getbuf(sizeof(tBTA_AV_HOST_STOP_SUSPEND_REQ));
+
+        if (p_msg != NULL)
+        {
+            tBTA_AV_BTLITE_INFO *p = (tBTA_AV_BTLITE_INFO *)lite_info;
+            memset(p_msg,0,sizeof(tBTA_AV_HOST_STOP_SUSPEND_REQ));
+            p_msg->hdr.event = BTA_DM_SEND_BTLITE_REQ;
+            p_msg->event = cmd_type;
+            p_msg->scb_idx = p->scb_idx;
+            p_msg->audio_open_cnt = p->audio_open_cnt;
+            p_msg->curr_mtu = p->curr_mtu;
+            p_msg->p_cb = p_cback;
+        }
+        p_pmsg = (void *)p_msg;
+    }
+    bta_sys_sendmsg(p_pmsg);
+}
+#endif //A2DP_KERNEL_DIRECT
+
+/*******************************************************************************
+**
+** Function         BTA_Set3DEIREnabled
+**
+** Description      Enables/disables the 3D Sync data in the EIR.
+**
+** Parameters       Boolean indicating whether to enable 3D.
+**
+** Returns          void
+**
+*******************************************************************************/
+BTA_API extern void BTA_Set3DEIREnabled (BOOLEAN enable, INT8 tx_power)
+{
+    tBTA_DM_API_SET_3D_EIR_ENABLED *p_msg;
+
+    APPL_TRACE_API2("%s: Enter(%d)", __FUNCTION__,enable);
+    if((p_msg = (tBTA_DM_API_SET_3D_EIR_ENABLED *) GKI_getbuf(sizeof(tBTA_DM_API_SET_3D_EIR_ENABLED))) != NULL)
+    {
+        memset(p_msg, 0, sizeof(tBTA_DM_API_SET_3D_EIR_ENABLED));
+
+        p_msg->hdr.event = BTA_DM_API_SET_3D_EIR_ENABLED_EVT;
+        p_msg->enable    = enable;
+        p_msg->tx_power  = tx_power;
+
+        bta_sys_sendmsg(p_msg);
+    }
+    APPL_TRACE_API1("%s: Exit", __FUNCTION__);
+}
+
diff -Naur '--exclude=.git' bluedroid-orig/bta/dm/bta_dm_cfg.c bluedroid/bta/dm/bta_dm_cfg.c
--- bluedroid-orig/bta/dm/bta_dm_cfg.c	2015-09-24 16:33:43.524227643 +0800
+++ bluedroid/bta/dm/bta_dm_cfg.c	2015-09-24 16:31:36.000000000 +0800
@@ -82,7 +82,7 @@
 
 #ifndef BTA_AV_ROLE
 /* By default, AV role (backward BTA_MASTER_ROLE_PREF) */
-#define BTA_AV_ROLE BTA_MASTER_ROLE_PREF
+#define BTA_AV_ROLE BTA_MASTER_ROLE_ONLY
 #endif
 
 #define BTA_DM_NUM_RM_ENTRY    4
diff -Naur '--exclude=.git' bluedroid-orig/bta/dm/bta_dm_int.h bluedroid/bta/dm/bta_dm_int.h
--- bluedroid-orig/bta/dm/bta_dm_int.h	2015-09-24 16:33:43.524227643 +0800
+++ bluedroid/bta/dm/bta_dm_int.h	2015-09-24 16:31:36.000000000 +0800
@@ -30,6 +30,9 @@
     #include "bta_gatt_api.h"
 #endif
 
+#if (A2DP_KERNEL_DIRECT == TRUE)
+#include "bta_av_api.h"
+#endif
 
 
 /*****************************************************************************
@@ -122,7 +125,11 @@
     BTA_DM_API_DISABLE_TEST_MODE_EVT,
     BTA_DM_API_EXECUTE_CBACK_EVT,
     BTA_DM_API_SET_AFH_CHANNEL_ASSESMENT_EVT,
+#if (A2DP_KERNEL_DIRECT == TRUE)
+    BTA_DM_SEND_BTLITE_REQ,
+#endif //A2DP_KERNEL_DIRECT
     BTA_DM_API_HCI_RAW_COMMAND_EVT,
+    BTA_DM_API_SET_3D_EIR_ENABLED_EVT,
     BTA_DM_MAX_EVT
 };
 
@@ -630,6 +637,13 @@
     BOOLEAN     remove_dev;
 }tBTA_DM_API_REMOVE_ACL;
 
+typedef struct
+{
+    BT_HDR  hdr;
+    BOOLEAN enable;
+    INT8    tx_power;
+}tBTA_DM_API_SET_3D_EIR_ENABLED;
+
 /* union of all data types */
 typedef union
 {
@@ -722,8 +736,13 @@
     tBTA_DM_API_SET_EIR_CONFIG          set_eir_cfg;
 #endif
     tBTA_DM_API_REMOVE_ACL              remove_acl;
+#if (A2DP_KERNEL_DIRECT == TRUE)
+    tBTA_AV_BTLITE_REQ                  bta_lite_req;
+#endif //A2DP_KERNEL_DIRECT
     tBTA_DM_API_RAW_COMMAND btc_command;
 
+    tBTA_DM_API_SET_3D_EIR_ENABLED      set_3d_eir_enabled;
+
 } tBTA_DM_MSG;
 
 #ifndef MAX_ACL_CONNECTIONS
@@ -1140,6 +1159,11 @@
 extern void bta_dm_execute_callback(tBTA_DM_MSG *p_data);
 
 extern void bta_dm_set_afh_channel_assesment(tBTA_DM_MSG *p_data);
+#if (A2DP_KERNEL_DIRECT == TRUE)
+extern void bta_dm_send_btlite_req(tBTA_DM_MSG *p_data);
+#endif//A2DP_KERNEL_DIRECT
 extern void bta_dm_hci_raw_command(tBTA_DM_MSG *p_data);
+
+extern void bta_dm_set_3d_eir_enabled(tBTA_DM_MSG * p_data);
 #endif /* BTA_DM_INT_H */
 
diff -Naur '--exclude=.git' bluedroid-orig/bta/dm/bta_dm_main.c bluedroid/bta/dm/bta_dm_main.c
--- bluedroid-orig/bta/dm/bta_dm_main.c	2015-09-24 16:33:43.524227643 +0800
+++ bluedroid/bta/dm/bta_dm_main.c	2015-09-24 16:31:36.000000000 +0800
@@ -119,7 +119,11 @@
     bta_dm_disable_test_mode,   /*  BTA_DM_API_DISABLE_TEST_MODE_EVT    */
     bta_dm_execute_callback,     /*  BTA_DM_API_EXECUTE_CBACK_EVT        */
     bta_dm_set_afh_channel_assesment,     /* BTA_DM_API_SET_AFH_CHANNEL_ASSESMENT_EVT */
-    bta_dm_hci_raw_command    /* BTA_DM_API_HCI_RAW_COMMAND_EVT */
+#if (A2DP_KERNEL_DIRECT == TRUE)
+    bta_dm_send_btlite_req,               /* BTA_DM_SEND_BTLITE_REQ*/
+#endif //A2DP_KERNEL_DIRECT
+    bta_dm_hci_raw_command,    /* BTA_DM_API_HCI_RAW_COMMAND_EVT */
+    bta_dm_set_3d_eir_enabled   /* BTA_DM_API_SET_3D_EIR_ENABLED */
 };
 
 
diff -Naur '--exclude=.git' bluedroid-orig/bta/hh/bta_hh_act.c bluedroid/bta/hh/bta_hh_act.c
--- bluedroid-orig/bta/hh/bta_hh_act.c	2015-09-24 16:33:43.524227643 +0800
+++ bluedroid/bta/hh/bta_hh_act.c	2015-09-24 16:31:36.000000000 +0800
@@ -27,7 +27,7 @@
 #if defined(BTA_HH_INCLUDED) && (BTA_HH_INCLUDED == TRUE)
 
 #include <string.h>
-
+#include <signal.h>
 #include "bta_sys.h"
 #include "btm_api.h"
 #include "l2c_api.h"
diff -Naur '--exclude=.git' bluedroid-orig/bta/include/bta_3d_api.h bluedroid/bta/include/bta_3d_api.h
--- bluedroid-orig/bta/include/bta_3d_api.h	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/bta/include/bta_3d_api.h	2015-09-24 16:31:36.000000000 +0800
@@ -0,0 +1,199 @@
+//XXX copyright header?
+#ifndef BTA_3D_API_H
+#define BTA_3D_API_H
+
+#include "bta_api.h"
+#include "btm_api.h"
+
+#define BTA_3D_ENABLE_EVT          1
+#define BTA_3D_DISABLE_EVT         2
+#define BTA_3D_ASSOCIATION_EVT     3
+#define BTA_3D_CLK_CAP_EVT         4
+#define BTA_3D_SYNC_TRAIN_CMPL_EVT 5
+#define BTA_3D_SLV_PAGE_RSP_TO_EVT 6
+#define BTA_3D_COMMAND_STATUS_EVT  7
+#define BTA_3D_CHANNEL_CHANGE_EVT  8
+
+typedef UINT16 tBTA_3D_EVT;
+
+enum
+{
+    BTA_3D_OK,
+    BTA_3D_ERR,
+    BTA_3D_ERR_SDP,
+    BTA_3D_ERR_NO_RES,
+    BTA_3D_ERR_BUSY,
+    BTA_3D_ERR_CMD_TIMEOUT
+};
+
+typedef UINT8 tBTA_3D_STATUS;
+
+typedef struct
+{
+    BD_ADDR bd;
+    UINT8   flags;
+    UINT8   battery;
+    BOOLEAN legacy;
+} tBTA_3D_ASSOC;
+
+#define BTA_3D_ASSOC_FLAGS_ASSOC         0x01
+#define BTA_3D_ASSOC_FLAGS_USER_BATT_REQ 0x02
+
+#define BTA_3D_ASSOC_BATT_LVL_NOT_SUPP   0xFF
+
+typedef struct
+{
+    UINT32 clock;
+    UINT16 offset;
+} tBTA_3D_CLK_CAP;
+
+#define BTA_3D_CMD_WRITE_PARAMS         BTM_WRITE_SYNC_TRAIN_PARAM_CMPL
+#define BTA_3D_CMD_START_TRAIN          BTM_START_SYNC_TRAIN_CMPL
+#define BTA_3D_CMD_SET_BROADCAST_DATA   BTM_SET_CLB_DATA_CMPL
+#define BTA_3D_CMD_SET_BROADCAST        BTM_SET_CLB_CMPL
+#define BTA_3D_CMD_SET_CLK_CAP          BTM_SET_TRG_CLK_CAP_CMPL
+
+typedef UINT16 tBTA_3D_CMD;
+
+typedef struct
+{
+    tBTA_3D_CMD cmd;
+    tBTA_3D_STATUS status;
+} tBTA_3D_CMD_STATUS;
+
+typedef union
+{
+    tBTA_3D_STATUS     status;         /* ENABLE_EVT          */
+    tBTA_3D_ASSOC      association;    /* ASSOCIATION_EVT     */
+    tBTA_3D_CLK_CAP    clk_cap;        /* CLK_CAP_EVT         */
+    UINT8              train_status;   /* SYNC_TRAIN_CMPL_EVT */
+    tBTA_3D_CMD_STATUS cmd_status;     /* COMMAND_STATUS      */
+} tBTA_3D;
+
+/* BTA 3D callback function. */
+typedef void (tBTA_3D_CBACK) (tBTA_3D_EVT event, tBTA_3D *p_data);
+
+typedef struct
+{
+    UINT32 instant;
+    UINT16 phase;
+    UINT16 left_open_off;
+    UINT16 left_close_off;
+    UINT16 right_open_off;
+    UINT16 right_close_off;
+    UINT16 period;
+    UINT8 fraction;
+    BOOLEAN dual_view;
+} tBTA_3D_BCAST_DATA;
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*******************************************************************************
+     **
+     ** Function         BTA_3dEnable
+     **
+     ** Description      This function enable 3D Display and registers the Dislpay with
+     **                  lower layers.
+     **
+     ** Returns          void
+     **
+     *******************************************************************************/
+    BTA_API extern void BTA_3dEnable(tBTA_3D_CBACK *p_cback, char *p_service_name);
+
+    /*******************************************************************************
+     **
+     ** Function         BTA_3dDisable
+     **
+     ** Description      This function is called when the host is about power down.
+     **
+     ** Returns          void
+     **
+     *******************************************************************************/
+    BTA_API extern void BTA_3dDisable(void);
+
+    /*******************************************************************************
+     **
+     ** Function         BTA_3dWriteSyncParams
+     **
+     ** Description      This function writes the Synchronization Train Parameters.
+     **                  Note, for spec-compliance the Interval is coded to 80ms internally.
+     **
+     ** Returns          void
+     **
+     *******************************************************************************/
+    BTA_API extern void BTA_3dWriteSyncTrainParams(UINT32 timeout, UINT8 service_data);
+
+    /*******************************************************************************
+     **
+     ** Function         BTA_3dStartSyncTrain
+     **
+     ** Description      This function start the synchronization train.
+     **
+     ** Returns          void
+     **
+     *******************************************************************************/
+    BTA_API extern void BTA_3dStartSyncTrain(void);
+
+    /*******************************************************************************
+     **
+     ** Function         BTA_3dSetBroadcastData
+     **
+     ** Description      This function sets the data being broadcast.
+     **
+     ** Returns          void
+     **
+     *******************************************************************************/
+    BTA_API extern void BTA_3dSetBroadcastData(tBTA_3D_BCAST_DATA *p_bcast_data);
+
+    /*******************************************************************************
+     **
+     ** Function         BTA_3dEnableBroadcasts
+     **
+     ** Description      This function enables 3D broadcasts.
+     **
+     ** Returns          void
+     **
+     *******************************************************************************/
+    BTA_API extern void BTA_3dEnableBroadcasts(UINT16 timeout, BOOLEAN low_power);
+
+    /*******************************************************************************
+     **
+     ** Function         BTA_3dDisableBroadcasts
+     **
+     ** Description      This function disables 3D broadcasts.
+     **
+     ** Returns          void
+     **
+     *******************************************************************************/
+    BTA_API extern void BTA_3dDisableBroadcasts(void);
+
+    /*******************************************************************************
+     **
+     ** Function         BTA_3dEnableClockCapture
+     **
+     ** Description      This function enabled Triggered Clock Capture.
+     **
+     ** Returns          void
+     **
+     *******************************************************************************/
+    BTA_API extern void BTA_3dEnableClockCapture(UINT8 filter_count);
+
+    /*******************************************************************************
+     **
+     ** Function         BTA_3dDisableClockCapture
+     **
+     ** Description      This function disabled Triggered Clock Capture.
+     **
+     ** Returns          void
+     **
+     *******************************************************************************/
+    BTA_API extern void BTA_3dDisableClockCapture(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -Naur '--exclude=.git' bluedroid-orig/bta/include/bta_api.h bluedroid/bta/include/bta_api.h
--- bluedroid-orig/bta/include/bta_api.h	2015-09-24 16:33:43.524227643 +0800
+++ bluedroid/bta/include/bta_api.h	2015-09-24 16:31:36.000000000 +0800
@@ -78,7 +78,7 @@
 #define BTA_NAP_SERVICE_ID      15          /* PAN Network access point */
 #define BTA_GN_SERVICE_ID       16          /* PAN Group Ad-hoc networks */
 #define BTA_SAP_SERVICE_ID      17          /* SIM Access profile */
-#define BTA_A2DP_SERVICE_ID     18          /* A2DP Sink */
+#define BTA_A2DP_SRC_SERVICE_ID     18      /* A2DP Src */
 #define BTA_AVRCP_SERVICE_ID    19          /* A/V remote control */
 #define BTA_HID_SERVICE_ID      20          /* HID */
 #define BTA_VDP_SERVICE_ID      21          /* Video distribution */
@@ -89,20 +89,22 @@
 #define BTA_MN_SERVICE_ID       26          /* Message Notification Service */
 #define BTA_HDP_SERVICE_ID      27          /* Health Device Profile */
 #define BTA_PCE_SERVICE_ID      28          /* PhoneBook Access Client*/
-#define BTA_HIDD_SERVICE_ID     29          /* HID Device */
+#define BTA_A2DP_SINK_SERVICE_ID 29          /* A2DP Sink */
+#define BTA_HIDD_SERVICE_ID     30          /* HID Device */
+#define BTA_3D_SERVICE_ID       31          /* 3D Sync Profile */
 
 #if BLE_INCLUDED == TRUE && BTA_GATT_INCLUDED == TRUE
 /* BLE profile service ID */
-#define BTA_BLE_SERVICE_ID      30          /* GATT profile */
+#define BTA_BLE_SERVICE_ID      32          /* GATT profile */
 
 // btla-specific ++
-#define BTA_USER_SERVICE_ID     31          /* User requested UUID */
+#define BTA_USER_SERVICE_ID     33          /* User requested UUID */
 
-#define BTA_MAX_SERVICE_ID      32
+#define BTA_MAX_SERVICE_ID      34
 // btla-specific --
 #else
-#define BTA_USER_SERVICE_ID     30          /* User requested UUID */
-#define BTA_MAX_SERVICE_ID      31
+#define BTA_USER_SERVICE_ID     32          /* User requested UUID */
+#define BTA_MAX_SERVICE_ID      33
 #endif
 /* service IDs (BTM_SEC_SERVICE_FIRST_EMPTY + 1) to (BTM_SEC_MAX_SERVICES - 1)
  * are used by BTA JV */
@@ -841,6 +843,9 @@
 /* Vendor Specific Command Callback */
 typedef tBTM_VSC_CMPL_CB        tBTA_VENDOR_CMPL_CBACK;
 
+/* HCI BTLITE Command Callback  */
+typedef tBTM_BTLITE_CMPL_CB        tBTA_BTLITE_CMPL_CBACK;
+
 /* Search callback events */
 #define BTA_DM_INQ_RES_EVT              0       /* Inquiry result for a peer device. */
 #define BTA_DM_INQ_CMPL_EVT             1       /* Inquiry complete. */
@@ -854,6 +859,72 @@
 
 #define BTA_DM_INQ_RES_IGNORE_RSSI      BTM_INQ_RES_IGNORE_RSSI /* 0x7f RSSI value not supplied (ignore it) */
 
+/* UIPC_MSG struct for A2DP_KERNEL_DIRECT*/
+
+typedef struct
+{
+    BT_HDR                  hdr;
+    tBTA_AV_DUAL_STACK_EVT  event;
+    tBTA_AV_SYNC_INFO       sync_info;
+    UINT16                  curr_mtu;                 /* common mtu shared by all active streams */
+    UINT8                   multi_av_supported;       /* Whether multi-av is supported */
+//    tBTA_VENDOR_CMPL_CBACK  *p_cb;                    /* callback for RSP */
+    tBTM_RAW_CMPL           *p_cb;
+
+}tBTA_AV_HOST_SYNC_INFO; /* SYNC_TO_LITE_REQ */
+
+typedef struct
+{
+    BT_HDR                          hdr;
+    tBTA_AV_DUAL_STACK_EVT          event;
+    UINT8                           scb_idx;
+    UINT8                           audio_open_cnt;
+    tBTA_AV_AUDIO_CODEC_SYNC_INFO   p_codec_cfg;
+    UINT8                           start_stop_flag;
+    UINT8                           streaming_type;  /* 0 for SBC; 1 for CLB */
+//    tBTA_VENDOR_CMPL_CBACK          *p_cb;
+    tBTM_BTLITE_CMPL                   *p_cb;
+
+}tBTA_AV_HOST_SCB_REQ;
+typedef struct
+{
+    UINT8  scb_idx;
+    UINT8  audio_open_cnt;
+    UINT16 curr_mtu;
+}tBTA_AV_BTLITE_INFO;
+typedef struct
+{
+    BT_HDR                 hdr;
+    tBTA_AV_DUAL_STACK_EVT event;
+    UINT8                  scb_idx;
+    UINT8                  audio_open_cnt;
+    UINT16                 curr_mtu;
+//    tBTA_VENDOR_CMPL_CBACK *p_cb;
+    tBTM_BTLITE_CMPL          *p_cb;
+
+}tBTA_AV_HOST_STOP_SUSPEND_REQ;
+typedef struct
+{
+
+}tBTA_AV_AVDT_SYNC_REQ;
+typedef union
+{
+    tBTA_AV_HOST_SYNC_INFO        sync;
+    tBTA_AV_HOST_SCB_REQ          start;
+    tBTA_AV_HOST_STOP_SUSPEND_REQ stop;
+}tBTA_AV_BTLITE_REQ;
+
+
+//Can be changed later as below?
+#if 0
+typedef struct
+{
+    BT_HDR                  hdr;
+    tBTA_AV_SYNC_INFO_REQ   sync_info_req;
+    tBTA_VENDOR_CMPL_CBACK  *p_cb;                    /* callback for RSP */
+}tBTA_AV_HOST_SYNC_INFO; /* SYNC_TO_LITE_REQ */
+#endif
+
 /* Structure associated with BTA_DM_INQ_RES_EVT */
 typedef struct
 {
@@ -879,12 +950,29 @@
     UINT8           num_resps;          /* Number of inquiry responses. */
 } tBTA_DM_INQ_CMPL;
 
+/* Device Identification (DI) data structure
+*/
+/* Used to set the DI record */
+typedef tSDP_DI_RECORD          tBTA_DI_RECORD;
+/* Used to get the DI record */
+typedef tSDP_DI_GET_RECORD      tBTA_DI_GET_RECORD;
+/* SDP discovery database */
+typedef tSDP_DISCOVERY_DB       tBTA_DISCOVERY_DB;
+
+#ifndef         BTA_DI_NUM_MAX
+#define         BTA_DI_NUM_MAX       3
+#endif
+
 /* Structure associated with BTA_DM_DI_DISC_CMPL_EVT */
+
 typedef struct
 {
     BD_ADDR             bd_addr;        /* BD address peer device. */
     UINT8               num_record;     /* Number of DI record */
     tBTA_STATUS         result;
+#ifndef PLATFORM_ANDROID
+    tBTA_DI_GET_RECORD  p_device_info; /*Primary DI record*/
+#endif
 } tBTA_DM_DI_DISC_CMPL;
 
 /* Structure associated with BTA_DM_DISC_RES_EVT */
@@ -1020,19 +1108,6 @@
 typedef UINT8 tBTA_DM_ROUTE_PATH;
 
 
-/* Device Identification (DI) data structure
-*/
-/* Used to set the DI record */
-typedef tSDP_DI_RECORD          tBTA_DI_RECORD;
-/* Used to get the DI record */
-typedef tSDP_DI_GET_RECORD      tBTA_DI_GET_RECORD;
-/* SDP discovery database */
-typedef tSDP_DISCOVERY_DB       tBTA_DISCOVERY_DB;
-
-#ifndef         BTA_DI_NUM_MAX
-#define         BTA_DI_NUM_MAX       3
-#endif
-
 /* Device features mask definitions */
 #define BTA_FEATURE_BYTES_PER_PAGE  BTM_FEATURE_BYTES_PER_PAGE
 #define BTA_EXT_FEATURES_PAGE_MAX   BTM_EXT_FEATURES_PAGE_MAX
@@ -2091,8 +2166,41 @@
 *******************************************************************************/
 BTA_API extern void BTA_DmBleBroadcast (BOOLEAN start);
 
+#ifdef A2DP_KERNEL_DIRECT
+/*******************************************************************************
+**
+** Function         BTA_DMSendBTLiteReq
+**
+** Description      This function send command to BTLITE stack.
+**
+** Parameters      CMD type,void pointer to BLITE stack structs and callback
+**
+** Returns          None
+**
+*******************************************************************************/
+//BTA_API extern void BTA_DMSendBTLiteReq (UINT8 cmd_type,void *p_info,tBTA_VENDOR_CMPL_CBACK *p_cback);
+BTA_API extern void BTA_DMSendBTLiteReq (UINT8 cmd_type,void *p_info,tBTA_BTLITE_CMPL_CBACK*p_cback);
+
+#endif //A2DP_KERNEL_DIRECT
+
 #endif
 
+//XXX ifdef?
+/*******************************************************************************
+**
+** Function         BTA_Set3DEIREnabled
+**
+** Description      Enables/disables the 3D Sync data in the EIR.
+**
+** Parameters       Boolean indicating whether to enable 3D.
+**                  Integer indicating the Tx Power to include in the EIR
+**                  if it is not coded into the cfg.
+**
+** Returns          void
+**
+*******************************************************************************/
+BTA_API extern void BTA_Set3DEIREnabled (BOOLEAN enable, INT8 tx_power);
+
 #ifdef __cplusplus
 }
 #endif
diff -Naur '--exclude=.git' bluedroid-orig/bta/include/bta_ar_api.h bluedroid/bta/include/bta_ar_api.h
--- bluedroid-orig/bta/include/bta_ar_api.h	2015-09-24 16:33:43.524227643 +0800
+++ bluedroid/bta/include/bta_ar_api.h	2015-09-24 16:31:36.000000000 +0800
@@ -119,7 +119,7 @@
 **
 ******************************************************************************/
 extern void bta_ar_reg_avrc(UINT16 service_uuid, char *p_service_name,
-							 char *p_provider_name, UINT16 categories, tBTA_SYS_ID sys_id);
+        char *p_provider_name, UINT16 categories, tBTA_SYS_ID sys_id, BOOLEAN browse_supported);
 
 /******************************************************************************
 **
diff -Naur '--exclude=.git' bluedroid-orig/bta/include/bta_av_api.h bluedroid/bta/include/bta_av_api.h
--- bluedroid-orig/bta/include/bta_av_api.h	2015-09-24 16:33:43.524227643 +0800
+++ bluedroid/bta/include/bta_av_api.h	2015-09-24 16:31:36.000000000 +0800
@@ -288,6 +288,15 @@
     BOOLEAN         starting;
     tBTA_AV_EDR     edr;        /* 0, if peer device does not support EDR */
     UINT8           sep;        /*  sep type of peer device */
+#if (A2DP_KERNEL_DIRECT == TRUE)
+    UINT8           avdt_handle; /* AVDTP handle*/
+    UINT8           hdi;         /* the index to SCB[] */
+    UINT16          l2c_cid;     /* l2cap cid */
+    UINT8           l2c_bufs;    /* the number of buffers queued to L2CAP */
+    BOOLEAN         cong;        /* True if AVDTP congested */
+    UINT8           codec_type;  /* Codec Type*/
+    UINT16          curr_mtu;      /* Stream MTU*/
+#endif //A2DP_KERNEL_DIRECT
 } tBTA_AV_OPEN;
 
 /* data associated with BTA_AV_CLOSE_EVT */
@@ -305,6 +314,9 @@
     tBTA_AV_STATUS  status;
     BOOLEAN         initiator; /* TRUE, if local device initiates the START */
     BOOLEAN         suspending;
+#if (A2DP_KERNEL_DIRECT == TRUE)
+    UINT8           audio_open_cnt;
+#endif
 } tBTA_AV_START;
 
 /* data associated with BTA_AV_SUSPEND_EVT */
@@ -364,6 +376,7 @@
 {
     UINT8           rc_handle;
     tBTA_AV_FEAT    peer_features;
+    BD_ADDR         peer_addr;
 } tBTA_AV_RC_FEAT;
 
 /* data associated with BTA_AV_REMOTE_CMD_EVT */
@@ -572,7 +585,7 @@
 **
 *******************************************************************************/
 BTA_API void BTA_AvRegister(tBTA_AV_CHNL chnl, const char *p_service_name,
-                            UINT8 app_id, tBTA_AV_DATA_CBACK  *p_data_cback);
+                            UINT8 app_id, tBTA_AV_DATA_CBACK  *p_data_cback, UINT16 service_uuid);
 
 /*******************************************************************************
 **
@@ -597,7 +610,7 @@
 **
 *******************************************************************************/
 BTA_API void BTA_AvOpen(BD_ADDR bd_addr, tBTA_AV_HNDL handle,
-                        BOOLEAN use_rc, tBTA_SEC sec_mask);
+                        BOOLEAN use_rc, tBTA_SEC sec_mask, UINT16 uuid);
 
 /*******************************************************************************
 **
@@ -623,6 +636,17 @@
 
 /*******************************************************************************
 **
+** Function         BTA_AvEnable_Sink
+**
+** Description      Enable/Disable A2DP Sink.
+**
+** Returns          void
+**
+*******************************************************************************/
+void BTA_AvEnable_Sink(int enable);
+
+/*******************************************************************************
+**
 ** Function         BTA_AvStart
 **
 ** Description      Start audio/video stream data transfer.
diff -Naur '--exclude=.git' bluedroid-orig/bta/include/bta_av_co.h bluedroid/bta/include/bta_av_co.h
--- bluedroid-orig/bta/include/bta_av_co.h	2015-09-24 16:33:43.524227643 +0800
+++ bluedroid/bta/include/bta_av_co.h	2015-09-24 16:31:36.000000000 +0800
@@ -100,7 +100,7 @@
 **
 *******************************************************************************/
 BTA_API extern void bta_av_co_audio_disc_res(tBTA_AV_HNDL hndl, UINT8 num_seps,
-                                             UINT8 num_snk, BD_ADDR addr);
+                    UINT8 num_snk, UINT8 num_src, BD_ADDR addr, UINT16 uuid_local);
 
 /*******************************************************************************
 **
diff -Naur '--exclude=.git' bluedroid-orig/bta/include/bta_av_sbc.h bluedroid/bta/include/bta_av_sbc.h
--- bluedroid-orig/bta/include/bta_av_sbc.h	2015-09-24 16:33:43.524227643 +0800
+++ bluedroid/bta/include/bta_av_sbc.h	2015-09-24 16:31:36.000000000 +0800
@@ -194,6 +194,18 @@
 
 /*******************************************************************************
 **
+** Function         bta_av_sbc_cfg_matches_cap
+**
+** Description      This function checks whether an SBC codec configuration
+**                  matched with capabilities. Here we check subset.
+**
+** Returns          0 if ok, nonzero if error.
+**
+*******************************************************************************/
+extern UINT8 bta_av_sbc_cfg_matches_cap(UINT8 *p_cfg, tA2D_SBC_CIE *p_cap);
+
+/*******************************************************************************
+**
 ** Function         bta_av_sbc_bld_hdr
 **
 ** Description      This function builds the packet header for MPF1.
diff -Naur '--exclude=.git' bluedroid-orig/bta/sys/bta_sys.h bluedroid/bta/sys/bta_sys.h
--- bluedroid-orig/bta/sys/bta_sys.h	2015-09-24 16:33:43.524227643 +0800
+++ bluedroid/bta/sys/bta_sys.h	2015-09-24 16:31:36.000000000 +0800
@@ -93,7 +93,8 @@
 #define BTA_ID_HL           30           /* Health Device Profile*/
 #define BTA_ID_GATTC        31           /* GATT Client */
 #define BTA_ID_GATTS        32           /* GATT Client */
-#define BTA_ID_BLUETOOTH_MAX   33        /* last BT profile */
+#define BTA_ID_3D           33           /* 3D Synchronization */
+#define BTA_ID_BLUETOOTH_MAX   34        /* last BT profile */
 
 /* FM */
 #define BTA_ID_FM           34           /* FM  */
diff -Naur '--exclude=.git' bluedroid-orig/btif/co/bta_av_co.c bluedroid/btif/co/bta_av_co.c
--- bluedroid-orig/btif/co/bta_av_co.c	2015-09-24 16:33:43.524227643 +0800
+++ bluedroid/btif/co/bta_av_co.c	2015-09-24 16:31:37.000000000 +0800
@@ -36,6 +36,8 @@
 #include "btif_media.h"
 #include "sbc_encoder.h"
 #include "btif_av_co.h"
+#include "btif_util.h"
+#include "bt_utils.h"
 
 
 /*****************************************************************************
@@ -125,17 +127,23 @@
 {
     BD_ADDR         addr;               /* address of audio/video peer */
     tBTA_AV_CO_SINK snks[BTIF_SV_AV_AA_SEP_INDEX]; /* array of supported sinks */
+    tBTA_AV_CO_SINK srcs[BTIF_SV_AV_AA_SEP_INDEX]; /* array of supported srcs */
     UINT8           num_snks;           /* total number of sinks at peer */
+    UINT8           num_srcs;           /* total number of srcs at peer */
     UINT8           num_seps;           /* total number of seids at peer */
     UINT8           num_rx_snks;        /* number of received sinks */
+    UINT8           num_rx_srcs;        /* number of received srcs */
     UINT8           num_sup_snks;       /* number of supported sinks in the snks array */
+    UINT8           num_sup_srcs;       /* number of supported srcs in the srcs array */
     tBTA_AV_CO_SINK *p_snk;             /* currently selected sink */
+    tBTA_AV_CO_SINK *p_src;             /* currently selected src */
     UINT8           codec_cfg[AVDT_CODEC_SIZE]; /* current codec configuration */
     BOOLEAN         cp_active;          /* current CP configuration */
     BOOLEAN         acp;                /* acceptor */
     BOOLEAN         recfg_needed;       /* reconfiguration is needed */
     BOOLEAN         opened;             /* opened */
     UINT16          mtu;                /* maximum transmit unit size */
+    UINT16          uuid_to_connect;    /* uuid of peer device */
 } tBTA_AV_CO_PEER;
 
 typedef struct
@@ -165,7 +173,7 @@
 static BOOLEAN bta_av_co_audio_peer_supports_codec(tBTA_AV_CO_PEER *p_peer, UINT8 *p_snk_index);
 static BOOLEAN bta_av_co_audio_media_supports_config(UINT8 codec_type, const UINT8 *p_codec_cfg);
 static BOOLEAN bta_av_co_audio_sink_supports_config(UINT8 codec_type, const UINT8 *p_codec_cfg);
-
+static BOOLEAN bta_av_co_audio_peer_src_supports_codec(tBTA_AV_CO_PEER *p_peer, UINT8 *p_src_index);
 
 
 
@@ -275,6 +283,16 @@
 
     APPL_TRACE_DEBUG1("bta_av_co_audio_init: %d", index);
 
+    /* By default - no content protection info */
+    *p_num_protect = 0;
+    *p_protect_info = 0;
+
+    /* reset remote preference through setconfig */
+    bta_av_co_cb.codec_cfg_setconfig.id = BTIF_AV_CODEC_NONE;
+
+    switch (index)
+    {
+    case BTIF_SV_AV_AA_SBC_INDEX:
 #if defined(BTA_AV_CO_CP_SCMS_T) && (BTA_AV_CO_CP_SCMS_T == TRUE)
     {
         UINT8 *p = p_protect_info;
@@ -285,18 +303,7 @@
         UINT16_TO_STREAM(p, BTA_AV_CP_SCMS_T_ID);
 
     }
-#else
-    /* By default - no content protection info */
-    *p_num_protect = 0;
-    *p_protect_info = 0;
 #endif
-
-    /* reset remote preference through setconfig */
-    bta_av_co_cb.codec_cfg_setconfig.id = BTIF_AV_CODEC_NONE;
-
-    switch (index)
-    {
-    case BTIF_SV_AV_AA_SBC_INDEX:
         /* Set up for SBC codec  for SRC*/
         *p_codec_type = BTA_AV_CODEC_SBC;
 
@@ -305,7 +312,7 @@
 
         /* Codec is valid */
         return TRUE;
-#ifdef BTA_AVK_INCLUDED
+#if (BTA_AV_SINK_INCLUDED == TRUE)
     case BTIF_SV_AV_AA_SBC_SINK_INDEX:
         *p_codec_type = BTA_AV_CODEC_SBC;
 
@@ -334,14 +341,14 @@
  **
  *******************************************************************************/
 BTA_API void bta_av_co_audio_disc_res(tBTA_AV_HNDL hndl, UINT8 num_seps, UINT8 num_snk,
-        BD_ADDR addr)
+        UINT8 num_src, BD_ADDR addr, UINT16 uuid_local)
 {
     tBTA_AV_CO_PEER *p_peer;
 
     FUNC_TRACE();
 
-    APPL_TRACE_DEBUG3("bta_av_co_audio_disc_res h:x%x num_seps:%d num_snk:%d",
-            hndl, num_seps, num_snk);
+    APPL_TRACE_DEBUG4("bta_av_co_audio_disc_res h:x%x num_seps:%d num_snk:%d num_src:%d",
+            hndl, num_seps, num_snk, num_src);
 
     /* Find the peer info */
     p_peer = bta_av_co_get_peer(hndl);
@@ -360,13 +367,209 @@
     /* Copy the discovery results */
     bdcpy(p_peer->addr, addr);
     p_peer->num_snks = num_snk;
+    p_peer->num_srcs = num_src;
     p_peer->num_seps = num_seps;
     p_peer->num_rx_snks = 0;
+    p_peer->num_rx_srcs = 0;
     p_peer->num_sup_snks = 0;
+    if (uuid_local == UUID_SERVCLASS_AUDIO_SINK)
+        p_peer->uuid_to_connect = UUID_SERVCLASS_AUDIO_SOURCE;
+    else if (uuid_local == UUID_SERVCLASS_AUDIO_SOURCE)
+        p_peer->uuid_to_connect = UUID_SERVCLASS_AUDIO_SINK;
 }
 
 /*******************************************************************************
  **
+ ** Function         bta_av_build_src_cfg
+ **
+ ** Description      This function will build preferred config from src capabilities
+ **
+ **
+ ** Returns          Pass or Fail for current getconfig.
+ **
+ *******************************************************************************/
+void bta_av_build_src_cfg (UINT8 *p_pref_cfg, UINT8 *p_src_cap)
+{
+    tA2D_SBC_CIE    src_cap;
+    tA2D_SBC_CIE    pref_cap;
+    UINT8           status = 0;
+
+    /* initialize it to default SBC configuration */
+    A2D_BldSbcInfo(AVDT_MEDIA_AUDIO, (tA2D_SBC_CIE *) &btif_av_sbc_default_config, p_pref_cfg);
+    /* now try to build a preferred one */
+    /* parse configuration */
+    if ((status = A2D_ParsSbcInfo(&src_cap, p_src_cap, TRUE)) != 0)
+    {
+         APPL_TRACE_DEBUG1(" Cant parse src cap ret = %d", status);
+         return ;
+    }
+
+    if (src_cap.samp_freq & A2D_SBC_IE_SAMP_FREQ_48)
+        pref_cap.samp_freq = A2D_SBC_IE_SAMP_FREQ_48;
+    else if (src_cap.samp_freq & A2D_SBC_IE_SAMP_FREQ_44)
+        pref_cap.samp_freq = A2D_SBC_IE_SAMP_FREQ_44;
+
+    if (src_cap.ch_mode & A2D_SBC_IE_CH_MD_JOINT)
+        pref_cap.ch_mode = A2D_SBC_IE_CH_MD_JOINT;
+    else if (src_cap.ch_mode & A2D_SBC_IE_CH_MD_STEREO)
+        pref_cap.ch_mode = A2D_SBC_IE_CH_MD_STEREO;
+    else if (src_cap.ch_mode & A2D_SBC_IE_CH_MD_DUAL)
+        pref_cap.ch_mode = A2D_SBC_IE_CH_MD_DUAL;
+    else if (src_cap.ch_mode & A2D_SBC_IE_CH_MD_MONO)
+        pref_cap.ch_mode = A2D_SBC_IE_CH_MD_MONO;
+
+    if (src_cap.block_len & A2D_SBC_IE_BLOCKS_16)
+        pref_cap.block_len = A2D_SBC_IE_BLOCKS_16;
+    else if (src_cap.block_len & A2D_SBC_IE_BLOCKS_12)
+        pref_cap.block_len = A2D_SBC_IE_BLOCKS_12;
+    else if (src_cap.block_len & A2D_SBC_IE_BLOCKS_8)
+        pref_cap.block_len = A2D_SBC_IE_BLOCKS_8;
+    else if (src_cap.block_len & A2D_SBC_IE_BLOCKS_4)
+        pref_cap.block_len = A2D_SBC_IE_BLOCKS_4;
+
+    if (src_cap.num_subbands & A2D_SBC_IE_SUBBAND_8)
+        pref_cap.num_subbands = A2D_SBC_IE_SUBBAND_8;
+    else if(src_cap.num_subbands & A2D_SBC_IE_SUBBAND_4)
+        pref_cap.num_subbands = A2D_SBC_IE_SUBBAND_4;
+
+    if (src_cap.alloc_mthd & A2D_SBC_IE_ALLOC_MD_L)
+        pref_cap.alloc_mthd = A2D_SBC_IE_ALLOC_MD_L;
+    else if(src_cap.alloc_mthd & A2D_SBC_IE_ALLOC_MD_S)
+        pref_cap.alloc_mthd = A2D_SBC_IE_ALLOC_MD_S;
+
+    pref_cap.max_bitpool = src_cap.max_bitpool;
+    pref_cap.min_bitpool = src_cap.min_bitpool;
+
+    A2D_BldSbcInfo(AVDT_MEDIA_AUDIO, (tA2D_SBC_CIE *) &pref_cap, p_pref_cfg);
+}
+
+/*******************************************************************************
+ **
+ ** Function         bta_av_audio_sink_getconfig
+ **
+ ** Description      This callout function is executed by AV to retrieve the
+ **                  desired codec and content protection configuration for the
+ **                  A2DP Sink audio stream in Initiator.
+ **
+ **
+ ** Returns          Pass or Fail for current getconfig.
+ **
+ *******************************************************************************/
+UINT8 bta_av_audio_sink_getconfig(tBTA_AV_HNDL hndl, tBTA_AV_CODEC codec_type,
+        UINT8 *p_codec_info, UINT8 *p_sep_info_idx, UINT8 seid, UINT8 *p_num_protect,
+        UINT8 *p_protect_info)
+{
+
+    UINT8 result = A2D_FAIL;
+    BOOLEAN supported;
+    tBTA_AV_CO_PEER *p_peer;
+    tBTA_AV_CO_SINK *p_src;
+    UINT8 codec_cfg[AVDT_CODEC_SIZE];
+    UINT8 pref_cfg[AVDT_CODEC_SIZE];
+    UINT8 index;
+
+    FUNC_TRACE();
+
+    APPL_TRACE_DEBUG3("bta_av_audio_sink_getconfig handle:0x%x codec_type:%d seid:%d",
+                                                               hndl, codec_type, seid);
+    APPL_TRACE_DEBUG4("num_protect:0x%02x protect_info:0x%02x%02x%02x",
+        *p_num_protect, p_protect_info[0], p_protect_info[1], p_protect_info[2]);
+
+    /* Retrieve the peer info */
+    p_peer = bta_av_co_get_peer(hndl);
+    if (p_peer == NULL)
+    {
+        APPL_TRACE_ERROR0("bta_av_audio_sink_getconfig could not find peer entry");
+        return A2D_FAIL;
+    }
+
+    APPL_TRACE_DEBUG4("bta_av_audio_sink_getconfig peer(o=%d,n_snks=%d,n_rx_snks=%d,n_sup_snks=%d)",
+            p_peer->opened, p_peer->num_srcs, p_peer->num_rx_srcs, p_peer->num_sup_srcs);
+
+    p_peer->num_rx_srcs++;
+
+    /* Check if this is a supported configuration */
+    supported = FALSE;
+    switch (codec_type)
+    {
+        case BTA_AV_CODEC_SBC:
+            supported = TRUE;
+            break;
+
+        default:
+            break;
+    }
+
+    if (supported)
+    {
+        /* If there is room for a new one */
+        if (p_peer->num_sup_srcs < BTA_AV_CO_NUM_ELEMENTS(p_peer->srcs))
+        {
+            p_src = &p_peer->srcs[p_peer->num_sup_srcs++];
+
+            APPL_TRACE_DEBUG6("bta_av_audio_sink_getconfig saved caps[%x:%x:%x:%x:%x:%x]",
+                    p_codec_info[1], p_codec_info[2], p_codec_info[3],
+                    p_codec_info[4], p_codec_info[5], p_codec_info[6]);
+
+            memcpy(p_src->codec_caps, p_codec_info, AVDT_CODEC_SIZE);
+            p_src->codec_type = codec_type;
+            p_src->sep_info_idx = *p_sep_info_idx;
+            p_src->seid = seid;
+            p_src->num_protect = *p_num_protect;
+            memcpy(p_src->protect_info, p_protect_info, BTA_AV_CP_INFO_LEN);
+        }
+        else
+        {
+            APPL_TRACE_ERROR0("bta_av_audio_sink_getconfig no more room for SRC info");
+        }
+    }
+
+    /* If last SNK get capabilities or all supported codec caps retrieved */
+    if ((p_peer->num_rx_srcs == p_peer->num_srcs) ||
+        (p_peer->num_sup_srcs == BTA_AV_CO_NUM_ELEMENTS(p_peer->srcs)))
+    {
+        APPL_TRACE_DEBUG0("bta_av_audio_sink_getconfig last SRC reached");
+
+        /* Protect access to bta_av_co_cb.codec_cfg */
+        GKI_disable();
+
+        /* Find a src that matches the codec config */
+        if (bta_av_co_audio_peer_src_supports_codec(p_peer, &index))
+        {
+            APPL_TRACE_DEBUG0(" Codec Supported ");
+            p_src = &p_peer->srcs[index];
+
+            /* Build the codec configuration for this sink */
+            {
+                /* Save the new configuration */
+                p_peer->p_src = p_src;
+                /* get preferred config from src_caps */
+                bta_av_build_src_cfg(pref_cfg, p_src->codec_caps);
+                memcpy(p_peer->codec_cfg, pref_cfg, AVDT_CODEC_SIZE);
+
+                APPL_TRACE_DEBUG6("bta_av_audio_sink_getconfig  p_codec_info[%x:%x:%x:%x:%x:%x]",
+                        p_peer->codec_cfg[1], p_peer->codec_cfg[2], p_peer->codec_cfg[3],
+                        p_peer->codec_cfg[4], p_peer->codec_cfg[5], p_peer->codec_cfg[6]);
+                /* By default, no content protection */
+                *p_num_protect = 0;
+
+#if defined(BTA_AV_CO_CP_SCMS_T) && (BTA_AV_CO_CP_SCMS_T == TRUE)
+                    p_peer->cp_active = FALSE;
+                    bta_av_co_cb.cp.active = FALSE;
+#endif
+
+                    *p_sep_info_idx = p_src->sep_info_idx;
+                    memcpy(p_codec_info, p_peer->codec_cfg, AVDT_CODEC_SIZE);
+                result =  A2D_SUCCESS;
+            }
+        }
+        /* Protect access to bta_av_co_cb.codec_cfg */
+        GKI_enable();
+    }
+    return result;
+}
+/*******************************************************************************
+ **
  ** Function         bta_av_co_audio_getconfig
  **
  ** Description      This callout function is executed by AV to retrieve the
@@ -391,10 +594,6 @@
 
     FUNC_TRACE();
 
-    APPL_TRACE_DEBUG3("bta_av_co_audio_getconfig handle:0x%x codec_type:%d seid:%d", hndl, codec_type, seid);
-    APPL_TRACE_DEBUG4("num_protect:0x%02x protect_info:0x%02x%02x%02x",
-        *p_num_protect, p_protect_info[0], p_protect_info[1], p_protect_info[2]);
-
     /* Retrieve the peer info */
     p_peer = bta_av_co_get_peer(hndl);
     if (p_peer == NULL)
@@ -403,6 +602,17 @@
         return A2D_FAIL;
     }
 
+    if (p_peer->uuid_to_connect == UUID_SERVCLASS_AUDIO_SOURCE)
+    {
+        result = bta_av_audio_sink_getconfig(hndl, codec_type, p_codec_info, p_sep_info_idx,
+                                             seid, p_num_protect, p_protect_info);
+        return result;
+    }
+    APPL_TRACE_DEBUG3("bta_av_co_audio_getconfig handle:0x%x codec_type:%d seid:%d",
+                                                              hndl, codec_type, seid);
+    APPL_TRACE_DEBUG4("num_protect:0x%02x protect_info:0x%02x%02x%02x",
+        *p_num_protect, p_protect_info[0], p_protect_info[1], p_protect_info[2]);
+
     APPL_TRACE_DEBUG4("bta_av_co_audio_getconfig peer(o=%d,n_snks=%d,n_rx_snks=%d,n_sup_snks=%d)",
             p_peer->opened, p_peer->num_snks, p_peer->num_rx_snks, p_peer->num_sup_snks);
 
@@ -539,7 +749,8 @@
     UINT8 category = A2D_SUCCESS;
     BOOLEAN recfg_needed = FALSE;
     BOOLEAN codec_cfg_supported = FALSE;
-
+    UNUSED(seid);
+    UNUSED(addr);
 
     FUNC_TRACE();
 
@@ -689,6 +900,7 @@
         UINT16 mtu)
 {
     tBTA_AV_CO_PEER *p_peer;
+    UNUSED(p_codec_info);
 
     FUNC_TRACE();
 
@@ -722,6 +934,8 @@
 
 {
     tBTA_AV_CO_PEER *p_peer;
+    UNUSED(codec_type);
+    UNUSED(mtu);
 
     FUNC_TRACE();
 
@@ -757,6 +971,11 @@
 BTA_API void bta_av_co_audio_start(tBTA_AV_HNDL hndl, tBTA_AV_CODEC codec_type,
         UINT8 *p_codec_info, BOOLEAN *p_no_rtp_hdr)
 {
+    UNUSED(hndl);
+    UNUSED(codec_type);
+    UNUSED(p_codec_info);
+    UNUSED(p_no_rtp_hdr);
+
     FUNC_TRACE();
 
     APPL_TRACE_DEBUG0("bta_av_co_audio_start");
@@ -776,6 +995,9 @@
  *******************************************************************************/
 BTA_API extern void bta_av_co_audio_stop(tBTA_AV_HNDL hndl, tBTA_AV_CODEC codec_type)
 {
+    UNUSED(hndl);
+    UNUSED(codec_type);
+
     FUNC_TRACE();
 
     APPL_TRACE_DEBUG0("bta_av_co_audio_stop");
@@ -795,6 +1017,8 @@
         UINT32 *p_timestamp)
 {
     BT_HDR *p_buf;
+    UNUSED(p_len);
+
     FUNC_TRACE();
 
     p_buf = btif_media_aa_readbuf();
@@ -1115,6 +1339,51 @@
                 return FALSE;
                 break;
             }
+        }
+    }
+    return FALSE;
+}
+
+/*******************************************************************************
+ **
+ ** Function         bta_av_co_audio_peer_src_supports_codec
+ **
+ ** Description      Check if a peer acting as src supports codec config
+ **
+ ** Returns          TRUE if the connection supports this codec, FALSE otherwise
+ **
+ *******************************************************************************/
+static BOOLEAN bta_av_co_audio_peer_src_supports_codec(tBTA_AV_CO_PEER *p_peer, UINT8 *p_src_index)
+{
+    int index;
+    UINT8 codec_type;
+    FUNC_TRACE();
+
+    /* Configure the codec type to look for */
+    codec_type = bta_av_co_cb.codec_cfg.id;
+
+
+    for (index = 0; index < p_peer->num_sup_srcs; index++)
+    {
+        if (p_peer->srcs[index].codec_type == codec_type)
+        {
+            switch (bta_av_co_cb.codec_cfg.id)
+            {
+            case BTIF_AV_CODEC_SBC:
+                if (p_src_index) *p_src_index = index;
+                if (0 ==  bta_av_sbc_cfg_matches_cap((UINT8 *)p_peer->srcs[index].codec_caps,
+                                                     (tA2D_SBC_CIE *)&bta_av_co_sbc_sink_caps))
+                {
+                    return TRUE;
+                }
+                break;
+
+            default:
+                APPL_TRACE_ERROR1("peer_src_supports_codec: unsupported codec id %d",
+                                                            bta_av_co_cb.codec_cfg.id);
+                return FALSE;
+                break;
+            }
         }
     }
     return FALSE;
diff -Naur '--exclude=.git' bluedroid-orig/btif/co/bta_hh_co.c bluedroid/btif/co/bta_hh_co.c
--- bluedroid-orig/btif/co/bta_hh_co.c	2015-09-24 16:33:43.528227643 +0800
+++ bluedroid/btif/co/bta_hh_co.c	2015-09-24 16:31:37.000000000 +0800
@@ -159,13 +159,20 @@
 {
 
     btif_hh_device_t *p_dev = arg;
-    APPL_TRACE_DEBUG2("%s: Thread created fd = %d", __FUNCTION__, p_dev->fd);
     struct pollfd pfds[1];
     int ret;
+
+    if (p_dev == NULL) {
+        APPL_TRACE_ERROR1("%s: P_DEV is NULL\n", __FUNCTION__);
+        return 0;
+    }
+
+    APPL_TRACE_DEBUG2("%s: Thread created fd = %d", __FUNCTION__, p_dev->fd);
+
     pfds[0].fd = p_dev->fd;
     pfds[0].events = POLLIN;
 
-    while(p_dev->hh_keep_polling){
+    while(p_dev && p_dev->hh_keep_polling){
         ret = poll(pfds, 1, 50);
         if (ret < 0) {
             APPL_TRACE_ERROR2("%s: Cannot poll for fds: %s\n", __FUNCTION__, strerror(errno));
diff -Naur '--exclude=.git' bluedroid-orig/btif/include/btif_3d.h bluedroid/btif/include/btif_3d.h
--- bluedroid-orig/btif/include/btif_3d.h	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/btif/include/btif_3d.h	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,12 @@
+#ifndef BTIF_3D_H
+#define BTIF_3D_H
+
+#include <hardware/bluetooth.h>
+#include <hardware/bt_3d.h>
+#include <stdint.h>
+#include "bta_3d_api.h"
+#include "btu.h"
+
+#define BTIF_3D_SERVICE_NAME "3D Synchronization Display" 
+
+#endif
diff -Naur '--exclude=.git' bluedroid-orig/btif/include/btif_api.h bluedroid/btif/include/btif_api.h
--- bluedroid-orig/btif/include/btif_api.h	2015-09-24 16:33:43.528227643 +0800
+++ bluedroid/btif/include/btif_api.h	2015-09-24 16:31:37.000000000 +0800
@@ -33,6 +33,7 @@
 #include "btif_common.h"
 #include "btif_dm.h"
 
+
 /*******************************************************************************
 **  BTIF CORE API
 ********************************************************************************/
@@ -445,4 +446,126 @@
 *******************************************************************************/
 bt_status_t btif_dm_cancel_hid_bond(const bt_bdaddr_t *bd_addr);
 
+/*******************************************************************************
+**
+** Function         btif_read_version
+**
+** Description      Returns the BT chip firmware versoin
+**
+** Returns          BT_STATUS_SUCCESS on success
+**
+*******************************************************************************/
+bt_status_t btif_read_version(btif_fw_version_t *version);
+
+/*******************************************************************************
+**
+** Function         btif_read_version_internal
+**
+** Description      Sends a HCI VSC to the controller to read the FW version
+**
+** Returns          Version of current firmware on the controller
+**
+*******************************************************************************/
+
+bt_status_t btif_read_version_internal(void);
+
+/*******************************************************************************
+**
+** Function         btif_hw_chip_firmware_update
+**
+** Description      Upgrades the BT Chip firmware
+**
+** Returns          BT_STATUS_SUCCESS on success
+**
+*******************************************************************************/
+bt_status_t btif_hw_chip_firmware_update(void);
+bt_status_t btif_hw_chip_firmware_update_callback(void);
+
+/*******************************************************************************
+** Function         btif_enter_headless_mode
+**
+** Description     Sends a HCI Vendor specific command to the controller
+**
+** Returns          BT_STATUS_SUCCESS on success
+**
+*******************************************************************************/
+bt_status_t btif_enter_headless_mode(void);
+
+/*******************************************************************************
+**
+** Function         btif_add_headless_mode_wakeup_device
+**
+** Description     Sends a HCI Vendor specific command to the controller
+**
+** Returns          BT_STATUS_SUCCESS on success
+**
+*******************************************************************************/
+bt_status_t btif_add_headless_mode_wakeup_device(bt_bdaddr_t *remote_addr);
+
+/*******************************************************************************
+**
+** Function         btif_add_av_dev_to_headless_mode
+**
+** Description     Sends a HCI Vendor specific command to the controller
+**
+** Returns          BT_STATUS_SUCCESS on success
+**
+*******************************************************************************/
+bt_status_t btif_add_av_dev_to_headless_mode(bt_bdaddr_t *remote_addr);
+
+/*******************************************************************************
+**
+** Function         btif_delete_headless_mode_wakeup_device
+**
+** Description     Sends a HCI Vendor specific command to the controller
+**
+** Returns          BT_STATUS_SUCCESS on success
+**
+*******************************************************************************/
+bt_status_t btif_delete_headless_mode_wakeup_device(bt_bdaddr_t *remote_addr);
+
+/*******************************************************************************
+**
+** Function         btif_bt_wake_up_test
+**
+** Description     Sends a HCI Vendor specific command to the controller
+**
+** Returns          BT_STATUS_SUCCESS on success
+**
+*******************************************************************************/
+bt_status_t btif_bt_wake_up_test(void);
+
+/*******************************************************************************
+**
+** Function         btif_set_headless_le_adv_data
+**
+** Description     Sends a HCI Vendor specific command to the controller
+**
+** Returns          BT_STATUS_SUCCESS on success
+**
+*******************************************************************************/
+bt_status_t btif_set_headless_le_adv_data(uint8_t *buf, uint8_t len);
+
+/*******************************************************************************
+**
+** Function         btif_set_headless_scan_configure
+**
+** Description     Sends a HCI Vendor specific command to the controller
+**
+** Returns          BT_STATUS_SUCCESS on success
+**
+*******************************************************************************/
+bt_status_t btif_set_headless_scan_configure(uint8_t *buf, uint8_t len);
+
+/*******************************************************************************
+**
+** Function         btif_dm_save_authorize_settings
+**
+** Description     Save Authorize settings for avdtp connection
+**
+** Returns          BT_STATUS_SUCCESS on success
+**
+*******************************************************************************/
+bt_status_t btif_dm_save_authorize_settings(bt_bdaddr_t *bd_addr,uint8_t val);
+
 #endif /* BTIF_API_H */
diff -Naur '--exclude=.git' bluedroid-orig/btif/include/btif_av.h bluedroid/btif/include/btif_av.h
--- bluedroid-orig/btif/include/btif_av.h	2015-09-24 16:33:43.528227643 +0800
+++ bluedroid/btif/include/btif_av.h	2015-09-24 16:31:37.000000000 +0800
@@ -31,6 +31,7 @@
 #include "btif_common.h"
 #include "btif_sm.h"
 #include "bta_av_api.h"
+#include "bt_avk.h"
 
 
 /*******************************************************************************
@@ -44,14 +45,15 @@
     BTIF_AV_START_STREAM_REQ_EVT,
     BTIF_AV_STOP_STREAM_REQ_EVT,
     BTIF_AV_SUSPEND_STREAM_REQ_EVT,
-    BTIF_AV_RECONFIGURE_REQ_EVT,
-    BTIF_AV_REQUEST_AUDIO_FOCUS_EVT,
+    BTIF_AV_SINK_CONFIG_REQ_EVT,
+    BTIF_AV_UPDATE_ENCODER_REQ_EVT,
 } btif_av_sm_event_t;
 
 
 /*******************************************************************************
 **  BTIF AV API
 ********************************************************************************/
+btavk_callbacks_t* btif_av_get_sink_cb(void);
 
 /*******************************************************************************
 **
@@ -124,7 +126,7 @@
 **
 *******************************************************************************/
 
-bt_status_t btif_av_init(void);
+bt_status_t btif_av_init(int service_id);
 
 /*******************************************************************************
 **
@@ -178,4 +180,14 @@
 ********************************************************************************/
 void btif_av_clear_remote_suspend_flag(void);
 
+/******************************************************************************
+**
+** Function         btif_av_get_peer_sep
+**
+** Description      Get peer sep
+**
+** Returns          UINT8
+********************************************************************************/
+UINT8 btif_av_get_peer_sep(void);
+
 #endif /* BTIF_AV_H */
diff -Naur '--exclude=.git' bluedroid-orig/btif/include/btif_media.h bluedroid/btif/include/btif_media.h
--- bluedroid-orig/btif/include/btif_media.h	2015-09-24 16:33:43.528227643 +0800
+++ bluedroid/btif/include/btif_media.h	2015-09-24 16:31:37.000000000 +0800
@@ -96,14 +96,15 @@
         BT_HDR hdr;
         UINT8 codec_info[AVDT_CODEC_SIZE];
 } tBTIF_MEDIA_SINK_CFG_UPDATE;
-#endif
 
+#ifdef AVK_BACKPORT
 typedef enum {
     BTIF_MEDIA_AUDIOFOCUS_LOSS = 0,
     BTIF_MEDIA_AUDIOFOCUS_GAIN,
     BTIF_MEDIA_AUDIOFOCUS_LOSS_TRANSIENT
 } btif_media_AudioFocus_state;
-
+#endif
+#endif
 
 /*******************************************************************************
  **  Public functions
@@ -267,10 +268,12 @@
 void btif_a2dp_stop_media_task(void);
 
 void btif_a2dp_on_init(void);
+void btif_a2dp_update_codec(void);
 tBTIF_STATUS btif_a2dp_setup_codec(void);
 void btif_a2dp_on_idle(void);
 void btif_a2dp_on_open(void);
 BOOLEAN btif_a2dp_on_started(tBTA_AV_START *p_av, BOOLEAN pending_start);
+void btif_a2dp_on_sink_ready();
 void btif_a2dp_ack_fail(void);
 void btif_a2dp_on_stop_req(void);
 void btif_a2dp_on_stopped(tBTA_AV_SUSPEND *p_av);
@@ -281,6 +284,12 @@
 void btif_media_check_iop_exceptions(UINT8 *peer_bda);
 void btif_reset_decoder(UINT8 *p_av);
 BOOLEAN btif_media_task_start_decoding_req(void);
+
+int btif_a2dp_get_track_frequency(UINT8 frequency);
+int btif_a2dp_get_track_channel_count(UINT8 channeltype);
+void btif_a2dp_set_peer_sep(UINT8 sep);
+#ifdef AVK_BACKPORT
 void btif_a2dp_set_audio_focus_state(btif_media_AudioFocus_state state);
+#endif
 
 #endif
diff -Naur '--exclude=.git' bluedroid-orig/btif/include/btif_profile_queue.h bluedroid/btif/include/btif_profile_queue.h
--- bluedroid-orig/btif/include/btif_profile_queue.h	2015-09-24 16:33:43.528227643 +0800
+++ bluedroid/btif/include/btif_profile_queue.h	2015-09-24 16:31:37.000000000 +0800
@@ -27,20 +27,17 @@
 #ifndef BTIF_PROFILE_QUEUE_H
 #define BTIF_PROFILE_QUEUE_H
 
-typedef bt_status_t (btif_connect_cb_t) (bt_bdaddr_t *bda);
+typedef bt_status_t (*btif_connect_cb_t) (bt_bdaddr_t *bda, uint16_t uuid);
 
 typedef enum {
   BTIF_QUEUE_CONNECT_EVT,
   BTIF_QUEUE_ADVANCE_EVT,
-  BTIF_QUEUE_PENDING_CONECT_EVT,
-  BTIF_QUEUE_PENDING_CONECT_ADVANCE_EVT,
-  BTIF_QUEUE_CHECK_CONNECT_REQ
+  BTIF_QUEUE_CHECK_CONNECT_REQ,
 } btif_queue_event_t;
 
-bt_status_t btif_queue_connect(uint16_t uuid, const bt_bdaddr_t *bda,
-                        btif_connect_cb_t *connect_cb, uint8_t connect_queue);
+bt_status_t btif_queue_connect(uint16_t uuid, const bt_bdaddr_t *bda, btif_connect_cb_t connect_cb);
+
 void btif_queue_advance();
-void btif_queue_pending_retry();
 void btif_queue_release();
 void btif_queue_remove_connect(uint16_t uuid, uint8_t check_connect_req);
 
diff -Naur '--exclude=.git' bluedroid-orig/btif/include/btif_sock_rfc.h bluedroid/btif/include/btif_sock_rfc.h
--- bluedroid-orig/btif/include/btif_sock_rfc.h	2015-09-24 16:33:43.528227643 +0800
+++ bluedroid/btif/include/btif_sock_rfc.h	2015-09-24 16:31:37.000000000 +0800
@@ -33,10 +33,12 @@
                               int* sock_fd, int flags);
 bt_status_t btsock_rfc_connect(const bt_bdaddr_t *bd_addr, const uint8_t* uuid,
                                int channel, int* sock_fd, int flags);
+#ifdef PLATFORM_ANDROID
 bt_status_t btsock_rfc_get_sockopt(int channel, btsock_option_type_t option_name,
                                             void *option_value, int *option_len);
 bt_status_t btsock_rfc_set_sockopt(int channel, btsock_option_type_t option_name,
                                             void *option_value, int option_len);
+#endif
 void btsock_rfc_signaled(int fd, int flags, uint32_t user_id);
 
 #endif
diff -Naur '--exclude=.git' bluedroid-orig/btif/include/btif_sock_util.h bluedroid/btif/include/btif_sock_util.h
--- bluedroid-orig/btif/include/btif_sock_util.h	2015-09-24 16:33:43.528227643 +0800
+++ bluedroid/btif/include/btif_sock_util.h	2015-09-24 16:31:37.000000000 +0800
@@ -44,14 +44,22 @@
 
 static inline void lock_slot(pthread_mutex_t* mutex)
 {
+#ifndef X86_BUILD
     if(mutex->value)
+#else
+    if(mutex != NULL)
+#endif
         pthread_mutex_lock(mutex);
     else ALOGE("mutex: %p is not initialized", mutex);
 }
 
 static inline void unlock_slot(pthread_mutex_t* mutex)
 {
+#ifndef X86_BUILD
    if(mutex->value)
+#else
+   if(mutex != NULL)
+#endif
         pthread_mutex_unlock(mutex);
    else ALOGE("mutex: %p is not initialized", mutex);
 }
diff -Naur '--exclude=.git' bluedroid-orig/btif/include/btif_storage.h bluedroid/btif/include/btif_storage.h
--- bluedroid-orig/btif/include/btif_storage.h	2015-09-24 16:33:43.528227643 +0800
+++ bluedroid/btif/include/btif_storage.h	2015-09-24 16:31:37.000000000 +0800
@@ -33,6 +33,7 @@
          (p_prop)->type = t;(p_prop)->len = l; (p_prop)->val = (p_v);
 
 #define  BTIF_STORAGE_MAX_ALLOWED_REMOTE_DEVICE 512
+#define BT_PROPERTY_REMOTE_AUTHORIZE_INFO 99
 
 /*******************************************************************************
 **  Functions
diff -Naur '--exclude=.git' bluedroid-orig/btif/include/list.h bluedroid/btif/include/list.h
--- bluedroid-orig/btif/include/list.h	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/btif/include/list.h	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,40 @@
+#pragma once
+
+#include <stdbool.h>
+#include <stdlib.h>
+
+struct list_node_t;
+typedef struct list_node_t list_node_t;
+
+struct list_t;
+typedef struct list_t list_t;
+
+typedef void (*list_free_cb)(void *data);
+typedef bool (*list_iter_cb)(void *data);
+typedef bool (*list_iter_cb_ext)(void *data, void *cb_data);
+
+// Lifecycle.
+list_t *list_new(list_free_cb callback);
+void list_free(list_t *list);
+
+// Accessors.
+bool list_is_empty(const list_t *list);
+size_t list_length(const list_t *list);
+void *list_front(const list_t *list);
+void *list_back(const list_t *list);
+
+// Mutators.
+bool list_insert_after(list_t *list, list_node_t *prev_node, void *data);
+bool list_prepend(list_t *list, void *data);
+bool list_append(list_t *list, void *data);
+bool list_remove(list_t *list, void *data);
+void list_clear(list_t *list);
+
+// Iteration.
+void list_foreach(const list_t *list, list_iter_cb callback);
+void list_foreach_ext(const list_t *list, list_iter_cb_ext callback, void *cb_data);
+
+list_node_t *list_begin(const list_t *list);
+list_node_t *list_end(const list_t *list);
+list_node_t *list_next(const list_node_t *node);
+void *list_node(const list_node_t *node);
diff -Naur '--exclude=.git' bluedroid-orig/btif/src/bluetooth.c bluedroid/btif/src/bluetooth.c
--- bluedroid-orig/btif/src/bluetooth.c	2015-09-24 16:33:43.528227643 +0800
+++ bluedroid/btif/src/bluetooth.c	2015-09-24 16:31:37.000000000 +0800
@@ -42,6 +42,7 @@
 #include <hardware/bt_mce.h>
 #include <hardware/bt_gatt.h>
 #include <hardware/bt_rc.h>
+#include <hardware/bt_3d.h>
 #include <hardware/wipower.h>
 
 #define LOG_NDDEBUG 0
@@ -72,9 +73,16 @@
 #define BT_LE_LPP_RSSI_MONITOR_CMD_CPL_EVT  0x1002
 #define BT_LE_LPP_RSSI_MONITOR_THRESH_EVT   0x1003
 
+#define LOG_FILE "//var//log//bluedroid.log"
+extern FILE* fLog;
+extern int bfileLogging;
+
 /************************************************************************************
 **  Local type definitions
 ************************************************************************************/
+
+#ifdef PLATFORM_ANDROID
+
 typedef struct
 {
     int       entries;
@@ -104,6 +112,8 @@
     } content;
 }bt_le_lpp_rssi_monitor_evt_cb_t;
 
+#endif
+
 /************************************************************************************
 **  Static variables
 ************************************************************************************/
@@ -118,6 +128,7 @@
 **  Externs
 ************************************************************************************/
 BOOLEAN is_multi_hf_supported = FALSE;
+BOOLEAN disable_3dd = FALSE;
 
 /* list all extended interfaces here */
 
@@ -130,7 +141,8 @@
 /* handsfree profile - client */
 extern bthf_client_interface_t *btif_hf_client_get_interface();
 /* advanced audio profile */
-extern btav_interface_t *btif_av_get_interface();
+extern btav_interface_t *btif_av_get_src_interface();
+extern btav_interface_t *btif_av_get_sink_interface();
 /*rfc l2cap*/
 extern btsock_interface_t *btif_sock_get_interface();
 /* hid host profile */
@@ -147,8 +159,11 @@
 extern btgatt_interface_t *btif_gatt_get_interface();
 /* avrc */
 extern btrc_interface_t *btif_rc_get_interface();
+/* 3d */
+extern bt3d_interface_t *btif_3d_get_interface();
 /*wipower*/
 extern wipower_interface_t *get_wipower_interface();
+extern btrc_interface_t *btif_rc_ctrl_get_interface();
 
 #if TEST_APP_INTERFACE == TRUE
 extern const btl2cap_interface_t *btif_l2cap_get_interface(void);
@@ -178,7 +193,21 @@
 
 static int init(bt_callbacks_t* callbacks )
 {
-    ALOGI("init");
+
+    fLog = fopen(LOG_FILE, "r");
+    if(fLog)
+    {
+        fclose(fLog);
+        fLog = fopen(LOG_FILE, "a+");
+        if(fLog)
+        {
+            bfileLogging = 1;
+            setbuf(fLog, NULL);
+        }
+    }
+
+    ALOGI("Qualcomm bluedroid init");
+
 
     /* sanity check */
     if (interface_ready() == TRUE)
@@ -197,6 +226,7 @@
     return BT_STATUS_SUCCESS;
 }
 
+#ifdef PLATFORM_ANDROID
 static int initq(bt_callbacks_t* callbacks)
 {
     ALOGI("initq");
@@ -210,12 +240,10 @@
     bt_hal_cbacks->le_lpp_rssi_threshold_evt_cb  = callbacks->le_lpp_rssi_threshold_evt_cb;
     return BT_STATUS_SUCCESS;
 }
-
+#endif
 
 static int enable( void )
 {
-    ALOGI("enable");
-
     /* sanity check */
     if (interface_ready() == FALSE)
         return BT_STATUS_NOT_READY;
@@ -238,18 +266,22 @@
     if (interface_ready() == FALSE)
         return;
 
-    btif_shutdown_bluetooth();
+    ALOGI("STACK CLEANUP TRIGGERED");
+
+    btif_disable_bluetooth_evt();
 
     /* hal callbacks reset upon shutdown complete callback */
 
+    ALOGI("STACK CLEANUP COMPLETE");
     return;
 }
-
+#ifdef PLATFORM_ANDROID
 static void ssrcleanup(void)
 {
     btif_ssr_cleanup();
     return;
 }
+#endif
 
 static int get_adapter_properties(void)
 {
@@ -400,6 +432,7 @@
     if (interface_ready() == FALSE)
         return NULL;
 
+#ifdef PLATFORM_ANDROID
     /* check for supported profile interfaces */
     if (is_profile(profile_id, BT_PROFILE_HANDSFREE_ID))
     {
@@ -415,7 +448,7 @@
         is_multi_hf_supported = TRUE;
         return btif_multihf_get_interface();
     }
-
+#endif
     if (is_profile(profile_id, BT_PROFILE_SOCKETS_ID))
         return btif_sock_get_interface();
 
@@ -423,11 +456,15 @@
         return btif_pan_get_interface();
 
     if (is_profile(profile_id, BT_PROFILE_ADVANCED_AUDIO_ID))
-        return btif_av_get_interface();
+        return btif_av_get_src_interface();
+
+    if (is_profile(profile_id, BT_PROFILE_ADVANCED_AUDIO_SINK_ID))
+        return btif_av_get_sink_interface();
 
     if (is_profile(profile_id, BT_PROFILE_HIDHOST_ID))
         return btif_hh_get_interface();
 
+#ifdef PLATFORM_ANDROID
     if (is_profile(profile_id, BT_PROFILE_HIDDEV_ID))
         return btif_hd_get_interface();
 
@@ -436,7 +473,7 @@
 
     if (is_profile(profile_id, BT_PROFILE_MAP_CLIENT_ID))
         return btif_mce_get_interface();
-
+#endif
 #if BTA_GATT_INCLUDED == TRUE
     if (is_profile(profile_id, BT_PROFILE_GATT_ID))
         return btif_gatt_get_interface();
@@ -444,10 +481,17 @@
 
     if (is_profile(profile_id, BT_PROFILE_AV_RC_ID))
         return btif_rc_get_interface();
-
+#ifdef PLATFORM_ANDROID
     if (is_profile(profile_id, WIPOWER_PROFILE_ID))
         return get_wipower_interface();
-
+#endif
+    if(disable_3dd != TRUE)
+    {
+      if (is_profile(profile_id, BT_PROFILE_3D_SYNC_ID))
+          return btif_3d_get_interface();
+    }
+    if (is_profile(profile_id, BT_PROFILE_AV_RCC_ID))
+        return btif_rc_ctrl_get_interface();
 
     return NULL;
 }
@@ -496,6 +540,7 @@
     return btif_dut_mode_send(opcode, buf, len);
 }
 
+#ifndef PLATFORM_ANDROID
 #if HCI_RAW_CMD_INCLUDED == TRUE
 int hci_cmd_send(uint16_t opcode, uint8_t* buf, uint8_t len)
 {
@@ -508,6 +553,7 @@
     return btif_hci_cmd_send(opcode, buf, len);
 }
 #endif
+#endif
 
 #if BLE_INCLUDED == TRUE
 int le_test_mode(uint16_t opcode, uint8_t* buf, uint8_t len)
@@ -569,6 +615,7 @@
     return btif_config_hci_snoop_log(enable);
 }
 
+#ifdef PLATFORM_ANDROID
 static void bt_handle_le_extended_scan(uint16_t event, char *p_param)
 {
     ALOGD("%s: Event %d, Parameter %p enter", __FUNCTION__, event, p_param);
@@ -852,7 +899,216 @@
                                  (char*)&btif_cb, sizeof(bt_le_lpp_monitor_rssi_cb_t), NULL);
 }
 
+#endif
+
+#ifndef PLATFORM_ANDROID
+// Dummy funcation for unsupported feature yet
+/* Send  service level Authorization response */
+static int authorize_response(const bt_bdaddr_t *bd_addr, bt_service_id_t service_id,
+                             uint8_t authorize, uint8_t save_settings)
+{
+    //ALOGE("[Qualcomm]%s: Need to implemented!!!", __FUNCTION__);
+    //return BT_STATUS_UNSUPPORTED;
+    ALOGE("%s authorize = %d, save_settings = %d",__func__,
+               authorize,save_settings);
+    btif_dm_save_authorize_settings(bd_addr,(authorize<<1 | save_settings));
+    if (!authorize)
+    {
+        ALOGD("align authorize value to BTA specific value");
+        authorize = BTA_DM_NOT_AUTH;
+    }
+    BTA_DmAuthorizeReply(bd_addr->address,service_id,authorize);
+    return BT_STATUS_SUCCESS;
+}
+
+/* Sets the vid/pid infor for the primary DID record and writes to EIR data */
+static int set_local_did(bt_local_di_record_t *local_di_record)
+{
+	ALOGE("[Qualcomm]%s: Need to implemented!!!", __FUNCTION__);
+	return BT_STATUS_UNSUPPORTED;
+}
+
+/* switch to dual mode stack */
+static int switch_stack_dual_mode(void)
+{
+	ALOGE("[Qualcomm]%s: Need to implemented!!!", __FUNCTION__);
+	return BT_STATUS_UNSUPPORTED;
+}
+
+/* switch back to full stack */
+static int switch_stack_full_mode (void)
+{
+	ALOGE("[Qualcomm]%s: Need to implemented!!!", __FUNCTION__);
+	return BT_STATUS_UNSUPPORTED;
+}
+/** Enter Headless mode. This API shall work only if Bluetooth is enabled.*/
+/** Do not see a need for exit_headless_mode as 'enable' API will called to wake up
+   * from headless mode */
+/** Note that the behavior of Bluedroid is undefined after this API is invoked
+   * and the application process needs to be killed and restarted for any
+   * Bluedroid APIs to have any meaningful effect. */
+static int enter_headless_mode(void)
+{
+    ALOGI("enter_headless_mode");
+
+    /* sanity check */
+    if (interface_ready() == FALSE)
+        return BT_STATUS_NOT_READY;
+
+    return btif_enter_headless_mode();
+}
+
+/** Add Headless mode wake-up remote device. Should be a paired device */
+static int add_headless_mode_wakeup_device(bt_bdaddr_t *remote_addr)
+{
+    ALOGI("add_headless_mode_wakeup_device");
+
+    /* sanity check */
+    if (interface_ready() == FALSE)
+        return BT_STATUS_NOT_READY;
+
+    return btif_add_headless_mode_wakeup_device(remote_addr);
+}
+
+/** Add AV device to Headless table */
+static int add_av_dev_to_headless_mode(bt_bdaddr_t *remote_addr)
+{
+    ALOGI("add_av_dev_to_headless_mode");
+
+    /* sanity check */
+    if (interface_ready() == FALSE)
+        return BT_STATUS_NOT_READY;
+
+    return btif_add_av_dev_to_headless_mode(remote_addr);
+}
+
+/** Remove Headless mode wake-up remote device */
+static int delete_headless_mode_wakeup_device(bt_bdaddr_t *remote_addr)
+{
+    ALOGI("delete_headless_mode_wakeup_device");
+
+    /* sanity check */
+    if (interface_ready() == FALSE)
+        return BT_STATUS_NOT_READY;
+
+    return btif_delete_headless_mode_wakeup_device(remote_addr);
+}
+
+/** Set Remote LLR scan mode */
+static int set_remote_llr_mode(bt_bdaddr_t *remote_addr, llr_scan_mode mode)
+{
+	ALOGE("[Qualcomm]%s: Need to implemented!!!", __FUNCTION__);
+	return BT_STATUS_UNSUPPORTED;
+}
+
+/** Set LE advertising data for Headless mode */
+static int set_headless_le_adv_data(uint8_t *buf, uint8_t len)
+{
+    ALOGI("set_headless_le_adv_data");
+
+    /* sanity check */
+    if (interface_ready() == FALSE)
+        return BT_STATUS_NOT_READY;
+
+    return btif_set_headless_le_adv_data(buf, len);
+
+
+}
+
+/** configure scan mode for Headless mode */
+static int set_headless_scan_configure(uint8_t *buf, uint8_t len)
+{
+
+    ALOGI("set_headless_scan_configure");
+
+    /* sanity check */
+    if (interface_ready() == FALSE)
+        return BT_STATUS_NOT_READY;
+
+    return btif_set_headless_scan_configure(buf, len);
+
+}
+
+/* Upgrade the BT Chip firmware */
+int hw_chip_firmware_update(void)
+{
+    return btif_hw_chip_firmware_update();
+}
+
+/** Read version */
+static int read_version(btif_fw_version_t *ver)
+{
+    ALOGI("Read BT-chip FW version");
+    ver->build = 0;
+    ver->config = 100;
+    ver->minor= 0;
+    ver->major= 0;
+
+    return btif_read_version(ver);
+}
+
+/** Set auto authorization for peer device. Should be a paired device */
+static int set_authorization(bt_bdaddr_t *bd_addr, uint8_t auth)
+{
+    ALOGE("%s autho = %d",__func__,auth);
+    btif_dm_save_authorize_settings(bd_addr,(1<<1 | auth));
+    return BT_STATUS_SUCCESS;
+}
+
+/** Dummy API for BT wake up test */
+static void bt_wake_up_test(void)
+{
+    ALOGI("bt_wake_up_test");
+
+    /* sanity check */
+    if (interface_ready() == FALSE)
+        return BT_STATUS_NOT_READY;
+
+    btif_bt_wake_up_test();
+    return;
+
+}
+
+/** Set LE advertising interval*/
+static int set_le_adv_interval(bt_bdaddr_t *bd_addr, uint8_t type, uint16_t min, uint16_t max)
+{
+    ALOGE("%s : Sending BLE ADV PARAMS...", __FUNCTION__);
+    return btif_set_le_adv_params(min, max, bd_addr, type);
+}
+
+/** Configure LLR param */
+static int set_host_llr_param(uint16_t host_scan_interval)
+{
+	ALOGE("[Qualcomm]%s: Need to implemented!!!", __FUNCTION__);
+	return BT_STATUS_UNSUPPORTED;
+}
+
+/** Configure parameters for page scan and inquiry scan*/
+static int set_scan_param(uint16_t page_scan_interval, uint16_t page_scan_window,
+                          uint16_t inquiry_scan_interval, uint16_t inquiry_scan_window)
+
+{
+	ALOGE("[Qualcomm]%s: Need to implemented!!!", __FUNCTION__);
+	return BT_STATUS_UNSUPPORTED;
+}
+
+/** Configure AFH channel which will be disabled */
+static int set_afh_channel(uint8_t first, uint8_t last)
+{
+	ALOGE("[Qualcomm]%s: Need to implemented!!!", __FUNCTION__);
+	return BT_STATUS_UNSUPPORTED;
+}
+
+/** Enter antenna isolation measure mode */
+static int enter_antenna_isolation_test_mode(void)
+{
+	ALOGE("[Qualcomm]%s: Need to implemented!!!", __FUNCTION__);
+	return BT_STATUS_UNSUPPORTED;
+}
+#endif
+
 static const bt_interface_t bluetoothInterface = {
+#ifdef PLATFORM_ANDROID
     sizeof(bluetoothInterface),
     init,
     initq,
@@ -908,6 +1164,58 @@
 #else
     NULL
 #endif
+#else // PLATFORM_ANDROID, Tizen platform 
+    .size = sizeof(bluetoothInterface),
+    .init = init,
+    .enable = enable,
+    .disable = disable,
+    .cleanup = cleanup,
+    .get_adapter_properties = get_adapter_properties,
+    .get_adapter_property = get_adapter_property,
+    .set_adapter_property = set_adapter_property,
+    .get_remote_device_properties = get_remote_device_properties,
+    .get_remote_device_property = get_remote_device_property,
+    .set_remote_device_property = set_remote_device_property,
+    .get_remote_service_record = get_remote_service_record,
+    .get_remote_services = get_remote_services,
+    .start_discovery = start_discovery,
+    .cancel_discovery = cancel_discovery,
+    .create_bond = create_bond,
+    .remove_bond = remove_bond,
+    .cancel_bond = cancel_bond,
+    .pin_reply = pin_reply,
+    .ssp_reply = ssp_reply,
+    .get_profile_interface = get_profile_interface,
+    .dut_mode_configure = dut_mode_configure,
+    .dut_mode_send = dut_mode_send,
+#ifdef X86_TEST_INTERFACE
+    .hci_cmd_send = hci_cmd_send,
+#endif
+    .authorize_response = authorize_response,
+    .le_test_mode = le_test_mode,
+    .config_hci_snoop_log = config_hci_snoop_log,
+    .set_local_did = set_local_did,
+    .switch_stack_dual_mode = switch_stack_dual_mode,
+    .switch_stack_full_mode = switch_stack_full_mode,
+    .enter_headless_mode = enter_headless_mode,
+    .add_headless_mode_wakeup_device = add_headless_mode_wakeup_device,
+    .add_av_dev_to_headless_mode = add_av_dev_to_headless_mode,
+    .delete_headless_mode_wakeup_device = delete_headless_mode_wakeup_device,
+    .set_remote_llr_mode = set_remote_llr_mode,
+   .set_headless_le_adv_data = set_headless_le_adv_data,
+   .set_headless_scan_configure = set_headless_scan_configure,
+   .read_version = read_version,
+   .set_authorization = set_authorization,
+   .bt_wake_up_test = bt_wake_up_test,
+   .set_le_adv_interval = set_le_adv_interval,
+   .set_host_llr_param = set_host_llr_param,
+   .set_scan_param = set_scan_param,
+   .set_afh_channel = set_afh_channel,
+   .enter_antenna_isolation_test_mode = enter_antenna_isolation_test_mode,
+#ifdef X86_TEST_INTERFACE
+   .hw_chip_firmware_update = hw_chip_firmware_update
+#endif
+#endif
 };
 
 const bt_interface_t* bluetooth__get_bluetooth_interface ()
@@ -920,6 +1228,13 @@
 static int close_bluetooth_stack(struct hw_device_t* device)
 {
     cleanup();
+
+    ALOGI("Qualcomm bluedroid close");
+    if(fLog)
+    {
+        fclose(fLog);
+    }
+
     return 0;
 }
 
diff -Naur '--exclude=.git' bluedroid-orig/btif/src/btif_3d.c bluedroid/btif/src/btif_3d.c
--- bluedroid-orig/btif/src/btif_3d.c	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/btif/src/btif_3d.c	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,373 @@
+/************************************************************************************
+ *
+ *  Filename:      btif_3d.c
+ *
+ *  Description:   3D Sync Profile Bluetooth Interface
+ *
+ *
+ ***********************************************************************************/
+#include <hardware/bluetooth.h>
+#include <hardware/bt_3d.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+
+#define LOG_TAG "BTIF_3D"
+
+#include "bta_api.h"
+#include "bta_3d_api.h"
+#include "bd.h"
+#include "btif_storage.h"
+
+#include "btif_common.h"
+#include "btif_util.h"
+#include "btif_3d.h"
+#include "gki.h"
+#include "l2c_api.h"
+
+
+//Approximately 2 per second for a 60hz display
+#define FRAMES_SYNCS_PER_CAPTURE 60
+
+#define INVALID_PERIOD_REPEAT_THRESHOLD 10
+
+#define MIN_PERIOD_3D 16655
+#define MAX_PERIOD_3D 16690
+
+#define PERIOD_VALID_3D(_x) ((_x >= MIN_PERIOD_3D) && (_x <= MAX_PERIOD_3D))
+
+#define MIN_PERIOD_2D 8000
+#define MAX_PERIOD_2D 9000
+
+#define PERIOD_VALID_2D(_x) ((_x >= MIN_PERIOD_2D) && (_x <= MAX_PERIOD_2D))
+
+#define CLK_SLOT_US 625
+
+typedef struct
+{
+    uint32_t clock;
+    uint16_t offset;
+} tBTIF_3D_CLK_CAP_DATA;
+
+/************************************************************************************
+**  Static variables
+************************************************************************************/
+static bt3d_callbacks_t *bt_3d_callbacks = NULL;
+static tBTA_3D_BCAST_DATA bcast_data;
+static BOOLEAN broadcasting;
+static TIMER_LIST_ENT clk_cap_to_tmr;
+static BOOLEAN enabled;
+static bt3d_mode_t current_mode = BT3D_MODE_IDLE;
+static unsigned int invalid_count;
+
+static tBTIF_3D_CLK_CAP_DATA last_cap;
+
+static void bta_3d_evt(tBTA_3D_EVT event, tBTA_3D *data);
+
+//Called when we haven't received a Triggered Clock Capture
+//for an unexpected period of time.
+//
+//Triggers 2D mode
+static void clk_cap_to_cb(TIMER_LIST_ENT *tmr)
+{
+    BTIF_TRACE_DEBUG0("Triggered Clock Capture stopped");
+    memset(&bcast_data, 0, sizeof(bcast_data));
+    memset(&last_cap, 0, sizeof(last_cap));
+    HAL_CBACK(bt_3d_callbacks, frame_period_cb, 0);
+}
+
+static bt_status_t init(bt3d_callbacks_t *callbacks)
+{
+    BTIF_TRACE_EVENT1("%s", __FUNCTION__);
+    BTIF_TRACE_EVENT1("BTIF_3D_CALL_IN: %s", __FUNCTION__);
+    bt_3d_callbacks = callbacks;
+    btif_enable_service(BTA_3D_SERVICE_ID);
+    return BT_STATUS_SUCCESS;
+}
+
+static bt_status_t set_mode(bt3d_mode_t mode, bt_bdaddr_t *master_bd_addr)
+{
+    bt_status_t status;
+
+    BTIF_TRACE_EVENT2("BTIF_3D_CALL_IN: %s,%d", __FUNCTION__,mode);
+    if(!enabled)
+        return BT_STATUS_NOT_READY;
+
+    switch(mode)
+    {
+        case BT3D_MODE_IDLE:
+            BTIF_TRACE_DEBUG0("Setting 3D idle mode");
+            BTA_3dDisableClockCapture();
+            //XXX Not sure if this will actually take effect before the FW
+            //    stops broadcasting altogether
+            memset(&bcast_data, 0, sizeof(tBTA_3D_BCAST_DATA));
+            bcast_data.left_open_off = 0xFFFF;
+            BTA_3dSetBroadcastData(&bcast_data);
+            BTA_3dDisableBroadcasts();
+
+            btu_stop_timer(&clk_cap_to_tmr);
+            memset(&last_cap, 0, sizeof(last_cap));
+
+            status = BT_STATUS_SUCCESS;
+
+            break;
+        case BT3D_MODE_MASTER:
+            BTIF_TRACE_DEBUG0("Setting 3D master mode");
+            if(current_mode == BT3D_MODE_MASTER)
+                return BT_STATUS_SUCCESS;
+
+            //Start in 2D mode until we have a valid period
+            invalid_count = 0;
+            memset(&bcast_data, 0, sizeof(tBTA_3D_BCAST_DATA));
+            bcast_data.left_open_off = 0xFFFF;
+            BTA_3dSetBroadcastData(&bcast_data);
+
+            BTA_3dEnableBroadcasts(5000, 0);
+            BTA_3dStartSyncTrain();
+            BTA_3dEnableClockCapture(FRAMES_SYNCS_PER_CAPTURE);
+
+            status = BT_STATUS_SUCCESS;
+            break;
+        case BT3D_MODE_SLAVE:
+        case BT3D_MODE_SHOWROOM:
+        default:
+            status = BT_STATUS_UNSUPPORTED;
+    }
+
+    if(status == BT_STATUS_SUCCESS)
+        current_mode = mode;
+
+    return status;
+}
+
+//XXX Reject if we aren't broadcasting?
+static bt_status_t broadcast_3d_data(bt3d_data_t data)
+{
+    BTIF_TRACE_EVENT1("BTIF_3D_CALL_IN: %s", __FUNCTION__);
+    BTIF_TRACE_EVENT4("BTIF_3D %d,%d,%d,%d",data.left_open_offset,data.left_close_offset,data.right_open_offset,data.right_close_offset);
+    bcast_data.left_open_off   = data.left_open_offset;
+    bcast_data.left_close_off  = data.left_close_offset;
+    bcast_data.right_open_off  = data.right_open_offset;
+    bcast_data.right_close_off = data.right_close_offset;
+    BTIF_TRACE_EVENT1("DUAL_VIEW: %d", data.dual_view);
+//    bcast_data.dual_view       = data.dual_view;
+    bcast_data.dual_view = 0;
+
+    BTA_3dSetBroadcastData(&bcast_data);
+
+    return BT_STATUS_SUCCESS;
+}
+
+static void cleanup(void)
+{
+    BTIF_TRACE_EVENT1("BTIF_3D_CALL_IN: %s", __FUNCTION__);
+    if(bt_3d_callbacks)
+    {
+        btif_disable_service(BTA_3D_SERVICE_ID);
+        bt_3d_callbacks = NULL;
+    }
+}
+
+static const bt3d_interface_t bt3dInterface = 
+{
+    sizeof(bt3d_interface_t),
+    init,
+    set_mode,
+    broadcast_3d_data,
+    cleanup,
+};
+
+/*******************************************************************************
+**
+** Function         btif_3d_upstreams_evt
+**
+** Description      Executes 3D UPSTREAMS events in btif context
+**
+** Returns          void
+**
+*******************************************************************************/
+static void btif_3d_upstreams_evt(UINT16 event, char* p_param)
+{
+    uint16_t  period;
+    uint16_t  period_diff;
+    uint32_t  shifted_clock;
+    uint16_t  shifted_offset;
+    uint32_t  clock_diff;
+    uint8_t   fraction;
+    tBTA_3D  *data          = (tBTA_3D *)p_param;
+    switch(event)
+    {
+        case BTA_3D_ENABLE_EVT:
+            if(data->status == BTA_3D_OK)
+            {
+                BTA_3dWriteSyncTrainParams(120000, 0);
+                //BTA_3dEnableClockCapture(FRAMES_SYNCS_PER_CAPTURE);
+                enabled = TRUE;
+            }
+            else
+                BTIF_TRACE_ERROR1("Enable Error: %u", data->status);
+            break;
+        case BTA_3D_DISABLE_EVT:
+            enabled = FALSE;
+            break;
+        case BTA_3D_ASSOCIATION_EVT:
+            BTIF_TRACE_DEBUG3("Association: %02X, battery: %d, legacy: %d", data->association.flags, data->association.battery, data->association.legacy);
+
+            if((data->association.flags & BTA_3D_ASSOC_FLAGS_ASSOC) || (data->association.legacy))
+            {
+                HAL_CBACK(bt_3d_callbacks, assos_notif_cb, (bt_bdaddr_t *)&data->association.bd);
+            }
+
+            if((!data->association.legacy) && (data->association.battery != BTA_3D_ASSOC_BATT_LVL_NOT_SUPP))
+            {
+                HAL_CBACK(bt_3d_callbacks, batt_level_cb, (bt_bdaddr_t *)&data->association.bd, data->association.battery);
+            }
+            break;
+        case BTA_3D_SLV_PAGE_RSP_TO_EVT:
+            //Start the sync train, because a device requested it
+            //(Only if we are in master mode)
+            BTIF_TRACE_DEBUG0("Slave pg rsp TO received");
+            if(current_mode == BT3D_MODE_MASTER)
+                BTA_3dStartSyncTrain();
+            break;
+        case BTA_3D_SYNC_TRAIN_CMPL_EVT:
+        case BTA_3D_CHANNEL_CHANGE_EVT:
+            BTA_3dStartSyncTrain();
+            break;
+        case BTA_3D_CLK_CAP_EVT:
+            btu_stop_timer(&clk_cap_to_tmr);
+            shifted_clock = data->clk_cap.clock >> 1;
+            BTIF_TRACE_DEBUG2("CAPTURE: %d, %d", shifted_clock, data->clk_cap.offset);
+
+            if(last_cap.clock != 0)
+            {
+                clock_diff = (shifted_clock*CLK_SLOT_US + (uint32_t)data->clk_cap.offset) - (last_cap.clock*CLK_SLOT_US + (uint32_t)last_cap.offset);
+                period = (uint16_t)(clock_diff / (FRAMES_SYNCS_PER_CAPTURE + 1)); 
+                fraction = (clock_diff % (FRAMES_SYNCS_PER_CAPTURE + 1)) >> 8;
+
+                BTIF_TRACE_DEBUG1("BTIF_3D_PERIOD: %d", period);
+
+                if(PERIOD_VALID_2D(period))
+                {
+                    invalid_count = 0;
+                    //Set 2D mode if we haven't already
+                    if(bcast_data.period != 0)
+                    {
+                        memset(&bcast_data, 0, sizeof(tBTA_3D_BCAST_DATA));
+                        bcast_data.left_open_off = 0xFFFF;
+                        BTA_3dSetBroadcastData(&bcast_data);
+                    }
+                }
+                else if(PERIOD_VALID_3D(period))
+                {
+                    shifted_offset = data->clk_cap.offset >> 1;
+                    invalid_count  = 0;
+
+                    // The period appears to be valid 3D
+                    // Don't update to OAL if it is the same as before
+                    if(period == bcast_data.period)
+                    {
+                        BTIF_TRACE_DEBUG0("BTIF_3D period same");
+                        bcast_data.instant  = shifted_clock;
+                        bcast_data.phase = shifted_offset;
+                        BTA_3dSetBroadcastData(&bcast_data);
+                    }
+                    else
+                    {
+                        //The period has shifted, but is still seemingly valid 3D
+                        //XXX: Need to account for slight drifts due to noise if
+                        //     the problem persists an a better environment
+                        BTIF_TRACE_DEBUG0("BTIF_3D update period");
+                        bcast_data.instant  = shifted_clock;
+                        bcast_data.phase = shifted_offset;
+                        bcast_data.period   = period;
+                        bcast_data.fraction = fraction;
+                        HAL_CBACK(bt_3d_callbacks, frame_period_cb, period);
+                        
+                    }
+                }
+                else
+                {
+                    //This period is not a valid expected value.
+                    //We could be shifting 60hz<->120hz, or there could
+                    //be noise. Either way, just drop this period unless
+                    //we have had a number of periods in this range in a row.
+                    //If we reach the repeat threshold, drop to 2D mode
+                    if(bcast_data.period)
+                    {
+                        if(invalid_count > INVALID_PERIOD_REPEAT_THRESHOLD)
+                        {
+                            BTIF_TRACE_DEBUG0("Invalid threshold reached. Drop to 2D");
+                            invalid_count = 0;
+
+                            memset(&bcast_data, 0, sizeof(tBTA_3D_BCAST_DATA));
+                            bcast_data.left_open_off = 0xFFFF;
+                            BTA_3dSetBroadcastData(&bcast_data);
+                        }
+                        else
+                        {
+                            BTIF_TRACE_DEBUG1("Invalid period (%d)", invalid_count);
+                            invalid_count++;
+                        }
+                    }
+                }
+
+                clk_cap_to_tmr.param = (UINT32)clk_cap_to_cb;
+                btu_start_timer(&clk_cap_to_tmr, BTU_TTYPE_USER_FUNC, 2);
+            }
+
+            last_cap.clock  = shifted_clock;
+            last_cap.offset = data->clk_cap.offset;
+            break;
+        case BTA_3D_COMMAND_STATUS_EVT:
+            if(data->cmd_status.status != BTA_3D_OK)
+                BTIF_TRACE_ERROR2("3D HCI Cmd Fail: %d, %d", data->cmd_status.cmd, data->cmd_status.status);
+            break;
+        default:
+            BTIF_TRACE_DEBUG1("Unhandled 3D event: %u", event);
+    }
+}
+
+static void bta_3d_evt(tBTA_3D_EVT event, tBTA_3D *data)
+{
+    btif_transfer_context(btif_3d_upstreams_evt, event, (void *)data, sizeof(tBTA_3D), NULL);
+}
+
+/*******************************************************************************
+**
+** Function         btif_3d_execute_service
+**
+** Description      Initializes/Shuts down the service
+**
+** Returns          BT_STATUS_SUCCESS on success, BT_STATUS_FAIL otherwise
+**
+*******************************************************************************/
+bt_status_t btif_3d_execute_service(BOOLEAN b_enable)
+{
+     if (b_enable)
+     {
+          /* Enable and register with BTA-3D */
+          BTA_3dEnable(bta_3d_evt, BTIF_3D_SERVICE_NAME);
+     }
+     else {
+         /* Disable 3D */
+         BTA_3dDisable();
+     }
+     return BT_STATUS_SUCCESS;
+}
+
+/*******************************************************************************
+**
+** Function         btif_3d_get_interface
+**
+** Description      Get the 3d callback interface
+**
+** Returns          bt3d_interface_t
+**
+*******************************************************************************/
+const bt3d_interface_t *btif_3d_get_interface()
+{
+    BTIF_TRACE_EVENT1("%s", __FUNCTION__);
+    return &bt3dInterface;
+}
diff -Naur '--exclude=.git' bluedroid-orig/btif/src/btif_av.c bluedroid/btif/src/btif_av.c
--- bluedroid-orig/btif/src/btif_av.c	2015-09-24 16:33:43.528227643 +0800
+++ bluedroid/btif/src/btif_av.c	2015-09-24 16:31:37.000000000 +0800
@@ -27,6 +27,7 @@
 
 #include <hardware/bluetooth.h>
 #include "hardware/bt_av.h"
+#include "hardware/bt_avk.h"
 
 #define LOG_TAG "BTIF_AV"
 
@@ -40,11 +41,13 @@
 #include "gki.h"
 #include "bd.h"
 #include "btu.h"
+#include "bt_utils.h"
 
 /*****************************************************************************
 **  Constants & Macros
 ******************************************************************************/
 #define BTIF_AV_SERVICE_NAME "Advanced Audio"
+#define BTIF_AVK_SERVICE_NAME "Advanced Audio Sink"
 
 #define BTIF_TIMEOUT_AV_OPEN_ON_RC_SECS  2
 
@@ -69,12 +72,6 @@
 /*****************************************************************************
 **  Local type definitions
 ******************************************************************************/
-typedef enum
-{
-    SEP_SRC = 0x0,
-    SEP_SNK,
-    SEP_NOT_OPENED
-}tbtif_AV_SEP_TYPE;
 
 typedef struct
 {
@@ -83,22 +80,33 @@
     btif_sm_handle_t sm_handle;
     UINT8 flags;
     tBTA_AV_EDR edr;
+    UINT8   peer_sep;  /* sep type of peer device */
     UINT8 edr_3mbps;
-    tbtif_AV_SEP_TYPE   sep;  /* sep type of peer device */
 } btif_av_cb_t;
 
+typedef struct
+{
+    bt_bdaddr_t *target_bda;
+    uint16_t uuid;
+} btif_av_connect_req_t;
+
+typedef struct
+{
+    int sample_rate;
+    int channel_count;
+} btif_av_sink_config_req_t;
+
 /*****************************************************************************
 **  Static variables
 ******************************************************************************/
-static btav_callbacks_t *bt_av_callbacks = NULL;
+static btav_callbacks_t *bt_av_src_callbacks = NULL;
+static btavk_callbacks_t *bt_av_sink_callbacks = NULL;
 static btif_av_cb_t btif_av_cb;
 static TIMER_LIST_ENT tle_av_open_on_rc;
-static btif_sm_event_t idle_rc_event;
-static tBTA_AV idle_rc_data;
-
 
 /* both interface and media task needs to be ready to alloc incoming request */
-#define CHECK_BTAV_INIT() if ((bt_av_callbacks == NULL) || (btif_av_cb.sm_handle == NULL))\
+#define CHECK_BTAV_INIT() if (((bt_av_src_callbacks == NULL) &&(bt_av_sink_callbacks == NULL)) \
+        || (btif_av_cb.sm_handle == NULL))\
 {\
      BTIF_TRACE_WARNING1("%s: BTAV not initialized", __FUNCTION__);\
      return BT_STATUS_NOT_READY;\
@@ -117,6 +125,7 @@
     case BTA_AV_META_MSG_EVT: \
     case BTA_AV_BROWSE_MSG_EVT: \
     case BTA_AV_RC_FEAT_EVT: \
+    case BTA_AV_REMOTE_RSP_EVT: \
     { \
          btif_rc_handler(e, d);\
     }break; \
@@ -126,7 +135,9 @@
 static BOOLEAN btif_av_state_opened_handler(btif_sm_event_t event, void *data);
 static BOOLEAN btif_av_state_started_handler(btif_sm_event_t event, void *data);
 static BOOLEAN btif_av_state_closing_handler(btif_sm_event_t event, void *data);
-
+#ifdef AVK_BACKPORT
+void btif_av_request_audio_focus( BOOLEAN enable);
+#endif
 static const btif_sm_handler_t btif_av_state_handlers[] =
 {
     btif_av_state_idle_handler,
@@ -141,9 +152,11 @@
 *************************************************************************/
 extern void btif_rc_handler(tBTA_AV_EVT event, tBTA_AV *p_data);
 extern BOOLEAN btif_rc_get_connected_peer(BD_ADDR peer_addr);
+extern UINT8 btif_rc_get_connected_peer_handle(void);
 extern void btif_rc_check_handle_pending_play (BD_ADDR peer_addr, BOOLEAN bSendToApp);
 extern BOOLEAN btif_hf_is_call_idle();
 extern BOOLEAN btif_multihf_is_call_idle();
+extern void btif_media_get_sbc_config(btavk_audio_config_t *btavk_audio_config);
 
 /*****************************************************************************
 ** Local helper functions
@@ -193,39 +206,13 @@
         CASE_RETURN_STR(BTIF_AV_START_STREAM_REQ_EVT)
         CASE_RETURN_STR(BTIF_AV_STOP_STREAM_REQ_EVT)
         CASE_RETURN_STR(BTIF_AV_SUSPEND_STREAM_REQ_EVT)
-        CASE_RETURN_STR(BTIF_AV_RECONFIGURE_REQ_EVT)
-        CASE_RETURN_STR(BTIF_AV_REQUEST_AUDIO_FOCUS_EVT)
+        CASE_RETURN_STR(BTIF_AV_SINK_CONFIG_REQ_EVT)
+        CASE_RETURN_STR(BTIF_AV_UPDATE_ENCODER_REQ_EVT)
 
         default: return "UNKNOWN_EVENT";
    }
 }
 
-/*******************************************************************************
-**
-** Function         btif_av_request_audio_focus
-**
-** Description      send request to gain audio focus
-**
-** Returns          void
-**
-*******************************************************************************/
-void btif_av_request_audio_focus( BOOLEAN enable)
-{
-    btif_sm_state_t state;
-    state= btif_sm_get_state(btif_av_cb.sm_handle);
-    /* We shld be in started state */
-    if (state != BTIF_AV_STATE_STARTED)
-        return;
-    /* If we are in started state, suspend shld not have been initiated */
-    if ((btif_av_cb.flags & BTIF_AV_FLAG_REMOTE_SUSPEND )||
-        (btif_av_cb.flags & BTIF_AV_FLAG_LOCAL_SUSPEND_PENDING))
-        return;
-    if(enable)
-    {
-         btif_dispatch_sm_event(BTIF_AV_REQUEST_AUDIO_FOCUS_EVT, NULL, 0);
-    }
-}
-
 /****************************************************************************
 **  Local helper functions
 *****************************************************************************/
@@ -243,11 +230,34 @@
 static void btif_initiate_av_open_tmr_hdlr(TIMER_LIST_ENT *tle)
 {
     BD_ADDR peer_addr;
-
+    UNUSED(tle);
+    btif_av_connect_req_t connect_req;
+    UNUSED(tle);
     /* is there at least one RC connection - There should be */
     if (btif_rc_get_connected_peer(peer_addr)) {
        BTIF_TRACE_DEBUG1("%s Issuing connect to the remote RC peer", __FUNCTION__);
-       btif_sm_dispatch(btif_av_cb.sm_handle, BTIF_AV_CONNECT_REQ_EVT, (void*)&peer_addr);
+       /* In case of AVRCP connection request, we will initiate SRC connection */
+       btif_sm_state_t state = btif_sm_get_state(btif_av_cb.sm_handle);
+       if ((state == BTIF_AV_STATE_STARTED) ||
+           (state == BTIF_AV_STATE_OPENED) )
+       {
+           BTIF_TRACE_DEBUG0(" A2DP Connection Already UP");
+           /*
+            * Check if A2DP conneciton is with same device
+            */
+           if(bdcmp(btif_av_cb.peer_bda.address, peer_addr))
+           {
+               BTIF_TRACE_WARNING0(" Disconnecting AVRCP ");
+               BTA_AvCloseRc(btif_rc_get_connected_peer_handle());
+               return;
+           }
+       }
+       connect_req.target_bda = (bt_bdaddr_t*)&peer_addr;
+       if(bt_av_sink_callbacks != NULL)
+           connect_req.uuid = UUID_SERVCLASS_AUDIO_SINK;
+       else if(bt_av_src_callbacks != NULL)
+           connect_req.uuid = UUID_SERVCLASS_AUDIO_SOURCE;
+       btif_sm_dispatch(btif_av_cb.sm_handle, BTIF_AV_CONNECT_REQ_EVT, (char*)&connect_req);
     }
     else
     {
@@ -259,6 +269,24 @@
 **  Static functions
 ******************************************************************************/
 
+static void btif_report_connection_state(btav_connection_state_t state, bt_bdaddr_t *bd_addr)
+{
+    if (bt_av_sink_callbacks != NULL) {
+        HAL_CBACK(bt_av_sink_callbacks, connection_state_cb, state, bd_addr);
+    } else if (bt_av_src_callbacks != NULL) {
+        HAL_CBACK(bt_av_src_callbacks, connection_state_cb, state, bd_addr);
+    }
+}
+
+static void btif_report_audio_state(btav_audio_state_t state, bt_bdaddr_t *bd_addr)
+{
+    if (bt_av_sink_callbacks != NULL) {
+        HAL_CBACK(bt_av_sink_callbacks, audio_state_cb, state, bd_addr);
+    } else if (bt_av_src_callbacks != NULL) {
+        HAL_CBACK(bt_av_src_callbacks, audio_state_cb, state, bd_addr);
+    }
+}
+
 /*****************************************************************************
 **
 ** Function     btif_av_state_idle_handler
@@ -271,8 +299,6 @@
 
 static BOOLEAN btif_av_state_idle_handler(btif_sm_event_t event, void *p_data)
 {
-    tBTA_AV *p_bta_data;
-
     BTIF_TRACE_IMP3("%s event:%s flags %x", __FUNCTION__,
                      dump_av_sm_event_name(event), btif_av_cb.flags);
     switch (event)
@@ -283,7 +309,6 @@
             btif_av_cb.flags = 0;
             btif_av_cb.edr = 0;
             btif_av_cb.edr_3mbps = 0;
-            btif_av_cb.sep = SEP_NOT_OPENED;
             btif_a2dp_on_idle();
             break;
 
@@ -295,50 +320,17 @@
 
         case BTA_AV_REGISTER_EVT:
             btif_av_cb.bta_handle = ((tBTA_AV*)p_data)->registr.hndl;
-            btif_queue_pending_retry();
             break;
 
         case BTIF_AV_CONNECT_REQ_EVT:
-             /* For outgoing connect stack and app are in sync.
-              */
-             memcpy(&btif_av_cb.peer_bda, (bt_bdaddr_t*)p_data, sizeof(bt_bdaddr_t));
-             BTA_AvOpen(btif_av_cb.peer_bda.address, btif_av_cb.bta_handle,
-                    TRUE, BTA_SEC_AUTHENTICATE);
-             btif_sm_change_state(btif_av_cb.sm_handle, BTIF_AV_STATE_OPENING);
-             break;
-
-        case BTA_AV_OPEN_EVT:
-             /* We get this event in Idle State if Signalling channel was not closed
-              * only Streaming channel was closed, and stream setup process was initiated
-              */
-             p_bta_data = (tBTA_AV*)p_data;
-             BTIF_TRACE_DEBUG2("status:%d, edr 0x%x", p_bta_data->open.status,
-                               p_bta_data->open.edr);
-
-             if (p_bta_data->open.status == BTA_AV_SUCCESS)
-             {
-                  btif_av_cb.edr = p_bta_data->open.edr;
-                  if (p_bta_data->open.edr & BTA_AV_EDR_3MBPS)
-                  {
-                      BTIF_TRACE_DEBUG0("remote supports 3 mbps");
-                      btif_av_cb.edr_3mbps = TRUE;
-                  }
-
-                  if (p_bta_data->open.sep == AVDT_TSEP_SRC)
-                     btif_av_cb.sep = SEP_SRC;
-                  else if (p_bta_data->open.sep == AVDT_TSEP_SNK)
-                      btif_av_cb.sep = SEP_SNK;
-
-                  bdcpy(btif_av_cb.peer_bda.address, ((tBTA_AV*)p_data)->open.bd_addr);
-
-                  /* inform the application of the event */
-                  HAL_CBACK(bt_av_callbacks, connection_state_cb,
-                        BTAV_CONNECTION_STATE_CONNECTED, &(btif_av_cb.peer_bda));
-                  /* change state to open/idle based on the status */
-                  btif_sm_change_state(btif_av_cb.sm_handle, BTIF_AV_STATE_OPENED);
-             }
-             btif_queue_advance();
-             break;
+            /* For outgoing connect stack and app are in sync.
+             */
+            memcpy(&btif_av_cb.peer_bda, ((btif_av_connect_req_t*)p_data)->target_bda,
+                                                                     sizeof(bt_bdaddr_t));
+            BTA_AvOpen(btif_av_cb.peer_bda.address, btif_av_cb.bta_handle,
+                    TRUE, BTA_SEC_NONE, ((btif_av_connect_req_t*)p_data)->uuid);
+            btif_sm_change_state(btif_av_cb.sm_handle, BTIF_AV_STATE_OPENING);
+            break;
 
         case BTA_AV_PENDING_EVT:
         case BTA_AV_RC_OPEN_EVT:
@@ -351,35 +343,90 @@
              *
              * TODO: We may need to do this only on an AVRCP Play. FixMe
              */
-
-            /* Check if connection allowed with this device */
-            BTIF_TRACE_DEBUG0("Check A2dp priority of device");
-            if (idle_rc_event != 0)
+            if(event == BTA_AV_PENDING_EVT)
             {
-                BTIF_TRACE_DEBUG0("Processing another RC Event ");
-                return FALSE;
+                bdcpy(btif_av_cb.peer_bda.address, ((tBTA_AV*)p_data)->pend.bd_addr);
+                btif_sm_change_state(btif_av_cb.sm_handle, BTIF_AV_STATE_OPENING);
+                if (bt_av_src_callbacks != NULL)
+                {
+                    BTA_AvOpen(btif_av_cb.peer_bda.address, btif_av_cb.bta_handle,
+                        TRUE, BTA_SEC_NONE, UUID_SERVCLASS_AUDIO_SOURCE);
+                }
+                if (bt_av_sink_callbacks != NULL)
+                {
+                    BTA_AvOpen(btif_av_cb.peer_bda.address, btif_av_cb.bta_handle,
+                        TRUE, BTA_SEC_NONE, UUID_SERVCLASS_AUDIO_SINK);
+                }
             }
-            idle_rc_event = event;
-            memcpy(&idle_rc_data, ((tBTA_AV*)p_data), sizeof(tBTA_AV));
-            if (event == BTA_AV_RC_OPEN_EVT )
+            else if(event == BTA_AV_RC_OPEN_EVT)
             {
                 bdcpy(btif_av_cb.peer_bda.address, ((tBTA_AV*)p_data)->rc_open.peer_addr);
+                memset(&tle_av_open_on_rc, 0, sizeof(tle_av_open_on_rc));
+                tle_av_open_on_rc.param = (UINT32)btif_initiate_av_open_tmr_hdlr;
+                btu_start_timer(&tle_av_open_on_rc, BTU_TTYPE_USER_FUNC,
+                    BTIF_TIMEOUT_AV_OPEN_ON_RC_SECS);
+                btif_rc_handler(event, p_data);
+            }
+            break;
+
+        case BTA_AV_OPEN_EVT:
+        {
+            /* We get this event in Idle State if Signaling
+             * channel is not closed, only Streaming channel was
+             * closed earlier, and now only stream setup process is
+             * initiated.
+             */
+            tBTA_AV *p_bta_data = (tBTA_AV*)p_data;
+            btav_connection_state_t state;
+            BTIF_TRACE_DEBUG2("status:%d, edr 0x%x",p_bta_data->open.status,
+                               p_bta_data->open.edr);
+
+            if (p_bta_data->open.status == BTA_AV_SUCCESS)
+            {
+                 state = BTAV_CONNECTION_STATE_CONNECTED;
+                 btif_av_cb.edr = p_bta_data->open.edr;
+
+                 btif_av_cb.peer_sep = p_bta_data->open.sep;
+                 btif_a2dp_set_peer_sep(p_bta_data->open.sep);
+                 bdcpy(btif_av_cb.peer_bda.address, ((tBTA_AV*)p_data)->open.bd_addr);
             }
             else
             {
-                bdcpy(btif_av_cb.peer_bda.address, ((tBTA_AV*)p_data)->pend.bd_addr);
+                BTIF_TRACE_WARNING1("BTA_AV_OPEN_EVT::FAILED status: %d",
+                                     p_bta_data->open.status );
+                state = BTAV_CONNECTION_STATE_DISCONNECTED;
             }
-            // Only for AVDTP connection request move to opening state
-            if (event == BTA_AV_PENDING_EVT)
-                btif_sm_change_state(btif_av_cb.sm_handle, BTIF_AV_STATE_OPENING);
-            HAL_CBACK(bt_av_callbacks, connection_priority_cb, &(btif_av_cb.peer_bda));
-            break;
+
+            /* change state to open based on the status */
+            if (p_bta_data->open.status == BTA_AV_SUCCESS)
+            {
+                /* inform the application of the event */
+                btif_report_connection_state(state, &(btif_av_cb.peer_bda));
+                btif_sm_change_state(btif_av_cb.sm_handle, BTIF_AV_STATE_OPENED);
+            }
+
+            if (btif_av_cb.peer_sep == AVDT_TSEP_SNK)
+            {
+                /* if queued PLAY command,  send it now */
+                btif_rc_check_handle_pending_play(p_bta_data->open.bd_addr,
+                                             (p_bta_data->open.status == BTA_AV_SUCCESS));
+            }
+            else if (btif_av_cb.peer_sep == AVDT_TSEP_SRC)
+            {
+                /* if queued PLAY command,  send it now */
+                btif_rc_check_handle_pending_play(p_bta_data->open.bd_addr, FALSE);
+                /* Bring up AVRCP connection too */
+                BTA_AvOpenRc(btif_av_cb.bta_handle);
+            }
+            btif_queue_advance();
+        } break;
 
         case BTA_AV_REMOTE_CMD_EVT:
         case BTA_AV_VENDOR_CMD_EVT:
         case BTA_AV_META_MSG_EVT:
         case BTA_AV_RC_FEAT_EVT:
         case BTA_AV_BROWSE_MSG_EVT:
+        case BTA_AV_REMOTE_RSP_EVT:
             btif_rc_handler(event, (tBTA_AV*)p_data);
             break;
 
@@ -419,8 +466,16 @@
     {
         case BTIF_SM_ENTER_EVT:
             /* inform the application that we are entering connecting state */
-            HAL_CBACK(bt_av_callbacks, connection_state_cb,
-                      BTAV_CONNECTION_STATE_CONNECTING, &(btif_av_cb.peer_bda));
+            if (bt_av_sink_callbacks != NULL)
+            {
+                HAL_CBACK(bt_av_sink_callbacks, connection_state_cb,
+                         BTAV_CONNECTION_STATE_CONNECTING, &(btif_av_cb.peer_bda));
+            }
+            else if (bt_av_src_callbacks != NULL)
+            {
+                HAL_CBACK(bt_av_src_callbacks, connection_state_cb,
+                         BTAV_CONNECTION_STATE_CONNECTING, &(btif_av_cb.peer_bda));
+            }
             break;
 
         case BTIF_SM_EXIT_EVT:
@@ -428,8 +483,7 @@
 
         case BTA_AV_REJECT_EVT:
             BTIF_TRACE_DEBUG0(" Received  BTA_AV_REJECT_EVT ");
-            HAL_CBACK(bt_av_callbacks, connection_state_cb,
-                BTAV_CONNECTION_STATE_DISCONNECTED, &(btif_av_cb.peer_bda));
+            btif_report_connection_state(BTAV_CONNECTION_STATE_DISCONNECTED, &(btif_av_cb.peer_bda));
             btif_sm_change_state(btif_av_cb.sm_handle, BTIF_AV_STATE_IDLE);
             break;
 
@@ -446,36 +500,69 @@
                  state = BTAV_CONNECTION_STATE_CONNECTED;
                  av_state = BTIF_AV_STATE_OPENED;
                  btif_av_cb.edr = p_bta_data->open.edr;
+
+                 btif_av_cb.peer_sep = p_bta_data->open.sep;
+                 btif_a2dp_set_peer_sep(p_bta_data->open.sep);
+
                  if (p_bta_data->open.edr & BTA_AV_EDR_3MBPS)
                  {
                      BTIF_TRACE_DEBUG0("remote supports 3 mbps");
                      btif_av_cb.edr_3mbps = TRUE;
                  }
-
-                 if (p_bta_data->open.sep == AVDT_TSEP_SRC)
-                    btif_av_cb.sep = SEP_SRC;
-                 else if (p_bta_data->open.sep == AVDT_TSEP_SNK)
-                     btif_av_cb.sep = SEP_SNK;
             }
             else
             {
                 BTIF_TRACE_WARNING1("BTA_AV_OPEN_EVT::FAILED status: %d",
                                      p_bta_data->open.status );
+                BD_ADDR peer_addr;
+                if ((btif_rc_get_connected_peer(peer_addr))
+                    &&(!bdcmp(btif_av_cb.peer_bda.address, peer_addr)))
+                {
+                    /*
+                     * Disconnect AVRCP connection, if
+                     * A2DP conneciton failed, for any reason
+                     */
+                    BTIF_TRACE_WARNING0(" Disconnecting AVRCP ");
+                    BTA_AvCloseRc(btif_rc_get_connected_peer_handle());
+                }
                 state = BTAV_CONNECTION_STATE_DISCONNECTED;
                 av_state  = BTIF_AV_STATE_IDLE;
             }
 
             /* inform the application of the event */
-            HAL_CBACK(bt_av_callbacks, connection_state_cb,
-                             state, &(btif_av_cb.peer_bda));
+            btif_report_connection_state(state, &(btif_av_cb.peer_bda));
             /* change state to open/idle based on the status */
             btif_sm_change_state(btif_av_cb.sm_handle, av_state);
-            /* if queued PLAY command,  send it now */
-            btif_rc_check_handle_pending_play(p_bta_data->open.bd_addr,
+            if (btif_av_cb.peer_sep == AVDT_TSEP_SNK)
+            {
+                /* if queued PLAY command,  send it now */
+                btif_rc_check_handle_pending_play(p_bta_data->open.bd_addr,
                                              (p_bta_data->open.status == BTA_AV_SUCCESS));
+            }
+            else if (btif_av_cb.peer_sep == AVDT_TSEP_SRC)
+            {
+                /* if queued PLAY command,  send it now */
+                btif_rc_check_handle_pending_play(p_bta_data->open.bd_addr, FALSE);
+                /* Bring up AVRCP connection too */
+                BTA_AvOpenRc(btif_av_cb.bta_handle);
+            }
             btif_queue_advance();
         } break;
 
+        case BTIF_AV_SINK_CONFIG_REQ_EVT:
+        {
+            btif_av_sink_config_req_t req;
+            // copy to avoid alignment problems
+            memcpy(&req, p_data, sizeof(req));
+
+            BTIF_TRACE_WARNING2("BTIF_AV_SINK_CONFIG_REQ_EVT %d %d", req.sample_rate,
+                    req.channel_count);
+            /*if (btif_av_cb.peer_sep == AVDT_TSEP_SRC && bt_av_sink_callbacks != NULL) {
+                HAL_CBACK(bt_av_sink_callbacks, audio_config_cb, &(btif_av_cb.peer_bda),
+                        req.sample_rate, req.channel_count);
+            }*/
+        } break;
+
         case BTIF_AV_CONNECT_REQ_EVT:
             // Check for device, if same device which moved to opening then ignore callback
             if (memcmp ((bt_bdaddr_t*)p_data, &(btif_av_cb.peer_bda),
@@ -485,8 +572,8 @@
                 break;
             }
             BTIF_TRACE_WARNING0("Moved from idle by Incoming Connection request");
-            HAL_CBACK(bt_av_callbacks, connection_state_cb,
-                        BTAV_CONNECTION_STATE_DISCONNECTED, (bt_bdaddr_t*)p_data);
+ 
+            btif_report_connection_state(BTAV_CONNECTION_STATE_DISCONNECTED, (bt_bdaddr_t*)p_data);
 
             break;
         case BTA_AV_PENDING_EVT:
@@ -501,8 +588,18 @@
             BTA_AvDisconnect(((tBTA_AV*)p_data)->pend.bd_addr);
             break;
         case BTIF_AV_DISCONNECT_REQ_EVT:
-            HAL_CBACK(bt_av_callbacks, connection_state_cb,
-                BTAV_CONNECTION_STATE_DISCONNECTED, &(btif_av_cb.peer_bda));
+            btif_report_connection_state(BTAV_CONNECTION_STATE_DISCONNECTED,
+                &(btif_av_cb.peer_bda));
+            BTA_AvClose(btif_av_cb.bta_handle);
+            btif_queue_advance();
+            btif_sm_change_state(btif_av_cb.sm_handle, BTIF_AV_STATE_IDLE);
+            break;
+        case BTA_AV_CLOSE_EVT:
+            /* avdtp link is closed */
+            btif_a2dp_on_stopped(NULL);
+            /* inform the application that we are disconnected */
+            btif_report_connection_state(BTAV_CONNECTION_STATE_DISCONNECTED,
+                &(btif_av_cb.peer_bda));
             btif_sm_change_state(btif_av_cb.sm_handle, BTIF_AV_STATE_IDLE);
             break;
         CHECK_RC_EVENT(event, p_data);
@@ -536,13 +633,13 @@
     switch (event)
     {
         case BTIF_SM_ENTER_EVT:
-            if (btif_av_cb.sep == SEP_SNK)
+            if (btif_av_cb.peer_sep == AVDT_TSEP_SNK)
             {
                 /* immediately stop transmission of frames */
                 btif_a2dp_set_tx_flush(TRUE);
                 /* wait for audioflinger to stop a2dp */
             }
-            if (btif_av_cb.sep == SEP_SRC)
+            if (btif_av_cb.peer_sep == AVDT_TSEP_SRC)
             {
                 btif_a2dp_set_rx_flush(TRUE);
             }
@@ -550,21 +647,18 @@
 
         case BTA_AV_STOP_EVT:
         case BTIF_AV_STOP_STREAM_REQ_EVT:
-            if (btif_av_cb.sep == SEP_SNK)
+            if (btif_av_cb.peer_sep == AVDT_TSEP_SNK)
             {
               /* immediately flush any pending tx frames while suspend is pending */
               btif_a2dp_set_tx_flush(TRUE);
             }
-            if (btif_av_cb.sep == SEP_SRC)
+            if (btif_av_cb.peer_sep == AVDT_TSEP_SRC)
             {
                 btif_a2dp_set_rx_flush(TRUE);
             }
-            /* inform the application that we are audio is stopped */
-            HAL_CBACK(bt_av_callbacks, audio_state_cb,
-                BTAV_AUDIO_STATE_STOPPED, &(btif_av_cb.peer_bda));
 
             btif_a2dp_on_stopped(NULL);
-              break;
+            break;
 
         case BTIF_SM_EXIT_EVT:
             break;
@@ -572,8 +666,7 @@
         case BTA_AV_CLOSE_EVT:
 
             /* inform the application that we are disconnecting */
-            HAL_CBACK(bt_av_callbacks, connection_state_cb,
-                BTAV_CONNECTION_STATE_DISCONNECTED, &(btif_av_cb.peer_bda));
+            btif_report_connection_state(BTAV_CONNECTION_STATE_DISCONNECTED, &(btif_av_cb.peer_bda));
 
             btif_sm_change_state(btif_av_cb.sm_handle, BTIF_AV_STATE_IDLE);
             break;
@@ -629,12 +722,19 @@
             break;
 
         case BTIF_AV_START_STREAM_REQ_EVT:
-            if (btif_av_cb.sep == SEP_SRC)
+            if (btif_av_cb.peer_sep == AVDT_TSEP_SRC)
             {
                 BTA_AvStart();
                 btif_av_cb.flags |= BTIF_AV_FLAG_PENDING_START;
                 break;
             }
+
+            if (btif_av_cb.flags == BTIF_AV_FLAG_PENDING_START)
+            {
+                BTIF_TRACE_DEBUG0("AV start under process");
+                break;
+            }
+
             status = btif_a2dp_setup_codec();
             if (status == BTIF_SUCCESS)
             {
@@ -659,6 +759,10 @@
             }
             break;
 
+        case BTIF_AV_UPDATE_ENCODER_REQ_EVT:
+            btif_a2dp_update_codec();
+            break;
+
         case BTA_AV_START_EVT:
         {
             BTIF_TRACE_EVENT3("BTA_AV_START_EVT status %d, suspending %d, init %d",
@@ -673,7 +777,7 @@
              */
             if (!(btif_av_cb.flags & BTIF_AV_FLAG_PENDING_START))
             {
-                if (btif_av_cb.sep == SEP_SNK)
+                if (btif_av_cb.peer_sep == AVDT_TSEP_SNK)
                 {
                     BTIF_TRACE_EVENT1("%s: trigger suspend as remote initiated!!", __FUNCTION__);
                     btif_dispatch_sm_event(BTIF_AV_SUSPEND_STREAM_REQ_EVT, NULL, 0);
@@ -686,7 +790,7 @@
             }
 
             /*  In case peer is A2DP SRC we do not want to ack commands on UIPC*/
-            if (btif_av_cb.sep == SEP_SNK)
+            if (btif_av_cb.peer_sep == AVDT_TSEP_SNK)
             {
                 if (btif_a2dp_on_started(&p_av->start,
                     ((btif_av_cb.flags & BTIF_AV_FLAG_PENDING_START) != 0)))
@@ -700,14 +804,16 @@
             if (p_av->start.status != BTA_AV_SUCCESS)
                 return FALSE;
 
-            if (btif_av_cb.sep == SEP_SRC)
+#ifndef AVK_BACKPORT
+            if (btif_av_cb.peer_sep == AVDT_TSEP_SRC)
             {
                 btif_a2dp_set_rx_flush(FALSE); /*  remove flush state, ready for streaming*/
             }
+#endif
 
             /* change state to started, send acknowledgement if start is pending */
             if (btif_av_cb.flags & BTIF_AV_FLAG_PENDING_START) {
-                if (btif_av_cb.sep == SEP_SNK)
+                if (btif_av_cb.peer_sep == AVDT_TSEP_SNK)
                     btif_a2dp_on_started(NULL, TRUE);
                 /* pending start flag will be cleared when exit current state */
             }
@@ -717,10 +823,12 @@
 
         case BTIF_AV_DISCONNECT_REQ_EVT:
             BTA_AvClose(btif_av_cb.bta_handle);
+            if (btif_av_cb.peer_sep == AVDT_TSEP_SRC) {
+                BTA_AvCloseRc(btif_av_cb.bta_handle);
+            }
 
             /* inform the application that we are disconnecting */
-            HAL_CBACK(bt_av_callbacks, connection_state_cb,
-               BTAV_CONNECTION_STATE_DISCONNECTING, &(btif_av_cb.peer_bda));
+            btif_report_connection_state(BTAV_CONNECTION_STATE_DISCONNECTING, &(btif_av_cb.peer_bda));
             break;
 
         case BTA_AV_CLOSE_EVT:
@@ -728,8 +836,7 @@
             btif_a2dp_on_stopped(NULL);
 
             /* inform the application that we are disconnected */
-            HAL_CBACK(bt_av_callbacks, connection_state_cb,
-                BTAV_CONNECTION_STATE_DISCONNECTED, &(btif_av_cb.peer_bda));
+            btif_report_connection_state(BTAV_CONNECTION_STATE_DISCONNECTED, &(btif_av_cb.peer_bda));
 
             /* change state to idle, send acknowledgement if start is pending */
             if (btif_av_cb.flags & BTIF_AV_FLAG_PENDING_START) {
@@ -764,8 +871,7 @@
             else
             {
                 BTIF_TRACE_WARNING0("Moved to opened by Other Incoming Conn req");
-                HAL_CBACK(bt_av_callbacks, connection_state_cb,
-                            BTAV_CONNECTION_STATE_DISCONNECTED, (bt_bdaddr_t*)p_data);
+                btif_report_connection_state(BTAV_CONNECTION_STATE_DISCONNECTED, (bt_bdaddr_t*)p_data);
             }
             break;
 
@@ -803,8 +909,15 @@
 
             /* we are again in started state, clear any remote suspend flags */
             btif_av_cb.flags &= ~BTIF_AV_FLAG_REMOTE_SUSPEND;
-            HAL_CBACK(bt_av_callbacks, audio_state_cb,
-                BTAV_AUDIO_STATE_STARTED, &(btif_av_cb.peer_bda));
+
+            btif_report_audio_state(BTAV_AUDIO_STATE_STARTED, &(btif_av_cb.peer_bda));
+
+#ifdef AVK_BACKPORT
+            if (btif_av_cb.peer_sep == AVDT_TSEP_SRC)
+            {
+                btif_av_request_audio_focus(TRUE);
+            }
+#endif
             break;
 
         case BTIF_SM_EXIT_EVT:
@@ -812,10 +925,14 @@
 
         case BTIF_AV_START_STREAM_REQ_EVT:
             /* we were remotely started, just ack back the local request */
-            if (btif_av_cb.sep == SEP_SNK)
+            if (btif_av_cb.peer_sep == AVDT_TSEP_SNK)
                 btif_a2dp_on_started(NULL, TRUE);
             break;
 
+        case BTIF_AV_UPDATE_ENCODER_REQ_EVT:
+            btif_a2dp_update_codec();
+            break;
+
         /* fixme -- use suspend = true always to work around issue with BTA AV */
         case BTIF_AV_STOP_STREAM_REQ_EVT:
         case BTIF_AV_SUSPEND_STREAM_REQ_EVT:
@@ -828,14 +945,16 @@
                always overrides */
             btif_av_cb.flags &= ~BTIF_AV_FLAG_REMOTE_SUSPEND;
 
-            if (btif_av_cb.sep == SEP_SNK)
+            if (btif_av_cb.peer_sep == AVDT_TSEP_SNK)
             {
             /* immediately stop transmission of frames while suspend is pending */
                 btif_a2dp_set_tx_flush(TRUE);
             }
 
-            if (btif_av_cb.sep == SEP_SRC)
+            if (btif_av_cb.peer_sep == AVDT_TSEP_SRC) {
                 btif_a2dp_set_rx_flush(TRUE);
+                btif_a2dp_on_stopped(NULL);
+            }
 
             BTA_AvStop(TRUE);
             break;
@@ -844,10 +963,12 @@
 
             /* request avdtp to close */
             BTA_AvClose(btif_av_cb.bta_handle);
+            if (btif_av_cb.peer_sep == AVDT_TSEP_SRC) {
+                BTA_AvCloseRc(btif_av_cb.bta_handle);
+            }
 
             /* inform the application that we are disconnecting */
-            HAL_CBACK(bt_av_callbacks, connection_state_cb,
-                BTAV_CONNECTION_STATE_DISCONNECTING, &(btif_av_cb.peer_bda));
+            btif_report_connection_state(BTAV_CONNECTION_STATE_DISCONNECTING, &(btif_av_cb.peer_bda));
 
             /* wait in closing state until fully closed */
             btif_sm_change_state(btif_av_cb.sm_handle, BTIF_AV_STATE_CLOSING);
@@ -866,7 +987,7 @@
             {
                 btif_av_cb.flags &= ~BTIF_AV_FLAG_LOCAL_SUSPEND_PENDING;
 
-               if (btif_av_cb.sep == SEP_SNK)
+               if (btif_av_cb.peer_sep == AVDT_TSEP_SNK)
                {
                 /* suspend failed, reset back tx flush state */
                     btif_a2dp_set_tx_flush(FALSE);
@@ -884,13 +1005,11 @@
                 if ((btif_av_cb.flags & BTIF_AV_FLAG_LOCAL_SUSPEND_PENDING) == 0)
                     btif_av_cb.flags |= BTIF_AV_FLAG_REMOTE_SUSPEND;
 
-                HAL_CBACK(bt_av_callbacks, audio_state_cb,
-                        BTAV_AUDIO_STATE_REMOTE_SUSPEND, &(btif_av_cb.peer_bda));
+                btif_report_audio_state(BTAV_AUDIO_STATE_REMOTE_SUSPEND, &(btif_av_cb.peer_bda));
             }
             else
             {
-                HAL_CBACK(bt_av_callbacks, audio_state_cb,
-                        BTAV_AUDIO_STATE_STOPPED, &(btif_av_cb.peer_bda));
+                btif_report_audio_state(BTAV_AUDIO_STATE_REMOTE_SUSPEND, &(btif_av_cb.peer_bda));
             }
 
             btif_sm_change_state(btif_av_cb.sm_handle, BTIF_AV_STATE_OPENED);
@@ -904,8 +1023,7 @@
             btif_av_cb.flags |= BTIF_AV_FLAG_PENDING_STOP;
             btif_a2dp_on_stopped(&p_av->suspend);
 
-            HAL_CBACK(bt_av_callbacks, audio_state_cb,
-                      BTAV_AUDIO_STATE_STOPPED, &(btif_av_cb.peer_bda));
+            btif_report_audio_state(BTAV_AUDIO_STATE_STOPPED, &(btif_av_cb.peer_bda));
 
             /* if stop was successful, change state to open */
             if (p_av->suspend.status == BTA_AV_SUCCESS)
@@ -913,11 +1031,6 @@
 
             break;
 
-            case BTIF_AV_REQUEST_AUDIO_FOCUS_EVT:
-                HAL_CBACK(bt_av_callbacks, audio_focus_request_cb,
-                                       1, &(btif_av_cb.peer_bda));
-                break;
-
         case BTA_AV_CLOSE_EVT:
 
              btif_av_cb.flags |= BTIF_AV_FLAG_PENDING_STOP;
@@ -926,8 +1039,7 @@
             btif_a2dp_on_stopped(NULL);
 
             /* inform the application that we are disconnected */
-            HAL_CBACK(bt_av_callbacks, connection_state_cb,
-                BTAV_CONNECTION_STATE_DISCONNECTED, &(btif_av_cb.peer_bda));
+            btif_report_connection_state(BTAV_CONNECTION_STATE_DISCONNECTED, &(btif_av_cb.peer_bda));
 
             btif_sm_change_state(btif_av_cb.sm_handle, BTIF_AV_STATE_IDLE);
             break;
@@ -952,17 +1064,135 @@
     btif_sm_dispatch(btif_av_cb.sm_handle, event, (void*)p_param);
 }
 
+void display_meta_msg(tBTA_AV_META_MSG meta_msg)
+{
+    int index, disp_index = 0;
+    char disp_buf[128] = {0};
+
+    BTIF_TRACE_DEBUG3("rc_hndl = %d : comp_id = 0x%x : label = %d",
+        meta_msg.rc_handle, meta_msg.company_id, meta_msg.label);
+
+    BTIF_TRACE_DEBUG4("len = %d : p_data = %p : p_msg = %p : rc_handle = %d",
+        meta_msg.len, meta_msg.p_data, meta_msg.p_msg, meta_msg.rc_handle);
+
+    BTIF_TRACE_DEBUG4("AVRC Msg : Vendor Header: ctype = %d : subunit_type = %d :"
+        "subunit_id = %d : opcode = %d",
+        meta_msg.p_msg->vendor.hdr.ctype, meta_msg.p_msg->vendor.hdr.subunit_type,
+        meta_msg.p_msg->vendor.hdr.subunit_id, meta_msg.p_msg->vendor.hdr.opcode);
+
+    BTIF_TRACE_DEBUG3("AVRC Msg : Vendor: comp_id = 0x%x : p_vendor_data = %p : vendor_len = %d",
+        meta_msg.p_msg->vendor.company_id, meta_msg.p_msg->vendor.p_vendor_data,
+        meta_msg.p_msg->vendor.vendor_len);
+
+    BTIF_TRACE_DEBUG0("Vendor data : ");
+    for (index = 0; index < meta_msg.p_msg->vendor.vendor_len; index++)
+    {
+        disp_index += snprintf(disp_buf + disp_index, 128 - disp_index, "%02x ",
+                                meta_msg.p_msg->vendor.p_vendor_data[index]);
+        if (disp_index % 20 == 0)
+        {
+            BTIF_TRACE_DEBUG1("%s", disp_buf);
+            disp_index = 0;
+        }
+    }
+    if(disp_index != 0)
+    {
+        BTIF_TRACE_DEBUG1("%s", disp_buf);
+    }
+}
+
+void btif_av_msg_copy(UINT16 event, char *p_dest, char *p_src)
+{
+    if (event == BTA_AV_META_MSG_EVT)
+    {
+        tBTA_AV *p_data;
+        tAVRC_MSG *p_avrc;
+        UINT8 *p_vendor_data;
+
+        memcpy(p_dest, p_src, sizeof(tBTA_AV));  /* callback parameter data */
+        p_data = (tBTA_AV *)p_dest;
+
+        p_avrc = (tAVRC_MSG *)GKI_getbuf(sizeof(tAVRC_MSG) +
+                  p_data->meta_msg.p_msg->vendor.vendor_len);
+        if(p_avrc == NULL)
+        {
+            BTIF_TRACE_ERROR0("GKI_getbuf failed : Failed to copy Meta Msg");
+            return;
+        }
+        memcpy(p_avrc, p_data->meta_msg.p_msg, sizeof(tAVRC_MSG));
+        p_vendor_data = (UINT8*)(p_avrc + 1);
+
+        memcpy(p_vendor_data, p_data->meta_msg.p_msg->vendor.p_vendor_data,
+            p_data->meta_msg.p_msg->vendor.vendor_len);
+
+        p_data->meta_msg.p_msg = p_avrc;
+        p_data->meta_msg.p_msg->vendor.p_vendor_data = p_vendor_data;
+    }
+    else if (event == BTA_AV_BROWSE_MSG_EVT)
+    {
+        tBTA_AV *p_data;
+        tAVRC_MSG *p_avrc;
+        UINT8 *p_browse_data;
+
+        memcpy(p_dest, p_src, sizeof(tBTA_AV));
+        p_data = (tBTA_AV *)p_dest;
+
+        p_avrc = (tAVRC_MSG *)GKI_getbuf(sizeof(tAVRC_MSG) +
+                  p_data->browse_msg.p_msg->browse.browse_len);
+        if(p_avrc == NULL)
+        {
+            BTIF_TRACE_ERROR0("GKI_getbuf failed : Failed to copy Browse Msg");
+            return;
+        }
+        memcpy(p_avrc, p_data->browse_msg.p_msg, sizeof(tAVRC_MSG));
+        p_browse_data = (UINT8*)(p_avrc + 1);
+
+        memcpy(p_browse_data, p_data->browse_msg.p_msg->browse.p_browse_data,
+            p_data->browse_msg.p_msg->browse.browse_len);
+
+        p_data->browse_msg.p_msg = p_avrc;
+        p_data->browse_msg.p_msg->browse.p_browse_data = p_browse_data;
+    }
+}
+
 static void bte_av_callback(tBTA_AV_EVT event, tBTA_AV *p_data)
 {
+    int param_len;
+
     /* Switch to BTIF context */
-    btif_transfer_context(btif_av_handle_event, event,
+    /* Special handling for META_MSG because of vendor data pointer */
+    if (event == BTA_AV_META_MSG_EVT)
+    {
+        param_len = sizeof(tAVRC_MSG) + p_data->meta_msg.p_msg->vendor.vendor_len;
+        BTIF_TRACE_DEBUG1(" Meta Message Length %d", param_len);
+
+        display_meta_msg(p_data->meta_msg);
+        btif_transfer_context(btif_av_handle_event, event,
+                          (char*)p_data, sizeof(tBTA_AV), btif_av_msg_copy);
+    }
+    /* Special handling for BROWSE_MSG because of browse data pointer */
+    else if (event == BTA_AV_BROWSE_MSG_EVT)
+    {
+        param_len = sizeof(tAVRC_MSG) + p_data->browse_msg.p_msg->browse.\
+                                                                browse_len;
+        BTIF_TRACE_DEBUG1(" Browse Message Length %d", param_len);
+        btif_transfer_context(btif_av_handle_event, event, (char*)p_data,
+                                        sizeof(tBTA_AV), btif_av_msg_copy);
+    }
+    else
+    {
+        btif_transfer_context(btif_av_handle_event, event,
                           (char*)p_data, sizeof(tBTA_AV), NULL);
+    }
 }
 
 static void bte_av_media_callback(tBTA_AV_EVT event, tBTA_AV_MEDIA *p_data)
 {
     btif_sm_state_t state;
     UINT8 que_len;
+    tA2D_STATUS a2d_status;
+    tA2D_SBC_CIE sbc_cie;
+    btif_av_sink_config_req_t config_req;
 
     if (event == BTA_AV_MEDIA_DATA_EVT)/* Switch to BTIF_MEDIA context */
     {
@@ -977,8 +1207,21 @@
             return;
     }
 
-    if (event == BTA_AV_MEDIA_SINK_CFG_EVT) /* send a command to BT Media Task */
+    if (event == BTA_AV_MEDIA_SINK_CFG_EVT) {
+        /* send a command to BT Media Task */
         btif_reset_decoder((UINT8*)p_data);
+
+        a2d_status = A2D_ParsSbcInfo(&sbc_cie, (UINT8 *)p_data, FALSE);
+        if (a2d_status == A2D_SUCCESS) {
+            /* Switch to BTIF context */
+            config_req.sample_rate = btif_a2dp_get_track_frequency(sbc_cie.samp_freq);
+            config_req.channel_count = btif_a2dp_get_track_channel_count(sbc_cie.ch_mode);
+            btif_transfer_context(btif_av_handle_event, BTIF_AV_SINK_CONFIG_REQ_EVT,
+                                     (char*)&config_req, sizeof(config_req), NULL);
+        } else {
+            APPL_TRACE_ERROR1("ERROR dump_codec_info A2D_ParsSbcInfo fail:%d", a2d_status);
+        }
+    }
 }
 /*******************************************************************************
 **
@@ -990,21 +1233,21 @@
 **
 *******************************************************************************/
 
-bt_status_t btif_av_init(void)
+bt_status_t btif_av_init(int service_id)
 {
     if (btif_av_cb.sm_handle == NULL)
     {
         if (btif_a2dp_start_media_task() != GKI_SUCCESS)
             return BT_STATUS_FAIL;
 
-        btif_enable_service(BTA_A2DP_SERVICE_ID);
+        btif_enable_service(service_id);
 
         /* Also initialize the AV state machine */
         btif_av_cb.sm_handle = btif_sm_init((const btif_sm_handler_t*)btif_av_state_handlers, BTIF_AV_STATE_IDLE);
 
         btif_a2dp_on_init();
 
-        return BT_STATUS_SUCCESS;
+       return BT_STATUS_SUCCESS;
     }
 
     return BT_STATUS_DONE;
@@ -1012,252 +1255,386 @@
 
 /*******************************************************************************
 **
-** Function         init
+** Function         init_src
 **
-** Description      Initializes the AV interface
+** Description      Initializes the AV interface for source mode
 **
 ** Returns          bt_status_t
 **
 *******************************************************************************/
 
-static bt_status_t init(btav_callbacks_t* callbacks )
+static bt_status_t init_src(btav_callbacks_t* callbacks, char * service_name, char * provider_name)
 {
-    int status;
+    bt_status_t status;
 
     BTIF_TRACE_EVENT1("%s", __FUNCTION__);
 
-    if (bt_av_callbacks)
-        return BT_STATUS_DONE;
-
-    bt_av_callbacks = callbacks;
+    if (bt_av_sink_callbacks != NULL) {
+        // already did btif_av_init()
+        status = BT_STATUS_SUCCESS;
+    } else {
+        status = btif_av_init(BTA_A2DP_SRC_SERVICE_ID);
+    }
 
-    memset(&btif_av_cb, 0, sizeof(btif_av_cb_t));
+    if (status == BT_STATUS_SUCCESS) {
+        bt_av_src_callbacks = callbacks;
+    }
 
-    return btif_av_init();
+    return status;
 }
 
 /*******************************************************************************
 **
-** Function         connect
+** Function         init_sink
 **
-** Description      Establishes the AV signalling channel with the remote headset
+** Description      Initializes the AV interface for sink mode
 **
 ** Returns          bt_status_t
 **
 *******************************************************************************/
 
-static bt_status_t connect_int(bt_bdaddr_t *bd_addr)
+static bt_status_t init_sink(btavk_callbacks_t* callbacks)
 {
+    bt_status_t status;
+
     BTIF_TRACE_EVENT1("%s", __FUNCTION__);
 
-    if(btif_storage_is_device_bonded (bd_addr))
-    {
-        btif_sm_dispatch(btif_av_cb.sm_handle, BTIF_AV_CONNECT_REQ_EVT, (char*)bd_addr);
+    if (bt_av_src_callbacks != NULL) {
+        // already did btif_av_init()
+        status = BT_STATUS_SUCCESS;
+    } else {
+        status = btif_av_init(BTA_A2DP_SINK_SERVICE_ID);
     }
-    else
-    {
-        bdstr_t bdstr;
 
-        BTIF_TRACE_ERROR1("## connect_int ## Device Not Bonded : %s", bd2str (bd_addr, &bdstr));
-        /* inform the application of the disconnection as the connection is not processed */
-        HAL_CBACK(bt_av_callbacks, connection_state_cb,
-                         BTAV_CONNECTION_STATE_DISCONNECTED, bd_addr);
-        btif_queue_advance();
+    if (status == BT_STATUS_SUCCESS) {
+        bt_av_sink_callbacks = callbacks;
+        //BTA_AvEnable_Sink(TRUE);
     }
 
-    return BT_STATUS_SUCCESS;
+    return status;
 }
 
-static bt_status_t connect(bt_bdaddr_t *bd_addr)
+#ifdef AVK_BACKPORT
+/*******************************************************************************
+**
+** Function         suspend_sink
+**
+** Description      Suspends stream  in case of A2DP Sink
+**
+** Returns          None
+**
+*******************************************************************************/
+void suspend_sink()
 {
-    CHECK_BTAV_INIT();
+    BTIF_TRACE_DEBUG0(" suspend Stream Suspend called");
+    btif_dispatch_sm_event(BTIF_AV_SUSPEND_STREAM_REQ_EVT, NULL, 0);
+}
 
-    btif_queue_remove_connect(UUID_SERVCLASS_AUDIO_SOURCE, BTIF_QUEUE_CHECK_CONNECT_REQ);
 
-    if(btif_av_cb.bta_handle)
-       return btif_queue_connect(UUID_SERVCLASS_AUDIO_SOURCE, bd_addr, connect_int, BTIF_QUEUE_CONNECT_EVT);
-    else
-       return btif_queue_connect(UUID_SERVCLASS_AUDIO_SOURCE, bd_addr, connect_int, BTIF_QUEUE_PENDING_CONECT_EVT);
+/*******************************************************************************
+**
+** Function         resume_sink
+**
+** Description      Resumes stream  in case of A2DP Sink
+**
+** Returns          None
+**
+*******************************************************************************/
+bt_status_t resume_sink(bt_bdaddr_t *bd_addr)
+{
+    BTIF_TRACE_DEBUG0(" resume Stream called");
+    btif_dispatch_sm_event(BTIF_AV_START_STREAM_REQ_EVT, NULL, 0);
+    return BT_STATUS_SUCCESS;
 }
 
 /*******************************************************************************
 **
-** Function         disconnect
+** Function         audio_focus_status
 **
-** Description      Tears down the AV signalling channel with the remote headset
+** Description      Update Audio Focus State
+**
+** Returns          None
+**
+*******************************************************************************/
+static void audio_focus_status(int state)
+{
+    BTIF_TRACE_DEBUG1(" Audio focus Granted  %d ",state);
+    btif_a2dp_set_audio_focus_state(state);
+}
+/*******************************************************************************
+**
+** Function         btif_av_request_audio_focus
+**
+** Description      Usend request to gain audio focus
+**
+** Returns          void
+**
+*******************************************************************************/
+void btif_av_request_audio_focus( BOOLEAN enable)
+{
+    /* If we are in started state, suspend shld not have been initiated */
+    if ((btif_av_cb.flags & BTIF_AV_FLAG_REMOTE_SUSPEND )||
+        (btif_av_cb.flags & BTIF_AV_FLAG_LOCAL_SUSPEND_PENDING))
+    {
+        return;
+    }
+    if (enable)
+    {
+        //HAL_CBACK(bt_av_sink_callbacks, audio_focus_request_cb,
+          //1, &(btif_av_cb.peer_bda));
+    }
+}
+#endif
+
+#if (A2DP_KERNEL_DIRECT == TRUE)
+/*******************************************************************************
+**
+** Function         start
+**
+** Description     Start streaming
 **
 ** Returns          bt_status_t
 **
 *******************************************************************************/
-static bt_status_t disconnect(bt_bdaddr_t *bd_addr)
+static bt_status_t start(void)
 {
+    BOOLEAN state;
     BTIF_TRACE_EVENT1("%s", __FUNCTION__);
 
     CHECK_BTAV_INIT();
 
     /* Switch to BTIF context */
-    return btif_transfer_context(btif_av_handle_event, BTIF_AV_DISCONNECT_REQ_EVT,
-                                 (char*)bd_addr, sizeof(bt_bdaddr_t), NULL);
+    if ((state = btif_av_is_connected()) == TRUE )
+    {
+          btif_dispatch_sm_event(BTIF_AV_START_STREAM_REQ_EVT,NULL,0);
+//        return btif_transfer_context(btif_av_handle_event, BTIF_AV_START_STREAM_REQ_EVT,
+//                                     NULL, NULL, NULL);
+    }
+    return BT_STATUS_SUCCESS;
 }
 
 /*******************************************************************************
 **
-** Function         cleanup
+** Function         suspend
 **
-** Description      Shuts down the AV interface and does the cleanup
+** Description     suspend streaming
 **
-** Returns          None
+** Returns          bt_status_t
 **
 *******************************************************************************/
-static void cleanup(void)
+static bt_status_t suspend(void)
 {
+    BOOLEAN state;
     BTIF_TRACE_EVENT1("%s", __FUNCTION__);
 
-    if (bt_av_callbacks)
-    {
-        btif_a2dp_stop_media_task();
-
-        btif_disable_service(BTA_A2DP_SERVICE_ID);
-        bt_av_callbacks = NULL;
+    CHECK_BTAV_INIT();
 
-        /* Also shut down the AV state machine */
-        btif_sm_shutdown(btif_av_cb.sm_handle);
-        btif_av_cb.sm_handle = NULL;
+    /* Switch to BTIF context */
+    if ((state = btif_av_is_connected()) == TRUE )
+    {
+         btif_dispatch_sm_event(BTIF_AV_SUSPEND_STREAM_REQ_EVT,NULL,0);
+//        return btif_transfer_context(btif_av_handle_event, BTIF_AV_SUSPEND_STREAM_REQ_EVT,
+//                                     NULL, NULL, NULL);
     }
-    return;
+    return BT_STATUS_SUCCESS;
 }
 
 /*******************************************************************************
 **
-** Function         is_src
+** Function         stop
 **
-** Description      Checks if peer device is A2DP SRC
+** Description     Stop streaming
 **
-** Returns          Success in case peer is A2DP Src, FAIL otherwise
+** Returns          bt_status_t
 **
 *******************************************************************************/
-bt_status_t is_src( bt_bdaddr_t *bd_addr )
+static bt_status_t stop(void)
 {
-    BTIF_TRACE_DEBUG0(" isSrc:  Check if peer device with bd_addr is audio src or sink");
-    if (btif_av_cb.sep == SEP_SRC)
-    {
-        BTIF_TRACE_DEBUG0(" Current Peer is SRC");
-        return BT_STATUS_SUCCESS;
-    }
-    else if (btif_av_cb.sep == SEP_SNK)
-    {
-        BTIF_TRACE_DEBUG0(" Current Peer is SNK");
-        return BT_STATUS_FAIL;
-    }
-    else
+    BOOLEAN state;
+BTIF_TRACE_EVENT1("%s", __FUNCTION__);
+
+    CHECK_BTAV_INIT();
+
+    /* Switch to BTIF context */
+    if ((state = btif_av_is_connected()) == TRUE )
     {
-        BTIF_TRACE_DEBUG0(" Stream not opened till now");
-        return BT_STATUS_NOT_READY;
+        btif_dispatch_sm_event(BTIF_AV_STOP_STREAM_REQ_EVT,NULL,0);
+//        return btif_transfer_context(btif_av_handle_event, BTIF_AV_STOP_STREAM_REQ_EVT,
+//                                     NULL, NULL, NULL);
     }
+    return BT_STATUS_SUCCESS;
+}
+#endif
+
+static bt_status_t get_audio_config(btavk_audio_config_t *btavk_audio_config)
+{
+    BTIF_TRACE_EVENT1("%s", __FUNCTION__);
+    btif_media_get_sbc_config(btavk_audio_config);
+    return BT_STATUS_SUCCESS;
 }
 
 /*******************************************************************************
 **
-** Function         suspend_sink
+** Function         start_sink
 **
-** Description      Suspends stream  in case of A2DP Sink
+** Description      Starts stream  in case of A2DP Sink
 **
 ** Returns          None
 **
 *******************************************************************************/
-void suspend_sink()
+bt_status_t start_sink(bt_bdaddr_t *bd_addr)
 {
-    BTIF_TRACE_DEBUG0(" suspend Stream Suspend called");
-    if (btif_av_cb.sep == SEP_SRC)
-        btif_dispatch_sm_event(BTIF_AV_SUSPEND_STREAM_REQ_EVT, NULL, 0);
+    BTIF_TRACE_DEBUG0(" start Stream called");
+    btif_a2dp_on_sink_ready();
+    btif_dispatch_sm_event(BTIF_AV_START_STREAM_REQ_EVT, NULL, 0);
+    return BT_STATUS_SUCCESS;
 }
 
 /*******************************************************************************
 **
-** Function         resume_sink
+** Function         connect
 **
-** Description      Resumes stream  in case of A2DP Sink
+** Description      Establishes the AV signalling channel with the remote headset
 **
-** Returns          None
+** Returns          bt_status_t
 **
 *******************************************************************************/
-void resume_sink()
+
+static bt_status_t connect_int(bt_bdaddr_t *bd_addr, uint16_t uuid)
 {
-    BTIF_TRACE_DEBUG0(" resume Stream called");
-    if (btif_av_cb.sep == SEP_SRC)
-        btif_dispatch_sm_event(BTIF_AV_START_STREAM_REQ_EVT, NULL, 0);
+    btif_av_connect_req_t connect_req;
+    connect_req.target_bda = bd_addr;
+    connect_req.uuid = uuid;
+    BTIF_TRACE_EVENT1("%s", __FUNCTION__);
+
+    if(btif_storage_is_device_bonded (bd_addr))
+    {
+        btif_sm_dispatch(btif_av_cb.sm_handle, BTIF_AV_CONNECT_REQ_EVT, (char*)&connect_req);
+    }
+    else
+    {
+        bdstr_t bdstr;
+
+        BTIF_TRACE_ERROR1("## connect_int ## Device Not Bonded : %s", bd2str (bd_addr, &bdstr));
+        /* inform the application of the disconnection as the connection is not processed */
+        btif_report_connection_state(BTAV_CONNECTION_STATE_DISCONNECTED,bd_addr);
+        btif_queue_advance();
+    }
+
+    return BT_STATUS_SUCCESS;
+}
+
+static bt_status_t src_connect_sink(bt_bdaddr_t *bd_addr)
+{
+    BTIF_TRACE_EVENT1("%s", __FUNCTION__);
+    CHECK_BTAV_INIT();
+
+    btif_queue_remove_connect(UUID_SERVCLASS_AUDIO_SOURCE, BTIF_QUEUE_CHECK_CONNECT_REQ);
+
+    return btif_queue_connect(UUID_SERVCLASS_AUDIO_SOURCE, bd_addr, connect_int);
+}
+
+static bt_status_t sink_connect_src(bt_bdaddr_t *bd_addr)
+{
+    BTIF_TRACE_EVENT1("%s", __FUNCTION__);
+    CHECK_BTAV_INIT();
+
+    btif_queue_remove_connect(UUID_SERVCLASS_AUDIO_SINK, BTIF_QUEUE_CHECK_CONNECT_REQ);
+
+    return btif_queue_connect(UUID_SERVCLASS_AUDIO_SINK, bd_addr, connect_int);
 }
 
 /*******************************************************************************
 **
-** Function         audio_focus_status
+** Function         disconnect
 **
-** Description      Updates audio focus state
+** Description      Tears down the AV signalling channel with the remote headset
 **
-** Returns          None
+** Returns          bt_status_t
 **
 *******************************************************************************/
-static void audio_focus_status(int state)
+static bt_status_t disconnect(bt_bdaddr_t *bd_addr)
 {
-    BTIF_TRACE_DEBUG1(" Audio Focus granted %d",state);
+    BTIF_TRACE_EVENT1("%s", __FUNCTION__);
 
-    btif_a2dp_set_audio_focus_state(state);
+    CHECK_BTAV_INIT();
+
+    /* Switch to BTIF context */
+    return btif_transfer_context(btif_av_handle_event, BTIF_AV_DISCONNECT_REQ_EVT,
+                                 (char*)bd_addr, sizeof(bt_bdaddr_t), NULL);
 }
 
-static void allow_connection(int is_valid)
+/*******************************************************************************
+**
+** Function         cleanup
+**
+** Description      Shuts down the AV interface and does the cleanup
+**
+** Returns          None
+**
+*******************************************************************************/
+static void cleanup(int service_uuid)
 {
-    BTIF_TRACE_EVENT3(" %s isValid is %d event %d", __FUNCTION__,is_valid,idle_rc_event);
-    switch (idle_rc_event)
+    BTIF_TRACE_EVENT1("%s", __FUNCTION__);
+
+    btif_a2dp_stop_media_task();
+
+    btif_disable_service(service_uuid);
+
+    /* Also shut down the AV state machine */
+    btif_sm_shutdown(btif_av_cb.sm_handle);
+    btif_av_cb.sm_handle = NULL;
+}
+
+static void cleanup_src(void) {
+    BTIF_TRACE_EVENT1("%s", __FUNCTION__);
+
+    if (bt_av_src_callbacks)
     {
-        case BTA_AV_RC_OPEN_EVT:
-            if (is_valid)
-            {
-                memset(&tle_av_open_on_rc, 0, sizeof(tle_av_open_on_rc));
-                tle_av_open_on_rc.param = (UINT32)btif_initiate_av_open_tmr_hdlr;
-                btu_start_timer(&tle_av_open_on_rc, BTU_TTYPE_USER_FUNC,
-                        BTIF_TIMEOUT_AV_OPEN_ON_RC_SECS);
-                btif_rc_handler(idle_rc_event, &idle_rc_data);
-            }
-            else
-            {
-                UINT8 rc_handle =  idle_rc_data.rc_open.rc_handle;
-                BTA_AvCloseRc(rc_handle);
-            }
-            break;
+        bt_av_src_callbacks = NULL;
+        if (bt_av_sink_callbacks == NULL)
+            cleanup(BTA_A2DP_SRC_SERVICE_ID);
+    }
+}
 
-        case BTA_AV_PENDING_EVT:
-            if (is_valid)
-            {
-                BTA_AvOpen(btif_av_cb.peer_bda.address, btif_av_cb.bta_handle,
-                       TRUE, BTA_SEC_AUTHENTICATE);
-            }
-            else
-            {
-                BTA_AvDisconnect(idle_rc_data.pend.bd_addr);
-            }
-            break;
+static void cleanup_sink(void) {
+    BTIF_TRACE_EVENT1("%s", __FUNCTION__);
 
-        default:
-            BTIF_TRACE_WARNING2("%s : unhandled event:%s", __FUNCTION__,
-                                dump_av_sm_event_name(idle_rc_event));
+    if (bt_av_sink_callbacks)
+    {
+        bt_av_sink_callbacks = NULL;
+        if (bt_av_src_callbacks == NULL)
+            cleanup(BTA_A2DP_SINK_SERVICE_ID);
     }
-    idle_rc_event = 0;
-    memset(&idle_rc_data, 0, sizeof(tBTA_AV));
 }
 
-static const btav_interface_t bt_av_interface = {
-    sizeof(btav_interface_t),
-    init,
-    connect,
-    disconnect,
-    cleanup,
-    allow_connection,
-    is_src,
-    suspend_sink,
-    resume_sink,
-    audio_focus_status,
+static const btav_interface_t bt_av_src_interface = {
+    .size = sizeof(btav_interface_t),
+    .init = init_src,
+    .connect = src_connect_sink,
+    .disconnect = disconnect,
+    .start = start,
+    .stop = stop,
+    .suspend = suspend,
+    .cleanup = cleanup_src,
 };
 
+static const btavk_interface_t bt_av_sink_interface = {
+    sizeof(btavk_interface_t),
+    .init = init_sink,
+    .connect = sink_connect_src,
+    .disconnect = disconnect,
+    .start_audio_routing = start_sink,
+    .get_audio_config = get_audio_config,
+    .cleanup = cleanup_sink,
+};
+
+btavk_callbacks_t* btif_av_get_sink_cb(void)
+{
+    return bt_av_sink_callbacks;
+}
+
+
 /*******************************************************************************
 **
 ** Function         btif_av_get_sm_handle
@@ -1290,6 +1667,21 @@
 
 /*******************************************************************************
 **
+** Function         btif_av_get_addr
+**
+** Description      Fetches current AV BD address
+**
+** Returns          BD address
+**
+*******************************************************************************/
+
+UINT8 btif_av_get_peer_sep(void)
+{
+    return btif_av_cb.peer_sep;
+}
+
+/*******************************************************************************
+**
 ** Function         btif_av_stream_ready
 **
 ** Description      Checks whether AV is ready for starting a stream
@@ -1382,19 +1774,57 @@
          /* Added BTA_AV_FEAT_NO_SCO_SSPD - this ensures that the BTA does not
           * auto-suspend av streaming on AG events(SCO or Call). The suspend shall
           * be initiated by the app/audioflinger layers */
+         /* Support for browsing for SDP record should work only if we enable BROWSE
+          * while registering. */
 #if (AVRC_METADATA_INCLUDED == TRUE)
          BTA_AvEnable(BTA_SEC_AUTHENTICATE,
              BTA_AV_FEAT_RCTG|BTA_AV_FEAT_METADATA|BTA_AV_FEAT_VENDOR|BTA_AV_FEAT_NO_SCO_SSPD
 #if (AVRC_ADV_CTRL_INCLUDED == TRUE)
              |BTA_AV_FEAT_RCCT
              |BTA_AV_FEAT_ADV_CTRL
+             |BTA_AV_FEAT_BROWSE
 #endif
              ,bte_av_callback);
 #else
          BTA_AvEnable(BTA_SEC_AUTHENTICATE, (BTA_AV_FEAT_RCTG | BTA_AV_FEAT_NO_SCO_SSPD),
                       bte_av_callback);
 #endif
-         BTA_AvRegister(BTA_AV_CHNL_AUDIO, BTIF_AV_SERVICE_NAME, 0, bte_av_media_callback);
+         BTA_AvRegister(BTA_AV_CHNL_AUDIO, BTIF_AV_SERVICE_NAME, 0, bte_av_media_callback,
+                                                             UUID_SERVCLASS_AUDIO_SOURCE);
+     }
+     else {
+         BTA_AvDeregister(btif_av_cb.bta_handle);
+         BTA_AvDisable();
+     }
+     return BT_STATUS_SUCCESS;
+}
+
+/*******************************************************************************
+**
+** Function         btif_avk_execute_service
+**
+** Description      Initializes/Shuts down the service
+**
+** Returns          BT_STATUS_SUCCESS on success, BT_STATUS_FAIL otherwise
+**
+*******************************************************************************/
+bt_status_t btif_avk_execute_service(BOOLEAN b_enable)
+{
+     if (b_enable)
+     {
+         /* TODO: Removed BTA_SEC_AUTHORIZE since the Java/App does not
+          * handle this request in order to allow incoming connections to succeed.
+          * We need to put this back once support for this is added */
+
+         /* Added BTA_AV_FEAT_NO_SCO_SSPD - this ensures that the BTA does not
+          * auto-suspend av streaming on AG events(SCO or Call). The suspend shall
+          * be initiated by the app/audioflinger layers */
+         BTA_AvEnable(BTA_SEC_AUTHENTICATE, BTA_AV_FEAT_NO_SCO_SSPD|BTA_AV_FEAT_RCCT|
+                                            BTA_AV_FEAT_METADATA|BTA_AV_FEAT_VENDOR|
+                                            BTA_AV_FEAT_ADV_CTRL|BTA_AV_FEAT_RCTG,
+                                                                        bte_av_callback);
+         BTA_AvRegister(BTA_AV_CHNL_AUDIO, BTIF_AVK_SERVICE_NAME, 0, bte_av_media_callback,
+                                                                UUID_SERVCLASS_AUDIO_SINK);
      }
      else {
          BTA_AvDeregister(btif_av_cb.bta_handle);
@@ -1405,17 +1835,32 @@
 
 /*******************************************************************************
 **
-** Function         btif_av_get_interface
+** Function         btif_av_get_src_interface
 **
-** Description      Get the AV callback interface
+** Description      Get the AV callback interface for A2DP source profile
 **
 ** Returns          btav_interface_t
 **
 *******************************************************************************/
-const btav_interface_t *btif_av_get_interface(void)
+const btav_interface_t *btif_av_get_src_interface(void)
+{
+    BTIF_TRACE_EVENT1("%s", __FUNCTION__);
+    return &bt_av_src_interface;
+}
+
+/*******************************************************************************
+**
+** Function         btif_av_get_sink_interface
+**
+** Description      Get the AV callback interface for A2DP sink profile
+**
+** Returns          btav_sink_interface_t
+**
+*******************************************************************************/
+const btavk_interface_t *btif_av_get_sink_interface(void)
 {
     BTIF_TRACE_EVENT1("%s", __FUNCTION__);
-    return &bt_av_interface;
+    return &bt_av_sink_interface;
 }
 
 /*******************************************************************************
@@ -1505,9 +1950,18 @@
     /* inform the application that we are disconnected */
     BTIF_TRACE_DEBUG0("Inform application for disconection ");
     btif_a2dp_on_stopped(NULL);
-    HAL_CBACK(bt_av_callbacks, connection_state_cb,
-              BTAV_CONNECTION_STATE_DISCONNECTED, &(btif_av_cb.peer_bda));
+    if (bt_av_sink_callbacks != NULL)
+    {
+        HAL_CBACK(bt_av_sink_callbacks, connection_state_cb,
+                 BTAV_CONNECTION_STATE_DISCONNECTED, &(btif_av_cb.peer_bda));
+    }
+    else if (bt_av_src_callbacks != NULL)
+    {
+        HAL_CBACK(bt_av_src_callbacks, connection_state_cb,
+                 BTAV_CONNECTION_STATE_DISCONNECTED, &(btif_av_cb.peer_bda));
+    }
 }
+
 /*******************************************************************************
 **
 ** Function         btif_av_move_idle
@@ -1530,8 +1984,7 @@
             (memcmp (&bd_addr, &(btif_av_cb.peer_bda), sizeof(bd_addr)) == 0))
     {
         BTIF_TRACE_DEBUG0("Moving State from Opening to Idle due to ACL disconnect");
-        HAL_CBACK(bt_av_callbacks, connection_state_cb,
-                  BTAV_CONNECTION_STATE_DISCONNECTED, &(btif_av_cb.peer_bda));
+        btif_report_connection_state(BTAV_CONNECTION_STATE_DISCONNECTED, &(btif_av_cb.peer_bda));
         btif_sm_change_state(btif_av_cb.sm_handle, BTIF_AV_STATE_IDLE);
         btif_queue_advance();
     }
diff -Naur '--exclude=.git' bluedroid-orig/btif/src/btif_config.c bluedroid/btif/src/btif_config.c
--- bluedroid-orig/btif/src/btif_config.c	2015-09-24 16:33:43.528227643 +0800
+++ bluedroid/btif/src/btif_config.c	2015-09-24 16:31:37.000000000 +0800
@@ -51,7 +51,11 @@
 #include "btif_sock_util.h"
 
 //#define UNIT_TEST
+#ifdef PLATFORM_ANDROID
 #define CFG_PATH "/data/misc/bluedroid/"
+#else
+#define CFG_PATH "/opt/usr/apps/bluetooth-frwk-service/data/" // For Tizen
+#endif
 #define CFG_FILE_NAME "bt_config"
 #define CFG_FILE_EXT ".xml"
 #define CFG_FILE_EXT_OLD ".old"
diff -Naur '--exclude=.git' bluedroid-orig/btif/src/btif_core.c bluedroid/btif/src/btif_core.c
--- bluedroid-orig/btif/src/btif_core.c	2015-09-24 16:33:43.532227643 +0800
+++ bluedroid/btif/src/btif_core.c	2015-09-24 16:31:37.000000000 +0800
@@ -37,6 +37,7 @@
 #include <dirent.h>
 #include <ctype.h>
 #include <cutils/properties.h>
+#include <hw_rome.h>
 
 #define LOG_TAG "BTIF_CORE"
 #include "btif_api.h"
@@ -51,11 +52,14 @@
 #include "btif_util.h"
 #include "btif_sock.h"
 #include "btif_pan.h"
+#if (defined(BTC_INCLUDED) && BTC_INCLUDED == TRUE)
 #include "btc_common.h"
+#endif
 #include "btif_mce.h"
 #include "btif_profile_queue.h"
 #include "btif_config.h"
 #include "btif_sock_util.h"
+#include "bta_sys.h"
 /************************************************************************************
 **  Constants & Macros
 ************************************************************************************/
@@ -70,6 +74,16 @@
 
 #define BTIF_TASK_STR        ((INT8 *) "BTIF")
 
+#define BT_MEDIA_TASK A2DP_MEDIA_TASK
+
+#define RAMPATCH_DEFAULT_PATH "/lib/firmware/ar3k/rampatch_tlv_usb_3.0.tlv"
+#define RAMPATCH_UPGRADE_PATH "/lib/firmware/ar3k/rampatch_tlv_usb_3.0_upgrade.tlv"
+#define RAMPATCH_BACKUP_PATH "/lib/firmware/ar3k/rampatch_tlv_usb_3.0_backup.tlv"
+
+#define NVM_DEFAULT_PATH "/lib/firmware/ar3k/nvm_tlv_usb_3.0.bin"
+#define NVM_UPGRADE_PATH "/lib/firmware/ar3k/nvm_tlv_usb_3.0_upgrade.bin"
+#define NVM_BACKUP_PATH "/lib/firmware/ar3k/nvm_tlv_usb_3.0_backup.bin"
+
 /************************************************************************************
 **  Local type definitions
 ************************************************************************************/
@@ -77,6 +91,18 @@
 static BOOLEAN bt_disabled = FALSE;
 pthread_mutex_t mutex_bt_disable;
 
+static BOOLEAN hci_disconnect = FALSE;
+static BOOLEAN enter_headless_mode = FALSE;
+
+/* Save the Rampatch version of controller */
+UINT16 fw_patch_version;
+UINT8  upgrade_initiated;
+/* Retrieving the patch info from upgrade file */
+FILE *file;
+unsigned char *phdr_buffer;
+unsigned char *pdata_buffer = NULL;
+unsigned char gTlv_type;
+
 /* These type definitions are used when passing data from the HAL to BTIF context
 *  in the downstream path for the adapter and remote_device property APIs */
 
@@ -140,6 +166,7 @@
 **  Externs
 ************************************************************************************/
 extern void bte_load_did_conf(const char *p_path);
+extern BOOLEAN unconditional_patch_upgrade;
 
 /** TODO: Move these to _common.h */
 void bte_main_boot_entry(void);
@@ -336,6 +363,33 @@
             break;
         }
 
+        /*
+         * Lost HCI communication as transport driver got reloaded: HCI module
+         * is down. Notify OAL about module unplug
+         */
+        if (event == BT_EVT_HCI_DISCONNECT)
+        {
+            BTIF_TRACE_ERROR0("BT_EVT_HCI_DISCONNECT : TRIGGERING CLEANUP");
+
+            /*
+             * This flag is to identify whether cleanup is initiated from upper
+             * layers by calling disable() API or if the cleanup is triggered
+             * internal to the stack as part of driver reload handling case
+             */
+            hci_disconnect = TRUE;
+
+            /*
+             * Not calling btif_disable_bluetooth() as it will send HCI CMDs
+             * for disabling connect and discover ability, which will eventually
+             * timeout as HCI is already down. No further commands can be sent
+             * to the Controller at this stage. So, cleanup the stack and notify
+             * upper-layers that HCI is down via hw_failure_cb() with error code
+             * as 'BT_HW_MODULE_FAILURE'
+             */
+            btif_disable_bluetooth_evt();
+            break;
+        }
+
         if (event & EVENT_MASK(GKI_SHUTDOWN_EVT))
             break;
 
@@ -418,13 +472,30 @@
         val_size = sizeof(val);
         if(btif_config_get_str("Local", "Adapter", "Address", val, &val_size))
         {
-            str2bd(val, local_addr);
-            BTIF_TRACE_DEBUG1("local bdaddr from bt_config.xml is  %s", val);
-            return;
+            BTIF_TRACE_ERROR1("[qcom] addr from config = %s",val);
+            if (strcmp (val,"00:00:00:00:5a:ad") == 0 )
+            {
+                BTIF_TRACE_ERROR0("Default BD address, generate new one");
+                valid_bda = FALSE;
+            }
+            else
+            {
+                str2bd(val, local_addr);
+                BTIF_TRACE_ERROR1("local bdaddr from bt_config.xml is  %s", val);
+                return;
+            }
         }
      }
+/*
+    // No factory BDADDR found. Look for previously generated random BDA
+    property_get(PERSIST_BDADDR_PROPERTY, val, NULL);
+    if(val != NULL){
+       BTIF_TRACE_ERROR0("[qcom]Read BD ADDR from persist property");
+    }
+    else{
+       BTIF_TRACE_ERROR0("[qcom]No BD ADDR from persist property");
+    }
 
-    /* No factory BDADDR found. Look for previously generated random BDA */
     if ((!valid_bda) && \
         (property_get(PERSIST_BDADDR_PROPERTY, val, NULL)))
     {
@@ -434,13 +505,15 @@
             local_addr->address[0], local_addr->address[1], local_addr->address[2],
             local_addr->address[3], local_addr->address[4], local_addr->address[5]);
     }
-
+*/
     /* Generate new BDA if necessary */
+    BTIF_TRACE_ERROR2("Generate random BD ADDR with pid = %d is valid_bda = %d",(unsigned int)getpid(),valid_bda);
     if (!valid_bda)
     {
         bdstr_t bdstr;
         /* Seed the random number generator */
-        srand((unsigned int) (time(0)));
+        //srand((unsigned int) (time(0)));
+        srand((unsigned int) (getpid()));
 
         /* No autogen BDA. Generate one now. */
         local_addr->address[0] = 0x22;
@@ -458,6 +531,7 @@
 
         if (property_set(PERSIST_BDADDR_PROPERTY, (char*)bdstr) < 0)
             BTIF_TRACE_ERROR1("Failed to set random BDA in prop %s",PERSIST_BDADDR_PROPERTY);
+        BTIF_TRACE_ERROR1("[qcom] Random BD ADDR generated = %s",bdstr)
     }
 
     //save the bd address to config file
@@ -586,6 +660,9 @@
     BTIF_TRACE_DEBUG3("%s: status %d, local bd [%s]", __FUNCTION__, status,
                                                      bd2str(&bd_addr, &bdstr));
 
+    BTIF_TRACE_ERROR1("%s: BTIF READ VERSION", __FUNCTION__);
+    btif_read_version_internal();
+
     if (bdcmp(btif_local_bd_addr.address,local_bd))
     {
         bdstr_t buf;
@@ -631,8 +708,8 @@
     /* callback to HAL */
     if (status == BTA_SUCCESS)
     {
-        /* initialize a2dp service */
-        btif_av_init();
+        /* don't initialize a2dp service */
+        //btif_av_init(); // we need av_init only from init_sink, init_src
 
         /* init rfcomm & l2cap api */
         btif_sock_init();
@@ -730,23 +807,47 @@
 {
     BTIF_TRACE_DEBUG1("%s", __FUNCTION__);
 
+    if (btif_core_state == BTIF_CORE_STATE_DISABLED) {
+        BTIF_TRACE_ERROR1("%s: STACK-CLEANUP: ALREADY COMPLETE", __FUNCTION__);
+        return;
+    }
+
+    /* update local state */
+    BTIF_TRACE_ERROR1("%s: STACK-CLEANUP: UPDATE BTIF CORE STATE: "
+        "BTIF_CORE_STATE_DISABLED", __FUNCTION__);
+    btif_core_state = BTIF_CORE_STATE_DISABLED;
+
 #if (defined(HCILP_INCLUDED) && HCILP_INCLUDED == TRUE)
+    BTIF_TRACE_ERROR1("%s: STACK-CLEANUP: DISABLE LPM OPERATION", __FUNCTION__);
     bte_main_enable_lpm(FALSE);
 #endif
 
+    BTIF_TRACE_ERROR1("%s: STACK-CLEANUP: BTE MAIN DISABLE", __FUNCTION__);
     bte_main_disable();
 
-    /* update local state */
-    btif_core_state = BTIF_CORE_STATE_DISABLED;
+    BTIF_TRACE_ERROR1("%s: STACK-CLEANUP: DESTROYING A2DP STOP MEDIA TASK", __FUNCTION__);
+    GKI_destroy_task(BT_MEDIA_TASK);
 
     /* callback to HAL */
-    HAL_CBACK(bt_hal_cbacks, adapter_state_changed_cb, BT_STATE_OFF);
-
-    if (btif_shutdown_pending)
-    {
-        BTIF_TRACE_DEBUG1("%s: calling btif_shutdown_bluetooth", __FUNCTION__);
-        btif_shutdown_bluetooth();
+    if (hci_disconnect) {
+        hci_disconnect = FALSE;
+        if (enter_headless_mode == FALSE) {
+            BTIF_TRACE_ERROR0("Notifying BT_HW_MODULE_FAILURE...");
+            HAL_CBACK(bt_hal_cbacks, hw_failure_cb, BT_HW_MODULE_FAILURE);
+        } else {
+            BTIF_TRACE_ERROR0("EHM IN-PROGRESS: NOTIFY EHM SUCCESS TO OAL...");
+            HAL_CBACK(bt_hal_cbacks, headless_mode_changed_cb, BT_STATUS_SUCCESS);
+        }
+        BTIF_TRACE_ERROR0("SELF-DESTROYING BTIF TASK");
+        GKI_task_self_cleanup(BTIF_TASK);
+    } else {
+        BTIF_TRACE_ERROR1("%s: STACK-CLEANUP: DESTROYING BTIF TASK", __FUNCTION__);
+        GKI_destroy_task(BTIF_TASK);
     }
+    BTIF_TRACE_ERROR1("%s: STACK-CLEANUP: GKI SHUTDOWN", __FUNCTION__);
+    bte_main_shutdown();
+
+    enter_headless_mode = FALSE;
 }
 
 
@@ -775,7 +876,7 @@
 
     if (btif_is_enabled())
     {
-        BTIF_TRACE_WARNING0("shutdown while still enabled, initiate disable");
+        BTIF_TRACE_DEBUG0("shutdown while still enabled, initiate disable");
 
         /* shutdown called prior to disabling, initiate disable */
         btif_disable_bluetooth();
@@ -864,6 +965,7 @@
 **   BTIF Test Mode APIs
 **
 *****************************************************************************/
+#ifndef PLATFORM_ANDROID
 #if HCI_RAW_CMD_INCLUDED == TRUE
 /*******************************************************************************
 **
@@ -879,8 +981,10 @@
     BTIF_TRACE_DEBUG1("%s", __FUNCTION__);
     if(p != NULL)
     {
+#ifdef X86_TEST_INTERFACE
         HAL_CBACK(bt_hal_cbacks, hci_event_recv_cb, p->event_code, p->p_param_buf,
                                                                 p->param_len);
+#endif
     }
 }
 
@@ -901,7 +1005,7 @@
     return BT_STATUS_SUCCESS;
 }
 #endif
-
+#endif
 
 /*******************************************************************************
 **
@@ -1035,6 +1139,10 @@
     bt_bdname_t name, alias;
     uint32_t cod, devtype, trustval;
     bt_uuid_t remote_uuids[BT_MAX_NUM_UUIDS];
+#if 1 // TODO Qualcomm
+    bt_remote_did_t did_info;
+    bt_remote_info_t remote_info;
+#endif
 
     memset(remote_properties, 0, sizeof(remote_properties));
     BTIF_STORAGE_FILL_PROPERTY(&remote_properties[num_props], BT_PROPERTY_BDNAME,
@@ -1049,11 +1157,13 @@
                                             &remote_properties[num_props]);
     num_props++;
 
+#ifdef PLATFORM_ANDROID
     BTIF_STORAGE_FILL_PROPERTY(&remote_properties[num_props], BT_PROPERTY_REMOTE_TRUST_VALUE,
                                sizeof(trustval), &trustval);
     btif_storage_get_remote_device_property(bd_addr,
                                             &remote_properties[num_props]);
     num_props++;
+#endif
 
     BTIF_STORAGE_FILL_PROPERTY(&remote_properties[num_props], BT_PROPERTY_CLASS_OF_DEVICE,
                                sizeof(cod), &cod);
@@ -1073,6 +1183,20 @@
                                             &remote_properties[num_props]);
     num_props++;
 
+#if 1// TODO Qualcomm
+    BTIF_STORAGE_FILL_PROPERTY(&remote_properties[num_props], BT_PROPERTY_REMOTE_DID_INFO,
+                               sizeof(did_info), &did_info);
+    btif_storage_get_remote_device_property(bd_addr,
+                                            &remote_properties[num_props]);
+    num_props++;
+
+    BTIF_STORAGE_FILL_PROPERTY(&remote_properties[num_props], BT_PROPERTY_REMOTE_INFO,
+                               sizeof(remote_info), &remote_info);
+    btif_storage_get_remote_device_property(bd_addr,
+                                            &remote_properties[num_props]);
+    num_props++;
+#endif
+
     HAL_CBACK(bt_hal_cbacks, remote_device_properties_cb,
                      BT_STATUS_SUCCESS, bd_addr, num_props, remote_properties);
 
@@ -1263,11 +1387,13 @@
     {
         case BTIF_DM_SYSTEM_WAKE:
         {
+#ifdef PLATFORM_ANDROID
              if(*(UINT32 *)p_param) {
                  HAL_CBACK(bt_hal_cbacks, wake_state_changed_cb, BT_STATE_ON);
              } else {
                  HAL_CBACK(bt_hal_cbacks, wake_state_changed_cb, BT_STATE_OFF);
              }
+#endif
         } break;
 
         default:
@@ -1398,6 +1524,7 @@
 
                 BTIF_TRACE_EVENT1("set property scan mode : %x", mode);
 
+#ifdef PLATFORM_ANDROID
                 if (!btif_data_profile_registered && mode != BT_SCAN_MODE_NONE)
                 {
                     btif_pending_mode = mode;
@@ -1406,12 +1533,14 @@
                         "data profile(s) are registered");
                     return BT_STATUS_SUCCESS;
                 }
+#endif
                 BTA_DmSetVisibility(disc_mode, conn_mode, BTA_DM_IGNORE, BTA_DM_IGNORE);
 
                 storage_req_id = BTIF_CORE_STORAGE_ADAPTER_WRITE;
             }
             break;
 
+#ifdef PLATFORM_ANDROID
         case BT_PROPERTY_ADAPTER_BLE_ADV_MODE:
             {
                 bt_ble_adv_mode_t mode = *(bt_scan_mode_t*)property->val;
@@ -1454,6 +1583,8 @@
                 storage_req_id = BTIF_CORE_STORAGE_ADAPTER_WRITE;
             }
             break;
+#endif
+
         case BT_PROPERTY_ADAPTER_DISCOVERY_TIMEOUT:
             {
                 /* Nothing to do beside store the value in NV.  Java
@@ -1851,3 +1982,612 @@
         btif_set_adapter_property(&property);
     }
 }
+
+#define READ_VERSION_REQUEST 0x19
+#define EDL_APP_VER_RES_EVT (0x02)
+
+void save_bt_firmware_version_cback(UINT8 *p, UINT8 evt_len)
+{
+    UINT8 status;
+    UINT8 vsc_rsp_evt;
+    UINT8 i;
+
+    BTIF_TRACE_EVENT2("%s vendor event length: 0x%2x", __FUNCTION__, evt_len);
+
+    STREAM_TO_UINT8(status, p);
+    BTIF_TRACE_EVENT2("%s  Status of VSC: %d", __FUNCTION__, status);
+
+    if (status == HCI_SUCCESS) {
+        STREAM_TO_UINT8(vsc_rsp_evt, p);
+        if (vsc_rsp_evt == EDL_APP_VER_RES_EVT) {
+            for (i = 0; i < evt_len; i++)
+                BTIF_TRACE_EVENT3("%s: p[%d]:0x%x", __FUNCTION__, i, p[i]);
+            fw_patch_version = (p[5] << 8 | p[4]);
+            BTIF_TRACE_EVENT2("%s: BT FIRMWARE VERSION: 0x%2x", __FUNCTION__, fw_patch_version);
+        }
+        if (upgrade_initiated) {
+            BTIF_TRACE_ERROR1("%s: Check FW Upgrade Status", __func__);
+            btif_hw_chip_firmware_update_callback();
+            upgrade_initiated = 0;
+        } else
+            BTIF_TRACE_ERROR1("%s: No upgrade was initiaed", __func__);
+    }
+}
+
+
+void btif_read_version_cback(tBTM_VSC_CMPL *p_params)
+{
+    UINT8  *p = p_params->p_param_buf;
+    UINT8  status = 0;
+
+    status = (UINT8)(*(p));
+
+    if (upgrade_initiated) {
+        BTIF_TRACE_ERROR1("%s: Check FW Upgrade Status", __func__);
+        btif_hw_chip_firmware_update_callback();
+        upgrade_initiated = 0;
+    } else
+        BTIF_TRACE_ERROR1("%s: No upgrade was initiaed", __func__);
+
+    //BTIF_TRACE_ERROR1("btif_read_version_cback = %d", status);
+    //HAL_CBACK(bt_hal_cbacks, read_firmware_version_cb, p);
+}
+
+int rome_get_tlv_file(char *file_path)
+{
+    FILE * pFile;
+    long fileSize;
+    int readSize, err = 0, total_segment, remain_size, nvm_length, nvm_index, i;
+    unsigned short nvm_tag_len;
+    tlv_patch_info *ptlv_header;
+    tlv_nvm_hdr *nvm_ptr;
+    unsigned char data_buf[PRINT_BUF_SIZE]={0,};
+    unsigned char *nvm_byte_ptr;
+    unsigned short patch_version;
+
+    BTIF_TRACE_ERROR2("%s: File Open (%s)", __FUNCTION__, file_path);
+    pFile = fopen ( file_path , "r" );
+    if (pFile==NULL) {
+        BTIF_TRACE_ERROR2("%s: File Open failed: (%s)", __FUNCTION__, file_path);
+        return -1;
+    }
+
+     BTIF_TRACE_ERROR1("%s: File open successful", __FUNCTION__);
+
+    /* Get File Size */
+    fseek (pFile , 0 , SEEK_END);
+    fileSize = ftell (pFile);
+    rewind (pFile);
+
+    BTIF_TRACE_ERROR2("%s: File size: %d", __FUNCTION__, fileSize);
+
+    pdata_buffer = (unsigned char*) malloc (sizeof(char)*fileSize);
+    if (pdata_buffer == NULL) {
+        BTIF_TRACE_ERROR0("Allocated Memory failed");
+        fclose (pFile);
+        return -1;
+    }
+
+    /* Copy file into allocated buffer */
+    readSize = fread (pdata_buffer,1,fileSize,pFile);
+
+    /* File Close */
+    fclose (pFile);
+
+    if (readSize != fileSize) {
+        BTIF_TRACE_ERROR2("Read file size(%d) not matched with actual file size (%ld bytes)",readSize,fileSize);
+        return -1;
+    }
+
+    ptlv_header = (tlv_patch_info *) pdata_buffer;
+
+    /* To handle different event between rampatch and NVM */
+    gTlv_type = ptlv_header->tlv_type;
+
+    BTIF_TRACE_ERROR2("%s: Type of patch: %d", __FUNCTION__, gTlv_type);
+
+    patch_version = ptlv_header->tlv.patch.patch_ver;
+    BTIF_TRACE_ERROR2("%s: Version of patch in the upgrade file: 0x%x", __FUNCTION__, patch_version);
+
+    if(ptlv_header->tlv_type == TLV_TYPE_PATCH){
+        BTIF_TRACE_ERROR0("====================================================");
+        BTIF_TRACE_ERROR1("TLV Type\t\t\t : 0x%x", ptlv_header->tlv_type);
+        BTIF_TRACE_ERROR1("Length\t\t\t : %d bytes", (ptlv_header->tlv_length1) |
+                                                    (ptlv_header->tlv_length2 << 8) |
+                                                    (ptlv_header->tlv_length3 << 16));
+        BTIF_TRACE_ERROR1("Total Length\t\t : %d bytes", ptlv_header->tlv.patch.tlv_data_len);
+        BTIF_TRACE_ERROR1("Patch Data Length\t\t\t : %d bytes",ptlv_header->tlv.patch.tlv_patch_data_len);
+        BTIF_TRACE_ERROR1("Signing Format Version\t : 0x%x", ptlv_header->tlv.patch.sign_ver);
+        BTIF_TRACE_ERROR1("Signature Algorithm\t : 0x%x", ptlv_header->tlv.patch.sign_algorithm);
+        BTIF_TRACE_ERROR1("Reserved\t\t\t : 0x%x", ptlv_header->tlv.patch.reserved1);
+        BTIF_TRACE_ERROR1("Product ID\t\t : 0x%04x\n", ptlv_header->tlv.patch.prod_id);
+        BTIF_TRACE_ERROR1("Rom Build Version\t\t : 0x%04x\n", ptlv_header->tlv.patch.build_ver);
+        BTIF_TRACE_ERROR1("Patch Version\t\t : 0x%04x\n", ptlv_header->tlv.patch.patch_ver);
+        BTIF_TRACE_ERROR1("Reserved\t\t\t : 0x%x\n", ptlv_header->tlv.patch.reserved2);
+        BTIF_TRACE_ERROR1("Patch Entry Address\t : 0x%x\n", (ptlv_header->tlv.patch.patch_entry_addr));
+        BTIF_TRACE_ERROR0("====================================================");
+
+    }
+    return patch_version;
+}
+
+/*******************************************************************************
+**
+** Function         btif_read_last_memory_content
+**
+** Description      Read the last memory contents from the flash
+**
+** Returns          BT_STATUS_SUCCESS on success
+**
+*******************************************************************************/
+void btif_read_last_memory_content_cback(tBTM_VSC_CMPL *p_params)
+{
+    BTIF_TRACE_DEBUG1("%s:", __FUNCTION__);
+}
+
+bt_status_t btif_read_last_memory_content(void)
+{
+    /* Send VSC for reading the last memory cocntents from flash */
+    BTIF_TRACE_ERROR1("%s: READING LAST MEMORY CONTENTS FROM FLASH...",
+       __FUNCTION__);
+    BTA_DmVendorSpecificCommand(HCI_VSC_READ_LAST_MEMORY,
+        0, NULL, btif_read_last_memory_content_cback);
+
+}
+/*******************************************************************************
+**
+** Function         btif_hw_chip_firmware_update
+**
+** Description      Updates the firmware on the BT Controller
+**
+** Returns          BT_STATUS_SUCCESS on success
+**
+*******************************************************************************/
+bt_status_t btif_hw_chip_firmware_update(void)
+{
+    UINT8 err = -1;
+    int upgrade_ramp_file_patch_version;
+    int upgrade_nvm_file_patch_version;
+    /*
+     * Check if the firmware file is present for upgrade
+     * Check if the firmware version in the upgrade file is
+     * higher than the current version in the flash
+     */
+    BTIF_TRACE_ERROR1("%s: Checking the patch version of the upgrade file...", __FUNCTION__);
+    upgrade_ramp_file_patch_version = rome_get_tlv_file(RAMPATCH_UPGRADE_PATH);
+
+    if (upgrade_ramp_file_patch_version < 0) {
+        BTIF_TRACE_ERROR1("%s: Firmware rampatch Upgrade file not present", __func__);
+        return BT_STATUS_FAIL;
+    }
+
+    upgrade_nvm_file_patch_version = rome_get_tlv_file(NVM_UPGRADE_PATH);
+    if (upgrade_nvm_file_patch_version < 0) {
+        BTIF_TRACE_ERROR1("%s: Firmware nvm upgrade file not present", __func__);
+        return BT_STATUS_FAIL;
+    }
+    if ((upgrade_ramp_file_patch_version > fw_patch_version)|| (TRUE == unconditional_patch_upgrade)) {
+        
+        if(TRUE == unconditional_patch_upgrade) {
+           BTIF_TRACE_ERROR1("%s: Unconditional Patch upgrade is configured true", __FUNCTION__); 
+        }
+      
+        BTIF_TRACE_ERROR2("<FW VER IN IN FLASH: 0x%x> <FW VER IN UPGRADE FILE: 0x%x> UPGRADE IN PROGRESS...",
+             fw_patch_version, upgrade_ramp_file_patch_version);
+
+        /* Backup the existing FW file prior to upgrade */
+        err = rename(RAMPATCH_DEFAULT_PATH, RAMPATCH_BACKUP_PATH);
+        if (err == 0) {
+            BTIF_TRACE_ERROR1("%s: Backup of default RAMPATCH file success", __FUNCTION__);
+        } else {
+            BTIF_TRACE_ERROR1("%s: Couldn't backup default RAMPATCH file!!!", __FUNCTION__);
+        }
+
+        /* Rename the upgrade FW file prior as default FW file */
+        err = rename(RAMPATCH_UPGRADE_PATH, RAMPATCH_DEFAULT_PATH);
+        if (err == 0) {
+            BTIF_TRACE_ERROR1("%s: Upgrade RAMPATCH file ready for download", __FUNCTION__);
+        } else {
+            BTIF_TRACE_ERROR1("%s: File System error caused upgrade failure!!!", __FUNCTION__);
+        }
+
+        /* Backup the existing NVM file prior to upgrade */
+        err = rename(NVM_DEFAULT_PATH, NVM_BACKUP_PATH);
+        if (err == 0) {
+            BTIF_TRACE_ERROR1("%s: Backup of default MVM file success", __FUNCTION__);
+        } else {
+            BTIF_TRACE_ERROR1("%s: Couldn't backup default NVM file!!!", __FUNCTION__);
+        }
+
+        /* Rename the upgrade NVM file prior as default FW file */
+        err = rename(NVM_UPGRADE_PATH, NVM_DEFAULT_PATH);
+        if (err == 0) {
+            BTIF_TRACE_ERROR1("%s: Upgrade NVM file ready for download", __FUNCTION__);
+        } else {
+            BTIF_TRACE_ERROR1("%s: File System error caused upgrade failure!!!", __FUNCTION__);
+        }
+
+        /* Update that FW UPgrade is in progress */
+        upgrade_initiated = 1;
+
+        /* Send VSC for erasing existing FW */
+        BTIF_TRACE_ERROR1("%s: Sending VSC to erase existing FW and upgrade the new FW...", __FUNCTION__);
+        BTA_DmVendorSpecificCommand(HCI_VSC_DETACH_PATCH,
+            0, NULL, btif_read_version_cback);
+
+    } else
+        BTIF_TRACE_ERROR2("Firmware version: 0x%x in flash is higher than upgrade firmware file: 0x%x!! NO UPGRADE REQUIRED",
+            fw_patch_version, upgrade_ramp_file_patch_version);
+
+    return BT_STATUS_SUCCESS;
+}
+
+void btif_restore_backup_fw(void)
+{
+    int err;
+
+    BTIF_TRACE_ERROR1("%s: Restoring the previous good backup FW...", __FUNCTION__);
+
+    /* Restore the backup RAMPATCH file as the default file */
+    err = rename(RAMPATCH_BACKUP_PATH, RAMPATCH_DEFAULT_PATH);
+    if (err == 0) {
+        BTIF_TRACE_ERROR1("%s: Restore of backup RAMPATCH file success", __FUNCTION__);
+    } else {
+        /* Should not reach here!! */
+        BTIF_TRACE_ERROR1("%s: Couldn't restore the backup RAMPATCH file as default!!!", __FUNCTION__);
+    }
+
+    /* Restore the backup NVM file as the default file */
+    err = rename(NVM_BACKUP_PATH, NVM_DEFAULT_PATH);
+    if (err == 0) {
+        BTIF_TRACE_ERROR1("%s: Restore of backup NVM file success", __FUNCTION__);
+    } else {
+        /* Should not reach here!! */
+        BTIF_TRACE_ERROR1("%s: Couldn't restore the backup NVM file as default!!!", __FUNCTION__);
+    }
+}
+
+
+//TODO: Provide FW Update Status to OAL
+/*******************************************************************************
+**
+** Function         Callback to OAL for providing the FW Update Status
+**
+** Description      Compare the version in the backup and default file to
+**                  determine if the upgrade happened or not.
+**
+** Returns          BT_STATUS_SUCCESS on success
+**
+*******************************************************************************/
+bt_status_t btif_hw_chip_firmware_update_callback(void)
+{
+    UINT16 prev_patch_version;
+
+    BTIF_TRACE_ERROR1("%s: Checking if the upgrade succeeded...", __FUNCTION__);
+
+    /* Retrieve the Rampatch version of the previous file */
+    prev_patch_version = rome_get_tlv_file(RAMPATCH_BACKUP_PATH);
+
+    BTIF_TRACE_ERROR2("FW VER IN IN FLASH: <0x%x> && Previous FW VER: <0x%x>",
+        fw_patch_version, prev_patch_version);
+
+    /*
+     * Compare the Rampatch version of previous file with the current Rampatch
+     * version present in the Controller. If former is greater than later, then
+     * firmware upgrade failed because of upgrade Rampatch file had bad
+     * CRC/Signature. Hence, Controller did not save to flash.
+     */
+    if (prev_patch_version > fw_patch_version) {
+        BTIF_TRACE_ERROR2("BT FW upgrade failed as FW VER IN IN FLASH: <0x%x> "
+            "lower than previous FW VER : <0x%x>!!!", fw_patch_version,
+            prev_patch_version);
+
+        if (TRUE == unconditional_patch_upgrade)
+        {
+            BTIF_TRACE_ERROR0("not rolling back due to unconditional_patch_upgrade");
+        }
+        else
+        {
+            BTIF_TRACE_ERROR0("rolling back firmware patch");
+
+           /* Emergency FW D/W handling */
+           btif_restore_backup_fw();
+
+           /* TODO:
+            * Notify OAL on the status of the FW Upgrade via registered callback
+            * function. OAL has to reload the driver and as part of driver probe()
+            * call, the restored good backed FW file will be downloaded.
+           */
+           return BT_STATUS_FAIL;
+        }
+    }
+
+    /* TODO: Invoke the FW Upgrade cback registered by OAL to notify status */
+    BTIF_TRACE_ERROR1("%s: BT FW Upgrade Succeeded", __FUNCTION__);
+    return BT_STATUS_SUCCESS;
+}
+
+/*******************************************************************************
+**
+** Function         btif_read_version
+**
+** Description     Sends a HCI Vendor specific command to the controller
+**
+** Returns          BT_STATUS_SUCCESS on success
+**
+*******************************************************************************/
+bt_status_t btif_read_version(btif_fw_version_t *version)
+{
+    if (version == NULL)
+        return BT_STATUS_FAIL;
+
+#ifdef X86_TEST_INTERFACE
+    /* Return the already fetched version */
+    version->patch_version = fw_patch_version;
+
+    /* Call the registered callback function */
+    HAL_CBACK(bt_hal_cbacks, read_firmware_version_cb, (UINT8 *)version);
+#endif
+
+    /* Issue the VSC to query the version, in case anything changed */
+    BTIF_TRACE_ERROR1("%s: Issue the VSC to query the version, in case anything changed", __FUNCTION__);
+    btif_read_version_internal();
+
+    return BT_STATUS_SUCCESS;
+}
+
+bt_status_t btif_read_version_internal()
+{
+    uint8_t patch_version = READ_VERSION_REQUEST;
+    BTIF_TRACE_ERROR1("%s", __FUNCTION__);
+
+    BTA_DmVendorSpecificCommand(HCI_GRP_VENDOR_SPECIFIC,
+        1, &patch_version, btif_read_version_cback);
+
+    return BT_STATUS_SUCCESS;
+}
+
+void btif_enter_headless_mode_cback(tBTM_VSC_CMPL *p_params)
+{
+    UINT8  *p = p_params->p_param_buf;
+    UINT8  status = 0;
+
+    STREAM_TO_UINT8(status, p);
+    BTIF_TRACE_ERROR3("%s: View of the callbacks structure: \n\t OAL CB struct size: %d \n\t"
+        " BT-STACK CB struct size: %d", __func__, bt_hal_cbacks->size, sizeof(bt_callbacks_t));
+
+    BTIF_TRACE_DEBUG1("enter_headless_mode status=%d", status);
+
+    if (status == HCI_SUCCESS)
+    {
+        HAL_CBACK(bt_hal_cbacks, headless_mode_changed_cb, BT_STATUS_SUCCESS);
+    }
+    else
+    {
+        HAL_CBACK(bt_hal_cbacks, headless_mode_changed_cb, BT_STATUS_FAIL);
+    }
+}
+
+void btif_add_headless_mode_wakeup_device_cback(tBTM_VSC_CMPL *p_params)
+{
+    UINT8  *p = p_params->p_param_buf;
+    UINT8  status = 0;
+
+    STREAM_TO_UINT8(status, p);
+
+    BTIF_TRACE_DEBUG1("add_headless_mode_wakeup_device status=%d", status);
+    btif_read_last_memory_content();
+}
+
+void btif_add_av_dev_to_headless_mode_cback(tBTM_VSC_CMPL *p_params)
+{
+    UINT8  *p = p_params->p_param_buf;
+    UINT8  status = 0;
+
+    STREAM_TO_UINT8(status, p);
+
+    BTIF_TRACE_DEBUG1("add_av_dev_to_headless_mode status=%d", status);
+
+    if (status == HCI_SUCCESS)
+    {
+        HAL_CBACK(bt_hal_cbacks, add_av_headless_wakeup_cb, BT_STATUS_SUCCESS);
+    }
+    else
+    {
+        HAL_CBACK(bt_hal_cbacks, add_av_headless_wakeup_cb, BT_STATUS_FAIL);
+    }
+}
+
+void btif_delete_headless_mode_wakeup_device_cback(tBTM_VSC_CMPL *p_params)
+{
+    UINT8  *p = p_params->p_param_buf;
+    UINT8  status = 0;
+
+    STREAM_TO_UINT8(status, p);
+
+    BTIF_TRACE_DEBUG1("delete_headless_mode_wakeup_device status=%d", status);
+}
+
+void btif_bt_wake_up_test_cback(tBTM_VSC_CMPL *p_params)
+{
+    UINT8  *p = p_params->p_param_buf;
+    UINT8  status = 0;
+
+    STREAM_TO_UINT8(status, p);
+
+    BTIF_TRACE_DEBUG1("bt_wake_up_test status=%d", status);
+}
+
+void btif_set_headless_le_adv_data_cback(tBTM_VSC_CMPL *p_params)
+{
+    UINT8  *p = p_params->p_param_buf;
+    UINT8  status = 0;
+
+    STREAM_TO_UINT8(status, p);
+
+    BTIF_TRACE_DEBUG1("set_headless_le_adv_data status=%d", status);
+}
+
+void btif_set_headless_scan_configure_cback(tBTM_VSC_CMPL *p_params)
+{
+    UINT8  *p = p_params->p_param_buf;
+    UINT8  status = 0;
+
+    STREAM_TO_UINT8(status, p);
+
+    BTIF_TRACE_DEBUG1("set_headless_scan_configure status=%d", status);
+}
+
+/*******************************************************************************
+**
+** Function         btif_enter_headless_mode
+**
+** Description     Sends a HCI Vendor specific command to the controller
+**
+** Returns          BT_STATUS_SUCCESS on success
+**
+*******************************************************************************/
+bt_status_t btif_enter_headless_mode(void)
+{
+    BTIF_TRACE_DEBUG1("%s", __FUNCTION__);
+
+    enter_headless_mode = TRUE;
+
+    BTA_DmVendorSpecificCommand(HCI_VSC_HEADLESS_ENABLE,
+                                     0, NULL, btif_enter_headless_mode_cback);
+
+    /* Trigger the initial level of profile cleanup */
+    BTIF_TRACE_ERROR1("%s: STACK-CLEANUP: UNREG. BT SUB-SYSTEM", __FUNCTION__);
+    bta_sys_disable(BTA_SYS_HW_BLUETOOTH);
+
+    /* cleanup rfcomm & l2cap api */
+    BTIF_TRACE_ERROR1("%s: STACK-CLEANUP: RFCOMM-L2CAP CLEANUP", __FUNCTION__);
+    btif_sock_cleanup();
+
+    BTIF_TRACE_ERROR1("%s: STACK-CLEANUP: PAN CLEANUP", __FUNCTION__);
+    btif_pan_cleanup();
+
+    BTIF_TRACE_ERROR1("%s: STACK-CLEANUP: PROFILE-Q CLEANUP", __FUNCTION__);
+    btif_queue_release();
+
+    return BT_STATUS_SUCCESS;
+}
+
+/*******************************************************************************
+**
+** Function         btif_add_headless_mode_wakeup_device
+**
+** Description     Sends a HCI Vendor specific command to the controller
+**
+** Returns          BT_STATUS_SUCCESS on success
+**
+*******************************************************************************/
+bt_status_t btif_add_headless_mode_wakeup_device(bt_bdaddr_t *remote_addr)
+{
+    BTIF_TRACE_DEBUG1("%s", __FUNCTION__);
+
+    BTA_DmVendorSpecificCommand(HCI_VSC_HEADLESS_DEV_ADD,
+                                     HCI_VSC_HEADLESS_DEV_ADD_DEL_PARAM_SIZE,
+                                     (UINT8 *)remote_addr, btif_add_headless_mode_wakeup_device_cback);
+
+    return BT_STATUS_SUCCESS;
+}
+
+/*******************************************************************************
+**
+** Function         btif_add_av_dev_to_headless_mode
+**
+** Description     Sends a HCI Vendor specific command to the controller
+**
+** Returns          BT_STATUS_SUCCESS on success
+**
+*******************************************************************************/
+bt_status_t btif_add_av_dev_to_headless_mode(bt_bdaddr_t *remote_addr)
+{
+    /* TODO: Check that opcode is a vendor command group */
+    BTIF_TRACE_DEBUG1("%s", __FUNCTION__);
+
+    BTA_DmVendorSpecificCommand(HCI_VSC_ADD_AV_DEVICE_TO_HEADLESS,
+                                     HCI_VSC_HEADLESS_DEV_ADD_DEL_PARAM_SIZE,
+                                     (UINT8 *)remote_addr, btif_add_av_dev_to_headless_mode_cback);
+
+    return BT_STATUS_SUCCESS;
+}
+
+/*******************************************************************************
+**
+** Function         btif_delete_headless_mode_wakeup_device
+**
+** Description     Sends a HCI Vendor specific command to the controller
+**
+** Returns          BT_STATUS_SUCCESS on success
+**
+*******************************************************************************/
+bt_status_t btif_delete_headless_mode_wakeup_device(bt_bdaddr_t *remote_addr)
+{
+    /* TODO: Check that opcode is a vendor command group */
+    BTIF_TRACE_DEBUG1("%s", __FUNCTION__);
+
+    BTA_DmVendorSpecificCommand(HCI_VSC_HEADLESS_DEV_DEL,
+                                     HCI_VSC_HEADLESS_DEV_ADD_DEL_PARAM_SIZE,
+                                     (UINT8 *)remote_addr, btif_delete_headless_mode_wakeup_device_cback);
+
+    return BT_STATUS_SUCCESS;
+}
+
+/*******************************************************************************
+**
+** Function         btif_bt_wake_up_test
+**
+** Description     Sends a HCI Vendor specific command to the controller
+**
+** Returns          BT_STATUS_SUCCESS on success
+**
+*******************************************************************************/
+bt_status_t btif_bt_wake_up_test(void)
+{
+    BTIF_TRACE_DEBUG1("%s", __FUNCTION__);
+
+    BTA_DmVendorSpecificCommand(HCI_VSC_ENABLE_WAKE_UP_TEST,
+                                     0, NULL, btif_bt_wake_up_test_cback);
+
+    return BT_STATUS_SUCCESS;
+}
+
+/*******************************************************************************
+**
+** Function         btif_set_headless_le_adv_data
+**
+** Description     Sends a HCI Vendor specific command to the controller
+**
+** Returns          BT_STATUS_SUCCESS on success
+**
+*******************************************************************************/
+bt_status_t btif_set_headless_le_adv_data(uint8_t *buf, uint8_t len)
+{
+    BTIF_TRACE_DEBUG1("%s", __FUNCTION__);
+
+    BTA_DmVendorSpecificCommand(HCI_VSC_HEADLESS_SET_LE_ADV_DATA,
+                                     len, buf, btif_set_headless_le_adv_data_cback);
+
+    return BT_STATUS_SUCCESS;
+}
+
+/*******************************************************************************
+**
+** Function         btif_set_headless_scan_configure
+**
+** Description     Sends a HCI Vendor specific command to the controller
+**
+** Returns          BT_STATUS_SUCCESS on success
+**
+*******************************************************************************/
+bt_status_t btif_set_headless_scan_configure(uint8_t *buf, uint8_t len)
+{
+    BTIF_TRACE_DEBUG1("%s", __FUNCTION__);
+
+    BTA_DmVendorSpecificCommand(HCI_VSC_HEADLESS_SET_SCAN_MODE,
+                                     len, buf, btif_set_headless_scan_configure_cback);
+
+    return BT_STATUS_SUCCESS;
+}
diff -Naur '--exclude=.git' bluedroid-orig/btif/src/btif_dm.c bluedroid/btif/src/btif_dm.c
--- bluedroid-orig/btif/src/btif_dm.c	2015-09-24 16:33:43.532227643 +0800
+++ bluedroid/btif/src/btif_dm.c	2015-09-24 16:31:37.000000000 +0800
@@ -169,7 +169,9 @@
 extern bt_status_t btif_hf_execute_service(BOOLEAN b_enable);
 extern bt_status_t btif_multihf_execute_service(BOOLEAN b_enable);
 extern bt_status_t btif_av_execute_service(BOOLEAN b_enable);
+extern bt_status_t btif_avk_execute_service(BOOLEAN b_enable);
 extern bt_status_t btif_hh_execute_service(BOOLEAN b_enable);
+extern bt_status_t btif_3d_execute_service(BOOLEAN b_enable);
 extern bt_status_t btif_mce_execute_service(BOOLEAN b_enable);
 extern bt_status_t btif_hf_client_execute_service(BOOLEAN b_enable);
 extern int btif_hh_connect(bt_bdaddr_t *bd_addr);
@@ -185,7 +187,13 @@
 extern void btif_av_move_idle(bt_bdaddr_t bd_addr);
 extern BOOLEAN btif_is_multi_hf_supported();
 
-
+enum
+{
+  REJ_CURR_CB_NEXT_REQ = 0, //Reject current connect request,HAL CB next req
+  REJ_CURR_AUTO_REJ_NEXT_REQ,//Reject current connect request, auto reject next req
+  ACP_CURR_CB_NEXT_REQ,      //Acp current connect request, HAL CB next req
+  ACP_CURR_AUTO_ACP_NEX_REQ, //Acp current connect request, Auto accept next req
+}authorize_status;
 /******************************************************************************
 **  Functions
 ******************************************************************************/
@@ -204,10 +212,14 @@
               else
                   btif_hf_execute_service(b_enable);
          }break;
-         case BTA_A2DP_SERVICE_ID:
+         case BTA_A2DP_SRC_SERVICE_ID:
          {
               btif_av_execute_service(b_enable);
          }break;
+         case BTA_A2DP_SINK_SERVICE_ID:
+         {
+              btif_avk_execute_service(b_enable);
+         }break;
          case BTA_HID_SERVICE_ID:
          {
               btif_hh_execute_service(b_enable);
@@ -224,6 +236,10 @@
          {
               btif_hd_execute_service(b_enable);
          }break;
+         case BTA_3D_SERVICE_ID:
+         {
+              btif_3d_execute_service(b_enable);
+         }break;
          default:
               BTIF_TRACE_ERROR1("%s: Unknown service being enabled", __FUNCTION__);
               return BT_STATUS_FAIL;
@@ -876,8 +892,14 @@
             }
         }
     }
+#ifdef PLATFORM_ANDROID
     HAL_CBACK(bt_hal_cbacks, pin_request_cb,
                      &bd_addr, &bd_name, cod, secure);
+#else
+    HAL_CBACK(bt_hal_cbacks, pin_request_cb,
+                     &bd_addr, &bd_name, cod);
+
+#endif
 }
 
 /*******************************************************************************
@@ -1069,7 +1091,11 @@
                 break;
 
             case HCI_ERR_PAIRING_NOT_ALLOWED:
+#ifdef PLATFORM_ANDROID
                 status = BT_STATUS_AUTH_REJECTED;
+#else
+		status = BT_STATUS_AUTH_FAILURE;
+#endif
                 break;
 
 
@@ -1410,6 +1436,7 @@
                 num_properties++;
             }
 
+#ifdef PLATFORM_ANDROID
             /* Remote name update */
             if (strlen((const char *) p_data->disc_res.bd_name))
             {
@@ -1421,6 +1448,7 @@
                 ASSERTC(ret == BT_STATUS_SUCCESS, "failed to save remote device property", ret);
                 num_properties++;
             }
+#endif
 
             if(num_properties > 0)
             {
@@ -1428,10 +1456,66 @@
                 HAL_CBACK(bt_hal_cbacks, remote_device_properties_cb,
                                  BT_STATUS_SUCCESS, &bd_addr, num_properties, prop);
             }
+#ifndef PLATFORM_ANDROID // TODO set the DID info values for temp to make connection successfully.
+            {
+                bt_remote_did_t did_info;
+
+#if 1 // TODO Qualcomm - temp code
+                memset(&did_info, 0, sizeof(did_info));
+#endif
+          
+                prop[0].type = BT_PROPERTY_REMOTE_DID_INFO;
+                prop[0].val = &did_info;
+                prop[0].len = sizeof(did_info);
+                ret = btif_storage_get_remote_device_property(&bd_addr,&prop[0]);
+                if (ret != BT_STATUS_SUCCESS)
+                {
+                    prop[0].val = NULL;
+                    prop[0].len = 0;
+                }
+                else
+                {
+                    BTIF_TRACE_ERROR6("%s Specid = %x, Vendor = %x, Vendor ID = %x, Prodct ID = %x Version = %x",
+                                       __func__,did_info.spec_id,did_info.vendor,did_info.vendor_id_source,
+                                      did_info.product,did_info.version);
+                }
 
+                /* Send the event to the BTIF */
+                HAL_CBACK(bt_hal_cbacks, remote_device_properties_cb,
+                                 BT_STATUS_SUCCESS, &bd_addr, 1, prop);
+            }
+#endif
         }
         break;
-
+#ifndef PLATFORM_ANDROID
+        case BTA_DM_DI_DISC_CMPL_EVT:
+        {
+            bt_property_t properties[1];
+            bt_bdaddr_t bd_addr;
+            int status;
+            BTIF_TRACE_DEBUG4("%s: num of DI records:%d, result: %d, vendorID: 0x%x",
+                    __FUNCTION__, p_data->di_disc.num_record, p_data->di_disc.result,
+                    p_data->di_disc.p_device_info.rec.vendor);
+            if (p_data->di_disc.result == BTA_SUCCESS && p_data->di_disc.num_record > 0)
+            {
+                bt_remote_did_t di_rec;
+
+                di_rec.spec_id = p_data->di_disc.p_device_info.spec_id;
+                di_rec.product = p_data->di_disc.p_device_info.rec.product;
+                di_rec.vendor = p_data->di_disc.p_device_info.rec.vendor;
+                di_rec.vendor_id_source = p_data->di_disc.p_device_info.rec.vendor_id_source;
+                di_rec.version = p_data->di_disc.p_device_info.rec.version;
+
+                bdcpy(bd_addr.address, p_data->di_disc.bd_addr);
+                properties[0].type = BT_PROPERTY_REMOTE_DID_INFO;
+                properties[0].val = &di_rec;
+                properties[0].len = sizeof(bt_remote_did_t);
+                status=btif_storage_set_remote_device_property(&bd_addr, &properties[0]);
+                ASSERTC(status == BT_STATUS_SUCCESS, "saving DI record", status);
+            }
+        }
+        break;
+#endif
         case BTA_DM_DISC_CMPL_EVT:
         {
             int device_type;
@@ -1720,7 +1804,7 @@
         case BTA_DM_AUTH_CMPL_EVT:
             btif_dm_auth_cmpl_evt(&p_data->auth_cmpl);
             break;
-
+#ifdef PLATFORM_ANDROID
         case BTA_DM_BLE_ADV_ENABLE_EVT:
             BTIF_TRACE_EVENT3("btif_dm_upstreams_evt:BTA_DM_BLE_ADV_ENABLE_EVT: enable:%d, advType: %d, islimited= %d",p_data->adv_enable.advEnable, p_data->adv_enable.advType, p_data->adv_enable.isLimited);
             if( p_data->adv_enable.advEnable)
@@ -1742,7 +1826,7 @@
             {
                 HAL_CBACK(bt_hal_cbacks, le_adv_enable_cb, p_data->adv_enable.advEnable, BLE_ADV_MODE_NONE);
             }
-
+#endif
         case BTA_DM_BOND_CANCEL_CMPL_EVT:
             if (pairing_cb.state == BT_BOND_STATE_BONDING)
             {
@@ -2026,6 +2110,46 @@
             break;
 
         case BTA_DM_AUTHORIZE_EVT:
+            {
+                BTIF_TRACE_DEBUG0("BTA_DM_AUTHORIZE_EVT");
+                bt_property_t prop[1];
+                uint32_t num_properties = 0;
+                uint8_t authorize_value=0;
+                bt_status_t status;
+                bdcpy(bd_addr.address, p_data->authorize.bd_addr);
+                prop[0].type = BT_PROPERTY_REMOTE_AUTHORIZE_INFO;
+                prop[0].len = sizeof(uint8_t);
+                prop[0].val = &authorize_value;
+                status = btif_storage_get_remote_device_property(&bd_addr,&prop[0]);
+                ASSERTC(status == BT_STATUS_SUCCESS, "failed to save remote device property",
+                       status);
+                BTIF_TRACE_DEBUG1("get remote device property for authorize info = %d",authorize_value);
+                if (status == BT_STATUS_FAIL)
+                {
+                    BTIF_TRACE_DEBUG0("Authorize Info property not found - request hal callback");
+                    authorize_value = 0;
+                }
+                //if (authorize_value == 0 || authorize_value == 2)
+                if (authorize_value == REJ_CURR_CB_NEXT_REQ ||
+                    authorize_value == ACP_CURR_CB_NEXT_REQ)
+                {
+                    BTIF_TRACE_DEBUG0("HAL callback for connect authorization");
+                    HAL_CBACK(bt_hal_cbacks, authorize_request_cb,&bd_addr,p_data->authorize.service);
+                }
+                //else if(authorize_value == 1)
+                else if(authorize_value == REJ_CURR_AUTO_REJ_NEXT_REQ)
+                {
+                    BTIF_TRACE_DEBUG0("Auto reject connect authorization");
+                    BTA_DmAuthorizeReply(p_data->authorize.bd_addr,p_data->authorize.service,2);//BTA_DM_NOT_AUTH = 2
+                }
+                //else if(authorize_value == 3)
+                else if(authorize_value == ACP_CURR_AUTO_ACP_NEX_REQ)
+                {
+                    BTIF_TRACE_DEBUG0("Auto accpet connect authorization");
+                    BTA_DmAuthorizeReply(p_data->authorize.bd_addr,p_data->authorize.service,1);//BTA_DM_AUTH_TEMP = 1
+                }
+            }
+            break;
         case BTA_DM_SIG_STRENGTH_EVT:
         case BTA_DM_SP_RMT_OOB_EVT:
         case BTA_DM_SP_KEYPRESS_EVT:
@@ -2321,8 +2445,20 @@
     if (pairing_cb.state != BT_BOND_STATE_NONE)
         return BT_STATUS_BUSY;
 
+#ifdef PLATFORM_ANDROID
     BTIF_TRACE_EVENT1("%s : Cancel Inquiry", __FUNCTION__);
     BTA_DmSearchCancel();
+#else
+    if(BTM_IsInquiryActive()!=BTM_INQUIRY_INACTIVE)
+    {
+        BTIF_TRACE_ERROR2("%s : Cancel Inquiry, [%s]", __FUNCTION__,BTM_IsInquiryActive());
+        BTA_DmSearchCancel();
+    }
+    else
+    {
+        BTIF_TRACE_ERROR2("%s : Inquiry is already inactive state:[%d]", __FUNCTION__,BTM_IsInquiryActive());
+    }
+#endif
 
     btif_transfer_context(btif_dm_generic_evt, BTIF_DM_CB_CREATE_BOND,
                           (char *)bd_addr, sizeof(bt_bdaddr_t), NULL);
@@ -3041,8 +3177,13 @@
 
     cod = COD_UNCLASSIFIED;
 
+#ifdef PLATFORM_ANDROID
     HAL_CBACK(bt_hal_cbacks, pin_request_cb,
               &bd_addr, &bd_name, cod, FALSE);
+#else
+    HAL_CBACK(bt_hal_cbacks, pin_request_cb,
+              &bd_addr, &bd_name, cod);
+#endif
 }
 
 
@@ -3132,3 +3273,17 @@
     }
     return btif_default_local_name;
 }
+
+bt_status_t btif_dm_save_authorize_settings(bt_bdaddr_t *bd_addr,uint8_t val)
+{
+    BTIF_TRACE_DEBUG1("btif_dm_save_authorize_settings - val = %d",val);
+    bt_property_t prop[1];
+    bt_status_t status;
+    prop[0].type = BT_PROPERTY_REMOTE_AUTHORIZE_INFO;
+    prop[0].len = sizeof(uint8_t);
+    prop[0].val = &val;
+    status = btif_storage_set_remote_device_property(bd_addr,&prop[0]);
+    ASSERTC(status == BT_STATUS_SUCCESS, "failed to set remote authorize setting value",
+                       status);
+    return BT_STATUS_SUCCESS;
+}
diff -Naur '--exclude=.git' bluedroid-orig/btif/src/btif_gatt_client.c bluedroid/btif/src/btif_gatt_client.c
--- bluedroid-orig/btif/src/btif_gatt_client.c	2015-09-24 16:33:43.532227643 +0800
+++ bluedroid/btif/src/btif_gatt_client.c	2015-09-24 16:31:37.000000000 +0800
@@ -506,10 +506,12 @@
 
         case BTA_GATTC_LISTEN_EVT:
         {
+#ifdef PLATFORM_ANDROID			
             HAL_CBACK(bt_gatt_callbacks, client->listen_cb
                 , p_data->reg_oper.status
                 , p_data->reg_oper.client_if
             );
+#endif
             break;
         }
         default:
@@ -567,6 +569,8 @@
                                  (char*) &btif_cb, sizeof(btif_gattc_cb_t), NULL);
 }
 
+#ifdef PLATFORM_ANDROID
+
 static void btif_le_extended_scan_upstreams_evt(uint16_t event, char* p_param)
 {
     ALOGD("%s: Event %d", __FUNCTION__, event);
@@ -637,6 +641,8 @@
     ALOGD("%s exit", __FUNCTION__);
 }
 
+#endif
+
 static void btm_read_rssi_cb (tBTM_RSSI_RESULTS *p_result)
 {
     btif_gattc_cb_t btif_cb;
@@ -1024,6 +1030,7 @@
                                  (char*) &btif_cb, sizeof(btif_gattc_cb_t), NULL);
 }
 
+#ifdef PLATFORM_ANDROID
 static bt_status_t btif_gattc_set_adv_data(int client_if, bool set_scan_rsp, bool include_name,
                 bool include_txpower, int min_interval, int max_interval, int appearance,
                 uint16_t manufacturer_len, char* manufacturer_data,
@@ -1183,6 +1190,7 @@
     return btif_transfer_context(btgattc_handle_event, BTIF_GATTC_SET_ADV_DATA,
                                  (char*) &btif_cb, sizeof(btif_gattc_cb_t), NULL);
 }
+#endif
 
 static bt_status_t btif_gattc_refresh( int client_if, const bt_bdaddr_t *bd_addr )
 {
@@ -1399,7 +1407,9 @@
     btif_gattc_scan,
     btif_gattc_open,
     btif_gattc_close,
+#ifdef PLATFORM_ANDROID        
     btif_gattc_listen,
+#endif    
     btif_gattc_refresh,
     btif_gattc_search_service,
     btif_gattc_get_included_service,
@@ -1414,7 +1424,9 @@
     btif_gattc_dereg_for_notification,
     btif_gattc_read_remote_rssi,
     btif_gattc_get_device_type,
+#ifdef PLATFORM_ANDROID    
     btif_gattc_set_adv_data,
+#endif    
     btif_gattc_test_command
 };
 
diff -Naur '--exclude=.git' bluedroid-orig/btif/src/btif_gatt_server.c bluedroid/btif/src/btif_gatt_server.c
--- bluedroid-orig/btif/src/btif_gatt_server.c	2015-09-24 16:33:43.532227643 +0800
+++ bluedroid/btif/src/btif_gatt_server.c	2015-09-24 16:31:37.000000000 +0800
@@ -53,6 +53,8 @@
 **  Constants & Macros
 ************************************************************************************/
 
+#define ADV_FLAGS 0x02
+
 #define CHECK_BTGATT_INIT() if (bt_gatt_callbacks == NULL)\
     {\
         ALOGW("%s: BTGATT not initialized", __FUNCTION__);\
@@ -75,12 +77,19 @@
     BTIF_GATTS_STOP_SERVICE,
     BTIF_GATTS_DELETE_SERVICE,
     BTIF_GATTS_SEND_INDICATION,
-    BTIF_GATTS_SEND_RESPONSE
+    BTIF_GATTS_SEND_RESPONSE,
+    BTIF_GATTS_SET_ADV_DATA,
+    BTIF_GATTS_SET_SCAN_RSP_DATA
 } btif_gatts_event_t;
 
 /************************************************************************************
 **  Local type definitions
 ************************************************************************************/
+typedef struct
+{
+    tBTA_BLE_AD_MASK mask;
+    tBTA_BLE_ADV_DATA data;
+} btgatt_adv_data;
 
 typedef struct
 {
@@ -103,6 +112,7 @@
     uint8_t             transport;
     uint8_t             confirm;
     uint8_t             status;
+    btgatt_adv_data     adv_data;
 } __attribute__((packed)) btif_gatts_cb_t;
 
 
@@ -328,7 +338,11 @@
         case BTA_GATTS_CLOSE_EVT:
             ALOGD("%s: Empty event (%d)!", __FUNCTION__, event);
             break;
-
+        case BTA_GATTS_LISTEN_EVT:
+            ALOGI("%s: Recvd. BTA_GATTS_LISTEN_EVT : (%d)!", __FUNCTION__, event);
+            ALOGI("%s: BTA_GATTS_LISTEN_EVT : status : %d SERVER-I/F : %d", __FUNCTION__, p_data->status, p_data->conn.server_if);
+            HAL_CBACK(bt_gatt_callbacks, server->listen_cb, p_data->reg_oper.status, p_data->reg_oper.server_if);
+            break;
         default:
             ALOGE("%s: Unhandled event (%d)!", __FUNCTION__, event);
             break;
@@ -462,7 +476,18 @@
                       0, rsp_struct.attr_value.handle);
             break;
         }
+        case BTIF_GATTS_SET_ADV_DATA:
+        {
+            BTA_DmBleSetAdvConfig(p_cb->adv_data.mask, &p_cb->adv_data.data);
+
+            break;
+        }
+        case BTIF_GATTS_SET_SCAN_RSP_DATA:
+        {
+            BTA_DmBleSetScanRsp(p_cb->adv_data.mask, &p_cb->adv_data.data);
 
+            break;
+        }
         default:
             ALOGE("%s: Unknown event (%d)!", __FUNCTION__, event);
             break;
@@ -624,6 +649,72 @@
                                  (char*) &btif_cb, sizeof(btif_gatts_cb_t), NULL);
 }
 
+static bt_status_t btif_gatts_listen(int server_if, bool start)
+{
+        BTA_GATTS_Listen(server_if, start, NULL);
+	return BT_STATUS_SUCCESS;
+}
+
+static bt_status_t btif_gatts_set_adv_data(int server_if, bool set_scan_rsp, bool include_name,
+                    bool include_txpower, int min_interval, int max_interval, int appearance,
+                    uint16_t manufacturer_len, char* manufacturer_data)
+{
+    ALOGE("%s: Configuring the BLE ADV DATA...", __FUNCTION__);
+
+    CHECK_BTGATT_INIT();
+    btif_gatts_cb_t btif_cb;
+    memset(&btif_cb, 0, sizeof(btif_gatts_cb_t));
+    memset(&btif_cb.adv_data, 0, sizeof(btgatt_adv_data));
+
+    btif_cb.server_if = (uint8_t) server_if;
+
+    if (!set_scan_rsp)
+    {
+        btif_cb.adv_data.mask = BTM_BLE_AD_BIT_FLAGS;
+        btif_cb.adv_data.data.flag = ADV_FLAGS;
+    }
+
+    if (include_name)
+        btif_cb.adv_data.mask |= BTM_BLE_AD_BIT_DEV_NAME;
+
+    if (include_txpower)
+        btif_cb.adv_data.mask |= BTM_BLE_AD_BIT_TX_PWR;
+
+    if (min_interval > 0 && max_interval > 0 && max_interval > min_interval)
+    {
+        btif_cb.adv_data.mask |= BTM_BLE_AD_BIT_INT_RANGE;
+        btif_cb.adv_data.data.int_range.low = min_interval;
+        btif_cb.adv_data.data.int_range.hi = max_interval;
+    }
+
+    if (appearance != 0)
+    {
+        btif_cb.adv_data.mask |= BTM_BLE_AD_BIT_APPEARANCE;
+        btif_cb.adv_data.data.appearance = appearance;
+    }
+
+    if (manufacturer_len > 0 && manufacturer_data != NULL)
+    {
+        btif_cb.adv_data.data.manu.p_val = GKI_getbuf(manufacturer_len);
+        if (btif_cb.adv_data.data.manu.p_val != NULL)
+        {
+            btif_cb.adv_data.mask |= BTM_BLE_AD_BIT_MANU;
+            btif_cb.adv_data.data.manu.len = manufacturer_len;
+            memcpy(btif_cb.adv_data.data.manu.p_val, manufacturer_data, manufacturer_len);
+        }
+    }
+    if (!set_scan_rsp)
+    {
+        ALOGI("%s: CONFIGURING THE BLE ADV DATA...", __FUNCTION__);
+        return btif_transfer_context(btgatts_handle_event, BTIF_GATTS_SET_ADV_DATA,
+            (char*) &btif_cb, sizeof(btif_gatts_cb_t), NULL);
+    } else {
+        ALOGI("%s: CONFIGURING THE SCAN RESPONSE DATA...", __FUNCTION__);
+        return btif_transfer_context(btgatts_handle_event, BTIF_GATTS_SET_SCAN_RSP_DATA,
+            (char*) &btif_cb, sizeof(btif_gatts_cb_t), NULL);
+    }
+}
+    
 const btgatt_server_interface_t btgattServerInterface = {
     btif_gatts_register_app,
     btif_gatts_unregister_app,
@@ -637,7 +728,9 @@
     btif_gatts_stop_service,
     btif_gatts_delete_service,
     btif_gatts_send_indication,
-    btif_gatts_send_response
+    btif_gatts_send_response,
+    btif_gatts_listen,
+    btif_gatts_set_adv_data
 };
 
 #endif
diff -Naur '--exclude=.git' bluedroid-orig/btif/src/btif_hf.c bluedroid/btif/src/btif_hf.c
--- bluedroid-orig/btif/src/btif_hf.c	2015-09-24 16:33:43.532227643 +0800
+++ bluedroid/btif/src/btif_hf.c	2015-09-24 16:31:37.000000000 +0800
@@ -266,7 +266,6 @@
 
         case BTA_AG_REGISTER_EVT:
             btif_hf_cb.handle = p_data->reg.hdr.handle;
-            btif_queue_pending_retry();
             break;
 
         case BTA_AG_OPEN_EVT:
@@ -403,7 +402,9 @@
             break;
 #if (BLUETOOTH_QCOM_SW == TRUE) /* Update the JNI about codec value.*/
         case BTA_AG_AT_BCS_EVT:
+#ifdef PLATFORM_ANDROID
             HAL_CBACK(bt_hf_callbacks, codec_negotiated_callback, p_data->val.num);
+#endif
             break;
 #endif
 
@@ -507,6 +508,7 @@
     return BT_STATUS_SUCCESS;
 }
 
+#ifdef PLATFORM_ANDROID
 /*******************************************************************************
 **
 ** Function         init_features
@@ -524,6 +526,7 @@
     btif_features = (UINT32)features;
     return BT_STATUS_SUCCESS;
 }
+#endif
 
 /*******************************************************************************
 **
@@ -534,7 +537,7 @@
 ** Returns         bt_status_t
 **
 *******************************************************************************/
-static bt_status_t connect_int( bt_bdaddr_t *bd_addr )
+static bt_status_t connect_int( bt_bdaddr_t *bd_addr, uint16_t uuid )
 {
     CHECK_BTHF_INIT();
     if (!is_connected(bd_addr))
@@ -556,10 +559,7 @@
 
     btif_queue_remove_connect(UUID_SERVCLASS_AG_HANDSFREE, BTIF_QUEUE_CHECK_CONNECT_REQ);
 
-   if(btif_hf_cb.handle)
-       return btif_queue_connect(UUID_SERVCLASS_AG_HANDSFREE, bd_addr, connect_int, BTIF_QUEUE_CONNECT_EVT);
-    else
-       return btif_queue_connect(UUID_SERVCLASS_AG_HANDSFREE, bd_addr, connect_int, BTIF_QUEUE_PENDING_CONECT_EVT);
+    return btif_queue_connect(UUID_SERVCLASS_AG_HANDSFREE, bd_addr, connect_int);
 }
 
 /*******************************************************************************
@@ -1124,6 +1124,7 @@
     return status;
 }
 
+#ifdef PLATFORM_ANDROID
 /*******************************************************************************
 **
 ** Function         get_remote_features
@@ -1139,6 +1140,7 @@
 
     return btif_hf_cb.peer_feat;
 }
+#endif
 
 /*******************************************************************************
 **
@@ -1180,6 +1182,10 @@
 *******************************************************************************/
 BOOLEAN btif_hf_is_call_idle()
 {
+    if (bt_hf_callbacks == NULL)
+    {
+        return TRUE;
+    }
     BTIF_TRACE_EVENT2("%s: call_setup_state: %d", __FUNCTION__, btif_hf_cb.call_setup_state );
     BTIF_TRACE_EVENT2("num_held:%d, num_active:%d", btif_hf_cb.num_held, btif_hf_cb.num_active );
     if ((btif_hf_cb.call_setup_state == BTHF_CALL_STATE_IDLE) &&
@@ -1242,7 +1248,9 @@
 static const bthf_interface_t bthfInterface = {
     sizeof(bthfInterface),
     init,
+#ifdef PLATFORM_ANDROID
     init_features,
+#endif
     connect,
     disconnect,
     connect_audio,
@@ -1257,7 +1265,9 @@
     at_response,
     clcc_response,
     phone_state_change,
+#ifdef PLATFORM_ANDROID
     get_remote_features,
+#endif
     cleanup,
 };
 
diff -Naur '--exclude=.git' bluedroid-orig/btif/src/btif_hf_client.c bluedroid/btif/src/btif_hf_client.c
--- bluedroid-orig/btif/src/btif_hf_client.c	2015-09-24 16:33:43.532227643 +0800
+++ bluedroid/btif/src/btif_hf_client.c	2015-09-24 16:31:37.000000000 +0800
@@ -210,7 +210,7 @@
 ** Returns         bt_status_t
 **
 *******************************************************************************/
-static bt_status_t connect_int( bt_bdaddr_t *bd_addr )
+static bt_status_t connect_int( bt_bdaddr_t *bd_addr, uint16_t uuid )
 {
     if (is_connected(bd_addr))
         return BT_STATUS_BUSY;
@@ -231,7 +231,7 @@
 
     btif_queue_remove_connect(UUID_SERVCLASS_HF_HANDSFREE, BTIF_QUEUE_CHECK_CONNECT_REQ);
 
-    return btif_queue_connect(UUID_SERVCLASS_HF_HANDSFREE, bd_addr, connect_int,BTIF_QUEUE_CONNECT_EVT);
+    return btif_queue_connect(UUID_SERVCLASS_HF_HANDSFREE, bd_addr, connect_int);
 
 }
 
diff -Naur '--exclude=.git' bluedroid-orig/btif/src/btif_hh.c bluedroid/btif/src/btif_hh.c
--- bluedroid-orig/btif/src/btif_hh.c	2015-09-24 16:33:43.532227643 +0800
+++ bluedroid/btif/src/btif_hh.c	2015-09-24 16:31:37.000000000 +0800
@@ -1535,7 +1535,7 @@
     if (btif_hh_add_added_dev(*bd_addr, hid_info.attr_mask))
     {
         BTA_HhAddDev(*bda, hid_info.attr_mask, hid_info.sub_class,
-                     hid_info.app_id, dscp_info, hid_info.priority);
+                     hid_info.app_id, dscp_info, BTIF_HH_CONNECTED_PRIORITY);
     }
 
     GKI_freebuf(dscp_info.descriptor.dsc_list);
@@ -1889,6 +1889,7 @@
     return BT_STATUS_FAIL;
 }
 
+#ifdef PLATFORM_ANDROID
 /*******************************************************************************
 **
 ** Function         set_priority
@@ -1921,6 +1922,33 @@
     }
     return BT_STATUS_SUCCESS;
 }
+#endif
+
+#ifndef PLATFORM_ANDROID
+bt_status_t send_n_data(bt_bdaddr_t *bd_addr, uint8_t *p_buf, uint16_t len)
+{
+    ALOGE("[Qualcomm]%s: Need to implemented!!!", __FUNCTION__);
+    return BT_STATUS_UNSUPPORTED;
+}
+
+bt_status_t send_ctrl(bt_bdaddr_t *bd_addr, uint8_t c_type)
+{
+    ALOGE("[Qualcomm]%s: Need to implemented!!!", __FUNCTION__);
+	return BT_STATUS_UNSUPPORTED;
+}
+
+bt_status_t register_for_report_id(uint8_t* report_ids, uint8_t num_of_report_ids)
+{
+    ALOGE("[Qualcomm]%s: Need to implemented!!!", __FUNCTION__);
+	return BT_STATUS_UNSUPPORTED;
+}
+
+bt_status_t ota_update_firmware(bt_bdaddr_t *bd_addr, char* path)
+{
+    ALOGE("[Qualcomm]%s: Need to implemented!!!", __FUNCTION__);
+	return BT_STATUS_UNSUPPORTED;
+}
+#endif
 
 /*******************************************************************************
 **
@@ -1969,12 +1997,21 @@
     set_info,
     get_protocol,
     set_protocol,
+#ifdef PLATFORM_ANDROID    
     get_idle_time,
     set_idle_time,
+#endif
     get_report,
     set_report,
     send_data,
+#ifdef PLATFORM_ANDROID    
     set_priority,
+#else
+    send_n_data,
+    send_ctrl,
+    register_for_report_id,
+    ota_update_firmware,
+#endif
     cleanup,
 };
 
diff -Naur '--exclude=.git' bluedroid-orig/btif/src/btif_hl.c bluedroid/btif/src/btif_hl.c
--- bluedroid-orig/btif/src/btif_hl.c	2015-09-24 16:33:43.532227643 +0800
+++ bluedroid/btif/src/btif_hl.c	2015-09-24 16:31:37.000000000 +0800
@@ -42,7 +42,7 @@
 #include <sys/select.h>
 #include <sys/poll.h>
 #include <cutils/sockets.h>
-#include <cutils/log.h>
+//#include <cutils/log.h>
 
 #include <hardware/bluetooth.h>
 #include <hardware/bt_hl.h>
diff -Naur '--exclude=.git' bluedroid-orig/btif/src/btif_media_task.c bluedroid/btif/src/btif_media_task.c
--- bluedroid-orig/btif/src/btif_media_task.c	2015-09-24 16:33:43.536227643 +0800
+++ bluedroid/btif/src/btif_media_task.c	2015-09-24 16:31:37.000000000 +0800
@@ -1,7 +1,6 @@
 /******************************************************************************
  *
  *  Copyright (C) 2009-2012 Broadcom Corporation
- *  Copyright (c) 2013, Linux Foundation. All rights reserved.
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -27,11 +26,8 @@
  **
  ******************************************************************************/
 
-//#define BT_AUDIO_SYSTRACE_LOG
 
-#ifdef BT_AUDIO_SYSTRACE_LOG
 #define ATRACE_TAG ATRACE_TAG_ALWAYS
-#endif
 
 #include <string.h>
 #include <stdio.h>
@@ -62,6 +58,8 @@
 #include "btif_av_co.h"
 #include "btif_media.h"
 
+#include "bt_utils.h"
+
 #if (BTA_AV_INCLUDED == TRUE)
 #include "sbc_encoder.h"
 #endif
@@ -73,30 +71,32 @@
 #include "btif_av.h"
 #include "btif_sm.h"
 #include "btif_util.h"
-#include "bt_utils.h"
-#ifdef BTA_AVK_INCLUDED
+#if (BTA_AV_SINK_INCLUDED == TRUE)
 #include "oi_codec_sbc.h"
 #include "oi_status.h"
+#include "bt_avk.h"
+#endif
+
+#ifdef AVK_BACKPORT
+#include "bluetoothTrack.h"
 #endif
+
 #include "stdio.h"
 #include <dlfcn.h>
-#include "bluetoothTrack.h"
 
 //#define DEBUG_MEDIA_AV_FLOW TRUE
+#define AVK_DATA_DUMP TRUE
 
-#ifdef BTA_AVK_INCLUDED
+#if (BTA_AV_SINK_INCLUDED == TRUE)
 OI_CODEC_SBC_DECODER_CONTEXT context;
 OI_UINT32 contextData[CODEC_DATA_WORDS(2, SBC_CODEC_FAST_FILTER_BUFFERS)];
 OI_INT16 pcmData[15*SBC_MAX_SAMPLES_PER_FRAME*SBC_MAX_CHANNELS];
-void *dlhandle = NULL;
-oi_sbc_decoder_vendor_interface_t *oi_sbc_decode_vnd_if = NULL;
 #endif
 
 #ifdef BT_AUDIO_SYSTRACE_LOG
 #include <cutils/trace.h>
-#define PERF_SYSTRACE 1
+#include <cutils/properties.h>
 #endif
-
 /*****************************************************************************
  **  Constants
  *****************************************************************************/
@@ -163,6 +163,7 @@
    (1000/TICKS_PER_SEC) (10) */
 
 #define BTIF_MEDIA_TIME_TICK                     (20 * BTIF_MEDIA_NUM_TICK)
+#define A2DP_DATA_READ_POLL_MS    (BTIF_MEDIA_TIME_TICK / 2)
 #define BTIF_SINK_MEDIA_TIME_TICK                (20 * BTIF_MEDIA_NUM_TICK)
 
 
@@ -183,7 +184,7 @@
 #endif
 
 /* Middle quality quality setting @ 48 khz */
-#define DEFAULT_SBC_BITRATE 345
+#define DEFAULT_SBC_BITRATE 237
 
 #ifndef BTIF_A2DP_NON_EDR_MAX_RATE
 #define BTIF_A2DP_NON_EDR_MAX_RATE 237
@@ -193,14 +194,17 @@
 #define A2DP_MEDIA_TASK_STACK_SIZE       0x2000         /* In bytes */
 #endif
 
-#define AVDTP_HDR_SIZE              12
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+/* A2DP header will contain a CP header of size 1 */
+#define A2DP_HDR_SIZE               2
+#else
 #define A2DP_HDR_SIZE               1
+#endif
 #define MAX_SBC_HQ_FRAME_SIZE_44_1  119
 #define MAX_SBC_HQ_FRAME_SIZE_48    115
-#define MAX_2MBPS_AVDTP_MTU         675
 
-#define MAX_SBC_MQ_FRAME_SIZE_44_1  83
-#define MAX_SBC_MQ_FRAME_SIZE_48    79
+/* 2DH5 payload size (679 bytes) - (4 bytes L2CAP Header + 12 bytes AVDTP Header) */
+#define MAX_2MBPS_AVDTP_MTU         663
 
 #define A2DP_MEDIA_TASK_TASK_STR        ((INT8 *) "A2DP-MEDIA")
 static UINT32 a2dp_media_task_stack[(A2DP_MEDIA_TASK_STACK_SIZE + 3) / 4];
@@ -210,8 +214,6 @@
 #define USEC_PER_SEC 1000000L
 #define TPUT_STATS_INTERVAL_US (3000*1000)
 
-BOOLEAN config_sbc_high_bitrate = TRUE;
-
 /*
  * CONGESTION COMPENSATION CTRL ::
  *
@@ -231,13 +233,18 @@
    but due to link flow control or thread preemption in lower
    layers we might need to temporarily buffer up data */
 
-/* 24 frames is equivalent to 6.89*24*2.9 ~= 480 ms @ 44.1 khz, 20 ms mediatick */
-#define MAX_OUTPUT_A2DP_FRAME_QUEUE_SZ 24
+/* 18 frames is equivalent to 6.89*24*2.9 ~= 360 ms @ 44.1 khz, 20 ms mediatick */
+#define MAX_OUTPUT_A2DP_FRAME_QUEUE_SZ 18
+
+#ifndef MAX_PCM_FRAME_NUM_PER_TICK
+#define MAX_PCM_FRAME_NUM_PER_TICK 14
+#endif
+
+#define MAX_PCM_ITER_NUM_PER_TICK     2
 
 //#define BTIF_MEDIA_VERBOSE_ENABLED
 /* In case of A2DP SINK, we will delay start by 5 AVDTP Packets*/
-#define MAX_A2DP_DELAYED_START_FRAME_COUNT 5
-#define MAX_A2DP_AV_SYNC_FRAME_COUNT 1
+#define MAX_A2DP_DELAYED_START_FRAME_COUNT 1
 #define PACKET_PLAYED_PER_TICK_48 8
 #define PACKET_PLAYED_PER_TICK_44 7
 #define PACKET_PLAYED_PER_TICK_32 5
@@ -296,13 +303,17 @@
     void* av_sm_hdl;
     UINT8 a2dp_cmd_pending; /* we can have max one command pending */
     BOOLEAN tx_flush; /* discards any outgoing data when true */
-    UINT8 TxNumSBCFrames;
     BOOLEAN rx_flush; /* discards any incoming data when true */
-    BOOLEAN scaling_disabled;
-    BOOLEAN is_edr_supported;
-    BOOLEAN is_source;
+    UINT8 peer_sep;
+    BOOLEAN data_channel_open;
     UINT8   frames_to_process;
-    BOOLEAN rx_audio_focus_gained;
+
+    UINT32  sample_rate;
+    UINT8   channel_count;
+#ifdef AVK_BACKPORT
+    btif_media_AudioFocus_state rx_audio_focus_gained;
+#endif
+    UINT8 TxNumSBCFrames;
 #endif
 
 } tBTIF_MEDIA_CB;
@@ -321,8 +332,9 @@
 
 static tBTIF_MEDIA_CB btif_media_cb;
 static int media_task_running = MEDIA_TASK_STATE_OFF;
+static UINT64 last_frame_us = 0;
 
-
+static UINT8 uipc_initialized = FALSE;
 /*****************************************************************************
  **  Local functions
  *****************************************************************************/
@@ -331,14 +343,24 @@
 static void btif_a2dp_ctrl_cb(tUIPC_CH_ID ch_id, tUIPC_EVENT event);
 static void btif_a2dp_encoder_update(void);
 const char* dump_media_event(UINT16 event);
-static UINT8 check_for_max_number_of_frames_per_packet();
-#ifdef BTA_AVK_INCLUDED
-void btif_load_decoder_library();
+#if (BTA_AV_SINK_INCLUDED == TRUE)
+extern OI_STATUS OI_CODEC_SBC_DecodeFrame(OI_CODEC_SBC_DECODER_CONTEXT *context,
+                                          const OI_BYTE **frameData,
+                                          unsigned long *frameBytes,
+                                          OI_INT16 *pcmData,
+                                          unsigned long *pcmBytes);
+extern OI_STATUS OI_CODEC_SBC_DecoderReset(OI_CODEC_SBC_DECODER_CONTEXT *context,
+                                           unsigned long *decoderData,
+                                           unsigned long decoderDataBytes,
+                                           OI_UINT8 maxChannels,
+                                           OI_UINT8 pcmStride,
+                                           OI_BOOL enhanced);
 #endif
 static void btif_media_flush_q(BUFFER_Q *p_q);
 static void btif_media_task_aa_handle_stop_decoding(void );
 static void btif_media_task_aa_rx_flush(void);
 static BOOLEAN btif_media_task_stop_decoding_req(void);
+static UINT8 check_for_max_number_of_frames_per_packet();
 
 /*****************************************************************************
  **  Externs
@@ -347,7 +369,7 @@
 static void btif_media_task_handle_cmd(BT_HDR *p_msg);
 static void btif_media_task_handle_media(BT_HDR*p_msg);
 /* Handle incoming media packets A2DP SINK streaming*/
-#ifdef BTA_AVK_INCLUDED
+#if (BTA_AV_SINK_INCLUDED == TRUE)
 static void btif_media_task_handle_inc_media(tBT_SBC_HDR*p_msg);
 #endif
 
@@ -361,89 +383,85 @@
 static void btif_media_task_audio_feeding_init(BT_HDR *p_msg);
 static void btif_media_task_aa_tx_flush(BT_HDR *p_msg);
 static void btif_media_aa_prep_2_send(UINT8 nb_frame);
-#ifdef BTA_AVK_INCLUDED
+#if (BTA_AV_SINK_INCLUDED == TRUE)
 static void btif_media_task_aa_handle_decoder_reset(BT_HDR *p_msg);
 static void btif_media_task_aa_handle_clear_track(void);
 #endif
 static void btif_media_task_aa_handle_start_decoding(void );
 #endif
-extern BOOLEAN btif_hf_is_call_idle();
-extern BOOLEAN btif_multihf_is_call_idle();
-extern void btif_av_request_audio_focus(BOOLEAN enable);
-
 BOOLEAN btif_media_task_start_decoding_req(void);
 BOOLEAN btif_media_task_clear_track(void);
+extern BOOLEAN btif_multihf_is_call_idle();
+
+static int bt_systrace_log_enabled=0;
+
 /*****************************************************************************
  **  Misc helper functions
  *****************************************************************************/
+int med_task_perf_systrace_enabled() {
+  char value[255] = {'\0'};
+  property_get("bt_audio_systrace_log", value, "false");
+  bt_systrace_log_enabled = (strcmp(value, "true") == 0);
+  return bt_systrace_log_enabled;
+}
+
+#if (BTA_AV_SINK_INCLUDED == TRUE)
+#if (defined(AVK_DATA_DUMP) && (AVK_DATA_DUMP == TRUE))
+FILE *outputPcmSampleFile;
+char outputFilename [50] = "/etc/bluetooth/output_sample.pcm";
 
-static void tput_mon(int is_rx, int len, int reset)
+void openDumpFile()
 {
-    /* only monitor one connection at a time for now */
-    static t_stat cur_stat;
-    struct timespec now;
-    unsigned long long prev_us;
-    unsigned long long now_us;
+    outputPcmSampleFile = fopen(outputFilename, "ab");
+    APPL_TRACE_DEBUG1("openDumpFile %u", outputPcmSampleFile);
+}
 
-    if (reset == TRUE)
+void closeDumpFile()
+{
+    APPL_TRACE_DEBUG1("closeDumpFile %u", outputPcmSampleFile);
+    if (outputPcmSampleFile)
     {
-        memset(&cur_stat, 0, sizeof(t_stat));
-        return;
+        fclose(outputPcmSampleFile);
     }
+    outputPcmSampleFile = NULL;
+}
 
-    if (is_rx)
-    {
-        cur_stat.rx+=len;
-        cur_stat.rx_tot+=len;
-    }
-    else
+void writeDumpFile(void *audioBuffer, int bufferlen)
+{
+    if (outputPcmSampleFile)
     {
-        cur_stat.tx+=len;
-        cur_stat.tx_tot+=len;
+        fwrite ((audioBuffer), 1, (size_t)bufferlen, outputPcmSampleFile);
     }
-    clock_gettime(CLOCK_MONOTONIC, &now);
-
-    now_us = now.tv_sec*USEC_PER_SEC + now.tv_nsec/1000;
-
-    if ((now_us - cur_stat.ts_prev_us) < TPUT_STATS_INTERVAL_US)
-        return;
-
-    APPL_TRACE_WARNING4("tput rx:%d, tx:%d (bytes/s)  (tot : rx %d, tx %d bytes)",
-          (cur_stat.rx*1000000)/((now_us - cur_stat.ts_prev_us)),
-          (cur_stat.tx*1000000)/((now_us - cur_stat.ts_prev_us)),
-           cur_stat.rx_tot, cur_stat.tx_tot);
-
-    /* stats dumped. now reset stats for next interval */
-    cur_stat.rx = 0;
-    cur_stat.tx = 0;
-    cur_stat.ts_prev_us = now_us;
 }
+#endif
+#endif
 
+static UINT64 time_now_us()
+{
+    struct timespec ts_now;
+    clock_gettime(CLOCK_BOOTTIME, &ts_now);
+    return ((UINT64)ts_now.tv_sec * USEC_PER_SEC) + ((UINT64)ts_now.tv_nsec / 1000);
+}
 
 static void log_tstamps_us(char *comment)
 {
-    #define USEC_PER_SEC 1000000L
     #define USEC_PER_MSEC 1000L
-    static struct timespec prev = {0, 0};
-    struct timespec now, diff;
-    unsigned int diff_us = 0;
-    unsigned int now_us = 0;
-
-    clock_gettime(CLOCK_MONOTONIC, &now);
-    now_us = now.tv_sec*USEC_PER_SEC + now.tv_nsec/1000;
-    diff_us = (now.tv_sec - prev.tv_sec) * USEC_PER_SEC + (now.tv_nsec - prev.tv_nsec)/1000;
+    static UINT64 prev_us = 0;
+    const UINT64 now_us = time_now_us();
+    static UINT64 diff_us = 0;
 
+    diff_us = now_us - prev_us;
     if ((diff_us / USEC_PER_MSEC) > (BTIF_MEDIA_TIME_TICK + 10))
     {
-        APPL_TRACE_ERROR4("[%s] ts %08d, diff : %08d, queue sz %d", comment, now_us, diff_us,
+        APPL_TRACE_ERROR4("[%s] ts %08llu, diff : %08llu, queue sz %d", comment, now_us, diff_us,
                 btif_media_cb.TxAaQ.count);
     }
     else
     {
-        APPL_TRACE_DEBUG4("[%s] ts %08d, diff : %08d, queue sz %d", comment, now_us, diff_us,
+        APPL_TRACE_DEBUG4("[%s] ts %08llu, diff : %08llu, queue sz %d", comment, now_us, diff_us,
                 btif_media_cb.TxAaQ.count);
     }
-    prev = now;
+    prev_us = now_us;
 }
 
 const char* dump_media_event(UINT16 event)
@@ -592,6 +610,11 @@
 
                 /* post start event and wait for audio path to open */
                 btif_dispatch_sm_event(BTIF_AV_START_STREAM_REQ_EVT, NULL, 0);
+
+#if (BTA_AV_SINK_INCLUDED == TRUE)
+                if (btif_media_cb.peer_sep == AVDT_TSEP_SRC)
+                    a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
+#endif
             }
             else if (btif_av_stream_started_ready())
             {
@@ -609,8 +632,7 @@
             break;
 
         case A2DP_CTRL_CMD_STOP:
-
-            if (btif_media_cb.is_tx_timer == FALSE)
+            if (btif_media_cb.peer_sep == AVDT_TSEP_SNK && btif_media_cb.is_tx_timer == FALSE)
             {
                 /* we are already stopped, just ack back */
                 a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
@@ -618,6 +640,7 @@
             }
 
             btif_dispatch_sm_event(BTIF_AV_STOP_STREAM_REQ_EVT, NULL, 0);
+            a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
             break;
 
         case A2DP_CTRL_CMD_SUSPEND:
@@ -636,6 +659,17 @@
             }
             break;
 
+        case A2DP_CTRL_GET_AUDIO_CONFIG:
+        {
+            uint32_t sample_rate = btif_media_cb.sample_rate;
+            uint8_t channel_count = btif_media_cb.channel_count;
+
+            a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
+            UIPC_Send(UIPC_CH_ID_AV_CTRL, 0, (UINT8 *)&sample_rate, 4);
+            UIPC_Send(UIPC_CH_ID_AV_CTRL, 0, &channel_count, 1);
+            break;
+        }
+
         default:
             APPL_TRACE_ERROR1("UNSUPPORTED CMD (%d)", cmd);
             a2dp_cmd_acknowledge(A2DP_CTRL_ACK_FAILURE);
@@ -646,6 +680,8 @@
 
 static void btif_a2dp_ctrl_cb(tUIPC_CH_ID ch_id, tUIPC_EVENT event)
 {
+    UNUSED(ch_id);
+
     APPL_TRACE_DEBUG1("A2DP-CTRL-CHANNEL EVENT %s", dump_uipc_event(event));
 
     switch(event)
@@ -673,6 +709,8 @@
 
 static void btif_a2dp_data_cb(tUIPC_CH_ID ch_id, tUIPC_EVENT event)
 {
+    UNUSED(ch_id);
+
     APPL_TRACE_DEBUG1("BTIF MEDIA (A2DP-DATA) EVENT %s", dump_uipc_event(event));
 
     switch(event)
@@ -682,12 +720,15 @@
             /*  read directly from media task from here on (keep callback for
                 connection events */
             UIPC_Ioctl(UIPC_CH_ID_AV_AUDIO, UIPC_REG_REMOVE_ACTIVE_READSET, NULL);
+            UIPC_Ioctl(UIPC_CH_ID_AV_AUDIO, UIPC_SET_READ_POLL_TMO,
+                       (void *)A2DP_DATA_READ_POLL_MS);
 
-            /* Start the media task to encode SBC */
-            btif_media_task_start_aa_req();
-
-            /* make sure we update any changed sbc encoder params */
-            btif_a2dp_encoder_update();
+            if (btif_media_cb.peer_sep == AVDT_TSEP_SNK) {
+                /* make sure we update any changed sbc encoder params */
+                /*post a message to btif_av to serialize encode update and encode init*/
+                btif_dispatch_sm_event(BTIF_AV_UPDATE_ENCODER_REQ_EVT, NULL, 0);
+            }
+            btif_media_cb.data_channel_open = TRUE;
 
             /* ack back when media task is fully started */
             break;
@@ -695,6 +736,7 @@
         case UIPC_CLOSE_EVT:
             a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
             btif_audiopath_detached();
+            btif_media_cb.data_channel_open = FALSE;
             break;
 
         default :
@@ -711,8 +753,9 @@
 static UINT16 btif_media_task_get_sbc_rate(void)
 {
     UINT16 rate = DEFAULT_SBC_BITRATE;
+
     /* restrict bitrate if a2dp link is non-edr */
-    if (!btif_av_is_peer_edr()|| config_sbc_high_bitrate == FALSE)
+    if (!btif_av_is_peer_edr())
     {
         rate = BTIF_A2DP_NON_EDR_MAX_RATE;
         APPL_TRACE_DEBUG1("non-edr a2dp sink detected, restrict rate to %d", rate);
@@ -930,6 +973,28 @@
 
 /*****************************************************************************
 **
+** Function        btif_a2dp_update_codec
+**
+** Description
+**
+** Returns
+**
+*******************************************************************************/
+
+void btif_a2dp_update_codec(void)
+{
+    APPL_TRACE_EVENT0("## A2DP UPDATE CODEC ##");
+
+    GKI_disable();
+    /* Start the media task to encode SBC */
+    btif_media_task_start_aa_req();
+    btif_a2dp_encoder_update();
+    GKI_enable();
+}
+
+
+/*****************************************************************************
+**
 ** Function        btif_a2dp_on_idle
 **
 ** Description
@@ -941,24 +1006,27 @@
 void btif_a2dp_on_idle(void)
 {
     APPL_TRACE_EVENT0("## ON A2DP IDLE ##");
-    if(btif_media_cb.is_source)
+    if (btif_media_cb.peer_sep == AVDT_TSEP_SNK)
     {
         /* Make sure media task is stopped */
         btif_media_task_stop_aa_req();
     }
 
     bta_av_co_init();
-#ifdef BTA_AVK_INCLUDED
-    if (!btif_media_cb.is_source)
+#if (BTA_AV_SINK_INCLUDED == TRUE)
+    if (btif_media_cb.peer_sep == AVDT_TSEP_SRC)
     {
         btif_media_cb.rx_flush = TRUE;
         btif_media_task_aa_rx_flush_req();
         btif_media_task_stop_decoding_req();
+#if (defined(AVK_DATA_DUMP) && (AVK_DATA_DUMP == TRUE))
+        closeDumpFile();
+#endif
         btif_media_task_clear_track();
         APPL_TRACE_DEBUG0("Stopped BT track");
-        APPL_TRACE_DEBUG0("Reset to Source role");
-        btif_media_cb.is_source = TRUE;
+#ifdef AVK_BACKPORT
         btif_media_cb.rx_audio_focus_gained = BTIF_MEDIA_AUDIOFOCUS_LOSS;
+#endif
     }
 #endif
 }
@@ -978,7 +1046,8 @@
     APPL_TRACE_EVENT0("## ON A2DP OPEN ##");
 
     /* always use callback to notify socket events */
-    UIPC_Open(UIPC_CH_ID_AV_AUDIO, btif_a2dp_data_cb);
+    if(uipc_initialized)
+        UIPC_Open(UIPC_CH_ID_AV_AUDIO, btif_a2dp_data_cb);
 }
 
 /*******************************************************************************
@@ -1090,6 +1159,22 @@
 
 /*****************************************************************************
 **
+** Function        btif_a2dp_on_sink_ready
+**
+** Description
+**
+** Returns
+**
+*******************************************************************************/
+
+void btif_a2dp_on_sink_ready()
+{
+    APPL_TRACE_EVENT0("btif_a2dp_on_sink_ready");
+    btif_media_cb.data_channel_open = TRUE;
+}
+
+/*****************************************************************************
+**
 ** Function        btif_a2dp_on_started
 **
 ** Description
@@ -1104,6 +1189,7 @@
     BOOLEAN ack = FALSE;
 
     APPL_TRACE_EVENT0("## ON A2DP STARTED ##");
+    med_task_perf_systrace_enabled();
 
     if (p_av == NULL)
     {
@@ -1173,11 +1259,14 @@
 void btif_a2dp_on_stopped(tBTA_AV_SUSPEND *p_av)
 {
     APPL_TRACE_EVENT0("## ON A2DP STOPPED ##");
-    if ((!btif_media_cb.is_source)) /*  Handling for A2DP SINK cases*/
+    if (btif_media_cb.peer_sep == AVDT_TSEP_SRC) /*  Handling for A2DP SINK cases*/
     {
         btif_media_cb.rx_flush = TRUE;
         btif_media_task_aa_rx_flush_req();
         btif_media_task_stop_decoding_req();
+        if(uipc_initialized)
+            UIPC_Close(UIPC_CH_ID_AV_AUDIO);
+        btif_media_cb.data_channel_open = FALSE;
         return;
     }
     /* allow using this api for other than suspend */
@@ -1217,7 +1306,7 @@
 void btif_a2dp_on_suspended(tBTA_AV_SUSPEND *p_av)
 {
     APPL_TRACE_EVENT0("## ON A2DP SUSPENDED ##");
-    if ((!btif_media_cb.is_source))
+    if (btif_media_cb.peer_sep == AVDT_TSEP_SRC)
     {
         btif_media_cb.rx_flush = TRUE;
         btif_media_task_aa_rx_flush_req();
@@ -1255,47 +1344,30 @@
     btif_media_cb.tx_flush = enable;
 }
 
-/* when true media task discards any rx frames */
+#if (BTA_AV_SINK_INCLUDED == TRUE)
+#ifdef AVK_BACKPORT
 void btif_a2dp_set_audio_focus_state(btif_media_AudioFocus_state state)
 {
-    APPL_TRACE_EVENT1("## Audio_focus_state Rx %d ##", state);
     btif_media_cb.rx_audio_focus_gained = state;
-}
-
-/*****************************************************************************
-**
-** Function        btif_calc_pcmtime
-**
-** Description     Calculates the pcmtime equivalent of a datapacket
-**
-** Returns         microseconds
-**
-*******************************************************************************/
-
-static int btif_calc_pcmtime(UINT32 bytes_processed)
-{
-    int pcm_time_us = 0;
-    tBTIF_AV_MEDIA_FEED_CFG *p_cfg;
-
-    p_cfg = &btif_media_cb.media_feeding.cfg;
-
-    /* calculate corresponding pcm time based on data processed */
-    switch(btif_media_cb.media_feeding.format)
+    if (btif_media_cb.rx_audio_focus_gained ==  BTIF_MEDIA_AUDIOFOCUS_LOSS)
     {
-        case BTIF_AV_CODEC_PCM:
-            pcm_time_us = (bytes_processed*1000000)/
-                          (p_cfg->pcm.num_channel*p_cfg->pcm.sampling_freq*p_cfg->pcm.bit_per_sample/8);
-            break;
-
-        default :
-            APPL_TRACE_ERROR1("mediafeeding format invalid : %d", btif_media_cb.media_feeding.format);
-            break;
+        btif_a2dp_set_rx_flush(TRUE);
+    }
+    if (btif_media_cb.rx_audio_focus_gained ==  BTIF_MEDIA_AUDIOFOCUS_GAIN)
+    {
+        btif_a2dp_set_rx_flush(FALSE);
     }
-
-    return pcm_time_us;
 }
+#endif
 
-#ifdef BTA_AVK_INCLUDED
+void btif_media_get_sbc_config(btavk_audio_config_t *btavk_audio_config)
+{
+    btavk_audio_config->bit_per_sample = 16; //Default
+    btavk_audio_config->num_channel = btif_media_cb.channel_count;
+    btavk_audio_config->sampling_freq = btif_media_cb.sample_rate;
+    APPL_TRACE_DEBUG2("btif_media_get_sbc_config: num_channel: %u, sampling_freq: %u",
+                btavk_audio_config->num_channel, btavk_audio_config->sampling_freq);
+}
 /*******************************************************************************
  **
  ** Function         btif_media_task_avk_handle_timer
@@ -1324,18 +1396,7 @@
             btif_media_flush_q(&(btif_media_cb.RxSbcQ));
             return;
         }
-        if (btif_media_cb.rx_audio_focus_gained == BTIF_MEDIA_AUDIOFOCUS_LOSS_TRANSIENT)
-        {
-            APPL_TRACE_DEBUG0("Received Transient Focus Loss, Ignoring");
-            return;
-        }
 
-        if (btif_media_cb.rx_audio_focus_gained == BTIF_MEDIA_AUDIOFOCUS_LOSS)
-        {
-            /* Send a Audio Focus Request */
-            btif_av_request_audio_focus(TRUE);
-            return;
-        }
         if (btif_media_cb.RxSbcQ.count > 3)
             num_frames_to_process = 2* btif_media_cb.frames_to_process;
         else
@@ -1449,14 +1510,13 @@
 void btif_media_task_init(void)
 {
     memset(&(btif_media_cb), 0, sizeof(btif_media_cb));
-
-    UIPC_Init(NULL);
-
+    if (uipc_initialized)
+    {
+        UIPC_Init(NULL);
 #if (BTA_AV_INCLUDED == TRUE)
-    UIPC_Open(UIPC_CH_ID_AV_CTRL , btif_a2dp_ctrl_cb);
+        UIPC_Open(UIPC_CH_ID_AV_CTRL , btif_a2dp_ctrl_cb);
 #endif
-    btif_media_cb.is_source = TRUE;
-    APPL_TRACE_DEBUG0("Reset to Source role");
+    }
 }
 /*******************************************************************************
  **
@@ -1476,6 +1536,7 @@
 {
     UINT16 event;
     BT_HDR *p_msg;
+    UNUSED(p);
 
     VERBOSE("================ MEDIA TASK STARTING ================");
 
@@ -1518,7 +1579,7 @@
 
         if (event & BTIF_MEDIA_AVK_TASK_TIMER)
         {
-#ifdef BTA_AVK_INCLUDED
+#if (BTA_AV_SINK_INCLUDED == TRUE)
             /* advance audio timer expiration for a2dp sink */
             btif_media_task_avk_handle_timer();
 #endif
@@ -1535,7 +1596,9 @@
             media_task_running = MEDIA_TASK_STATE_SHUTTING_DOWN;
 
             /* this calls blocks until uipc is fully closed */
-            UIPC_Close(UIPC_CH_ID_ALL);
+            if(uipc_initialized)
+                UIPC_Close(UIPC_CH_ID_ALL);
+
             break;
         }
     }
@@ -1583,7 +1646,7 @@
  *******************************************************************************/
 static void btif_media_flush_q(BUFFER_Q *p_q)
 {
-    while (GKI_IS_QUEUE_EMPTY(p_q) == FALSE)
+    while (!GKI_queue_is_empty(p_q))
     {
         GKI_freebuf(GKI_dequeue(p_q));
     }
@@ -1629,7 +1692,7 @@
         btif_media_task_aa_handle_uipc_rx_rdy();
         break;
     case BTIF_MEDIA_AUDIO_SINK_CFG_UPDATE:
-#ifdef BTA_AVK_INCLUDED
+#if (BTA_AV_SINK_INCLUDED == TRUE)
         btif_media_task_aa_handle_decoder_reset(p_msg);
 #endif
         break;
@@ -1637,7 +1700,7 @@
         btif_media_task_aa_handle_start_decoding();
         break;
     case BTIF_MEDIA_AUDIO_SINK_CLEAR_TRACK:
-#ifdef BTA_AVK_INCLUDED
+#if (BTA_AV_SINK_INCLUDED == TRUE)
         btif_media_task_aa_handle_clear_track();
 #endif
         break;
@@ -1655,7 +1718,7 @@
     VERBOSE("btif_media_task_handle_cmd : %s DONE", dump_media_event(p_msg->event));
 }
 
-#ifdef BTA_AVK_INCLUDED
+#if (BTA_AV_SINK_INCLUDED == TRUE)
 /*******************************************************************************
  **
  ** Function         btif_media_task_handle_inc_media
@@ -1674,21 +1737,36 @@
     OI_STATUS status;
     int num_sbc_frames = p_msg->num_frames_to_be_processed;
     UINT32 sbc_frame_len = p_msg->len - 1;
+#ifdef AVK_BACKPORT
     int retwriteAudioTrack = 0;
+#endif
+    APPL_TRACE_DEBUG0(" btif_media_task_handle_inc_media ");
     availPcmBytes = 2*sizeof(pcmData);
 
-    if ((btif_media_cb.is_source) || (btif_media_cb.rx_flush))
+    if ((btif_media_cb.peer_sep == AVDT_TSEP_SNK) || (btif_media_cb.rx_flush))
     {
         APPL_TRACE_DEBUG0(" State Changed happened in this tick ");
         return;
     }
+
+#ifndef AVK_BACKPORT
+    // ignore data if no one is listening
+    if (!btif_media_cb.data_channel_open)
+    {
+        APPL_TRACE_WARNING0(" data_channel_open not opened, drop packets ");
+        return;
+    }
+#endif
+
     APPL_TRACE_DEBUG2("Number of sbc frames %d, frame_len %d", num_sbc_frames, sbc_frame_len);
 
     for(count = 0; count < num_sbc_frames && sbc_frame_len != 0; count ++)
     {
         pcmBytes = availPcmBytes;
-        status = oi_sbc_decode_vnd_if->OI_CODEC_SBC_DecodeFrame(&context, (const OI_BYTE**)&sbc_start_frame,
-                                                        &sbc_frame_len, pcmDataPointer, &pcmBytes);
+        status = OI_CODEC_SBC_DecodeFrame(&context, (const OI_BYTE**)&sbc_start_frame,
+                                                        (OI_UINT32 *)&sbc_frame_len,
+                                                        (OI_INT16 *)pcmDataPointer,
+                                                        (OI_UINT32 *)&pcmBytes);
         if (!OI_SUCCESS(status)) {
             APPL_TRACE_ERROR1("Decoding failure: %d\n", status);
             break;
@@ -1698,9 +1776,17 @@
         p_msg->offset += (p_msg->len - 1) - sbc_frame_len;
         p_msg->len = sbc_frame_len + 1;
     }
-
+#if (defined(AVK_DATA_DUMP) && (AVK_DATA_DUMP == TRUE))
+    APPL_TRACE_DEBUG1("Dumping %d bytes of audio data", (2*sizeof(pcmData) - availPcmBytes));
+    writeDumpFile((void*)pcmData, (2*sizeof(pcmData) - availPcmBytes));
+#endif
+#ifdef AVK_BACKPORT
     retwriteAudioTrack = btWriteData((void*)pcmData, (2*sizeof(pcmData) - availPcmBytes));
     APPL_TRACE_LATENCY_AUDIO1("Written to audio, seq number %d", p_msg->layer_specific);
+#else
+    HAL_CBACK(btif_av_get_sink_cb(), btavk_audio_data_cb, (void*)pcmData,
+                                        (2*sizeof(pcmData) - availPcmBytes));
+#endif
 }
 #endif
 
@@ -1915,6 +2001,8 @@
  *******************************************************************************/
 static void btif_media_task_aa_tx_flush(BT_HDR *p_msg)
 {
+    UNUSED(p_msg);
+
     /* Flush all enqueued GKI music buffers (encoded) */
     APPL_TRACE_DEBUG0("btif_media_task_aa_tx_flush");
 
@@ -1957,7 +2045,6 @@
     btif_media_cb.TxAaMtuSize = ((BTIF_MEDIA_AA_BUF_SIZE-BTIF_MEDIA_AA_SBC_OFFSET-sizeof(BT_HDR))
             < pInitAudio->MtuSize) ? (BTIF_MEDIA_AA_BUF_SIZE - BTIF_MEDIA_AA_SBC_OFFSET
             - sizeof(BT_HDR)) : pInitAudio->MtuSize;
-    btif_media_cb.TxNumSBCFrames = check_for_max_number_of_frames_per_packet();
 
     APPL_TRACE_EVENT3("btif_media_task_enc_init busy %d, mtu %d, peer mtu %d",
                      btif_media_cb.busy_level, btif_media_cb.TxAaMtuSize, pInitAudio->MtuSize);
@@ -1969,6 +2056,8 @@
 
     /* Reset entirely the SBC encoder */
     SBC_Encoder_Init(&(btif_media_cb.encoder));
+
+    btif_media_cb.TxNumSBCFrames = check_for_max_number_of_frames_per_packet();
     APPL_TRACE_DEBUG1("btif_media_task_enc_init bit pool %d", btif_media_cb.encoder.s16BitPool);
 }
 
@@ -1987,7 +2076,7 @@
     tBTIF_MEDIA_UPDATE_AUDIO * pUpdateAudio = (tBTIF_MEDIA_UPDATE_AUDIO *) p_msg;
     SBC_ENC_PARAMS *pstrEncParams = &btif_media_cb.encoder;
     UINT16 s16SamplingFreq;
-    SINT16 s16BitPool;
+    SINT16 s16BitPool = 0;
     SINT16 s16BitRate;
     SINT16 s16FrameLen;
     UINT8 protect = 0;
@@ -2018,8 +2107,6 @@
                                       BTIF_MEDIA_AA_SBC_OFFSET - sizeof(BT_HDR))
                 < pUpdateAudio->MinMtuSize) ? (BTIF_MEDIA_AA_BUF_SIZE - BTIF_MEDIA_AA_SBC_OFFSET
                 - sizeof(BT_HDR)) : pUpdateAudio->MinMtuSize;
-        btif_media_cb.TxNumSBCFrames = check_for_max_number_of_frames_per_packet();
-
         /* Set the initial target bit rate */
         pstrEncParams->u16BitRate = btif_media_task_get_sbc_rate();
 
@@ -2034,6 +2121,16 @@
 
         do
         {
+            if (pstrEncParams->s16NumOfBlocks == 0 || pstrEncParams->s16NumOfSubBands == 0
+                || pstrEncParams->s16NumOfChannels == 0)
+            {
+                APPL_TRACE_ERROR0("btif_media_task_enc_update() - Avoiding division by zero...");
+                APPL_TRACE_ERROR3("btif_media_task_enc_update() - block=%d, subBands=%d, channels=%d",
+                    pstrEncParams->s16NumOfBlocks, pstrEncParams->s16NumOfSubBands,
+                    pstrEncParams->s16NumOfChannels);
+                break;
+            }
+
             if ((pstrEncParams->s16ChannelMode == SBC_JOINT_STEREO) ||
                 (pstrEncParams->s16ChannelMode == SBC_STEREO) )
             {
@@ -2098,9 +2195,13 @@
             {
                 APPL_TRACE_WARNING1("btif_media_task_enc_update computed bitpool too small (%d)", s16BitPool);
                 /* Increase bitrate */
+                UINT16 previous_u16BitRate = btif_media_cb.encoder.u16BitRate;
                 btif_media_cb.encoder.u16BitRate += BTIF_MEDIA_BITRATE_STEP;
                 /* Record that we have increased the bitrate */
                 protect |= 2;
+                /* Check over-flow */
+                if (btif_media_cb.encoder.u16BitRate < previous_u16BitRate)
+                    protect |= 3;
             }
             else
             {
@@ -2122,6 +2223,7 @@
 
         /* make sure we reinitialize encoder with new settings */
         SBC_Encoder_Init(&(btif_media_cb.encoder));
+        btif_media_cb.TxNumSBCFrames = check_for_max_number_of_frames_per_packet();
     }
 }
 
@@ -2238,7 +2340,7 @@
     }
 }
 
-int a2dp_get_track_frequency(UINT8 frequency) {
+int btif_a2dp_get_track_frequency(UINT8 frequency) {
     int freq = 48000;
     switch (frequency) {
         case A2D_SBC_IE_SAMP_FREQ_16:
@@ -2257,19 +2359,40 @@
     return freq;
 }
 
+int btif_a2dp_get_track_channel_count(UINT8 channeltype) {
+    int count = 1;
+    switch (channeltype) {
+        case A2D_SBC_IE_CH_MD_MONO:
+            count = 1;
+            break;
+        case A2D_SBC_IE_CH_MD_DUAL:
+        case A2D_SBC_IE_CH_MD_STEREO:
+        case A2D_SBC_IE_CH_MD_JOINT:
+            count = 2;
+            break;
+    }
+    return count;
+}
+
+#ifdef AVK_BACKPORT
 int a2dp_get_track_channel_type(UINT8 channeltype) {
-    int channel = AUDIO_CHANNEL_OUT_MONO;
+    int count = 1;
     switch (channeltype) {
         case A2D_SBC_IE_CH_MD_MONO:
-            channel = AUDIO_CHANNEL_OUT_MONO;
+            count = 1;
             break;
         case A2D_SBC_IE_CH_MD_DUAL:
         case A2D_SBC_IE_CH_MD_STEREO:
         case A2D_SBC_IE_CH_MD_JOINT:
-            channel = AUDIO_CHANNEL_OUT_STEREO;
+            count = 3;
             break;
     }
-    return channel;
+    return count;
+}
+#endif
+
+void btif_a2dp_set_peer_sep(UINT8 sep) {
+    btif_media_cb.peer_sep = sep;
 }
 
 /*******************************************************************************
@@ -2285,7 +2408,9 @@
 {
     btif_media_cb.is_rx_timer = FALSE;
     GKI_stop_timer(BTIF_MEDIA_AVK_TASK_TIMER_ID);
+#ifdef AVK_BACKPORT
     btPauseTrack();
+#endif
 }
 
 /*******************************************************************************
@@ -2301,25 +2426,22 @@
 {
     if(btif_media_cb.is_rx_timer == TRUE)
         return;
+#ifdef AVK_BACKPORT
     btStartTrack();
+#endif
     btif_media_cb.is_rx_timer = TRUE;
     GKI_start_timer(BTIF_MEDIA_AVK_TASK_TIMER_ID, GKI_MS_TO_TICKS(BTIF_SINK_MEDIA_TIME_TICK), TRUE);
 }
 
-#ifdef BTA_AVK_INCLUDED
+#if (BTA_AV_SINK_INCLUDED == TRUE)
 
 static void btif_media_task_aa_handle_clear_track (void)
 {
     APPL_TRACE_DEBUG0("btif_media_task_aa_handle_clear_track");
+#ifdef AVK_BACKPORT
     btStopTrack();
     btDeleteTrack();
-    if (dlhandle)
-    {
-        APPL_TRACE_DEBUG0("Unload Decoder lib");
-        dlclose(dlhandle);
-        dlhandle = NULL;
-        oi_sbc_decode_vnd_if = NULL;
-    }
+#endif
 }
 
 /*******************************************************************************
@@ -2337,10 +2459,9 @@
     tA2D_STATUS a2d_status;
     tA2D_SBC_CIE sbc_cie;
     OI_STATUS       status;
-    UINT32          freq_multiple; /* frequency multiple for 20ms of data */
-    UINT32          num_blocks;
-    UINT32          num_subbands;
-    UINT32          num_channel;
+    UINT32          freq_multiple = 48*20; /* frequency multiple for 20ms of data , initialize with 48K*/
+    UINT32          num_blocks = 16;
+    UINT32          num_subbands = 8;
 
     APPL_TRACE_DEBUG6("btif_media_task_aa_handle_decoder_reset p_codec_info[%x:%x:%x:%x:%x:%x]",
             p_buf->codec_info[1], p_buf->codec_info[2], p_buf->codec_info[3],
@@ -2352,19 +2473,30 @@
         APPL_TRACE_ERROR1("ERROR dump_codec_info A2D_ParsSbcInfo fail:%d", a2d_status);
         return;
     }
-    btif_media_cb.is_source = FALSE;
+
+    btif_media_cb.sample_rate = btif_a2dp_get_track_frequency(sbc_cie.samp_freq);
+    btif_media_cb.channel_count = btif_a2dp_get_track_channel_count(sbc_cie.ch_mode);
+
+#ifndef AVK_BACKPORT
     btif_media_cb.rx_flush = FALSE;
+#endif
+
     APPL_TRACE_DEBUG0("Reset to sink role");
-    btif_load_decoder_library();
-    status = oi_sbc_decode_vnd_if->OI_CODEC_SBC_DecoderReset(&context, contextData, sizeof(contextData), 2, 2, FALSE);
+    status = OI_CODEC_SBC_DecoderReset(&context, contextData, sizeof(contextData), 2, 2, FALSE);
     if (!OI_SUCCESS(status)) {
         APPL_TRACE_ERROR1("OI_CODEC_SBC_DecoderReset failed with error code %d\n", status);
     }
+#ifdef AVK_BACKPORT
     APPL_TRACE_DEBUG0("A2dpSink: Crate Track");
-    if (btCreateTrack(a2dp_get_track_frequency(sbc_cie.samp_freq), a2dp_get_track_channel_type(sbc_cie.ch_mode)) == -1) {
+    if (btCreateTrack(btif_a2dp_get_track_frequency(sbc_cie.samp_freq), a2dp_get_track_channel_type(sbc_cie.ch_mode)) == -1) {
         APPL_TRACE_ERROR0("A2dpSink: Track creation fails!!!");
         return;
     }
+#endif
+
+#if (defined(AVK_DATA_DUMP) && (AVK_DATA_DUMP == TRUE))
+    openDumpFile();
+#endif
 
     switch(sbc_cie.samp_freq)
     {
@@ -2468,34 +2600,6 @@
 
 /*******************************************************************************
  **
- ** Function         btif_media_task_uipc_cback
- **
- ** Description      UIPC call back function for synchronous mode only
- **
- ** Returns          void
- **
- *******************************************************************************/
-static void btif_media_task_uipc_cback(BT_HDR *p_msg)
-{
-    /* Sanity check */
-    if (NULL == p_msg)
-    {
-        return;
-    }
-
-    /* Just handle RX_EVT */
-    if (p_msg->event != UIPC_RX_DATA_EVT)
-    {
-        return;
-    }
-
-    p_msg->event = BTIF_MEDIA_UIPC_RX_RDY;
-
-    GKI_send_msg(BT_MEDIA_TASK, BTIF_MEDIA_TASK_CMD_MBOX, p_msg);
-}
-
-/*******************************************************************************
- **
  ** Function         btif_media_task_feeding_state_reset
  **
  ** Description      Reset the media feeding state
@@ -2516,8 +2620,6 @@
                  btif_media_cb.media_feeding.cfg.pcm.num_channel *
                  BTIF_MEDIA_TIME_TICK)/1000;
 
-        APPL_TRACE_DEBUG1("bit_per_sample %u", btif_media_cb.media_feeding.cfg.pcm.bit_per_sample);
-
         APPL_TRACE_WARNING1("pcm bytes per tick %d",
                             (int)btif_media_cb.media_feeding_state.pcm.bytes_per_tick);
     }
@@ -2540,6 +2642,7 @@
     // UIPC_Ioctl(UIPC_CH_ID_AV_AUDIO, UIPC_REG_CBACK, NULL);
 
     btif_media_cb.is_tx_timer = TRUE;
+    last_frame_us = 0;
 
     /* Reset the media feeding state */
     btif_media_task_feeding_state_reset();
@@ -2571,7 +2674,9 @@
         btif_media_cb.is_tx_timer = FALSE;
         is_data_path  = TRUE ;
     }
-    UIPC_Close(UIPC_CH_ID_AV_AUDIO);
+    if (uipc_initialized)
+        UIPC_Close(UIPC_CH_ID_AV_AUDIO);
+
     /* Try to send acknowldegment once the media stream is
        stopped. This will make sure that the A2dp HAL layer is
        unblocked on wait for acknowledgment for the sent command.
@@ -2588,15 +2693,59 @@
 
     /* audio engine stopped, reset tx suspended flag */
     btif_media_cb.tx_flush = 0;
+    last_frame_us = 0;
 
     /* Reset the media feeding state */
     btif_media_task_feeding_state_reset();
 }
 
+static UINT32 get_frame_length()
+{
+    UINT32 frame_len = 0;
+    APPL_TRACE_DEBUG6("channel mode: %d, sub-band: %d, number of block: %d, \
+            bitpool: %d, sampling frequency: %d, num channels: %d",
+            btif_media_cb.encoder.s16ChannelMode,
+            btif_media_cb.encoder.s16NumOfSubBands,
+            btif_media_cb.encoder.s16NumOfBlocks,
+            btif_media_cb.encoder.s16BitPool,
+            btif_media_cb.encoder.s16SamplingFreq,
+            btif_media_cb.encoder.s16NumOfChannels);
+
+    switch(btif_media_cb.encoder.s16ChannelMode)
+    {
+        case SBC_MONO:
+        case SBC_DUAL:
+            frame_len = 4 + ((UINT32)(4 * btif_media_cb.encoder.s16NumOfSubBands *
+                btif_media_cb.encoder.s16NumOfChannels) / 8) +
+                ((UINT32)(btif_media_cb.encoder.s16NumOfBlocks *
+                btif_media_cb.encoder.s16NumOfChannels *
+                btif_media_cb.encoder.s16BitPool) / 8);
+            break;
+        case SBC_STEREO:
+            frame_len = 4 + ((UINT32)(4 * btif_media_cb.encoder.s16NumOfSubBands *
+                btif_media_cb.encoder.s16NumOfChannels) / 8) +
+                ((UINT32)(btif_media_cb.encoder.s16NumOfBlocks *
+                btif_media_cb.encoder.s16BitPool) / 8);
+            break;
+        case SBC_JOINT_STEREO:
+            frame_len = 4 + ((UINT32)(4 * btif_media_cb.encoder.s16NumOfSubBands *
+                btif_media_cb.encoder.s16NumOfChannels) / 8) +
+                ((UINT32)(btif_media_cb.encoder.s16NumOfSubBands +
+                (btif_media_cb.encoder.s16NumOfBlocks *
+                btif_media_cb.encoder.s16BitPool)) / 8);
+            break;
+        default:
+            APPL_TRACE_DEBUG0("Invalid channel number");
+    }
+    APPL_TRACE_DEBUG1("calculated frame length: %d", frame_len);
+    return frame_len;
+}
+
 static UINT8 check_for_max_number_of_frames_per_packet()
 {
     UINT16 result = 0;
     UINT16 effective_mtu_size = btif_media_cb.TxAaMtuSize;
+    UINT32 frame_len;
 
     APPL_TRACE_DEBUG1("original AVDTP MTU size: %d", btif_media_cb.TxAaMtuSize);
     if (btif_av_is_peer_edr() && (btif_av_peer_supports_3mbps() == FALSE)) {
@@ -2610,34 +2759,47 @@
             btif_media_cb.TxAaMtuSize = effective_mtu_size;
         }
     }
-    APPL_TRACE_DEBUG1("effective Tx MTU to be considered: %d", effective_mtu_size);
+
+    if (!btif_media_cb.encoder.s16NumOfSubBands)
+    {
+        APPL_TRACE_ERROR0("Error: SubBands are set to 0, resetting to Max");
+        btif_media_cb.encoder.s16NumOfSubBands = SBC_MAX_NUM_OF_SUBBANDS;
+    }
+    if (!btif_media_cb.encoder.s16NumOfBlocks)
+    {
+        APPL_TRACE_ERROR0("Error: Blocks are set to 0, resetting to Max");
+        btif_media_cb.encoder.s16NumOfBlocks = SBC_MAX_NUM_OF_BLOCKS;
+    }
+    if (!btif_media_cb.encoder.s16NumOfChannels)
+    {
+        APPL_TRACE_ERROR0("Error: Channels are set to 0, resetting to Max");
+        btif_media_cb.encoder.s16NumOfChannels = SBC_MAX_NUM_OF_CHANNELS;
+    }
+    frame_len = get_frame_length();
+
+    APPL_TRACE_DEBUG1("effective Tx MTU to be considered: %d",
+                                            effective_mtu_size);
     switch(btif_media_cb.encoder.s16SamplingFreq)
     {
         case SBC_sf44100:
-            if(config_sbc_high_bitrate == TRUE)
-            {
-              result = (effective_mtu_size - (AVDTP_HDR_SIZE + A2DP_HDR_SIZE))
-                                                    / MAX_SBC_HQ_FRAME_SIZE_44_1;
-            }
-            else
+            if(!frame_len)
             {
-              result = (effective_mtu_size - (AVDTP_HDR_SIZE + A2DP_HDR_SIZE))
-                                                    / MAX_SBC_MQ_FRAME_SIZE_44_1;
+                APPL_TRACE_ERROR0("Error: Calculating frame length, \
+                                            resetting it to default");
+                frame_len = MAX_SBC_HQ_FRAME_SIZE_44_1;
             }
+            result = (effective_mtu_size - A2DP_HDR_SIZE) / frame_len;
             APPL_TRACE_DEBUG1("max number of sbc frames: %d", result);
             break;
 
         case SBC_sf48000:
-            if(config_sbc_high_bitrate == TRUE)
+            if(!frame_len)
             {
-              result = (effective_mtu_size - (AVDTP_HDR_SIZE + A2DP_HDR_SIZE))
-                                                    / MAX_SBC_HQ_FRAME_SIZE_48;
-            }
-            else
-            {
-              result = (effective_mtu_size - (AVDTP_HDR_SIZE + A2DP_HDR_SIZE))
-                                                    / MAX_SBC_MQ_FRAME_SIZE_48;
+                APPL_TRACE_ERROR0("Error: Calculating frame length, \
+                                            resetting it to default");
+                frame_len = MAX_SBC_HQ_FRAME_SIZE_48;
             }
+            result = (effective_mtu_size - A2DP_HDR_SIZE) / frame_len;
             APPL_TRACE_DEBUG1("max number of sbc frames: %d", result);
             break;
 
@@ -2675,8 +2837,15 @@
                              btif_media_cb.media_feeding.cfg.pcm.bit_per_sample / 8;
             APPL_TRACE_DEBUG1("pcm_bytes_per_frame %u", pcm_bytes_per_frame);
 
+            UINT32 us_this_tick = BTIF_MEDIA_TIME_TICK * 1000;
+            UINT64 now_us = time_now_us();
+            if (last_frame_us != 0)
+                us_this_tick = (now_us - last_frame_us);
+            last_frame_us = now_us;
+
             btif_media_cb.media_feeding_state.pcm.counter +=
-                                btif_media_cb.media_feeding_state.pcm.bytes_per_tick;
+                                btif_media_cb.media_feeding_state.pcm.bytes_per_tick *
+                                us_this_tick / (BTIF_MEDIA_TIME_TICK * 1000);
 
             /* calculate nbr of frames pending for this media tick */
             result = btif_media_cb.media_feeding_state.pcm.counter/pcm_bytes_per_frame;
@@ -2690,7 +2859,7 @@
                 }
                 nof = btif_media_cb.TxNumSBCFrames;
                 if(!nof) {
-                    APPL_TRACE_ERROR0("Error: Num frames not updated, stick to calculated values");
+                    APPL_TRACE_ERROR0("Error: Num frames not updated, set calculated values");
                     nof = result;
                     noi = 1;
                 }
@@ -2699,6 +2868,14 @@
                     if (nof < result)
                     {
                         noi = result / nof; // number of iterations would vary
+                        if (noi > MAX_PCM_ITER_NUM_PER_TICK)
+                        {
+                            APPL_TRACE_ERROR2("## Audio Congestion (iterations:%d > max (%d))",
+                                 noi, MAX_PCM_ITER_NUM_PER_TICK);
+                            noi = 1;
+                            btif_media_cb.media_feeding_state.pcm.counter
+                                =noi * nof * pcm_bytes_per_frame;
+                        }
                         result = nof;
                     }
                     else
@@ -2713,6 +2890,14 @@
             {
                 // For BR cases nof will be same as the value retrieved at result
                 APPL_TRACE_DEBUG1("headset is of type BR %u", nof);
+                if (result > MAX_PCM_FRAME_NUM_PER_TICK)
+                {
+                    APPL_TRACE_ERROR2("## Audio Congestion (frames: %d > max (%d))"
+                        ,result, MAX_PCM_FRAME_NUM_PER_TICK);
+                    result = MAX_PCM_FRAME_NUM_PER_TICK;
+                    btif_media_cb.media_feeding_state.pcm.counter
+                        = noi * result * pcm_bytes_per_frame;
+                }
                 nof = result;
             }
             btif_media_cb.media_feeding_state.pcm.counter -= noi * nof * pcm_bytes_per_frame;
@@ -2768,7 +2953,7 @@
         p_msg->num_frames_to_be_processed = (*((UINT8*)(p_msg + 1) + p_msg->offset)) & 0x0f;
         BTIF_TRACE_VERBOSE1("btif_media_sink_enque_buf + ", p_msg->num_frames_to_be_processed);
         GKI_enqueue(&(btif_media_cb.RxSbcQ), p_msg);
-        if(btif_media_cb.RxSbcQ.count == MAX_A2DP_AV_SYNC_FRAME_COUNT)
+        if(btif_media_cb.RxSbcQ.count == MAX_A2DP_DELAYED_START_FRAME_COUNT)
         {
             BTIF_TRACE_DEBUG0(" Initiate Decoding ");
             btif_media_task_start_decoding_req();
@@ -2826,9 +3011,6 @@
     INT32   fract_max;
     INT32   fract_threshold;
     UINT32  nb_byte_read;
-    #ifdef BT_AUDIO_SYSTRACE_LOG
-    char trace_buf[512];
-    #endif
 
     /* Get the SBC sampling rate */
     switch (btif_media_cb.encoder.s16SamplingFreq)
@@ -2919,19 +3101,18 @@
         APPL_TRACE_WARNING2("### UNDERRUN :: ONLY READ %d BYTES OUT OF %d ###",
                 nb_byte_read, read_size);
 
-        #ifdef BT_AUDIO_SYSTRACE_LOG
-        snprintf(trace_buf, 32, "A2DP UNDERRUN read %ld ", nb_byte_read);
-
-        if (PERF_SYSTRACE)
+#ifdef BT_AUDIO_SYSTRACE_LOG
+        if (bt_systrace_log_enabled)
         {
+            char trace_buf[512];
+            snprintf(trace_buf, 32, "A2DP UNDERRUN read %d ", (int)nb_byte_read);
             ATRACE_BEGIN(trace_buf);
         }
-
-        if (PERF_SYSTRACE)
+        if (bt_systrace_log_enabled)
         {
             ATRACE_END();
         }
-        #endif
+#endif
 
         if (nb_byte_read == 0)
             return FALSE;
@@ -3112,10 +3293,10 @@
 
 static void btif_media_aa_prep_2_send(UINT8 nb_frame)
 {
-    VERBOSE("btif_media_aa_prep_2_send : %d frames (queue %d)", nb_frame,
-                       btif_media_cb.TxAaQ.count);
+    VERBOSE("%s() - frames=%d (queue=%d)", __FUNCTION__, nb_frame,
+                                        btif_media_cb.TxAaQ.count)
 
-    while (btif_media_cb.TxAaQ.count >= MAX_OUTPUT_A2DP_FRAME_QUEUE_SZ)
+    while (btif_media_cb.TxAaQ.count >= (MAX_OUTPUT_A2DP_FRAME_QUEUE_SZ-nb_frame))
     {
         APPL_TRACE_WARNING1("btif_media_aa_prep_2_send congestion buf count %d",
                              btif_media_cb.TxAaQ.count);
@@ -3149,34 +3330,34 @@
     UINT8 nb_frame_2_send;
     UINT8 nb_iterations;
     UINT8 counter;
-    #ifdef BT_AUDIO_SYSTRACE_LOG
-    char trace_buf[1024];
-    #endif
 
     /* get the number of frame to send */
     btif_get_num_aa_frame(&nb_iterations, &nb_frame_2_send);
 
-    #ifdef BT_AUDIO_SYSTRACE_LOG
-    snprintf(trace_buf, 32, "btif_media_send_aa_frame:");
-    if (PERF_SYSTRACE)
+    for (counter = 0; counter < nb_iterations; counter++)
     {
-        ATRACE_BEGIN(trace_buf);
+        /* format and Q buffer to send */
+        if (nb_frame_2_send != 0)
+        {
+            btif_media_aa_prep_2_send(nb_frame_2_send);
+        }
     }
-    #endif
 
-    for (counter = 0; counter < nb_iterations; counter++)
+#ifdef BT_AUDIO_SYSTRACE_LOG
+    if (bt_systrace_log_enabled)
     {
-        /* format and Q buffer to send */
-        btif_media_aa_prep_2_send(nb_frame_2_send);
+        char trace_buf[1024];
+        snprintf(trace_buf, 32, "btif_media_send_aa_frame:");
+        ATRACE_BEGIN(trace_buf);
     }
+
     /* send it */
 
-    #ifdef BT_AUDIO_SYSTRACE_LOG
-    if (PERF_SYSTRACE)
+    if (bt_systrace_log_enabled)
     {
         ATRACE_END();
     }
-    #endif
+#endif
 
     VERBOSE("btif_media_send_aa_frame : send %d frames", nb_frame_2_send);
     bta_av_ci_src_data_ready(BTA_AV_CHNL_AUDIO);
@@ -3258,22 +3439,3 @@
 
 }
 
-#ifdef BTA_AVK_INCLUDED
-void btif_load_decoder_library()
-{
-    dlhandle = dlopen("liboi_sbc_decoder.so", RTLD_NOW);
-    APPL_TRACE_DEBUG0("Load decoder library");
-    if (!dlhandle)
-    {
-        APPL_TRACE_ERROR0("!!! Failed to load oi_sbc_decoder.so !!!");
-        return;
-    }
-
-    oi_sbc_decode_vnd_if = (oi_sbc_decoder_vendor_interface_t *) dlsym(dlhandle, "OI_SBC_DECODER_VENDOR_LIB_INTERFACE");
-    if (!oi_sbc_decode_vnd_if)
-    {
-        APPL_TRACE_ERROR0("!!! Failed to get oi sbc decode vendor interface !!!");
-        return;
-    }
-}
-#endif
diff -Naur '--exclude=.git' bluedroid-orig/btif/src/btif_multi_hf.c bluedroid/btif/src/btif_multi_hf.c
--- bluedroid-orig/btif/src/btif_multi_hf.c	2015-09-24 16:33:43.536227643 +0800
+++ bluedroid/btif/src/btif_multi_hf.c	2015-09-24 16:31:37.000000000 +0800
@@ -382,7 +382,6 @@
 
         case BTA_AG_REGISTER_EVT:
             btif_hf_cb[idx].handle = p_data->reg.hdr.handle;
-            btif_queue_pending_retry();
             break;
 
         case BTA_AG_OPEN_EVT:
@@ -693,7 +692,7 @@
 ** Returns         bt_status_t
 **
 *******************************************************************************/
-static bt_status_t connect_int( bt_bdaddr_t *bd_addr )
+static bt_status_t connect_int( bt_bdaddr_t *bd_addr, uint16_t uuid )
 {
     CHECK_BTHF_INIT();
     int i;
@@ -721,14 +720,7 @@
 static bt_status_t connect( bt_bdaddr_t *bd_addr )
 {
     CHECK_BTHF_INIT();
-    /* handle may be zero if stack is not initialised
-       at time of connect request; queue connect */
-    if (btif_hf_cb[0].handle)
-       return btif_queue_connect(UUID_SERVCLASS_AG_HANDSFREE, bd_addr, connect_int,
-                                                           BTIF_QUEUE_CONNECT_EVT);
-    else
-       return btif_queue_connect(UUID_SERVCLASS_AG_HANDSFREE, bd_addr, connect_int,
-                                                    BTIF_QUEUE_PENDING_CONECT_EVT);
+    return btif_queue_connect(UUID_SERVCLASS_AG_HANDSFREE, bd_addr, connect_int);
 }
 
 /*******************************************************************************
@@ -1417,6 +1409,10 @@
 BOOLEAN btif_multihf_is_call_idle()
 {
     int i, j = 1;
+    if (bt_multi_hf_callbacks == NULL)
+    {
+        return TRUE;
+    }
     for (i = 0; i < btif_max_hf_clients; i++)
     {
         BTIF_TRACE_EVENT3("%s: call_setup_state: %d for handle: %d",
diff -Naur '--exclude=.git' bluedroid-orig/btif/src/btif_pan.c bluedroid/btif/src/btif_pan.c
--- bluedroid-orig/btif/src/btif_pan.c	2015-09-24 16:33:43.536227643 +0800
+++ bluedroid/btif/src/btif_pan.c	2015-09-24 16:31:37.000000000 +0800
@@ -38,12 +38,15 @@
 #include <fcntl.h>
 #include <sys/socket.h>
 #include <sys/wait.h>
+#ifdef PLATFORM_ANDROID
 #include <net/if.h>
+#endif
 #include <linux/sockios.h>
 #include <sys/prctl.h>
 #include <linux/if.h>
 #include <linux/if_tun.h>
 #include <linux/if_ether.h>
+#include <cutils/sockets.h>
 
 #define LOG_TAG "BTIF_PAN"
 #include "btif_common.h"
@@ -71,6 +74,10 @@
 
 #define asrt(s) if(!(s)) BTIF_TRACE_ERROR3("btif_pan: ## %s assert %s failed at line:%d ##",__FUNCTION__, #s, __LINE__)
 
+#ifndef PLATFORM_ANDROID
+#define IF_NAMESIZE     IFNAMSIZ
+#endif
+	
 btpan_cb_t btpan_cb;
 
 BD_ADDR local_addr;
diff -Naur '--exclude=.git' bluedroid-orig/btif/src/btif_profile_queue.c bluedroid/btif/src/btif_profile_queue.c
--- bluedroid-orig/btif/src/btif_profile_queue.c	2015-09-24 16:33:43.536227643 +0800
+++ bluedroid/btif/src/btif_profile_queue.c	2015-09-24 16:31:37.000000000 +0800
@@ -30,133 +30,112 @@
 #include "btif_common.h"
 #include "btif_profile_queue.h"
 #include "gki.h"
+#include "list.h"
 
 /*******************************************************************************
 **  Local type definitions
 *******************************************************************************/
 
-typedef struct connect_node_tag
-{
+typedef struct {
     bt_bdaddr_t bda;
     uint16_t uuid;
-    uint16_t busy;
-    void *p_cb;
-    struct connect_node_tag *p_next;
-} __attribute__((packed))connect_node_t;
-
+    bool busy;
+    btif_connect_cb_t connect_cb;
+} connect_node_t;
 
 /*******************************************************************************
 **  Static variables
 *******************************************************************************/
 
-static connect_node_t *connect_queue;
-
+static list_t *connect_queue;
 
 /*******************************************************************************
 **  Queue helper functions
 *******************************************************************************/
 
-static void queue_int_add(connect_node_t *p_param)
-{
-    connect_node_t *p_list = connect_queue;
+static void queue_int_add(connect_node_t *p_param) {
     connect_node_t *p_node = GKI_getbuf(sizeof(connect_node_t));
     ASSERTC(p_node != NULL, "Failed to allocate new list node", 0);
-
-    memcpy(p_node, p_param, sizeof(connect_node_t));
-
-    if (connect_queue == NULL)
+    if (p_node)
+        memcpy(p_node, p_param, sizeof(connect_node_t));
+    else
     {
-        connect_queue = p_node;
+        BTIF_TRACE_ERROR0("%s, Failed to allocate new list node");
         return;
     }
-
-    while (p_list->p_next)
-        p_list = p_list->p_next;
-    p_list->p_next = p_node;
+    if (!connect_queue) {
+        connect_queue = list_new(GKI_freebuf);
+        ASSERTC(connect_queue != NULL, "Failed to allocate list", 0);
+    }
+    if (connect_queue)
+        list_append(connect_queue, p_node);
+    else
+        BTIF_TRACE_ERROR0("%s, Failed to allocate list");
 }
 
-static void queue_int_advance()
-{
-    connect_node_t *p_head = connect_queue;
-    if (connect_queue == NULL)
-        return;
-
-    connect_queue = connect_queue->p_next;
-    GKI_freebuf(p_head);
+static void queue_int_advance() {
+    if (connect_queue && !list_is_empty(connect_queue))
+        list_remove(connect_queue, list_front(connect_queue));
 }
 
-static bt_status_t queue_int_connect_next()
-{
-    connect_node_t* p_head = connect_queue;
-
-    if (p_head == NULL)
+static bt_status_t queue_int_connect_next() {
+    if (!connect_queue || list_is_empty(connect_queue))
         return BT_STATUS_FAIL;
 
-    /* If the queue is currently busy, we return  success anyway,
-     * since the connection has been queued... */
-    if (p_head->busy != FALSE)
+    connect_node_t *p_head = list_front(connect_queue);
+    if (!p_head)
+        return BT_STATUS_FAIL;
+    // If the queue is currently busy, we return success anyway,
+    // since the connection has been queued...
+    if (p_head->busy)
         return BT_STATUS_SUCCESS;
 
-    p_head->busy = TRUE;
-    return (*(btif_connect_cb_t*)p_head->p_cb)(&p_head->bda);
+    p_head->busy = true;
+    return p_head->connect_cb(&p_head->bda, p_head->uuid);
+}
+
+static bool queue_check_uuid(void *data, void *cb_data)
+{
+    connect_node_t *node = (connect_node_t *)data;
+    uint16_t uuid = *(uint16_t*)cb_data;
+
+    BTIF_TRACE_VERBOSE2("%s, UUID : 0x%x", __FUNCTION__, uuid);
+    if(node->uuid == uuid)
+    {
+        list_remove(connect_queue, data);
+    }
+    return true;
 }
 
 static void queue_check_connect(connect_node_t *p_param)
 {
     BTIF_TRACE_VERBOSE2("%s, UUID : 0x%x", __FUNCTION__, p_param->uuid);
-    connect_node_t *p_head = connect_queue;
-    connect_node_t *p_temp = p_head;
+
     if (connect_queue == NULL)
         return;
-    // need to delete whole list in case of single node.
-    if (p_head != NULL && connect_queue->p_next == NULL)
-    {
-        if ((p_param->uuid == p_head->uuid))
-        {
-            BTIF_TRACE_VERBOSE0("Matched Connect req with uuid for single node");
-            connect_queue = connect_queue->p_next;
-            GKI_freebuf(p_head);
-            return;
-        }
-    }
-    // parse list for common node and delete that node
-    while (p_head != NULL && connect_queue->p_next != NULL)
-    {
-        if ((p_param->uuid == p_head->uuid))
-        {
-            BTIF_TRACE_VERBOSE0("Matched Connect req with uuid");
-            // delete this node
-            p_temp->p_next = p_head->p_next;
-            GKI_freebuf(p_head);
-            break;
-        }
-        p_temp = p_head;
-        p_head = p_head->p_next;
-    }
+
+    list_foreach_ext(connect_queue, queue_check_uuid, (void*)&(p_param->uuid));
 }
 
 static void queue_int_handle_evt(UINT16 event, char *p_param)
 {
-
     BTIF_TRACE_VERBOSE2("%s, Event : 0x%x", __FUNCTION__, event);
     switch(event)
     {
         case BTIF_QUEUE_CONNECT_EVT:
-            queue_int_add((connect_node_t*)p_param);
+            queue_int_add((connect_node_t *)p_param);
             break;
 
         case BTIF_QUEUE_ADVANCE_EVT:
             queue_int_advance();
             break;
-        case BTIF_QUEUE_PENDING_CONECT_EVT:
-            queue_int_add((connect_node_t*)p_param);
-            return;
-            break;
+
         case BTIF_QUEUE_CHECK_CONNECT_REQ:
             queue_check_connect((connect_node_t*)p_param);
             break;
+
         default:
-            BTIF_TRACE_VERBOSE0("BTIF_QUEUE_PENDING_CONECT_ADVANCE_EVT");
+            BTIF_TRACE_VERBOSE0("Unknown Event");
             break;
     }
 
@@ -173,16 +152,15 @@
 ** Returns          BT_STATUS_SUCCESS if successful
 **
 *******************************************************************************/
-bt_status_t btif_queue_connect(uint16_t uuid, const bt_bdaddr_t *bda,
-                        btif_connect_cb_t *connect_cb, uint8_t queue_connect)
-{
+bt_status_t btif_queue_connect(uint16_t uuid, const bt_bdaddr_t *bda, btif_connect_cb_t connect_cb) {
     connect_node_t node;
     memset(&node, 0, sizeof(connect_node_t));
-    memcpy(&(node.bda), bda, sizeof(bt_bdaddr_t));
+    memcpy(&node.bda, bda, sizeof(bt_bdaddr_t));
     node.uuid = uuid;
-    node.p_cb = connect_cb;
-    return btif_transfer_context(queue_int_handle_evt, queue_connect,
-                          (char*)&node, sizeof(connect_node_t), NULL);
+    node.connect_cb = connect_cb;
+
+    return btif_transfer_context(queue_int_handle_evt, BTIF_QUEUE_CONNECT_EVT,
+                          (char *)&node, sizeof(connect_node_t), NULL);
 }
 
 /*******************************************************************************
@@ -195,26 +173,10 @@
 ** Returns          void
 **
 *******************************************************************************/
-void btif_queue_advance()
-{
+void btif_queue_advance() {
     btif_transfer_context(queue_int_handle_evt, BTIF_QUEUE_ADVANCE_EVT,
                           NULL, 0, NULL);
 }
-/*******************************************************************************
-**
-** Function         btif_queue_pending_retry
-**
-** Description      Advance to the next scheduled connection.
-**
-** Returns          void
-**
-*******************************************************************************/
-void btif_queue_pending_retry()
-{
-    BTIF_TRACE_VERBOSE0("btif_queue_pending_retry");
-    btif_transfer_context(queue_int_handle_evt, BTIF_QUEUE_PENDING_CONECT_ADVANCE_EVT,
-                          NULL, 0, NULL);
-}
 
 
 /*******************************************************************************
@@ -226,17 +188,8 @@
 ** Returns          void
 **
 *******************************************************************************/
-void btif_queue_release()
-{
-    connect_node_t *current = connect_queue;
-
-    while (current != NULL)
-    {
-         connect_node_t *next = current->p_next;
-         GKI_freebuf(current);
-         current = next;
-    }
-
+void btif_queue_release() {
+    list_free(connect_queue);
     connect_queue = NULL;
 }
 /*******************************************************************************
diff -Naur '--exclude=.git' bluedroid-orig/btif/src/btif_rc.c bluedroid/btif/src/btif_rc.c
--- bluedroid-orig/btif/src/btif_rc.c	2015-09-24 16:33:43.536227643 +0800
+++ bluedroid/btif/src/btif_rc.c	2015-09-24 16:31:37.000000000 +0800
@@ -1,5 +1,6 @@
 /******************************************************************************
  *
+ *  Copyright (c) 2015, The Linux Foundation. All rights reserved.
  *  Copyright (C) 2009-2012 Broadcom Corporation
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
@@ -31,13 +32,17 @@
 #include "avrc_defs.h"
 #include "bd.h"
 #include "gki.h"
+#include "btu.h"
 
 #define LOG_TAG "BTIF_RC"
 #include "btif_common.h"
 #include "btif_util.h"
 #include "btif_av.h"
 #include "hardware/bt_rc.h"
+#include "hardware/bt_rcc.h"
 #include "uinput.h"
+#include "bt_utils.h"
+#include <pthread.h>
 
 /*****************************************************************************
 **  Constants & Macros
@@ -50,24 +55,33 @@
 //#define TEST_BROWSE_RESPONSE
 #define MAX_FOLDER_RSP_SUPPORT 3
 
-#define IDX_GET_PLAY_STATUS_RSP   0
-#define IDX_LIST_APP_ATTR_RSP     1
-#define IDX_LIST_APP_VALUE_RSP    2
-#define IDX_GET_CURR_APP_VAL_RSP  3
-#define IDX_SET_APP_VAL_RSP       4
-#define IDX_GET_APP_ATTR_TXT_RSP  5
-#define IDX_GET_APP_VAL_TXT_RSP   6
-#define IDX_GET_ELEMENT_ATTR_RSP  7
-#define IDX_GET_FOLDER_ITEMS_RSP  8
-#define IDX_SET_FOLDER_ITEM_RSP   9
+#define IDX_GET_PLAY_STATUS_RSP    0
+#define IDX_LIST_APP_ATTR_RSP      1
+#define IDX_LIST_APP_VALUE_RSP     2
+#define IDX_GET_CURR_APP_VAL_RSP   3
+#define IDX_SET_APP_VAL_RSP        4
+#define IDX_GET_APP_ATTR_TXT_RSP   5
+#define IDX_GET_APP_VAL_TXT_RSP    6
+#define IDX_GET_ELEMENT_ATTR_RSP   7
+#define IDX_GET_FOLDER_ITEMS_RSP   8
+#define IDX_SET_FOLDER_ITEM_RSP    9
 #define IDX_SET_ADDRESS_PLAYER_RSP 10
 #define MAX_VOLUME 128
 #define MAX_LABEL 16
 #define MAX_TRANSACTIONS_PER_SESSION 16
-#define MAX_CMD_QUEUE_LEN 11
 #define PLAY_STATUS_PLAYING 1
+#define MAX_CMD_QUEUE_LEN 15
 #define ERR_PLAYER_NOT_ADDRESED 0x13
 
+#define NOTIF_STATE_INVALID 0
+#define NOTIF_STATE_INTERIM 1
+#define NOTIF_STATE_CHANGED 2
+
+#define KEY_CODE_POWER 0x40
+#define KEY_CODE_VOLUME_UP 0x41
+#define KEY_CODE_VOLUME_DOWN 0x42
+#define KEY_CODE_MUTE 0x43
+
 #define CHECK_RC_CONNECTED                                                                  \
     BTIF_TRACE_DEBUG1("## %s ##", __FUNCTION__);                                            \
     if(btif_rc_cb.rc_connected == FALSE)                                                    \
@@ -138,6 +152,8 @@
     btif_rc_reg_notifications_t rc_notif[MAX_RC_NOTIFICATIONS];
     unsigned int                rc_volume;
     uint8_t                     rc_vol_label;
+    uint8_t                     rcc_absvol_notif_state;
+    uint8_t                     whitelisted_device;
 } btif_rc_cb_t;
 
 typedef struct {
@@ -160,12 +176,14 @@
                        {"/dev/uinput", "/dev/input/uinput", "/dev/misc/uinput" };
 static int uinput_fd = -1;
 
+/*
 static int  send_event (int fd, uint16_t type, uint16_t code, int32_t value);
 static void send_key (int fd, uint16_t key, int pressed);
 static int  uinput_driver_check();
 static int  uinput_create(char *name);
 static int  init_uinput (void);
 static void close_uinput (void);
+*/
 static BOOLEAN dev_blacklisted_for_absolute_volume(BD_ADDR peer_dev);
 
 static const struct {
@@ -184,6 +202,9 @@
     { NULL,           0,                0,                0 }
 };
 
+static TIMER_LIST_ENT tle_avrc_cmd_tout;
+#define BTIF_AVRC_CMD_TIMEOUT  5
+
 /* the rc_black_addr_prefix and rc_white_addr_prefix are used to correct
  * IOP issues of absolute volume feature
  * We encoutered A2DP headsets/carkits advertising absolute volume but buggy.
@@ -202,7 +223,32 @@
 
 static const UINT8 rc_white_addr_prefix[][3] = {
     {0x94, 0xCE, 0x2C}, // Sony SBH50
-    {0x30, 0x17, 0xC8}  // Sony wm600
+    {0x30, 0x17, 0xC8}, // Sony wm600
+    {0x00, 0x15, 0x83}, // BlueSoleil dongle
+    {0x00, 0x80, 0x98}, // PTS dongle
+    {0x48, 0xC1, 0xAC}, // Plantronics Backbeat Go
+    {0x00, 0x1B, 0xDC}, // PTS dongle 2
+    {0x00, 0x19, 0x8E}, // Demant
+    {0x04, 0x88, 0xE2}, // Apple
+    {0x00, 0x0C, 0x8A}, // Bose
+    {0x1C, 0x48, 0xF9}  // Jabra Pulse
+};
+
+static const char* rc_white_name[] = {
+    "SBH50",
+    "MW600"
+};
+
+/*
+List of devices that can handle AVRCP CT passthrough cmds
+like volume up/down,mute and power-off sent from DUT
+*/
+static const UINT8 ct_passthru_white_addr_prefix[][3] = {
+    {0x24, 0x4B, 0x03}  // Samsung J Sound Bar
+};
+
+static const char* ct_passthru_white_name[] = {
+    "[Samsung] Soundbar J-Series"
 };
 
 static void send_reject_response (UINT8 rc_handle, UINT8 label,
@@ -218,20 +264,32 @@
 static void release_transaction(UINT8 label);
 static rc_transaction_t* get_transaction_by_lbl(UINT8 label);
 static void handle_rc_metamsg_rsp(tBTA_AV_META_MSG *pmeta_msg);
+#if (AVRC_CTLR_INCLUDED == TRUE)
+static void handle_avk_rc_metamsg_cmd(tBTA_AV_META_MSG *pmeta_msg);
+static void handle_avk_rc_metamsg_rsp(tBTA_AV_META_MSG *pmeta_msg);
+static void btif_rc_ctrl_upstreams_rsp_cmd(UINT16 event, tAVRC_COMMAND *pavrc_cmd,
+                                           UINT8* p_buf, UINT16 buf_len);
+static void btif_rc_ctrl_upstreams_rsp_evt(UINT16 event, tAVRC_RESPONSE *pavrc_resp,
+                                           UINT8* p_buf, UINT16 buf_len, UINT8 rsp_type);
+#endif
 static void btif_rc_upstreams_evt(UINT16 event, tAVRC_COMMAND* p_param, UINT8 ctype, UINT8 label);
 static void btif_rc_upstreams_rsp_evt(UINT16 event, tAVRC_RESPONSE *pavrc_resp, UINT8 ctype, UINT8 label);
-static bt_status_t set_addrplayer_rsp(btrc_status_t status_code);
+//static bt_status_t set_addrplayer_rsp(btrc_status_t status_code);
+static bt_status_t send_passthrough_cmd(bt_bdaddr_t *bd_addr, btrcc_pass_cmd_t key_code,
+    btrcc_pass_state_t key_state, uint8_t data_field_len, uint8_t *data_field);
 
 /*Added for Browsing Message Response */
 static void send_browsemsg_rsp (UINT8 rc_handle, UINT8 label,
     tBTA_AV_CODE code, tAVRC_RESPONSE *pmetamsg_resp);
 
+static BOOLEAN dev_whitelisted_for_ct_passthrough_cmd(BD_ADDR peer_dev);
 
 /*****************************************************************************
 **  Static variables
 ******************************************************************************/
 static btif_rc_cb_t btif_rc_cb;
 static btrc_callbacks_t *bt_rc_callbacks = NULL;
+static btrcc_callbacks_t *bt_rc_ctrl_callbacks = NULL;
 
 /*****************************************************************************
 **  Static functions
@@ -240,7 +298,6 @@
 /*****************************************************************************
 **  Externs
 ******************************************************************************/
-extern BOOLEAN btif_multihf_call_terminated_recently();
 extern BOOLEAN btif_hf_call_terminated_recently();
 extern BOOLEAN check_cod(const bt_bdaddr_t *remote_bdaddr, uint32_t cod);
 extern BOOLEAN btif_multihf_is_call_idle();
@@ -252,6 +309,7 @@
 /*****************************************************************************
 **   Local uinput helper functions
 ******************************************************************************/
+/*
 int send_event (int fd, uint16_t type, uint16_t code, int32_t value)
 {
     struct uinput_event event;
@@ -280,7 +338,6 @@
     send_event(fd, EV_SYN, SYN_REPORT, 0);
 }
 
-/************** uinput related functions **************/
 int uinput_driver_check()
 {
     uint32_t i;
@@ -369,77 +426,124 @@
         uinput_fd = -1;
     }
 }
+*/
 
-void handle_rc_features()
+static void btif_ctlr_cmd_tout_tmr_hdlr(TIMER_LIST_ENT *tle)
 {
-    btrc_remote_features_t rc_features = BTRC_FEAT_NONE;
-    bt_bdaddr_t rc_addr;
-    bt_bdaddr_t avdtp_addr;
-    bdstr_t addr1, addr2;
-
-    bdcpy(rc_addr.address, btif_rc_cb.rc_addr);
-    avdtp_addr = btif_av_get_addr();
-
-    BTIF_TRACE_DEBUG2("AVDTP Address : %s AVCTP address: %s",
-                       bd2str(&avdtp_addr, &addr1), bd2str(&rc_addr, &addr2));
+    btrcc_label_t lbl; // SS does not make use of this in apps
+    HAL_CBACK(bt_rc_ctrl_callbacks, command_timeout_cb, &btif_rc_cb.rc_addr, lbl);
+}
 
-    if (dev_blacklisted_for_absolute_volume(btif_rc_cb.rc_addr) ||
-        bdcmp(avdtp_addr.address, rc_addr.address))
+#if (AVRC_CTLR_INCLUDED == TRUE)
+void handle_rc_ctrl_features(BD_ADDR bd_addr)
+{
+    if ((btif_rc_cb.rc_features & BTA_AV_FEAT_RCTG)||
+       ((btif_rc_cb.rc_features & BTA_AV_FEAT_RCCT)&&
+        (btif_rc_cb.rc_features & BTA_AV_FEAT_ADV_CTRL)))
     {
-        btif_rc_cb.rc_features &= ~BTA_AV_FEAT_ADV_CTRL;
-    }
+        bt_bdaddr_t rc_addr;
+        int rc_features = 0;
+        bdcpy(rc_addr.address,bd_addr);
 
-    if (btif_rc_cb.rc_features & BTA_AV_FEAT_BROWSE)
-    {
-        rc_features |= BTRC_FEAT_BROWSE;
-    }
-    if ( (btif_rc_cb.rc_features & BTA_AV_FEAT_ADV_CTRL) &&
-         (btif_rc_cb.rc_features & BTA_AV_FEAT_RCTG))
-    {
-        rc_features |= BTRC_FEAT_ABSOLUTE_VOLUME;
+        if ((btif_rc_cb.rc_features & BTA_AV_FEAT_ADV_CTRL)&&
+             (btif_rc_cb.rc_features & BTA_AV_FEAT_RCCT))
+        {
+            rc_features |= BTRC_FEAT_ABSOLUTE_VOLUME;
+        }
+        if ((btif_rc_cb.rc_features & BTA_AV_FEAT_METADATA)&&
+            (btif_rc_cb.rc_features & BTA_AV_FEAT_VENDOR))
+        {
+            rc_features |= BTRC_FEAT_METADATA;
+        }
+        BTIF_TRACE_DEBUG1("Update rc features to CTRL %d",rc_features);
+        //HAL_CBACK(bt_rc_ctrl_callbacks, getrcfeatures_cb, &rc_addr, rc_features);
     }
-    if (btif_rc_cb.rc_features & BTA_AV_FEAT_METADATA)
+}
+#endif
+
+void handle_rc_features(BD_ADDR bd_addr)
+{
+    if (bt_rc_callbacks != NULL)
     {
-        rc_features |= BTRC_FEAT_METADATA;
-    }
-    BTIF_TRACE_IMP2("%s: rc_features=0x%x", __FUNCTION__, rc_features);
-    HAL_CBACK(bt_rc_callbacks, remote_features_cb, &rc_addr, rc_features)
+        /*Enabling Absolute volume and other avrcp TG specific features only if A2dp Src and
+        Avrcp TG role is activated along with Avrcp CT. Check for bt_rc_callbacks not equal to
+        null assures that avrcp TG service is up
+        */
+        btrc_remote_features_t rc_features = BTRC_FEAT_NONE;
+        bt_bdaddr_t rc_addr;
+        bt_bdaddr_t avdtp_addr;
+        bdstr_t addr1, addr2;
+
+        bdcpy(rc_addr.address, btif_rc_cb.rc_addr);
+        avdtp_addr = btif_av_get_addr();
+
+        BTIF_TRACE_DEBUG2("AVDTP Address : %s AVCTP address: %s",
+                           bd2str(&avdtp_addr, &addr1), bd2str(&rc_addr, &addr2));
+
+        if (dev_blacklisted_for_absolute_volume(btif_rc_cb.rc_addr) ||
+            bdcmp(avdtp_addr.address, rc_addr.address))
+        {
+            btif_rc_cb.rc_features &= ~BTA_AV_FEAT_ADV_CTRL;
+        }
+        if (dev_whitelisted_for_ct_passthrough_cmd(btif_rc_cb.rc_addr))
+        {
+            btif_rc_cb.whitelisted_device = TRUE;
+        }
+        if (btif_rc_cb.rc_features & BTA_AV_FEAT_BROWSE)
+        {
+            rc_features |= BTRC_FEAT_BROWSE;
+        }
+        if ( (btif_rc_cb.rc_features & BTA_AV_FEAT_ADV_CTRL) &&
+             (btif_rc_cb.rc_features & BTA_AV_FEAT_RCTG))
+        {
+            rc_features |= BTRC_FEAT_ABSOLUTE_VOLUME;
+        }
+        if (btif_rc_cb.rc_features & BTA_AV_FEAT_METADATA)
+        {
+            rc_features |= BTRC_FEAT_METADATA;
+        }
+        BTIF_TRACE_IMP2("%s: rc_features=0x%x", __FUNCTION__, rc_features);
+        // Need to check if anything needs to be filled in into last two params
+        HAL_CBACK(bt_rc_callbacks, remote_features_cb, &rc_addr, rc_features, NULL, NULL)
 
 #if (AVRC_ADV_CTRL_INCLUDED == TRUE)
-     BTIF_TRACE_DEBUG1("Checking for feature flags in btif_rc_handler with label %d",
+        BTIF_TRACE_DEBUG1("Checking for feature flags in btif_rc_handler with label %d",
                         btif_rc_cb.rc_vol_label);
-     // Register for volume change on connect
-      if(btif_rc_cb.rc_features & BTA_AV_FEAT_ADV_CTRL &&
+        // Register for volume change on connect
+        if(btif_rc_cb.rc_features & BTA_AV_FEAT_ADV_CTRL &&
          btif_rc_cb.rc_features & BTA_AV_FEAT_RCTG)
-      {
-         rc_transaction_t *p_transaction=NULL;
-         bt_status_t status = BT_STATUS_NOT_READY;
-         if(MAX_LABEL==btif_rc_cb.rc_vol_label)
-         {
-            status=get_transaction(&p_transaction);
-         }
-         else
-         {
-            p_transaction=get_transaction_by_lbl(btif_rc_cb.rc_vol_label);
-            if(NULL!=p_transaction)
+        {
+            rc_transaction_t *p_transaction=NULL;
+            bt_status_t status = BT_STATUS_NOT_READY;
+            if(MAX_LABEL==btif_rc_cb.rc_vol_label)
             {
-               BTIF_TRACE_DEBUG1("register_volumechange already in progress for label %d",
-                                  btif_rc_cb.rc_vol_label);
-               return;
+                status=get_transaction(&p_transaction);
             }
             else
-              status=get_transaction(&p_transaction);
-         }
+            {
+                p_transaction=get_transaction_by_lbl(btif_rc_cb.rc_vol_label);
+                if(NULL!=p_transaction)
+                {
+                    BTIF_TRACE_DEBUG1("register_volumechange already in progress for label %d",
+                                      btif_rc_cb.rc_vol_label);
+                    return;
+                }
+                else
+                {
+                    status=get_transaction(&p_transaction);
+                }
+            }
 
-         if(BT_STATUS_SUCCESS == status && NULL!=p_transaction)
-         {
-            btif_rc_cb.rc_vol_label=p_transaction->lbl;
-            register_volumechange(btif_rc_cb.rc_vol_label);
-         }
-       }
+            if(BT_STATUS_SUCCESS == status && NULL!=p_transaction)
+            {
+                btif_rc_cb.rc_vol_label=p_transaction->lbl;
+                register_volumechange(btif_rc_cb.rc_vol_label);
+            }
+        }
 #endif
-}
+    }
 
+}
 
 /***************************************************************************
  *  Function       handle_rc_connect
@@ -455,6 +559,9 @@
     bt_status_t result = BT_STATUS_SUCCESS;
     int i;
     char bd_str[18];
+#if (AVRC_CTLR_INCLUDED == TRUE)
+    bt_bdaddr_t rc_addr;
+#endif
 
     if(p_rc_open->status == BTA_AV_SUCCESS)
     {
@@ -478,16 +585,35 @@
 
         btif_rc_cb.rc_connected = TRUE;
         btif_rc_cb.rc_handle = p_rc_open->rc_handle;
-
+        btif_rc_cb.whitelisted_device = FALSE;
         /* on locally initiated connection we will get remote features as part of connect */
         if (btif_rc_cb.rc_features != 0)
-            handle_rc_features();
-
-        result = uinput_driver_check();
-        if(result == BT_STATUS_SUCCESS)
+            handle_rc_features(btif_rc_cb.rc_addr);
+        /*if (bt_rc_callbacks)
+        {
+            result = uinput_driver_check();
+            if(result == BT_STATUS_SUCCESS)
+            {
+                init_uinput();
+            }
+        }
+        else
         {
-            init_uinput();
+            BTIF_TRACE_WARNING0("Avrcp TG role not enabled, not initializing UInput");
+        }*/
+#if (AVRC_CTLR_INCLUDED == TRUE)
+        bdcpy(rc_addr.address, btif_rc_cb.rc_addr);
+        /* report connection state if remote device is AVRCP target */
+        if ((btif_rc_cb.rc_features & BTA_AV_FEAT_RCTG)||
+           ((btif_rc_cb.rc_features & BTA_AV_FEAT_RCCT)&&
+            (btif_rc_cb.rc_features & BTA_AV_FEAT_ADV_CTRL)))
+        {
+            HAL_CBACK(bt_rc_ctrl_callbacks, connection_state_cb, &rc_addr,
+                                    BT_STATUS_SUCCESS, BTRCC_CONNECTED);
+            handle_rc_ctrl_features(btif_rc_cb.rc_addr);
         }
+        btif_rc_cb.rcc_absvol_notif_state = NOTIF_STATE_INVALID;
+#endif
     }
     else
     {
@@ -507,6 +633,10 @@
  ***************************************************************************/
 void handle_rc_disconnect (tBTA_AV_RC_CLOSE *p_rc_close)
 {
+#if (AVRC_CTLR_INCLUDED == TRUE)
+    bt_bdaddr_t rc_addr;
+    tBTA_AV_FEAT features;
+#endif
     BTIF_TRACE_IMP2("%s: rc_handle: %d", __FUNCTION__, p_rc_close->rc_handle);
     if ((p_rc_close->rc_handle != btif_rc_cb.rc_handle)
         && (bdcmp(btif_rc_cb.rc_addr, p_rc_close->peer_addr)))
@@ -514,16 +644,41 @@
         BTIF_TRACE_ERROR0("Got disconnect of unknown device");
         return;
     }
-
+#if (AVRC_CTLR_INCLUDED == TRUE)
+    bdcpy(rc_addr.address, btif_rc_cb.rc_addr);
+#endif
     btif_rc_cb.rc_handle = 0;
     btif_rc_cb.rc_connected = FALSE;
     memset(btif_rc_cb.rc_addr, 0, sizeof(BD_ADDR));
     memset(btif_rc_cb.rc_notif, 0, sizeof(btif_rc_cb.rc_notif));
+#if (AVRC_CTLR_INCLUDED == TRUE)
+    features = btif_rc_cb.rc_features;
+#endif
     btif_rc_cb.rc_features = 0;
     btif_rc_cb.rc_vol_label=MAX_LABEL;
     btif_rc_cb.rc_volume=MAX_VOLUME;
+    btif_rc_cb.whitelisted_device = FALSE;
     init_all_transactions();
-    close_uinput();
+    /*if (bt_rc_callbacks != NULL)
+    {
+        close_uinput();
+    }
+    else
+    {
+        BTIF_TRACE_WARNING0("Avrcp TG role not enabled, not closing UInput");
+    }*/
+
+    memset(btif_rc_cb.rc_addr, 0, sizeof(BD_ADDR));
+#if (AVRC_CTLR_INCLUDED == TRUE)
+    /* report connection state if device is AVRCP target */
+    if ((features & BTA_AV_FEAT_RCTG)||
+       ((features & BTA_AV_FEAT_RCCT)&&(features & BTA_AV_FEAT_ADV_CTRL)))
+    {
+        HAL_CBACK(bt_rc_ctrl_callbacks, connection_state_cb, &rc_addr,
+                                BT_STATUS_SUCCESS, BTRCC_DISCONNECTED);
+    }
+    btif_rc_cb.rcc_absvol_notif_state = NOTIF_STATE_INVALID;
+#endif
 }
 
 /***************************************************************************
@@ -541,6 +696,8 @@
     int pressed, i;
 
     BTIF_TRACE_DEBUG2("%s: p_remote_cmd->rc_id=%d", __FUNCTION__, p_remote_cmd->rc_id);
+    if (p_remote_cmd == NULL)
+        return;
 
     /* If AVRC is open and peer sends PLAY but there is no AVDT, then we queue-up this PLAY */
     if (p_remote_cmd)
@@ -562,6 +719,8 @@
             btif_rc_cb.rc_pending_play = FALSE;
             return;
         }
+        if ((p_remote_cmd->rc_id == BTA_AV_RC_VOL_UP)||(p_remote_cmd->rc_id == BTA_AV_RC_VOL_DOWN))
+            return; // this command is not to be sent to UINPUT, only needed for PTS
     }
 
     if(!btif_av_is_connected())
@@ -571,6 +730,12 @@
         return;
     }
 
+    if ((p_remote_cmd->rc_id == BTA_AV_RC_STOP) && (!btif_av_stream_started_ready()))
+    {
+        APPL_TRACE_WARNING1("%s: Stream suspended, ignore STOP cmd",__FUNCTION__);
+        return;
+    }
+
     if (p_remote_cmd->key_state == AVRC_STATE_RELEASE) {
         status = "released";
         pressed = 0;
@@ -580,22 +745,16 @@
     }
 
 
-    if (p_remote_cmd->rc_id == BTA_AV_RC_FAST_FOR || p_remote_cmd->rc_id == BTA_AV_RC_REWIND) {
-        HAL_CBACK(bt_rc_callbacks, passthrough_cmd_cb, p_remote_cmd->rc_id, pressed);
-        return;
-    }
+    //if (p_remote_cmd->rc_id == BTA_AV_RC_FAST_FOR || p_remote_cmd->rc_id == BTA_AV_RC_REWIND) {
+    HAL_CBACK(bt_rc_callbacks, passthrough_cmd_cb, p_remote_cmd->rc_id, pressed);
+        //return;
+    //}
 
+/*
     for (i = 0; key_map[i].name != NULL; i++) {
         if (p_remote_cmd->rc_id == key_map[i].avrcp) {
             BTIF_TRACE_DEBUG3("%s: %s %s", __FUNCTION__, key_map[i].name, status);
 
-           /* MusicPlayer uses a long_press_timeout of 1 second for PLAYPAUSE button
-            * and maps that to autoshuffle. So if for some reason release for PLAY/PAUSE
-            * comes 1 second after the press, the MediaPlayer UI goes into a bad state.
-            * The reason for the delay could be sniff mode exit or some AVDTP procedure etc.
-            * The fix is to generate a release right after the press and drown the 'actual'
-            * release.
-            */
             if ((key_map[i].release_quirk == 1) && (pressed == 0))
             {
                 BTIF_TRACE_DEBUG2("%s: AVRC %s Release Faked earlier, drowned now",
@@ -616,7 +775,47 @@
 
     if (key_map[i].name == NULL)
         BTIF_TRACE_ERROR3("%s AVRCP: unknown button 0x%02X %s", __FUNCTION__,
-                        p_remote_cmd->rc_id, status);
+                        p_remote_cmd->rc_id, status); */
+}
+
+/***************************************************************************
+ *  Function       handle_rc_passthrough_rsp
+ *
+ *  - Argument:    tBTA_AV_REMOTE_RSP passthrough command response
+ *
+ *  - Description: Remote control passthrough response handler
+ *
+ ***************************************************************************/
+void handle_rc_passthrough_rsp ( tBTA_AV_REMOTE_RSP *p_remote_rsp)
+{
+#if (AVRC_CTLR_INCLUDED == TRUE)
+    const char *status;
+    if (btif_rc_cb.rc_features & BTA_AV_FEAT_RCTG || btif_rc_cb.whitelisted_device)
+    {
+        int key_state;
+        if (p_remote_rsp->key_state == AVRC_STATE_RELEASE)
+        {
+            status = "released";
+            key_state = 1;
+        }
+        else
+        {
+            status = "pressed";
+            key_state = 0;
+        }
+
+        BTIF_TRACE_DEBUG3("%s: rc_id=%d status=%s", __FUNCTION__, p_remote_rsp->rc_id, status);
+
+        release_transaction(p_remote_rsp->label);
+        //HAL_CBACK(bt_rc_ctrl_callbacks, passthrough_rsp_cb, p_remote_rsp->rc_id, key_state);
+    }
+    else
+    {
+        BTIF_TRACE_ERROR1("%s DUT does not support AVRCP controller role", __FUNCTION__);
+    }
+#else
+    BTIF_TRACE_ERROR1("%s AVRCP controller role is not enabled", __FUNCTION__);
+#endif
 }
 
 void handle_uid_changed_notification(tBTA_AV_META_MSG *pmeta_msg, tAVRC_COMMAND *pavrc_command)
@@ -735,6 +934,53 @@
     }
 }
 
+/************************************************************************************
+*  Function                 handle_get_folder_item_mediaplyerlist_cmd
+*
+* - Argument:               tBTA_AV_BROWSE_MSG  structure containing  the received
+*                           browse message
+*                           tAVRC_COMMAND       structure containing the commands
+*                           to be updated
+*                           UINT8 event,        variable having value of event.
+*
+*  - Description:           Handler for get media player list command
+*
+************************************************************************************/
+UINT8 handle_get_folder_item_mediaplyerlist_cmd (tBTA_AV_BROWSE_MSG *pbrowse_msg,
+                                                        tAVRC_COMMAND *cmd, UINT8 *event)
+{
+    UINT8 *p_length, *start_item, *end_item;
+    UINT8 length, xx;
+    *event = pbrowse_msg->p_msg->browse.p_browse_data[0] ;
+    cmd->get_items.pdu = *event;
+    //Check length
+    p_length = &pbrowse_msg->p_msg->browse.p_browse_data[1];
+    BE_STREAM_TO_UINT16(length, p_length);
+    if (length < 10)
+    {
+        BTIF_TRACE_ERROR1("GET_FOLDER_ITEMS: length error: =%d", length);
+        return TRUE;
+    }
+    else
+    {
+        start_item = &pbrowse_msg->p_msg->browse.p_browse_data[4];
+        BE_STREAM_TO_UINT32(cmd->get_items.start_item ,start_item);
+        BTIF_TRACE_EVENT1("pbrowse_msg start_item :%x",cmd->get_items.start_item);
+        end_item  =  &pbrowse_msg->p_msg->browse.p_browse_data[8];
+        BE_STREAM_TO_UINT32(cmd->get_items.end_item,end_item);
+        BTIF_TRACE_EVENT1("pbrowse_msg start_item :%x",cmd->get_items.end_item);
+        cmd->get_items.attr_count = 0xff; /* in MediaPlayerList we don't have attr_id */
+        //Update OPCODE
+        cmd->get_items.opcode  = AVRC_OP_BROWSE;
+        cmd->get_items.scope   = pbrowse_msg->p_msg->browse.p_browse_data[3] ;
+        cmd->get_items.status = AVRC_STS_NO_ERROR ;
+        for (xx = 0; xx < BTRC_MAX_ELEM_ATTR_SIZE ; xx++)
+        {
+            cmd->get_items.attrs[xx] = 0;
+        }
+        return FALSE;
+    }
+}
 
 /************************************************************************************
 *  Function                 handle_rc_browsemsg_cmd
@@ -783,7 +1029,7 @@
                 cmd.get_items.opcode  = AVRC_OP_BROWSE;
                 cmd.get_items.scope   = pbrowse_msg->p_msg->browse.p_browse_data[3] ;
                 cmd.get_items.status = AVRC_STS_NO_ERROR ;
-                cmd.get_items.p_attr_list = NULL;
+                //cmd.get_items.p_attr_list = NULL;
                 //Fill PDU to send Response
                 btif_rc_upstreams_evt(event,&cmd,0,pbrowse_msg->label);
                 dropmsg = FALSE;
@@ -851,42 +1097,112 @@
 
         case BTA_AV_REMOTE_CMD_EVT:
         {
-            BTIF_TRACE_DEBUG2("rc_id:0x%x key_state:%d", p_data->remote_cmd.rc_id,
-                               p_data->remote_cmd.key_state);
-            /** In race conditions just after 2nd AVRCP is connected
-             *  remote might send pass through commands, so check for
-             *  Rc handle before processing pass through commands
-             **/
-            if (btif_rc_cb.rc_handle == p_data->remote_cmd.rc_handle)
+            if (bt_rc_callbacks != NULL)
             {
-                handle_rc_passthrough_cmd( (&p_data->remote_cmd) );
+                BTIF_TRACE_DEBUG2("rc_id:0x%x key_state:%d",
+                    p_data->remote_cmd.rc_id, p_data->remote_cmd.key_state);
+                /** In race conditions just after 2nd AVRCP is connected
+                 *  remote might send pass through commands, so check for
+                 *  Rc handle before processing pass through commands
+                 **/
+                if (btif_rc_cb.rc_handle == p_data->remote_cmd.rc_handle)
+                {
+                    handle_rc_passthrough_cmd( (&p_data->remote_cmd) );
+                }
+                else
+                {
+                    BTIF_TRACE_DEBUG0("Pass-through command for Invalid rc handle");
+                }
             }
             else
             {
-                BTIF_TRACE_DEBUG0("Pas-through command for Invalid rc handle");
+                BTIF_TRACE_ERROR0("AVRCP TG role not up, drop passthrough commands");
             }
         }
         break;
+#if (AVRC_CTLR_INCLUDED == TRUE)
+        case BTA_AV_REMOTE_RSP_EVT:
+        {
+            BTIF_TRACE_DEBUG2("RSP: rc_id:0x%x key_state:%d", p_data->remote_rsp.rc_id,
+                               p_data->remote_rsp.key_state);
+            handle_rc_passthrough_rsp( (&p_data->remote_rsp) );
+        }
+        break;
+#endif
         case BTA_AV_RC_FEAT_EVT:
         {
             BTIF_TRACE_DEBUG1("Peer_features:%x", p_data->rc_feat.peer_features);
             btif_rc_cb.rc_features = p_data->rc_feat.peer_features;
-            handle_rc_features();
+            handle_rc_features(p_data->rc_feat.peer_addr);
+#if (AVRC_CTLR_INCLUDED == TRUE)
+            if ((btif_rc_cb.rc_connected) && (bt_rc_ctrl_callbacks != NULL))
+            {
+                handle_rc_ctrl_features(btif_rc_cb.rc_addr);
+            }
+#endif
         }
         break;
         case BTA_AV_META_MSG_EVT:
         {
-            BTIF_TRACE_DEBUG2("BTA_AV_META_MSG_EVT  code:%d label:%d", p_data->meta_msg.code,
-                p_data->meta_msg.rc_handle);
-            /* handle the metamsg command */
-            handle_rc_metamsg_cmd(&(p_data->meta_msg));
+            if (bt_rc_callbacks != NULL)
+            {
+                BTIF_TRACE_DEBUG2("BTA_AV_META_MSG_EVT  code:%d label:%d",
+                                                p_data->meta_msg.code,
+                                                p_data->meta_msg.label);
+                BTIF_TRACE_DEBUG3("  company_id:0x%x len:%d handle:%d",
+                                            p_data->meta_msg.company_id,
+                                            p_data->meta_msg.len,
+                                            p_data->meta_msg.rc_handle);
+                /* handle the metamsg command */
+                handle_rc_metamsg_cmd(&(p_data->meta_msg));
+                /* Free the Memory allocated for tAVRC_MSG */
+            }
+#if (AVRC_CTLR_INCLUDED == TRUE)
+            else if((bt_rc_callbacks == NULL)&&(bt_rc_ctrl_callbacks != NULL))
+            {
+                /* This is case of Sink + CT + TG(for abs vol)) */
+                BTIF_TRACE_DEBUG2("BTA_AV_META_MSG_EVT  code:%d label:%d",
+                                                p_data->meta_msg.code,
+                                                p_data->meta_msg.label);
+                BTIF_TRACE_DEBUG3("  company_id:0x%x len:%d handle:%d",
+                                            p_data->meta_msg.company_id,
+                                            p_data->meta_msg.len,
+                                            p_data->meta_msg.rc_handle);
+                if ((p_data->meta_msg.code >= AVRC_RSP_NOT_IMPL)&&
+                    (p_data->meta_msg.code <= AVRC_RSP_INTERIM))
+                {
+                    /* Its a response */
+                    handle_avk_rc_metamsg_rsp(&(p_data->meta_msg));
+                }
+                else if (p_data->meta_msg.code <= AVRC_CMD_GEN_INQ)
+                {
+                    /* Its a command  */
+                    handle_avk_rc_metamsg_cmd(&(p_data->meta_msg));
+                }
+
+            }
+#endif
+            else
+            {
+                BTIF_TRACE_ERROR0("Neither CTRL, nor TG is up, drop meta commands");
+            }
+            GKI_freebuf(p_data->meta_msg.p_msg);
         }
         break;
         case BTA_AV_BROWSE_MSG_EVT:
         {
-            BTIF_TRACE_DEBUG2("BTA_AV_BROWSE_MSG_EVT  label:%d handle:%d", p_data->browse_msg.label,
-                p_data->browse_msg.rc_handle);
-            handle_rc_browsemsg_cmd(&(p_data->browse_msg));
+            if (bt_rc_callbacks != NULL)
+            {
+                BTIF_TRACE_DEBUG2("BTA_AV_BROWSE_MSG_EVT  label:%d handle:%d",
+                                                p_data->browse_msg.label,
+                                                p_data->browse_msg.rc_handle);
+                handle_rc_browsemsg_cmd(&(p_data->browse_msg));
+            }
+            else
+            {
+                BTIF_TRACE_ERROR0("AVRCP TG role not up, drop browse commands");
+            }
+            GKI_freebuf(p_data->browse_msg.p_msg);
         }
         break;
         default:
@@ -912,6 +1228,18 @@
 
 /***************************************************************************
  **
+ ** Function       btif_rc_get_connected_peer_handle
+ **
+ ** Description    Fetches the connected headset's handle if any
+ **
+ ***************************************************************************/
+UINT8 btif_rc_get_connected_peer_handle(void)
+{
+    return btif_rc_cb.rc_handle;
+}
+
+/***************************************************************************
+ **
  ** Function       btif_rc_check_handle_pending_play
  **
  ** Description    Clears the queued PLAY command. if bSend is TRUE, forwards to app
@@ -921,6 +1249,8 @@
 /* clear the queued PLAY command. if bSend is TRUE, forward to app */
 void btif_rc_check_handle_pending_play (BD_ADDR peer_addr, BOOLEAN bSendToApp)
 {
+    UNUSED(peer_addr);
+
     BTIF_TRACE_DEBUG2("%s: bSendToApp=%d", __FUNCTION__, bSendToApp);
     if (btif_rc_cb.rc_pending_play)
     {
@@ -989,7 +1319,6 @@
     tAVRC_RESPONSE *pmetamsg_resp)
 {
     UINT8 ctype;
-    tAVRC_STS status;
 
     if (!pmetamsg_resp)
     {
@@ -1385,6 +1714,7 @@
             }
         }
         break;
+        /*
         case AVRC_PDU_SET_ADDRESSED_PLAYER:
         {
             btrc_status_t status_code = AVRC_STS_NO_ERROR;
@@ -1396,7 +1726,9 @@
             if (btif_rc_cb.rc_connected == TRUE)
             {
                 FILL_PDU_QUEUE(IDX_SET_ADDRESS_PLAYER_RSP, ctype, label, TRUE);
+#ifdef PLATFORM_ANDROID				
                 HAL_CBACK(bt_rc_callbacks, set_addrplayer_cb, pavrc_cmd->addr_player.player_id);
+#endif
             }
         }
         break;
@@ -1404,21 +1736,53 @@
         {
             //For testing purpose to cover Send path, initiate Send from here
             tAVRC_RESPONSE avrc_rsp;
+#ifdef PLATFORM_ANDROID			
             btrc_getfolderitem_t getfolder ;
             btrc_browse_folderitem_t scope;
+#endif			
             UINT8 player[] = "MusicPlayer1";
             tAVRC_ITEM tem[1];
-            UINT8  index ;
+            UINT8  index, numAttr;
             BTIF_TRACE_EVENT1("%s()AVRC_PDU_GET_FOLDER_ITEMS", __FUNCTION__);
             FILL_PDU_QUEUE(IDX_GET_FOLDER_ITEMS_RSP,ctype, label, TRUE);
             BTIF_TRACE_EVENT1("rc_connected: %d",btif_rc_cb.rc_connected);
             if (btif_rc_cb.rc_connected == TRUE)
             {
+#ifdef PLATFORM_ANDROID			
                 getfolder.start_item = pavrc_cmd->get_items.start_item;
                 getfolder.end_item   = pavrc_cmd->get_items.end_item;
                 getfolder.size       = AVCT_GetBrowseMtu(btif_rc_cb.rc_handle);
+                getfolder.attr_count = pavrc_cmd->get_items.attr_count;
                 scope                = (btrc_browse_folderitem_t)pavrc_cmd->get_items.scope;
+                if (getfolder.attr_count == 255)
+                {
+                    numAttr = 0;
+                }
+                else
+                {
+                    if (getfolder.attr_count == 0)
+                    {
+                        numAttr = 7;
+                        for (index = 0; index < BTRC_MAX_ELEM_ATTR_SIZE; index++)
+                        {
+                            getfolder.attrs[index] = index + 1;
+                        }
+                    }
+                    else
+                    {
+                        numAttr = getfolder.attr_count;
+                        for (index = 0; index < numAttr; index++)
+                        {
+                            getfolder.attrs[index] = pavrc_cmd->get_items.attrs[index];
+                            BTIF_TRACE_ERROR2("getfolder[%d] = %d", index, getfolder.\
+                                                                        attrs[index]);
+                            BTIF_TRACE_ERROR2("pavrc_cmd->get_items.attrs[%d] = %d",\
+                                            index, pavrc_cmd->get_items.attrs[index]);
+                        }
+                    }
+                }
                 HAL_CBACK(bt_rc_callbacks, get_folderitems_cb, scope, &getfolder);
+#endif
             }
         }
         break;
@@ -1454,6 +1818,7 @@
             }
         }
         break;
+        */
         default:
         {
             send_reject_response (btif_rc_cb.rc_handle, label, pavrc_cmd->pdu,
@@ -1461,92 +1826,380 @@
         }
         break;
     }
-
 }
+#if (AVRC_CTLR_INCLUDED == TRUE)
 
+static void btif_rc_ctrl_process_get_elem_attr(btrcc_element_attr_t *p_attrs,
+                            UINT8 *p_byte_array, UINT8 num_items)
+{
+    int count;
+    for (count =0; count < num_items; count++)
+    {
+        BE_STREAM_TO_UINT32(p_attrs->id, p_byte_array);
+        BE_STREAM_TO_UINT16(p_attrs->attr_str.character_set, p_byte_array);
+        BE_STREAM_TO_UINT16(p_attrs->attr_str.length, p_byte_array);
+        p_attrs->attr_str.string = (uint8_t *) GKI_getbuf(p_attrs->attr_str.length);
+        BE_STREAM_TO_ARRAY(p_byte_array,p_attrs->attr_str.string,
+                    p_attrs->attr_str.length)
+    }
+}
 
 /*******************************************************************************
 **
-** Function         btif_rc_upstreams_rsp_evt
+** Function         btif_rc_ctrl_upstreams_rsp_cmd
 **
 ** Description      Executes AVRC UPSTREAMS response events in btif context.
 **
 ** Returns          void
 **
 *******************************************************************************/
-static void btif_rc_upstreams_rsp_evt(UINT16 event, tAVRC_RESPONSE *pavrc_resp, UINT8 ctype, UINT8 label)
+static void btif_rc_ctrl_upstreams_rsp_cmd(UINT16 event, tAVRC_COMMAND *pavrc_cmd, UINT8* p_buf,
+                                                                                 UINT16 buf_len)
 {
-    BTIF_TRACE_IMP5("%s pdu: %s handle: 0x%x ctype:%x label:%x", __FUNCTION__,
-        dump_rc_pdu(pavrc_resp->pdu), btif_rc_cb.rc_handle, ctype, label);
-
-#if (AVRC_ADV_CTRL_INCLUDED == TRUE)
+    BTIF_TRACE_IMP3("%s pdu: %s handle: 0x%x", __FUNCTION__,
+        dump_rc_pdu(pavrc_cmd->pdu), btif_rc_cb.rc_handle);
+    bt_bdaddr_t rc_addr;
+    bdcpy(rc_addr.address, btif_rc_cb.rc_addr);
+#if (AVRC_CTLR_INCLUDED == TRUE)
     switch (event)
     {
-        case AVRC_PDU_REGISTER_NOTIFICATION:
-        {
-             if(AVRC_RSP_CHANGED==ctype)
-                 btif_rc_cb.rc_volume=pavrc_resp->reg_notif.param.volume;
-             HAL_CBACK(bt_rc_callbacks, volume_change_cb, pavrc_resp->reg_notif.param.volume,ctype)
-        }
-        break;
-
-        case AVRC_PDU_SET_ABSOLUTE_VOLUME:
-        {
-            BTIF_TRACE_DEBUG2("Set absolute volume change event received: volume %d,ctype %d",
-                pavrc_resp->volume.volume,ctype);
-            if(AVRC_RSP_ACCEPT==ctype)
-                btif_rc_cb.rc_volume=pavrc_resp->volume.volume;
-            HAL_CBACK(bt_rc_callbacks,volume_change_cb,pavrc_resp->volume.volume,ctype)
-        }
-        break;
-
-        default:
-            return;
+    case AVRC_PDU_SET_ABSOLUTE_VOLUME:
+        // As confirmed by SS transaction label is no more used in Apps.
+         HAL_CBACK(bt_rc_ctrl_callbacks, set_absolute_volume_cmd_cb, &rc_addr,
+                                                    0, pavrc_cmd->volume.volume);
+         break;
+    case AVRC_PDU_REGISTER_NOTIFICATION:
+         if (pavrc_cmd->reg_notif.event_id == AVRC_EVT_VOLUME_CHANGE)
+         {
+             BTIF_TRACE_IMP1("%s: Absolute volume registration by peer", __FUNCTION__);
+             btif_rc_cb.rcc_absvol_notif_state = NOTIF_STATE_INTERIM;
+             btrcc_notification_t notif;
+             notif.volume = 0; // Not used though
+             HAL_CBACK(bt_rc_ctrl_callbacks, notification_cb, &rc_addr, BT_STATUS_SUCCESS,
+                pavrc_cmd->reg_notif.event_id, &notif);
+         }
+         break;
     }
 #endif
 }
 
-/************************************************************************************
-**  AVRCP API Functions
-************************************************************************************/
-
 /*******************************************************************************
 **
-** Function         init
+** Function         btif_rc_ctrl_upstreams_rsp_evt
 **
-** Description      Initializes the AVRC interface
+** Description      Executes AVRC UPSTREAMS response events in btif context.
 **
-** Returns          bt_status_t
+** Returns          void
 **
 *******************************************************************************/
-static bt_status_t init(btrc_callbacks_t* callbacks )
+static void btif_rc_ctrl_upstreams_rsp_evt(UINT16 event, tAVRC_RESPONSE *pavrc_resp,
+                                        UINT8* p_buf, UINT16 buf_len, UINT8 rsp_type)
 {
-    BTIF_TRACE_EVENT1("## %s ##", __FUNCTION__);
-    bt_status_t result = BT_STATUS_SUCCESS;
-
-    if (bt_rc_callbacks)
-        return BT_STATUS_DONE;
-
-    bt_rc_callbacks = callbacks;
-    memset (&btif_rc_cb, 0, sizeof(btif_rc_cb));
-    btif_rc_cb.rc_vol_label=MAX_LABEL;
-    btif_rc_cb.rc_volume=MAX_VOLUME;
-    lbl_init();
-
-    return result;
-}
+    BTIF_TRACE_IMP4("%s pdu: %s handle: 0x%x rsp_type:%x", __FUNCTION__,
+        dump_rc_pdu(pavrc_resp->pdu), btif_rc_cb.rc_handle, rsp_type);
+    bt_bdaddr_t rc_addr;
+    bdcpy(rc_addr.address, btif_rc_cb.rc_addr);
 
-/***************************************************************************
-**
-** Function         get_play_status_rsp
-**
-** Description      Returns the current play status.
-**                      This method is called in response to
-**                      GetPlayStatus request.
-**
-** Returns          bt_status_t
-**
-***************************************************************************/
+#if (AVRC_CTLR_INCLUDED == TRUE)
+    switch (event)
+    {
+        /*case AVRC_PDU_GET_CAPABILITIES:
+        {
+            int xx = 0;
+            uint32_t *p_int_array = NULL;
+            if (pavrc_resp->get_caps.count > 0)
+                p_int_array = (uint32_t*)GKI_getbuf(4*pavrc_resp->get_caps.count);
+            for (xx = 0; xx < pavrc_resp->get_caps.count; xx++)
+            {
+                if (pavrc_resp->get_caps.capability_id == AVRC_CAP_COMPANY_ID)
+                {
+                    p_int_array[xx] = pavrc_resp->get_caps.param.company_id[xx];
+                }
+                else if (pavrc_resp->get_caps.capability_id == AVRC_CAP_EVENTS_SUPPORTED)
+                {
+                    p_int_array[xx] = pavrc_resp->get_caps.param.event_id[xx];
+                }
+            }
+            HAL_CBACK(bt_rc_ctrl_callbacks, getcap_rsp_cb, &rc_addr,
+            pavrc_resp->get_caps.capability_id, p_int_array, pavrc_resp->get_caps.count, rsp_type);
+            if (p_int_array != NULL)
+                GKI_freebuf(p_int_array);
+        }
+            break;*/
+        case AVRC_PDU_LIST_PLAYER_APP_ATTR:
+        {
+            int xx = 0;
+            UINT8  *p_byte_array = NULL;
+            if (pavrc_resp->list_app_attr.num_attr > 0)
+                p_byte_array = (UINT8*)GKI_getbuf(pavrc_resp->list_app_attr.num_attr);
+            for (xx = 0; xx < pavrc_resp->list_app_attr.num_attr; xx++)
+            {
+                p_byte_array[xx] = pavrc_resp->list_app_attr.attrs[xx];
+            }
+            if (tle_avrc_cmd_tout.in_use) {
+                BTIF_TRACE_DEBUG0("AVRC_PDU_LIST_PLAYER_APP_ATTR: Stopping TOUT timer.");
+                btu_stop_timer(&tle_avrc_cmd_tout);
+            }
+            HAL_CBACK(bt_rc_ctrl_callbacks, list_player_attrs_rsp_cb, &rc_addr, 0,
+                    (rsp_type == 0x0C) ? BT_STATUS_SUCCESS : BT_STATUS_FAIL,
+                    pavrc_resp->list_app_attr.num_attr, p_byte_array);
+            if (p_byte_array != NULL)
+                GKI_freebuf(p_byte_array);
+        }
+            break;
+        case AVRC_PDU_LIST_PLAYER_APP_VALUES:
+        {
+            int xx = 0;
+            UINT8  *p_byte_array = NULL;
+            if (pavrc_resp->list_app_values.num_val > 0)
+                p_byte_array = (UINT8*)GKI_getbuf(pavrc_resp->list_app_values.num_val);
+            for (xx = 0; xx < pavrc_resp->list_app_values.num_val; xx++)
+            {
+                p_byte_array[xx] = pavrc_resp->list_app_values.vals[xx];
+            }
+            if (tle_avrc_cmd_tout.in_use) {
+                BTIF_TRACE_DEBUG0("AVRC_PDU_LIST_PLAYER_APP_ATTR: Stopping TOUT timer.");
+                btu_stop_timer(&tle_avrc_cmd_tout);
+            }
+            HAL_CBACK(bt_rc_ctrl_callbacks, list_player_values_rsp_cb, &rc_addr, 0,
+                    (rsp_type == 0x0C) ? BT_STATUS_SUCCESS : BT_STATUS_FAIL,
+                    pavrc_resp->list_app_values.num_val, p_byte_array);
+            if (p_byte_array != NULL)
+                GKI_freebuf(p_byte_array);
+        }
+            break;
+        case AVRC_PDU_GET_CUR_PLAYER_APP_VALUE:
+        {
+            if (pavrc_resp->get_cur_app_val.num_val <= 0)
+            {
+                HAL_CBACK(bt_rc_ctrl_callbacks, get_player_value_rsp_cb, &rc_addr, 0,
+                      BT_STATUS_FAIL, NULL);
+                break;
+            }
+            int xx = 0;
+            btrcc_player_settings_t p_attrs;
+            UINT8  *p_supported_ids = (UINT8*)GKI_getbuf(pavrc_resp->get_cur_app_val.num_val);
+            UINT8  *p_byte_array = (UINT8*)GKI_getbuf(pavrc_resp->get_cur_app_val.num_val);
+            for (xx = 0; xx < pavrc_resp->get_cur_app_val.num_val; xx++)
+            {
+                p_supported_ids[xx] = pavrc_resp->get_cur_app_val.p_vals[xx].attr_id;
+                p_byte_array[xx] = pavrc_resp->get_cur_app_val.p_vals[xx].attr_val;
+            }
+            p_attrs.num_attr = pavrc_resp->get_cur_app_val.num_val;
+            for (xx = 0; xx < pavrc_resp->get_cur_app_val.num_val; xx++)
+            {
+                p_attrs.attr[xx] = pavrc_resp->get_cur_app_val.p_vals[xx].attr_id;
+                p_attrs.value[xx] = pavrc_resp->get_cur_app_val.p_vals[xx].attr_val;
+            }
+            if (tle_avrc_cmd_tout.in_use) {
+                BTIF_TRACE_DEBUG0("AVRC_PDU_LIST_PLAYER_APP_ATTR: Stopping TOUT timer.");
+                btu_stop_timer(&tle_avrc_cmd_tout);
+            }
+            HAL_CBACK(bt_rc_ctrl_callbacks, get_player_value_rsp_cb, &rc_addr, 0,
+                (rsp_type == 0x0C) ? BT_STATUS_SUCCESS : BT_STATUS_FAIL, &p_attrs);
+            GKI_freebuf(pavrc_resp->get_cur_app_val.p_vals);
+            GKI_freebuf(p_byte_array);
+            GKI_freebuf(p_supported_ids);
+        }
+            break;
+        case AVRC_PDU_SET_PLAYER_APP_VALUE:
+        {
+            if (tle_avrc_cmd_tout.in_use) {
+                BTIF_TRACE_DEBUG0("AVRC_PDU_LIST_PLAYER_APP_ATTR: Stopping TOUT timer.");
+                btu_stop_timer(&tle_avrc_cmd_tout);
+            }
+            //HAL_CBACK(bt_rc_ctrl_callbacks, setplayerappsetting_rsp_cb, &rc_addr, rsp_type);
+        }
+            break;
+        case AVRC_PDU_REGISTER_NOTIFICATION:
+        {
+            if(buf_len <= 0)
+            {
+                HAL_CBACK(bt_rc_ctrl_callbacks, notification_cb, &rc_addr,
+                    BT_STATUS_FAIL, pavrc_resp->reg_notif.event_id, NULL);
+                break;
+            }
+            UINT8  *p_byte_array = (UINT8*)GKI_getbuf(buf_len);
+            memcpy(p_byte_array,p_buf,buf_len);
+            HAL_CBACK(bt_rc_ctrl_callbacks, notification_cb, &rc_addr,
+                    BT_STATUS_FAIL, pavrc_resp->reg_notif.event_id,
+                    (btrcc_notification_t *)&pavrc_resp->reg_notif.param);
+            GKI_freebuf(p_byte_array);
+        }
+            break;
+        case AVRC_PDU_GET_ELEMENT_ATTR:
+        {
+            if (pavrc_resp->get_elem_attrs.num_attr <= 0)
+            {
+                HAL_CBACK(bt_rc_ctrl_callbacks, get_element_attr_rsp_cb, &rc_addr,
+                  0, (rsp_type == 0x0C) ? BT_STATUS_SUCCESS : BT_STATUS_FAIL, 0, NULL);
+                break;
+            }
+            int freecount;
+            UINT8 *p_byte_array = (UINT8*)GKI_getbuf(buf_len);
+            memcpy(p_byte_array,p_buf,buf_len);
+            btrcc_element_attr_t *p_attrs = (btrcc_element_attr_t *)
+                    GKI_getbuf(pavrc_resp->get_elem_attrs.num_attr *
+                    sizeof(btrcc_element_attr_t));
+            btif_rc_ctrl_process_get_elem_attr(p_attrs, p_byte_array,
+                    pavrc_resp->get_elem_attrs.num_attr);
+            if (tle_avrc_cmd_tout.in_use) {
+                BTIF_TRACE_DEBUG0("AVRC_PDU_LIST_PLAYER_APP_ATTR: Stopping TOUT timer.");
+                btu_stop_timer(&tle_avrc_cmd_tout);
+            }
+            HAL_CBACK(bt_rc_ctrl_callbacks, get_element_attr_rsp_cb, &rc_addr,
+              0, (rsp_type == 0x0C) ? BT_STATUS_SUCCESS : BT_STATUS_FAIL,
+              pavrc_resp->get_elem_attrs.num_attr, p_attrs);
+            for (freecount = 0; freecount < pavrc_resp->get_elem_attrs.num_attr;
+                    freecount++)
+            {
+                GKI_freebuf(p_attrs[freecount].attr_str.string);
+            }
+            GKI_freebuf(p_attrs);
+            GKI_freebuf(p_byte_array);
+        }
+            break;
+        case AVRC_PDU_GET_PLAY_STATUS:
+        {
+            if (buf_len <= 0)
+            {
+                HAL_CBACK(bt_rc_ctrl_callbacks, get_play_status_rsp_cb, &rc_addr,
+                    0, BT_STATUS_FAIL, 0, 0, 0);
+                break;
+            }
+            UINT8  *p_byte_array = (UINT8*)GKI_getbuf(buf_len);
+            memcpy(p_byte_array, p_buf, buf_len);
+            uint32_t song_len, song_pos;
+            btrcc_play_status_t play_status;
+            BE_STREAM_TO_UINT32(song_len, p_byte_array);
+            BE_STREAM_TO_UINT32(song_pos, p_byte_array);
+            BE_STREAM_TO_UINT8(play_status, p_byte_array);
+            if (tle_avrc_cmd_tout.in_use) {
+                BTIF_TRACE_DEBUG0("AVRC_PDU_LIST_PLAYER_APP_ATTR: Stopping TOUT timer.");
+                btu_stop_timer(&tle_avrc_cmd_tout);
+            }
+            HAL_CBACK(bt_rc_ctrl_callbacks, get_play_status_rsp_cb, &rc_addr,
+                0, (rsp_type == 0x0C) ? BT_STATUS_SUCCESS : BT_STATUS_FAIL,
+                song_len, song_pos, play_status);
+            GKI_freebuf(p_byte_array);
+        }
+            break;
+        default:
+            return;
+    }
+#endif
+}
+#endif
+/*******************************************************************************
+**
+** Function         btif_rc_upstreams_rsp_evt
+**
+** Description      Executes AVRC UPSTREAMS response events in btif context.
+**
+** Returns          void
+**
+*******************************************************************************/
+static void btif_rc_upstreams_rsp_evt(UINT16 event, tAVRC_RESPONSE *pavrc_resp, UINT8 ctype, UINT8 label)
+{
+    BTIF_TRACE_IMP5("%s pdu: %s handle: 0x%x ctype:%x label:%x", __FUNCTION__,
+        dump_rc_pdu(pavrc_resp->pdu), btif_rc_cb.rc_handle, ctype, label);
+
+#if (AVRC_ADV_CTRL_INCLUDED == TRUE)
+    switch (event)
+    {
+        case AVRC_PDU_REGISTER_NOTIFICATION:
+        {
+             if(AVRC_RSP_CHANGED==ctype)
+                 btif_rc_cb.rc_volume=pavrc_resp->reg_notif.param.volume;
+             // As confirmed by SS, this CB is not used in Apps layer
+             HAL_CBACK(bt_rc_callbacks, volume_change_cb, pavrc_resp->reg_notif.param.volume, 0, ctype)
+        }
+        break;
+
+        case AVRC_PDU_SET_ABSOLUTE_VOLUME:
+        {
+            BTIF_TRACE_DEBUG2("Set absolute volume change event received: volume %d,ctype %d",
+                pavrc_resp->volume.volume,ctype);
+            if(AVRC_RSP_ACCEPT==ctype)
+                btif_rc_cb.rc_volume=pavrc_resp->volume.volume;
+            // As confirmed by SS, this CB is not used in Apps layer
+            HAL_CBACK(bt_rc_callbacks, volume_change_cb, pavrc_resp->volume.volume, 0, ctype)
+        }
+        break;
+
+        default:
+            return;
+    }
+#endif
+}
+
+/************************************************************************************
+**  AVRCP API Functions
+************************************************************************************/
+
+/*******************************************************************************
+**
+** Function         init
+**
+** Description      Initializes the AVRC interface
+**
+** Returns          bt_status_t
+**
+*******************************************************************************/
+static bt_status_t init(btrc_callbacks_t* callbacks )
+{
+    BTIF_TRACE_EVENT1("## %s ##", __FUNCTION__);
+    bt_status_t result = BT_STATUS_SUCCESS;
+
+    if (bt_rc_callbacks)
+        return BT_STATUS_DONE;
+
+    bt_rc_callbacks = callbacks;
+    memset (&btif_rc_cb, 0, sizeof(btif_rc_cb));
+    btif_rc_cb.rc_vol_label=MAX_LABEL;
+    btif_rc_cb.rc_volume=MAX_VOLUME;
+    lbl_init();
+
+    return result;
+}
+
+/*******************************************************************************
+**
+** Function         init_ctrl
+**
+** Description      Initializes the AVRC interface
+**
+** Returns          bt_status_t
+**
+*******************************************************************************/
+static bt_status_t init_ctrl(btrcc_callbacks_t* callbacks )
+{
+    BTIF_TRACE_EVENT1("## %s ##", __FUNCTION__);
+    bt_status_t result = BT_STATUS_SUCCESS;
+
+    if (bt_rc_ctrl_callbacks)
+        return BT_STATUS_DONE;
+
+    bt_rc_ctrl_callbacks = callbacks;
+    memset (&btif_rc_cb, 0, sizeof(btif_rc_cb));
+    btif_rc_cb.rc_vol_label=MAX_LABEL;
+    btif_rc_cb.rc_volume=MAX_VOLUME;
+    lbl_init();
+
+    return result;
+}
+
+/***************************************************************************
+**
+** Function         get_play_status_rsp
+**
+** Description      Returns the current play status.
+**                      This method is called in response to
+**                      GetPlayStatus request.
+**
+** Returns          bt_status_t
+**
+***************************************************************************/
 static bt_status_t get_play_status_rsp(btrc_play_status_t play_status, uint32_t song_len,
     uint32_t song_pos)
 {
@@ -1577,10 +2230,14 @@
 ** Returns          bt_status_t
 **
 ****************************************************************************/
+#ifdef PLATFORM_ANDROID
 static bt_status_t  list_player_app_attr_rsp( uint8_t num_attr, btrc_player_attr_t *p_attrs)
+#else
+static bt_status_t  list_player_app_attr_rsp( int num_attr, btrc_player_attr_t *p_attrs)
+#endif
 {
     tAVRC_RESPONSE avrc_rsp;
-    UINT32 i;
+    int i;
 
     CHECK_RC_CONNECTED
     memset(&(avrc_rsp.list_app_attr), 0, sizeof(tAVRC_LIST_APP_ATTR_RSP));
@@ -1590,7 +2247,7 @@
     }
     else
     {
-        avrc_rsp.list_app_attr.num_attr = num_attr;
+        avrc_rsp.list_app_attr.num_attr = (UINT8)num_attr;
         for (i = 0 ; i < num_attr ; ++i)
         {
             avrc_rsp.list_app_attr.attrs[i] = p_attrs[i];
@@ -1611,10 +2268,14 @@
 ** Description      ListPlayerApplicationSettingValues (PDU ID: 0x12)
                     This method is called in response to PDU 0x12
 ************************************************************************/
+#ifdef PLATFORM_ANDROID
 static bt_status_t  list_player_app_value_rsp( uint8_t num_val, uint8_t *value)
+#else
+static bt_status_t  list_player_app_value_rsp( int num_val, uint8_t *value)
+#endif
 {
     tAVRC_RESPONSE avrc_rsp;
-    UINT32 i;
+    int i;
 
     CHECK_RC_CONNECTED
     memset(&(avrc_rsp.list_app_values), 0, sizeof(tAVRC_LIST_APP_VALUES_RSP));
@@ -1624,7 +2285,7 @@
     }
     else
     {
-        avrc_rsp.list_app_values.num_val = num_val;
+        avrc_rsp.list_app_values.num_val = (UINT8)num_val;
         for (i = 0; i < num_val; ++i)
         {
             avrc_rsp.list_app_values.vals[i] = value[i];
@@ -1656,11 +2317,11 @@
     memset(&(avrc_rsp.get_cur_app_val) ,0 , sizeof(tAVRC_GET_CUR_APP_VALUE_RSP));
     avrc_rsp.get_cur_app_val.p_vals   = app_sett ;
     //Check for Error Condition
-    if ((p_vals == NULL) || (p_vals->num_attr== 0) || (p_vals->num_attr > AVRC_MAX_APP_ATTR_SIZE))
+    if ((p_vals == NULL) || (p_vals->num_attr== 0) || (p_vals->num_attr > BTRC_MAX_ELEM_ATTR_SIZE))
     {
         avrc_rsp.get_cur_app_val.status = AVRC_STS_BAD_PARAM;
     }
-    else
+    else if (p_vals->num_attr <= BTRC_MAX_APP_SETTINGS)
     {
         memset(app_sett, 0, sizeof(tAVRC_APP_SETTING)*p_vals->num_attr );
         //update num_val
@@ -1776,7 +2437,7 @@
         {
             attr_txt[i].charset_id = AVRC_CHARSET_ID_UTF8;
             attr_txt[i].attr_id  = p_attrs[i].id ;
-            attr_txt[i].str_len  = (UINT8)strnlen((char *)p_attrs[i].text ,BTRC_MAX_ATTR_STR_LEN );
+            attr_txt[i].str_len  = (UINT8)strnlen((char *)p_attrs[i].text , BTRC_MAX_ATTR_STR_LEN);
             attr_txt[i].p_str    = p_attrs[i].text ;
             BTIF_TRACE_DEBUG5("%s attr_id:0x%x, charset_id:0x%x, str_len:%d, str:%s",
                                   __FUNCTION__, (unsigned int)attr_txt[i].attr_id,
@@ -1818,7 +2479,8 @@
     }
     else
     {
-        for (i=0; i<num_attr; i++) {
+        for (i=0; i<num_attr; i++)
+        {
             element_attrs[i].attr_id = p_attrs[i].attr_id;
             element_attrs[i].name.charset_id = AVRC_CHARSET_ID_UTF8;
             element_attrs[i].name.str_len = (UINT16)strlen((char *)p_attrs[i].text);
@@ -1887,6 +2549,7 @@
             memcpy(&avrc_rsp.reg_notif.param.player_setting.attr_value,
                                        p_param->player_setting.attr_values, 2);
             break;
+#ifdef PLATFORM_ANDROID
         case BTRC_EVT_ADDRESSED_PLAYER_CHANGED:
             avrc_rsp.reg_notif.param.addr_player.player_id = p_param->player_id;
             avrc_rsp.reg_notif.param.addr_player.uid_counter = 0;
@@ -1894,6 +2557,7 @@
         case BTRC_EVT_AVAILABLE_PLAYERS_CHANGED:
             avrc_rsp.reg_notif.param.evt  = 0x0a;
             break;
+#endif			
         default:
             BTIF_TRACE_WARNING2("%s : Unhandled event ID : 0x%x", __FUNCTION__, event_id);
             return BT_STATUS_UNHANDLED;
@@ -1901,6 +2565,7 @@
 
     avrc_rsp.reg_notif.pdu = AVRC_PDU_REGISTER_NOTIFICATION;
     avrc_rsp.reg_notif.opcode = opcode_from_pdu(AVRC_PDU_REGISTER_NOTIFICATION);
+#ifdef PLATFORM_ANDROID	
     if (type == BTRC_NOTIFICATION_TYPE_REJECT)
     {
         /* Spec AVRCP 1.5 ,section 6.9.2.2, on completion
@@ -1913,6 +2578,7 @@
         avrc_rsp.get_play_status.status = AVRC_STS_ADDR_PLAYER_CHG;
     }
     else
+#endif		
     {
         avrc_rsp.get_play_status.status = AVRC_STS_NO_ERROR;
     }
@@ -1923,7 +2589,7 @@
     return BT_STATUS_SUCCESS;
 }
 
-
+#ifdef PLATFORM_ANDROID
 /***************************************************************************
 **
 ** Function         get_folderitem_rsp
@@ -1982,13 +2648,13 @@
         }
     }
     if (avrc_rsp.get_items.item_count == 0) {
-        /*As per spec Send proper Error if no Music App is registered.*/
         avrc_rsp.get_items.status = AVRC_STS_BAD_RANGE;
     }
     avrc_rsp.get_items.p_item_list = item;
     app_sendbrowsemsg(IDX_GET_FOLDER_ITEMS_RSP ,&avrc_rsp);
     return BT_STATUS_SUCCESS;
 }
+#endif
 
 /**********************************************************************
 **
@@ -2000,17 +2666,16 @@
 **
 *********************************************************************/
 
-static bt_status_t set_addrplayer_rsp(btrc_status_t status_code)
+/*static bt_status_t set_addrplayer_rsp(btrc_status_t status_code)
 {
     tAVRC_RESPONSE avrc_rsp;
     CHECK_RC_CONNECTED
     avrc_rsp.addr_player.status = status_code;
     avrc_rsp.addr_player.opcode = opcode_from_pdu(AVRC_PDU_SET_ADDRESSED_PLAYER);
     avrc_rsp.addr_player.pdu    = AVRC_PDU_SET_ADDRESSED_PLAYER;
-    /* Send the response */
     SEND_METAMSG_RSP(IDX_SET_ADDRESS_PLAYER_RSP, &avrc_rsp);
     return BT_STATUS_SUCCESS;
-}
+}*/
 
 /***************************************************************************
 **
@@ -2109,6 +2774,7 @@
     avrc_cmd.pdu = AVRC_PDU_REGISTER_NOTIFICATION;
     avrc_cmd.reg_notif.event_id = AVRC_EVT_VOLUME_CHANGE;
     avrc_cmd.reg_notif.status = AVRC_STS_NO_ERROR;
+    avrc_cmd.reg_notif.param = 0;
 
     BldResp=AVRC_BldCommand(&avrc_cmd, &p_msg);
     if(AVRC_STS_NO_ERROR==BldResp && p_msg)
@@ -2206,8 +2872,111 @@
      btif_rc_upstreams_rsp_evt((uint16_t)avrc_response.rsp.pdu, &avrc_response, pmeta_msg->code,
                                 pmeta_msg->label);
 }
+#if (AVRC_CTLR_INCLUDED == TRUE)
+/***************************************************************************
+**
+** Function         handle_avk_rc_metamsg_rsp
+**
+** Description      Handle RC metamessage response
+**
+** Returns          void
+**
+***************************************************************************/
+static void handle_avk_rc_metamsg_rsp(tBTA_AV_META_MSG *pmeta_msg)
+{
+    tAVRC_RESPONSE    avrc_response = {0};
+    UINT8             scratch_buf[4096] = {0};// maximum size that can be used
+    UINT16            buf_len;
+    tAVRC_STS status = BT_STATUS_UNSUPPORTED;
+    BTIF_TRACE_DEBUG3(" %s opcode = %d rsp_code = %d  ",__FUNCTION__,
+                        pmeta_msg->p_msg->hdr.opcode,pmeta_msg->code);
+    if((AVRC_OP_VENDOR==pmeta_msg->p_msg->hdr.opcode)&&
+                (pmeta_msg->code >= AVRC_RSP_NOT_IMPL)&&
+                (pmeta_msg->code <= AVRC_RSP_INTERIM))
+    {
+        status=AVRC_Ctrl_ParsResponse(pmeta_msg->p_msg, &avrc_response, scratch_buf, &buf_len);
+        BTIF_TRACE_DEBUG2(" pdu = %d rsp_status = %d",avrc_response.pdu,
+                                    pmeta_msg->p_msg->vendor.hdr.ctype);
+
+        if ((avrc_response.pdu == AVRC_PDU_REGISTER_NOTIFICATION)&&
+            (pmeta_msg->code == AVRC_RSP_INTERIM))
+        {
+            BTIF_TRACE_DEBUG0(" Don't release transaction label ");
+        }
+        else
+        {
+            BTIF_TRACE_DEBUG1(" Releasing label = %d",pmeta_msg->label);
+            release_transaction(pmeta_msg->label);
+        }
+        btif_rc_ctrl_upstreams_rsp_evt((uint16_t)avrc_response.rsp.pdu, &avrc_response,
+                               scratch_buf, buf_len,pmeta_msg->p_msg->vendor.hdr.ctype);
+    }
+    else
+    {
+        BTIF_TRACE_DEBUG3("%s:Invalid Vendor Command  code: %d len: %d. Not processing it.",
+        __FUNCTION__, pmeta_msg->code, pmeta_msg->len);
+        return;
+    }
+}
 
+/***************************************************************************
+**
+** Function         handle_avk_rc_metamsg_cmd
+**
+** Description      Handle RC metamessage response
+**
+** Returns          void
+**
+***************************************************************************/
+static void handle_avk_rc_metamsg_cmd(tBTA_AV_META_MSG *pmeta_msg)
+{
+    tAVRC_COMMAND    avrc_cmd = {0};
+    UINT8             scratch_buf[4096] = {0};
+    UINT16            buf_len = 4096;
+    tAVRC_STS status = BT_STATUS_UNSUPPORTED;
+    BTIF_TRACE_DEBUG3(" %s opcode = %d rsp_code = %d  ",__FUNCTION__,
+                       pmeta_msg->p_msg->hdr.opcode,pmeta_msg->code);
+    if((AVRC_OP_VENDOR==pmeta_msg->p_msg->hdr.opcode)&&
+                (pmeta_msg->code <= AVRC_CMD_GEN_INQ))
+    {
+        status=AVRC_Ctrl_ParsCommand(pmeta_msg->p_msg, &avrc_cmd, scratch_buf, buf_len);
+        BTIF_TRACE_DEBUG3("Received vendor command.code,PDU and label: %d, %d,%d",pmeta_msg->code,
+                           avrc_cmd.pdu, pmeta_msg->label);
 
+        if (status != AVRC_STS_NO_ERROR)
+        {
+            /* return error */
+            BTIF_TRACE_WARNING2("%s: Error in parsing received metamsg command. status: 0x%02x",
+                __FUNCTION__, status);
+            send_reject_response(pmeta_msg->rc_handle, pmeta_msg->label, avrc_cmd.pdu, status);
+        }
+        else
+        {
+            if (avrc_cmd.pdu == AVRC_PDU_REGISTER_NOTIFICATION)
+            {
+                UINT8 event_id = avrc_cmd.reg_notif.event_id;
+                BTIF_TRACE_EVENT4("%s:New register notification received.event_id:%s,label:0x%x,code:%x"
+                ,__FUNCTION__,dump_rc_notification_event_id(event_id), pmeta_msg->label,pmeta_msg->code);
+                btif_rc_cb.rc_notif[event_id-1].bNotify = TRUE;
+                btif_rc_cb.rc_notif[event_id-1].label = pmeta_msg->label;
+            }
+            else if (avrc_cmd.pdu == AVRC_PDU_SET_ABSOLUTE_VOLUME)
+            {
+                BTIF_TRACE_EVENT3("%s:Abs Volume Cmd Recvd,label:0x%x,code:%x",
+                __FUNCTION__, pmeta_msg->label,pmeta_msg->code);
+                btif_rc_cb.rc_vol_label = pmeta_msg->label;
+            }
+            btif_rc_ctrl_upstreams_rsp_cmd((uint16_t)avrc_cmd.pdu, &avrc_cmd, scratch_buf, buf_len);
+        }
+    }
+    else
+    {
+        BTIF_TRACE_DEBUG3("%s:Invalid Vendor Command  code: %d len: %d. Not processing it.",
+        __FUNCTION__, pmeta_msg->code, pmeta_msg->len);
+        return;
+    }
+}
+#endif
 /***************************************************************************
 **
 ** Function         cleanup
@@ -2220,50 +2989,826 @@
 static void cleanup()
 {
     BTIF_TRACE_EVENT1("## %s ##", __FUNCTION__);
-    close_uinput();
+    /*close_uinput();*/
     if (bt_rc_callbacks)
     {
         bt_rc_callbacks = NULL;
     }
     memset(&btif_rc_cb, 0, sizeof(btif_rc_cb_t));
     lbl_destroy();
+    BTIF_TRACE_EVENT1("## %s ## completed", __FUNCTION__);
 }
 
-
-static const btrc_interface_t bt_rc_interface = {
-    sizeof(bt_rc_interface),
-    init,
-    get_play_status_rsp,
-    list_player_app_attr_rsp,     /* list_player_app_attr_rsp */
-    list_player_app_value_rsp,    /* list_player_app_value_rsp */
-    get_player_app_value_rsp,     /* get_player_app_value_rsp PDU 0x13*/
-    get_player_app_attr_text_rsp, /* get_player_app_attr_text_rsp */
-    get_player_app_value_text_rsp,/* get_player_app_value_text_rsp */
-    get_element_attr_rsp,
-    set_player_app_value_rsp,     /* set_player_app_value_rsp */
-    register_notification_rsp,
-    set_volume,
-    get_folderitem_rsp,
-    set_addrplayer_rsp,
-    cleanup,
-};
-
-/*******************************************************************************
+/***************************************************************************
 **
-** Function         btif_rc_get_interface
+** Function         cleanup_ctrl
 **
-** Description      Get the AVRCP callback interface
+** Description      Closes the AVRC Controller interface
 **
-** Returns          btav_interface_t
+** Returns          void
 **
-*******************************************************************************/
-const btrc_interface_t *btif_rc_get_interface(void)
+***************************************************************************/
+static bt_status_t cleanup_ctrl()
+{
+    bt_status_t result = BT_STATUS_SUCCESS;
+    BTIF_TRACE_EVENT1("## %s ##", __FUNCTION__);
+
+    if (bt_rc_ctrl_callbacks)
+    {
+        bt_rc_ctrl_callbacks = NULL;
+    }
+    memset(&btif_rc_cb, 0, sizeof(btif_rc_cb_t));
+    lbl_destroy();
+    BTIF_TRACE_EVENT1("## %s ## completed", __FUNCTION__);
+    return result;
+}
+
+static bt_status_t set_rel_volume(btrc_rel_volume_t volume)
+{
+    BTIF_TRACE_DEBUG1("%s: Not implemented!!!", __FUNCTION__);
+    return BT_STATUS_UNSUPPORTED;
+}
+
+static bt_status_t set_rel_volume_button_state(btrc_rel_volume_t volume,
+                                            btrc_button_state_t button_state)
+{
+    bt_status_t status = BT_STATUS_FAIL;
+    BTIF_TRACE_DEBUG2("%s: Button state %d", __FUNCTION__, button_state);
+    if (volume == BTRC_VOL_UP)
+        status = send_passthrough_cmd(NULL, KEY_CODE_VOLUME_UP, button_state, 0, NULL);
+    else if (volume == BTRC_VOL_DOWN)
+        status = send_passthrough_cmd(NULL, KEY_CODE_VOLUME_DOWN, button_state, 0, NULL);
+    else
+        BTIF_TRACE_DEBUG2("%s: wrong key code %d", __FUNCTION__, volume);
+    return status;
+}
+
+static bt_status_t send_key_event_power()
+{
+    BTIF_TRACE_DEBUG1("%s: Not implemented!!!", __FUNCTION__);
+    return BT_STATUS_UNSUPPORTED;
+}
+
+static bt_status_t send_key_event_power_button_state(btrc_button_state_t button_state)
+{
+    BTIF_TRACE_DEBUG2("%s: Button state %d", __FUNCTION__, button_state);
+    return send_passthrough_cmd(NULL, KEY_CODE_POWER, button_state, 0, NULL);
+}
+
+static bt_status_t send_key_event_mute()
+{
+    ALOGE("%s: Not implemented!!!", __FUNCTION__);
+    return BT_STATUS_UNSUPPORTED;
+}
+
+static bt_status_t send_key_event_mute_button_state(btrc_button_state_t button_state)
+{
+    BTIF_TRACE_DEBUG2("%s: Button state %d", __FUNCTION__, button_state);
+    return send_passthrough_cmd(NULL, KEY_CODE_MUTE, button_state, 0, NULL);
+}
+
+static bt_status_t connect_ctrl(bt_bdaddr_t *bd_addr)
+{
+    BTIF_TRACE_EVENT1("## %s ##", __FUNCTION__);
+    return BT_STATUS_UNHANDLED;
+}
+
+static bt_status_t disconnect_ctrl(bt_bdaddr_t *bd_addr)
+{
+    BTIF_TRACE_EVENT1("## %s ##", __FUNCTION__);
+    return BT_STATUS_UNHANDLED;
+}
+
+static int get_target_features_ctrl(bt_bdaddr_t *bd_addr)
+{
+    BTIF_TRACE_EVENT1("## %s ##", __FUNCTION__);
+    return BT_STATUS_UNHANDLED;
+}
+
+static bt_status_t get_player_attr_text_cmd(bt_bdaddr_t* bd_addr,
+                                     uint8_t num_attr,
+                                     btrcc_player_attr_t *p_attrs,
+                                     btrcc_label_t* p_label)
+{
+    BTIF_TRACE_EVENT1("## %s ##", __FUNCTION__);
+    return BT_STATUS_UNHANDLED;
+}
+
+static bt_status_t get_player_val_text_cmd(bt_bdaddr_t* bd_addr,
+                                      btrcc_player_attr_t attr,
+                                      uint8_t num_val,
+                                      btrcc_player_value_t *p_values,
+                                      btrcc_label_t* p_label)
+{
+    BTIF_TRACE_EVENT1("## %s ##", __FUNCTION__);
+    return BT_STATUS_UNHANDLED;
+}
+
+/***************************************************************************
+**
+** Function         getcapabilities_cmd
+**
+** Description      GetCapabilties from Remote(Company_ID, Events_Supported)
+**
+** Returns          void
+**
+***************************************************************************/
+static bt_status_t getcapabilities_cmd (uint8_t cap_id)
+{
+    tAVRC_STS status = BT_STATUS_UNSUPPORTED;
+    rc_transaction_t *p_transaction=NULL;
+#if (AVRC_CTLR_INCLUDED == TRUE)
+    BTIF_TRACE_DEBUG2("%s: cap_id %d", __FUNCTION__, cap_id);
+    CHECK_RC_CONNECTED
+    bt_status_t tran_status=get_transaction(&p_transaction);
+    if(BT_STATUS_SUCCESS != tran_status || NULL==p_transaction)
+        return BT_STATUS_FAIL;
+
+     tAVRC_COMMAND avrc_cmd = {0};
+     BT_HDR *p_msg = NULL;
+     avrc_cmd.get_caps.opcode = AVRC_OP_VENDOR;
+     avrc_cmd.get_caps.capability_id = cap_id;
+     avrc_cmd.get_caps.pdu = AVRC_PDU_GET_CAPABILITIES;
+     avrc_cmd.get_caps.status = AVRC_STS_NO_ERROR;
+     status = AVRC_BldCommand(&avrc_cmd, &p_msg);
+     if (status == AVRC_STS_NO_ERROR)
+     {
+         UINT8* data_start = (UINT8*)(p_msg + 1) + p_msg->offset;
+         BTIF_TRACE_DEBUG2("%s msgreq being sent out with label %d",
+                            __FUNCTION__,p_transaction->lbl);
+         BTA_AvVendorCmd(btif_rc_cb.rc_handle,p_transaction->lbl,AVRC_CMD_STATUS,
+                                                          data_start, p_msg->len);
+         if (p_msg != NULL)
+             GKI_freebuf(p_msg);
+         status =  BT_STATUS_SUCCESS;
+     }
+     else
+     {
+         if(NULL!=p_msg)
+            GKI_freebuf(p_msg);
+         BTIF_TRACE_ERROR2("%s: failed to build command. status: 0x%02x",
+                             __FUNCTION__, status);
+     }
+#else
+    BTIF_TRACE_DEBUG1("%s: feature not enabled", __FUNCTION__);
+#endif
+    return status;
+}
+
+/***************************************************************************
+**
+** Function         list_player_app_setting_attrib_cmd
+**
+** Description      Get supported List Player Attributes
+**
+** Returns          void
+**
+***************************************************************************/
+static bt_status_t list_player_app_setting_attrib_cmd(bt_bdaddr_t *bd_addr,
+        btrcc_label_t *label)
+{
+    tAVRC_STS status = BT_STATUS_UNSUPPORTED;
+    rc_transaction_t *p_transaction=NULL;
+#if (AVRC_CTLR_INCLUDED == TRUE)
+    BTIF_TRACE_DEBUG1("%s: ", __FUNCTION__);
+    CHECK_RC_CONNECTED
+    bt_status_t tran_status=get_transaction(&p_transaction);
+    if(BT_STATUS_SUCCESS != tran_status || NULL==p_transaction)
+        return BT_STATUS_FAIL;
+
+     tAVRC_COMMAND avrc_cmd = {0};
+     BT_HDR *p_msg = NULL;
+     avrc_cmd.list_app_attr.opcode = AVRC_OP_VENDOR;
+     avrc_cmd.list_app_attr.pdu = AVRC_PDU_LIST_PLAYER_APP_ATTR;
+     avrc_cmd.list_app_attr.status = AVRC_STS_NO_ERROR;
+     status = AVRC_BldCommand(&avrc_cmd, &p_msg);
+     if (status == AVRC_STS_NO_ERROR)
+     {
+         UINT8* data_start = (UINT8*)(p_msg + 1) + p_msg->offset;
+         BTIF_TRACE_DEBUG2("%s msgreq being sent out with label %d",
+                            __FUNCTION__,p_transaction->lbl);
+         BTA_AvVendorCmd(btif_rc_cb.rc_handle,p_transaction->lbl,AVRC_CMD_STATUS,
+                                                          data_start, p_msg->len);
+         if (p_msg != NULL)
+             GKI_freebuf(p_msg);
+         status =  BT_STATUS_SUCCESS;
+         memset(&tle_avrc_cmd_tout, 0, sizeof(tle_avrc_cmd_tout));
+         tle_avrc_cmd_tout.param = (UINT32)btif_ctlr_cmd_tout_tmr_hdlr;
+         btu_start_timer(&tle_avrc_cmd_tout, BTU_TTYPE_USER_FUNC, BTIF_AVRC_CMD_TIMEOUT);
+     }
+     else
+     {
+         if(NULL!=p_msg)
+            GKI_freebuf(p_msg);
+         BTIF_TRACE_ERROR2("%s: failed to build command. status: 0x%02x",
+                            __FUNCTION__, status);
+     }
+#else
+    BTIF_TRACE_DEBUG1("%s: feature not enabled", __FUNCTION__);
+#endif
+    return status;
+}
+
+/***************************************************************************
+**
+** Function         list_player_app_setting_value_cmd
+**
+** Description      Get values of supported Player Attributes
+**
+** Returns          void
+**
+***************************************************************************/
+static bt_status_t list_player_app_setting_value_cmd(bt_bdaddr_t *bd_addr,
+        btrcc_player_attr_t attrib_id, btrcc_label_t *label)
+{
+    tAVRC_STS status = BT_STATUS_UNSUPPORTED;
+    rc_transaction_t *p_transaction=NULL;
+#if (AVRC_CTLR_INCLUDED == TRUE)
+    BTIF_TRACE_DEBUG2("%s: attrib_id %d", __FUNCTION__, attrib_id);
+    CHECK_RC_CONNECTED
+    bt_status_t tran_status=get_transaction(&p_transaction);
+    if(BT_STATUS_SUCCESS != tran_status || NULL==p_transaction)
+        return BT_STATUS_FAIL;
+
+     tAVRC_COMMAND avrc_cmd = {0};
+     BT_HDR *p_msg = NULL;
+     avrc_cmd.list_app_values.attr_id = attrib_id;
+     avrc_cmd.list_app_values.opcode = AVRC_OP_VENDOR;
+     avrc_cmd.list_app_values.pdu = AVRC_PDU_LIST_PLAYER_APP_VALUES;
+     avrc_cmd.list_app_values.status = AVRC_STS_NO_ERROR;
+     status = AVRC_BldCommand(&avrc_cmd, &p_msg);
+     if (status == AVRC_STS_NO_ERROR)
+     {
+         UINT8* data_start = (UINT8*)(p_msg + 1) + p_msg->offset;
+         BTIF_TRACE_DEBUG2("%s msgreq being sent out with label %d",
+                            __FUNCTION__,p_transaction->lbl);
+         BTA_AvVendorCmd(btif_rc_cb.rc_handle,p_transaction->lbl,AVRC_CMD_STATUS,
+                               data_start, p_msg->len);
+         if (p_msg != NULL)
+             GKI_freebuf(p_msg);
+         status =  BT_STATUS_SUCCESS;
+         memset(&tle_avrc_cmd_tout, 0, sizeof(tle_avrc_cmd_tout));
+         tle_avrc_cmd_tout.param = (UINT32)btif_ctlr_cmd_tout_tmr_hdlr;
+         btu_start_timer(&tle_avrc_cmd_tout, BTU_TTYPE_USER_FUNC, BTIF_AVRC_CMD_TIMEOUT);
+     }
+     else
+     {
+         if(NULL!=p_msg)
+            GKI_freebuf(p_msg);
+         BTIF_TRACE_ERROR2("%s: failed to build command. status: 0x%02x",
+                            __FUNCTION__, status);
+     }
+#else
+    BTIF_TRACE_DEBUG1("%s: feature not enabled", __FUNCTION__);
+#endif
+    return status;
+}
+
+/***************************************************************************
+**
+** Function         get_player_app_setting_cmd
+**
+** Description      Get current values of Player Attributes
+**
+** Returns          void
+**
+***************************************************************************/
+static bt_status_t get_player_app_setting_cmd(bt_bdaddr_t* bd_addr,
+    uint8_t num_attrib, btrcc_player_attr_t *attrib_ids, btrcc_label_t* p_label)
+{
+    tAVRC_STS status = BT_STATUS_UNSUPPORTED;
+    rc_transaction_t *p_transaction=NULL;
+    int count  = 0;
+#if (AVRC_CTLR_INCLUDED == TRUE)
+    BTIF_TRACE_DEBUG2("%s: num attrib_id %d", __FUNCTION__, num_attrib);
+    CHECK_RC_CONNECTED
+    bt_status_t tran_status=get_transaction(&p_transaction);
+    if(BT_STATUS_SUCCESS != tran_status || NULL==p_transaction)
+        return BT_STATUS_FAIL;
+
+     tAVRC_COMMAND avrc_cmd = {0};
+     BT_HDR *p_msg = NULL;
+     avrc_cmd.get_cur_app_val.opcode = AVRC_OP_VENDOR;
+     avrc_cmd.get_cur_app_val.status = AVRC_STS_NO_ERROR;
+     avrc_cmd.get_cur_app_val.num_attr = num_attrib;
+     avrc_cmd.get_cur_app_val.pdu = AVRC_PDU_GET_CUR_PLAYER_APP_VALUE;
+
+     for (count = 0; count < num_attrib; count++)
+     {
+         avrc_cmd.get_cur_app_val.attrs[count] = attrib_ids[count];
+     }
+     status = AVRC_BldCommand(&avrc_cmd, &p_msg);
+     if (status == AVRC_STS_NO_ERROR)
+     {
+         UINT8* data_start = (UINT8*)(p_msg + 1) + p_msg->offset;
+         BTIF_TRACE_DEBUG2("%s msgreq being sent out with label %d",
+                            __FUNCTION__,p_transaction->lbl);
+         BTA_AvVendorCmd(btif_rc_cb.rc_handle,p_transaction->lbl,AVRC_CMD_STATUS,
+                          data_start, p_msg->len);
+         if (p_msg != NULL)
+             GKI_freebuf(p_msg);
+         status =  BT_STATUS_SUCCESS;
+         memset(&tle_avrc_cmd_tout, 0, sizeof(tle_avrc_cmd_tout));
+         tle_avrc_cmd_tout.param = (UINT32)btif_ctlr_cmd_tout_tmr_hdlr;
+         btu_start_timer(&tle_avrc_cmd_tout, BTU_TTYPE_USER_FUNC, BTIF_AVRC_CMD_TIMEOUT);
+     }
+     else
+     {
+         if(NULL!=p_msg)
+            GKI_freebuf(p_msg);
+         BTIF_TRACE_ERROR2("%s: failed to build command. status: 0x%02x",
+                            __FUNCTION__, status);
+     }
+#else
+    BTIF_TRACE_DEBUG1("%s: feature not enabled", __FUNCTION__);
+#endif
+    return status;
+}
+
+/***************************************************************************
+**
+** Function         set_player_app_setting_cmd
+**
+** Description      Set current values of Player Attributes
+**
+** Returns          void
+**
+***************************************************************************/
+static bt_status_t set_player_app_setting_cmd(bt_bdaddr_t* bd_addr,
+    btrcc_player_settings_t *p_vals)
+{
+    tAVRC_STS status = BT_STATUS_UNSUPPORTED;
+    rc_transaction_t *p_transaction=NULL;
+    int count  = 0;
+#if (AVRC_CTLR_INCLUDED == TRUE)
+    BTIF_TRACE_DEBUG2("%s: num attrib_id %d", __FUNCTION__, p_vals->num_attr);
+    CHECK_RC_CONNECTED
+    bt_status_t tran_status=get_transaction(&p_transaction);
+    if(BT_STATUS_SUCCESS != tran_status || NULL==p_transaction)
+        return BT_STATUS_FAIL;
+
+     tAVRC_COMMAND avrc_cmd = {0};
+     BT_HDR *p_msg = NULL;
+     avrc_cmd.set_app_val.opcode = AVRC_OP_VENDOR;
+     avrc_cmd.set_app_val.status = AVRC_STS_NO_ERROR;
+     avrc_cmd.set_app_val.num_val = p_vals->num_attr;
+     avrc_cmd.set_app_val.pdu = AVRC_PDU_SET_PLAYER_APP_VALUE;
+     avrc_cmd.set_app_val.p_vals =
+           (tAVRC_APP_SETTING*)GKI_getbuf(sizeof(tAVRC_APP_SETTING)*p_vals->num_attr);
+     for (count = 0; count < p_vals->num_attr; count++)
+     {
+         avrc_cmd.set_app_val.p_vals[count].attr_id = p_vals->attr[count];
+         avrc_cmd.set_app_val.p_vals[count].attr_val = p_vals->value[count];
+     }
+     status = AVRC_BldCommand(&avrc_cmd, &p_msg);
+     if (status == AVRC_STS_NO_ERROR)
+     {
+         UINT8* data_start = (UINT8*)(p_msg + 1) + p_msg->offset;
+         BTIF_TRACE_DEBUG2("%s msgreq being sent out with label %d",
+                            __FUNCTION__,p_transaction->lbl);
+         BTA_AvVendorCmd(btif_rc_cb.rc_handle,p_transaction->lbl,AVRC_CMD_CTRL,
+                              data_start, p_msg->len);
+         if (p_msg != NULL)
+             GKI_freebuf(p_msg);
+         status =  BT_STATUS_SUCCESS;
+         memset(&tle_avrc_cmd_tout, 0, sizeof(tle_avrc_cmd_tout));
+         tle_avrc_cmd_tout.param = (UINT32)btif_ctlr_cmd_tout_tmr_hdlr;
+         btu_start_timer(&tle_avrc_cmd_tout, BTU_TTYPE_USER_FUNC, BTIF_AVRC_CMD_TIMEOUT);
+     }
+     else
+     {
+         if(NULL!=p_msg)
+            GKI_freebuf(p_msg);
+         BTIF_TRACE_ERROR2("%s: failed to build command. status: 0x%02x",
+                            __FUNCTION__, status);
+     }
+     GKI_freebuf(avrc_cmd.set_app_val.p_vals);
+#else
+    BTIF_TRACE_DEBUG1("%s: feature not enabled", __FUNCTION__);
+#endif
+    return status;
+}
+
+/***************************************************************************
+**
+** Function         register_notification_cmd
+**
+** Description      Send Command to register for a Notification ID
+**
+** Returns          void
+**
+***************************************************************************/
+static bt_status_t register_notification_cmd(uint8_t event_id, uint32_t event_value)
+{
+    tAVRC_STS status = BT_STATUS_UNSUPPORTED;
+    rc_transaction_t *p_transaction=NULL;
+    int count  = 0;
+#if (AVRC_CTLR_INCLUDED == TRUE)
+    BTIF_TRACE_DEBUG3("%s: event_id %d  event_value %d", __FUNCTION__, event_id, event_value);
+    CHECK_RC_CONNECTED
+    bt_status_t tran_status=get_transaction(&p_transaction);
+    if(BT_STATUS_SUCCESS != tran_status || NULL==p_transaction)
+        return BT_STATUS_FAIL;
+
+     tAVRC_COMMAND avrc_cmd = {0};
+     BT_HDR *p_msg = NULL;
+     avrc_cmd.reg_notif.opcode = AVRC_OP_VENDOR;
+     avrc_cmd.reg_notif.status = AVRC_STS_NO_ERROR;
+     avrc_cmd.reg_notif.event_id = event_id;
+     avrc_cmd.reg_notif.pdu = AVRC_PDU_REGISTER_NOTIFICATION;
+     avrc_cmd.reg_notif.param = event_value;
+     status = AVRC_BldCommand(&avrc_cmd, &p_msg);
+     if (status == AVRC_STS_NO_ERROR)
+     {
+         UINT8* data_start = (UINT8*)(p_msg + 1) + p_msg->offset;
+         BTIF_TRACE_DEBUG2("%s msgreq being sent out with label %d",
+                            __FUNCTION__,p_transaction->lbl);
+         BTA_AvVendorCmd(btif_rc_cb.rc_handle,p_transaction->lbl,AVRC_CMD_NOTIF,
+                                 data_start, p_msg->len);
+         if (p_msg != NULL)
+             GKI_freebuf(p_msg);
+         status =  BT_STATUS_SUCCESS;
+     }
+     else
+     {
+         if(NULL!=p_msg)
+            GKI_freebuf(p_msg);
+         BTIF_TRACE_ERROR2("%s: failed to build command. status: 0x%02x",
+                            __FUNCTION__, status);
+     }
+#else
+    BTIF_TRACE_DEBUG1("%s: feature not enabled", __FUNCTION__);
+#endif
+    return status;
+}
+
+/***************************************************************************
+**
+** Function         get_element_attribute_cmd
+**
+** Description      Get Element Attribute for  attributeIds
+**
+** Returns          void
+**
+***************************************************************************/
+static bt_status_t get_element_attribute_cmd (bt_bdaddr_t* bd_addr,
+                                    btrcc_uid_t element_id,
+                                    uint8_t num_attribute,
+                                    btrcc_media_attr_t *p_attrs,
+                                    btrcc_label_t* p_label)
+{
+    tAVRC_STS status = BT_STATUS_UNSUPPORTED;
+    rc_transaction_t *p_transaction=NULL;
+    int count  = 0;
+#if (AVRC_CTLR_INCLUDED == TRUE)
+    BTIF_TRACE_DEBUG2("%s: num_attribute  %d", __FUNCTION__, num_attribute);
+    CHECK_RC_CONNECTED
+    bt_status_t tran_status=get_transaction(&p_transaction);
+    if(BT_STATUS_SUCCESS != tran_status || NULL==p_transaction)
+        return BT_STATUS_FAIL;
+    if(num_attribute > AVRC_MAX_ELEM_ATTR_SIZE)
+        return BT_STATUS_FAIL;
+
+    tAVRC_COMMAND avrc_cmd = {0};
+    BT_HDR *p_msg = NULL;
+    avrc_cmd.get_elem_attrs.opcode = AVRC_OP_VENDOR;
+    avrc_cmd.get_elem_attrs.status = AVRC_STS_NO_ERROR;
+    avrc_cmd.get_elem_attrs.num_attr = num_attribute;
+    avrc_cmd.get_elem_attrs.pdu = AVRC_PDU_GET_ELEMENT_ATTR;
+    for (count=0; count<num_attribute; count++)
+    {
+        avrc_cmd.get_elem_attrs.attrs[count] = p_attrs[count];
+    }
+    status = AVRC_BldCommand(&avrc_cmd, &p_msg);
+    if (status == AVRC_STS_NO_ERROR)
+    {
+        UINT8* data_start = (UINT8*)(p_msg + 1) + p_msg->offset;
+        BTIF_TRACE_DEBUG2("%s msgreq being sent out with label %d",
+                        __FUNCTION__,p_transaction->lbl);
+        BTA_AvVendorCmd(btif_rc_cb.rc_handle,p_transaction->lbl,AVRC_CMD_STATUS,
+                            data_start, p_msg->len);
+        if (p_msg != NULL)
+         GKI_freebuf(p_msg);
+        status =  BT_STATUS_SUCCESS;
+        memset(&tle_avrc_cmd_tout, 0, sizeof(tle_avrc_cmd_tout));
+        tle_avrc_cmd_tout.param = (UINT32)btif_ctlr_cmd_tout_tmr_hdlr;
+        btu_start_timer(&tle_avrc_cmd_tout, BTU_TTYPE_USER_FUNC,
+                                                BTIF_AVRC_CMD_TIMEOUT);
+    }
+    else
+    {
+     if(NULL!=p_msg)
+        GKI_freebuf(p_msg);
+     BTIF_TRACE_ERROR2("%s: failed to build command. status: 0x%02x",
+                        __FUNCTION__, status);
+    }
+#else
+    BTIF_TRACE_DEBUG1("%s: feature not enabled", __FUNCTION__);
+#endif
+    return status;
+}
+
+/***************************************************************************
+**
+** Function         get_play_status_cmd
+**
+** Description      Get Element Attribute for  attributeIds
+**
+** Returns          void
+**
+***************************************************************************/
+static bt_status_t get_play_status_cmd(bt_bdaddr_t* bd_addr, btrcc_label_t* p_label)
+{
+    tAVRC_STS status = BT_STATUS_UNSUPPORTED;
+    rc_transaction_t *p_transaction=NULL;
+#if (AVRC_CTLR_INCLUDED == TRUE)
+    BTIF_TRACE_DEBUG1("%s: ", __FUNCTION__);
+    CHECK_RC_CONNECTED
+    bt_status_t tran_status=get_transaction(&p_transaction);
+    if(BT_STATUS_SUCCESS != tran_status || NULL==p_transaction)
+        return BT_STATUS_FAIL;
+
+     tAVRC_COMMAND avrc_cmd = {0};
+     BT_HDR *p_msg = NULL;
+     avrc_cmd.get_play_status.opcode = AVRC_OP_VENDOR;
+     avrc_cmd.get_play_status.pdu = AVRC_PDU_GET_PLAY_STATUS;
+     avrc_cmd.get_play_status.status = AVRC_STS_NO_ERROR;
+     status = AVRC_BldCommand(&avrc_cmd, &p_msg);
+     if (status == AVRC_STS_NO_ERROR)
+     {
+         UINT8* data_start = (UINT8*)(p_msg + 1) + p_msg->offset;
+         BTIF_TRACE_DEBUG2("%s msgreq being sent out with label %d",
+                            __FUNCTION__,p_transaction->lbl);
+         BTA_AvVendorCmd(btif_rc_cb.rc_handle,p_transaction->lbl,AVRC_CMD_STATUS,
+                              data_start, p_msg->len);
+         if (p_msg != NULL)
+             GKI_freebuf(p_msg);
+         status =  BT_STATUS_SUCCESS;
+         memset(&tle_avrc_cmd_tout, 0, sizeof(tle_avrc_cmd_tout));
+         tle_avrc_cmd_tout.param = (UINT32)btif_ctlr_cmd_tout_tmr_hdlr;
+         btu_start_timer(&tle_avrc_cmd_tout, BTU_TTYPE_USER_FUNC, BTIF_AVRC_CMD_TIMEOUT);
+     }
+     else
+     {
+         if(NULL!=p_msg)
+            GKI_freebuf(p_msg);
+         BTIF_TRACE_ERROR2("%s: failed to build command. status: 0x%02x",
+                            __FUNCTION__, status);
+     }
+#else
+    BTIF_TRACE_DEBUG1("%s: feature not enabled", __FUNCTION__);
+#endif
+    return status;
+}
+
+/***************************************************************************
+**
+** Function         send_abs_vol_rsp
+**
+** Description      Rsp for SetAbsoluteVolume Command
+**
+** Returns          void
+**
+***************************************************************************/
+static void send_abs_vol_rsp(bt_bdaddr_t* bd_addr, uint8_t abs_vol, btrcc_label_t p_label,
+                                     btrcc_status_t i_status)
+{
+    tAVRC_STS status = BT_STATUS_UNSUPPORTED;
+#if (AVRC_CTLR_INCLUDED == TRUE)
+    BTIF_TRACE_DEBUG2("%s: abs_vol %d", __FUNCTION__, abs_vol);
+    //CHECK_RC_CONNECTED
+
+    tAVRC_RESPONSE avrc_rsp = {0};
+     BT_HDR *p_msg = NULL;
+     avrc_rsp.volume.opcode = AVRC_OP_VENDOR;
+     avrc_rsp.volume.pdu = AVRC_PDU_SET_ABSOLUTE_VOLUME;
+     avrc_rsp.volume.status = AVRC_STS_NO_ERROR;
+     avrc_rsp.volume.volume = abs_vol;
+     status = AVRC_BldResponse(btif_rc_cb.rc_handle, &avrc_rsp, &p_msg);
+     if (status == AVRC_STS_NO_ERROR)
+     {
+         UINT8* data_start = (UINT8*)(p_msg + 1) + p_msg->offset;
+         BTIF_TRACE_DEBUG2("%s msgreq being sent out with label %d",
+                            __FUNCTION__,btif_rc_cb.rc_vol_label);
+         BTA_AvVendorRsp(btif_rc_cb.rc_handle,btif_rc_cb.rc_vol_label,BTA_AV_RSP_ACCEPT,
+                                  data_start,p_msg->len,0);
+         if (p_msg != NULL)
+             GKI_freebuf(p_msg);
+         status =  BT_STATUS_SUCCESS;
+     }
+     else
+     {
+         if(NULL!=p_msg)
+            GKI_freebuf(p_msg);
+         BTIF_TRACE_ERROR2("%s: failed to build command. status: 0x%02x",
+                            __FUNCTION__, status);
+     }
+#else
+    BTIF_TRACE_DEBUG1("%s: feature not enabled", __FUNCTION__);
+#endif
+    //return status;
+}
+
+/***************************************************************************
+**
+** Function         send_register_abs_vol_rsp
+**
+** Description      Rsp for Notification of Absolute Volume
+**
+** Returns          void
+**
+***************************************************************************/
+static bt_status_t send_register_abs_vol_rsp(uint8_t abs_vol)
+{
+    tAVRC_STS status = BT_STATUS_UNSUPPORTED;
+    uint8_t label = 0;
+#if (AVRC_CTLR_INCLUDED == TRUE)
+    uint8_t rsp_type;
+    BTIF_TRACE_DEBUG2("%s: notification state %d", __FUNCTION__,
+                                btif_rc_cb.rcc_absvol_notif_state);
+    if (btif_rc_cb.rcc_absvol_notif_state == NOTIF_STATE_CHANGED)
+        rsp_type = AVRC_RSP_CHANGED;
+    else if (btif_rc_cb.rcc_absvol_notif_state == NOTIF_STATE_INTERIM)
+        rsp_type = AVRC_RSP_INTERIM;
+    else
+        return BT_STATUS_FAIL;
+    BTIF_TRACE_DEBUG3("%s: rsp_type  %d abs_vol %d", __FUNCTION__, rsp_type, abs_vol);
+    CHECK_RC_CONNECTED
+
+    tAVRC_RESPONSE avrc_rsp = {0};
+     BT_HDR *p_msg = NULL;
+     avrc_rsp.reg_notif.opcode = AVRC_OP_VENDOR;
+     avrc_rsp.reg_notif.pdu = AVRC_PDU_REGISTER_NOTIFICATION;
+     avrc_rsp.reg_notif.status = AVRC_STS_NO_ERROR;
+     avrc_rsp.reg_notif.param.volume = abs_vol;
+     avrc_rsp.reg_notif.event_id = AVRC_EVT_VOLUME_CHANGE;
+     label = btif_rc_cb.rc_notif[AVRC_EVT_VOLUME_CHANGE-1].label;
+     if ((rsp_type == AVRC_RSP_CHANGED) && (btif_rc_cb.rc_notif[AVRC_EVT_VOLUME_CHANGE-1].bNotify))
+     {
+         btif_rc_cb.rc_notif[AVRC_EVT_VOLUME_CHANGE-1].bNotify = FALSE;
+     }
+     status = AVRC_BldResponse(btif_rc_cb.rc_handle, &avrc_rsp, &p_msg);
+     if (status == AVRC_STS_NO_ERROR)
+     {
+         BTIF_TRACE_DEBUG2("%s msgreq being sent out with label %d",
+                            __FUNCTION__,label);
+         UINT8* data_start = (UINT8*)(p_msg + 1) + p_msg->offset;
+         BTA_AvVendorRsp(btif_rc_cb.rc_handle,label,rsp_type,data_start,p_msg->len,0);
+         if (p_msg != NULL)
+             GKI_freebuf(p_msg);
+         status =  BT_STATUS_SUCCESS;
+         if (btif_rc_cb.rcc_absvol_notif_state == NOTIF_STATE_CHANGED)
+             btif_rc_cb.rcc_absvol_notif_state = NOTIF_STATE_INVALID;
+         if (btif_rc_cb.rcc_absvol_notif_state == NOTIF_STATE_INTERIM)
+             btif_rc_cb.rcc_absvol_notif_state = NOTIF_STATE_CHANGED;
+     }
+     else
+     {
+         if(NULL!=p_msg)
+            GKI_freebuf(p_msg);
+         BTIF_TRACE_ERROR2("%s: failed to build command. status: 0x%02x",
+                            __FUNCTION__, status);
+     }
+#else
+    BTIF_TRACE_DEBUG1("%s: feature not enabled", __FUNCTION__);
+#endif
+    return status;
+}
+
+/***************************************************************************
+**
+** Function         send_passthrough_cmd
+**
+** Description      Send Pass-Through command
+**
+** Returns          void
+**
+***************************************************************************/
+static bt_status_t send_passthrough_cmd(bt_bdaddr_t *bd_addr, btrcc_pass_cmd_t key_code,
+    btrcc_pass_state_t key_state, uint8_t data_field_len, uint8_t *data_field)
+{
+    tAVRC_STS status = BT_STATUS_UNSUPPORTED;
+#if (AVRC_CTLR_INCLUDED == TRUE)
+    CHECK_RC_CONNECTED
+    rc_transaction_t *p_transaction=NULL;
+    //BTIF_TRACE_DEBUG5("%s: key-code: %d, key-state: %d, data-field-len: %d, data-field: %u",
+    //                        __FUNCTION__, key_code, key_state, data_field_len, *data_field);
+    BTIF_TRACE_DEBUG4("%s: key-code: %d, key-state: %d, data-field-len: %d",
+                            __FUNCTION__, key_code, key_state, data_field_len);
+    if (btif_rc_cb.rc_features & BTA_AV_FEAT_RCTG || btif_rc_cb.whitelisted_device)
+    {
+        tAVRC_MSG_PASS avrc_cmd;
+        bt_status_t tran_status = get_transaction(&p_transaction);
+        if(BT_STATUS_SUCCESS == tran_status && NULL != p_transaction)
+        {
+            BTA_AvRemoteCmd(btif_rc_cb.rc_handle, p_transaction->lbl,
+                (tBTA_AV_RC)key_code, (tBTA_AV_STATE)key_state);
+            status =  BT_STATUS_SUCCESS;
+            BTIF_TRACE_DEBUG1("%s: succesfully sent passthrough command to BTA", __FUNCTION__);
+        }
+        else
+        {
+            status =  BT_STATUS_FAIL;
+            BTIF_TRACE_DEBUG1("%s: error in fetching transaction", __FUNCTION__);
+        }
+    }
+    else
+    {
+        status =  BT_STATUS_FAIL;
+        BTIF_TRACE_DEBUG1("%s: feature not supported", __FUNCTION__);
+    }
+#else
+    BTIF_TRACE_DEBUG1("%s: feature not enabled", __FUNCTION__);
+#endif
+    return status;
+}
+
+static const btrc_interface_t bt_rc_interface = {
+    sizeof(bt_rc_interface),
+    init,
+    get_play_status_rsp,
+    list_player_app_attr_rsp,     /* list_player_app_attr_rsp */
+    list_player_app_value_rsp,    /* list_player_app_value_rsp */
+    get_player_app_value_rsp,     /* get_player_app_value_rsp PDU 0x13*/
+    get_player_app_attr_text_rsp, /* get_player_app_attr_text_rsp */
+    get_player_app_value_text_rsp,/* get_player_app_value_text_rsp */
+    get_element_attr_rsp,
+    set_player_app_value_rsp,     /* set_player_app_value_rsp */
+    register_notification_rsp,
+    set_volume,
+#ifdef PLATFORM_ANDROID    
+    get_folderitem_rsp,
+    set_addrplayer_rsp,
+#else
+    set_rel_volume,
+    set_rel_volume_button_state,
+    send_key_event_power,
+    send_key_event_power_button_state,
+    send_key_event_mute,
+    send_key_event_mute_button_state,
+#endif
+    cleanup,
+};
+
+static const btrcc_interface_t bt_rc_ctrl_interface = {
+    sizeof(bt_rc_ctrl_interface),
+    init_ctrl,
+    cleanup_ctrl,
+    connect_ctrl,
+    disconnect_ctrl,
+    get_target_features_ctrl,
+    send_passthrough_cmd,
+    list_player_app_setting_attrib_cmd,
+    list_player_app_setting_value_cmd,
+    get_player_app_setting_cmd,
+    set_player_app_setting_cmd,
+    get_player_attr_text_cmd,
+    get_player_val_text_cmd,
+    get_element_attribute_cmd,
+    get_play_status_cmd,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    send_abs_vol_rsp,
+    send_register_abs_vol_rsp,
+};
+
+/*******************************************************************************
+**
+** Function         btif_rc_get_interface
+**
+** Description      Get the AVRCP callback interface
+**
+** Returns          btav_interface_t
+**
+*******************************************************************************/
+const btrc_interface_t *btif_rc_get_interface(void)
 {
     BTIF_TRACE_EVENT1("%s", __FUNCTION__);
     return &bt_rc_interface;
 }
 
 /*******************************************************************************
+**
+** Function         btif_rc_ctrl_get_interface
+**
+** Description      Get the AVRCP Controller callback interface
+**
+** Returns          btav_interface_t
+**
+*******************************************************************************/
+const btrcc_interface_t *btif_rc_ctrl_get_interface(void)
+{
+    BTIF_TRACE_EVENT1("%s", __FUNCTION__);
+    return &bt_rc_ctrl_interface;
+}
+
+/*******************************************************************************
 **      Function         initialize_transaction
 **
 **      Description    Initializes fields of the transaction structure
@@ -2425,6 +3970,7 @@
 static BOOLEAN dev_blacklisted_for_absolute_volume(BD_ADDR peer_dev)
 {
     int i;
+    char *dev_name_str = NULL;
     int whitelist_size = sizeof(rc_white_addr_prefix)/sizeof(rc_white_addr_prefix[0]);
     for (i = 0; i < whitelist_size; i++) {
         if (rc_white_addr_prefix[i][0] == peer_dev[0] &&
@@ -2435,7 +3981,56 @@
             return FALSE;
         }
     }
-    BTIF_TRACE_WARNING3("blacklist absolute volume for %02x:%02x:%02x",
-                        peer_dev[0], peer_dev[1], peer_dev[2]);
+
+    dev_name_str = BTM_SecReadDevName(peer_dev);
+    whitelist_size = sizeof(rc_white_name)/sizeof(char*);
+    if (dev_name_str != NULL) {
+        for (i = 0; i < whitelist_size; i++) {
+            if (strcmp(dev_name_str, rc_white_name[i]) == 0) {
+                BTIF_TRACE_DEBUG1("whitelist absolute volume for %s", dev_name_str);
+                return FALSE;
+            }
+        }
+    }
+
+    BTIF_TRACE_WARNING4("blacklist absolute volume for %02x:%02x:%02x, name = %s",
+                        peer_dev[0], peer_dev[1], peer_dev[2], dev_name_str);
     return TRUE;
 }
+
+/*******************************************************************************
+**      Function       dev_blacklisted_for_absolute_volume
+**
+**      Description    Blacklist Devices that donot handle absolute volume well
+**                     We are blacklisting all the devices that are not in whitelist
+**
+**      Returns        True if the device is in the list
+*******************************************************************************/
+static BOOLEAN dev_whitelisted_for_ct_passthrough_cmd(BD_ADDR peer_dev)
+{
+    int i;
+    char *dev_name_str = NULL;
+    int list_size = sizeof(ct_passthru_white_addr_prefix)/sizeof(ct_passthru_white_addr_prefix[0]);
+    for (i = 0; i < list_size; i++) {
+        if (ct_passthru_white_addr_prefix[i][0] == peer_dev[0] &&
+            ct_passthru_white_addr_prefix[i][1] == peer_dev[1] &&
+            ct_passthru_white_addr_prefix[i][2] == peer_dev[2]) {
+            BTIF_TRACE_DEBUG3("whitelist CT Passthrough for %02x:%02x:%02x",
+                                peer_dev[0], peer_dev[1], peer_dev[2]);
+            return TRUE;
+        }
+    }
+
+    dev_name_str = BTM_SecReadDevName(peer_dev);
+    list_size = sizeof(ct_passthru_white_name)/sizeof(char*);
+    if (dev_name_str != NULL) {
+        for (i = 0; i < list_size; i++) {
+            if (strcmp(dev_name_str, ct_passthru_white_name[i]) == 0) {
+                BTIF_TRACE_DEBUG1("whitelist CT Passthrough for %s", dev_name_str);
+                return TRUE;
+            }
+        }
+    }
+
+    return FALSE;
+}
diff -Naur '--exclude=.git' bluedroid-orig/btif/src/btif_sm.c bluedroid/btif/src/btif_sm.c
--- bluedroid-orig/btif/src/btif_sm.c	2015-09-24 16:33:43.536227643 +0800
+++ bluedroid/btif/src/btif_sm.c	2015-09-24 16:31:37.000000000 +0800
@@ -75,7 +75,7 @@
 
 btif_sm_handle_t btif_sm_init(const btif_sm_handler_t *p_handlers, btif_sm_state_t initial_state)
 {
-    btif_sm_cb_t *p_cb;
+    btif_sm_cb_t *p_cb = NULL;
 
     if (p_handlers == NULL)
     {
@@ -84,6 +84,11 @@
     }
 
     p_cb = (btif_sm_cb_t*) GKI_os_malloc(sizeof(btif_sm_cb_t));
+    if (!p_cb)
+    {
+        BTIF_TRACE_ERROR1("%s : Failed to allocate memory", __FUNCTION__);
+        return NULL;
+    }
     p_cb->state = initial_state;
     p_cb->p_handlers = (btif_sm_handler_t*)p_handlers;
 
diff -Naur '--exclude=.git' bluedroid-orig/btif/src/btif_sock.c bluedroid/btif/src/btif_sock.c
--- bluedroid-orig/btif/src/btif_sock.c	2015-09-24 16:33:43.536227643 +0800
+++ bluedroid/btif/src/btif_sock.c	2015-09-24 16:31:37.000000000 +0800
@@ -43,10 +43,12 @@
                                 const uint8_t* uuid, int channel, int* sock_fd, int flags);
 static bt_status_t btsock_connect(const bt_bdaddr_t *bd_addr, btsock_type_t type,
                                   const uint8_t* uuid, int channel, int* sock_fd, int flags);
+#ifdef PLATFORM_ANDROID
 static bt_status_t btsock_get_sockopt(btsock_type_t type, int channel, btsock_option_type_t option_name,
                                             void *option_value, int *option_len);
 static bt_status_t btsock_set_sockopt(btsock_type_t type, int channel, btsock_option_type_t option_name,
                                             void *option_value, int option_len);
+#endif
 static void btsock_signaled(int fd, int type, int flags, uint32_t user_id);
 
 /*******************************************************************************
@@ -61,9 +63,7 @@
 static btsock_interface_t sock_if = {
                 sizeof(sock_if),
                 btsock_listen,
-                btsock_connect,
-                btsock_get_sockopt,
-                btsock_set_sockopt
+                btsock_connect
        };
 btsock_interface_t *btif_sock_get_interface()
 {
@@ -125,6 +125,7 @@
     return status;
 }
 
+#ifdef PLATFORM_ANDROID
 static bt_status_t btsock_get_sockopt(btsock_type_t type, int channel, btsock_option_type_t option_name,
                                             void *option_value, int *option_len)
 {
@@ -187,6 +188,7 @@
     }
     return status;
 }
+#endif
 
 static bt_status_t btsock_connect(const bt_bdaddr_t *bd_addr, btsock_type_t type,
         const uint8_t* uuid, int channel, int* sock_fd, int flags)
diff -Naur '--exclude=.git' bluedroid-orig/btif/src/btif_sock_rfc.c bluedroid/btif/src/btif_sock_rfc.c
--- bluedroid-orig/btif/src/btif_sock_rfc.c	2015-09-24 16:33:43.536227643 +0800
+++ bluedroid/btif/src/btif_sock_rfc.c	2015-09-24 16:31:37.000000000 +0800
@@ -404,6 +404,7 @@
     return status;
 }
 
+#ifdef PLATFORM_ANDROID
 bt_status_t btsock_rfc_get_sockopt(int channel, btsock_option_type_t option_name,
                                             void *option_value, int *option_len)
 {
@@ -493,6 +494,7 @@
 
     return status;
 }
+#endif
 
 bt_status_t btsock_rfc_connect(const bt_bdaddr_t *bd_addr, const uint8_t* service_uuid,
         int channel, int* sock_fd, int flags)
diff -Naur '--exclude=.git' bluedroid-orig/btif/src/btif_sock_util.c bluedroid/btif/src/btif_sock_util.c
--- bluedroid-orig/btif/src/btif_sock_util.c	2015-09-24 16:33:43.536227643 +0800
+++ bluedroid/btif/src/btif_sock_util.c	2015-09-24 16:31:37.000000000 +0800
@@ -163,7 +163,12 @@
 }
 
 
+#if defined(PLATFORM_ANDROID) || (ANDROID)
 #define PRINT(s) __android_log_write(ANDROID_LOG_DEBUG, NULL, s)
+#else
+#define PRINT(s) __dlog_print(LOG_ID_APPS, DLOG_ERROR, "bt-sock", s)
+#endif
+
 static const char* hex_table = "0123456789abcdef";
 static inline void byte2hex(const char* data, char** str)
 {
diff -Naur '--exclude=.git' bluedroid-orig/btif/src/btif_storage.c bluedroid/btif/src/btif_storage.c
--- bluedroid-orig/btif/src/btif_storage.c	2015-09-24 16:33:43.536227643 +0800
+++ bluedroid/btif/src/btif_storage.c	2015-09-24 16:31:37.000000000 +0800
@@ -55,7 +55,7 @@
 **  Constants & Macros
 ************************************************************************************/
 
-#define BTIF_STORAGE_PATH_BLUEDROID "/data/misc/bluedroid"
+#define BTIF_STORAGE_PATH_BLUEDROID "/target/bluedroid"
 
 //#define BTIF_STORAGE_PATH_ADAPTER_INFO "adapter_info"
 //#define BTIF_STORAGE_PATH_REMOTE_DEVICES "remote_devices"
@@ -66,6 +66,13 @@
 #define BTIF_STORAGE_PATH_REMOTE_VER_MFCT "Manufacturer"
 #define BTIF_STORAGE_PATH_REMOTE_VER_VER "LmpVer"
 #define BTIF_STORAGE_PATH_REMOTE_VER_SUBVER "LmpSubVer"
+#ifndef PLATFORM_ANDROID
+#define BTIF_STORAGE_PATH_REMOTE_DID_SPEC_ID "SpecID"
+#define BTIF_STORAGE_PATH_REMOTE_DID_VENDOR "Vendor"
+#define BTIF_STORAGE_PATH_REMOTE_DID_VENDOR_ID_SRC "VendorIDSrc"
+#define BTIF_STORAGE_PATH_REMOTE_DID_PRODUCT "Product"
+#define BTIF_STORAGE_PATH_REMOTE_DID_VER "Ver"
+#endif
 
 //#define BTIF_STORAGE_PATH_REMOTE_LINKKEYS "remote_linkkeys"
 #define BTIF_STORAGE_PATH_REMOTE_ALIASE "Aliase"
@@ -76,9 +83,9 @@
 #define BTIF_STORAGE_KEY_ADAPTER_SCANMODE "ScanMode"
 #define BTIF_STORAGE_KEY_ADAPTER_ADVMODE "AdvMode"
 #define BTIF_STORAGE_KEY_ADAPTER_DISC_TIMEOUT "DiscoveryTimeout"
+#define BTIF_STORAGE_PATH_REMOTE_AUTHORIZE_INFO "Authorize"
 
-
-#define BTIF_AUTO_PAIR_CONF_FILE  "/etc/bluetooth/auto_pair_devlist.conf"
+#define BTIF_AUTO_PAIR_CONF_FILE  "target/conf/auto_pair_devlist.conf"
 #define BTIF_STORAGE_PATH_AUTOPAIR_BLACKLIST "AutoPairBlacklist"
 #define BTIF_STORAGE_KEY_AUTOPAIR_BLACKLIST_ADDR "AddressBlacklist"
 #define BTIF_STORAGE_KEY_AUTOPAIR_BLACKLIST_EXACTNAME "ExactNameBlacklist"
@@ -288,18 +295,22 @@
             value[prop->len]='\0';
             btif_config_set_str("Remote", bdstr, BTIF_STORAGE_PATH_REMOTE_ALIASE, value);
             break;
+#ifdef PLATFORM_ANDROID
         case BT_PROPERTY_REMOTE_TRUST_VALUE:
             btif_config_set_int("Remote", bdstr, BTIF_STORAGE_PATH_REMOTE_TRUST_VALUE, *(int*)prop->val);
             btif_config_save();
             break;
+#endif
         case BT_PROPERTY_ADAPTER_SCAN_MODE:
             btif_config_set_int("Local", "Adapter",
                                 BTIF_STORAGE_KEY_ADAPTER_SCANMODE, *(int*)prop->val);
             break;
+#ifdef PLATFORM_ANDROID
         case BT_PROPERTY_ADAPTER_BLE_ADV_MODE:
             btif_config_set_int("Local", "Adapter",
                                 BTIF_STORAGE_KEY_ADAPTER_ADVMODE, *(int*)prop->val);
             break;
+#endif
         case BT_PROPERTY_ADAPTER_DISCOVERY_TIMEOUT:
             btif_config_set_int("Local", "Adapter",
                                 BTIF_STORAGE_KEY_ADAPTER_DISC_TIMEOUT, *(int*)prop->val);
@@ -345,7 +356,38 @@
                                 BTIF_STORAGE_PATH_REMOTE_VER_SUBVER, info->sub_ver);
             btif_config_save();
          } break;
+#ifndef PLATFORM_ANDROID
+        case BT_PROPERTY_REMOTE_DID_INFO:
+        {
+            bt_remote_did_t *info = (bt_remote_did_t *)prop->val;
+            if (!info)
+                return FALSE;
 
+            btif_config_set_int("Remote", bdstr,
+                                BTIF_STORAGE_PATH_REMOTE_DID_SPEC_ID , info->spec_id);
+            btif_config_set_int("Remote", bdstr,
+                                BTIF_STORAGE_PATH_REMOTE_DID_VENDOR , info->vendor);
+            btif_config_set_int("Remote", bdstr,
+                                BTIF_STORAGE_PATH_REMOTE_DID_VENDOR_ID_SRC , info->vendor_id_source);
+            btif_config_set_int("Remote", bdstr,
+                                BTIF_STORAGE_PATH_REMOTE_DID_PRODUCT  , info->product);
+            btif_config_set_int("Remote", bdstr,
+                                BTIF_STORAGE_PATH_REMOTE_DID_VER  , info->version);
+            btif_config_save();
+            
+            BTIF_TRACE_ERROR0("BT_PROPERTY_REMOTE_DID_INFO: need to implement");
+        }break;
+#endif
+        case BT_PROPERTY_REMOTE_AUTHORIZE_INFO:
+        {
+            BTIF_TRACE_DEBUG0("prop2cfg BT_PROPERTY_REMOTE_AUTHORIZE_INFO");
+            uint8_t auth_value = *(uint8_t*)prop->val;
+            if (remote_bd_addr)
+                btif_config_set_int("Remote", bdstr,
+                                    BTIF_STORAGE_PATH_REMOTE_AUTHORIZE_INFO, auth_value);
+            btif_config_save();
+        }
+	break;
         default:
              BTIF_TRACE_ERROR1("Unknow prop type:%d", prop->type);
              return FALSE;
@@ -402,6 +444,7 @@
             }
             break;
         }
+#ifdef PLATFORM_ANDROID
         case BT_PROPERTY_REMOTE_TRUST_VALUE:
         {
             if(prop->len >= (int)sizeof(int))
@@ -410,17 +453,19 @@
             break;
 
         }
-
+#endif
         case BT_PROPERTY_ADAPTER_SCAN_MODE:
            if(prop->len >= (int)sizeof(int))
                 ret = btif_config_get_int("Local", "Adapter",
                                           BTIF_STORAGE_KEY_ADAPTER_SCANMODE, (int*)prop->val);
            break;
+#ifdef PLATFORM_ANDROID
         case BT_PROPERTY_ADAPTER_BLE_ADV_MODE:
            if(prop->len >= (int)sizeof(int))
                 ret = btif_config_get_int("Local", "Adapter",
                                           BTIF_STORAGE_KEY_ADAPTER_ADVMODE, (int*)prop->val);
            break;
+#endif
         case BT_PROPERTY_ADAPTER_DISCOVERY_TIMEOUT:
            if(prop->len >= (int)sizeof(int))
                 ret = btif_config_get_int("Local", "Adapter",
@@ -474,7 +519,58 @@
                                 BTIF_STORAGE_PATH_REMOTE_VER_SUBVER, &info->sub_ver);
             }
          } break;
+#ifndef PLATFORM_ANDROID
+        case BT_PROPERTY_REMOTE_DID_INFO:
+        {
+            bt_remote_did_t *info = (bt_remote_did_t *)prop->val;
 
+            if(prop->len >= (int)sizeof(bt_remote_did_t))
+            {
+                ret = btif_config_get_int("Remote", bdstr,
+                                BTIF_STORAGE_PATH_REMOTE_DID_SPEC_ID, (int*)&info->spec_id);
+                if (ret == TRUE)
+                    ret = btif_config_get_int("Remote", bdstr,
+                                BTIF_STORAGE_PATH_REMOTE_DID_VENDOR, (int*)&info->vendor);
+                if (ret == TRUE)
+                    ret = btif_config_get_int("Remote", bdstr,
+                                BTIF_STORAGE_PATH_REMOTE_DID_VENDOR_ID_SRC, (int*)&info->vendor_id_source);
+                if (ret == TRUE)
+                    ret = btif_config_get_int("Remote", bdstr,
+                                BTIF_STORAGE_PATH_REMOTE_DID_PRODUCT, (int*)&info->product);
+                if (ret == TRUE)
+                    ret = btif_config_get_int("Remote", bdstr,
+                                BTIF_STORAGE_PATH_REMOTE_DID_VER, (int*)&info->version);
+            }
+        }break;
+        
+        case BT_PROPERTY_REMOTE_INFO:
+        {
+
+        bt_remote_info_t *info = (bt_remote_info_t *)prop->val;
+        info->bond_state = BT_BOND_STATE_NONE;
+        if(btif_storage_is_device_bonded(remote_bd_addr) == TRUE)
+            info->bond_state = BT_BOND_STATE_BONDED;
+        
+        info->acl_state = BT_ACL_STATE_DISCONNECTED;
+        if(BTA_DmIsAclConnectionUp(remote_bd_addr->address) == TRUE)
+            info->acl_state = BT_ACL_STATE_CONNECTED;
+      }
+#endif
+        case BT_PROPERTY_REMOTE_AUTHORIZE_INFO:
+        {
+            BTIF_TRACE_DEBUG0("cfg2prop BT_PROPERTY_REMOTE_AUTHORIZE_INFO");
+            ret = btif_config_get_int("Remote", bdstr,
+                                   BTIF_STORAGE_PATH_REMOTE_AUTHORIZE_INFO, (uint8_t*)prop->val);
+            if (!ret)
+            {
+                BTIF_TRACE_ERROR0("Failed to retrive authorize info");
+            }
+            else
+            {
+                BTIF_TRACE_DEBUG1("Authorize value retrieved = %d",*(uint8_t*)prop->val);
+            }
+        }
+        break;
         default:
             BTIF_TRACE_ERROR1("Unknow prop type:%d", prop->type);
             return FALSE;
@@ -642,6 +738,13 @@
             property->len = bonded_devices.num_devices * sizeof(bt_bdaddr_t);
             memcpy(property->val, bonded_devices.devices, property->len);
         }
+#ifndef PLATFROM_ANDROID        
+        else // when bonded_device is zero
+        {
+           property->len = 0;
+           memset(property->val, 0x00, sizeof(property->val));
+        }
+#endif  
 
         /* if there are no bonded_devices, then length shall be 0 */
         return BT_STATUS_SUCCESS;
@@ -676,12 +779,18 @@
                                               p_uuid+num_uuids);
                             num_uuids++;
                         }break;
-                    case BTA_A2DP_SERVICE_ID:
+                    case BTA_A2DP_SRC_SERVICE_ID:
                         {
                             uuid16_to_uuid128(UUID_SERVCLASS_AUDIO_SOURCE,
                                               p_uuid+num_uuids);
                             num_uuids++;
                         }break;
+                    case BTA_A2DP_SINK_SERVICE_ID:
+                        {
+                            uuid16_to_uuid128(UUID_SERVCLASS_AUDIO_SINK,
+                                              p_uuid+num_uuids);
+                            num_uuids++;
+                        }break;
                     case BTA_HFP_HS_SERVICE_ID:
                         {
                             uuid16_to_uuid128(UUID_SERVCLASS_HF_HANDSFREE,
@@ -976,10 +1085,12 @@
                                          remote_properties[num_props]);
             num_props++;
 
+#ifdef PLATFORM_ANDROID
             BTIF_STORAGE_GET_REMOTE_PROP(p_remote_addr, BT_PROPERTY_REMOTE_TRUST_VALUE,
                                          &trustval, sizeof(trustval),
                                          remote_properties[num_props]);
             num_props++;
+#endif
 
             BTIF_STORAGE_GET_REMOTE_PROP(p_remote_addr, BT_PROPERTY_CLASS_OF_DEVICE,
                                          &cod, sizeof(cod),
diff -Naur '--exclude=.git' bluedroid-orig/btif/src/btif_util.c bluedroid/btif/src/btif_util.c
--- bluedroid-orig/btif/src/btif_util.c	2015-09-24 16:33:43.536227643 +0800
+++ bluedroid/btif/src/btif_util.c	2015-09-24 16:31:37.000000000 +0800
@@ -101,8 +101,8 @@
     char *addr = (char *) bdaddr->address;
 
     sprintf((char*)bdstr, "%02x:%02x:%02x:%02x:%02x:%02x",
-                       (int)addr[0],(int)addr[1],(int)addr[2],
-                       (int)addr[3],(int)addr[4],(int)addr[5]);
+                       (uint8_t)addr[0],(uint8_t)addr[1],(uint8_t)addr[2],
+                       (uint8_t)addr[3],(uint8_t)addr[4],(uint8_t)addr[5]);
     return (char *)bdstr;
 }
 
@@ -250,7 +250,9 @@
         CASE_RETURN_STR(BT_PROPERTY_ADAPTER_BONDED_DEVICES)
         CASE_RETURN_STR(BT_PROPERTY_ADAPTER_SCAN_MODE)
         CASE_RETURN_STR(BT_PROPERTY_REMOTE_FRIENDLY_NAME)
+#ifdef PLATFORM_ANDROID
         CASE_RETURN_STR(BT_PROPERTY_REMOTE_TRUST_VALUE)
+ #endif
 
         default:
             return "UNKNOWN PROPERTY ID";
@@ -577,6 +579,7 @@
         CASE_RETURN_STR(AVRC_PDU_ABORT_CONTINUATION_RSP)
         CASE_RETURN_STR(AVRC_PDU_SET_ABSOLUTE_VOLUME)
         CASE_RETURN_STR(AVRC_PDU_SET_ADDRESSED_PLAYER)
+        CASE_RETURN_STR(AVRC_PDU_GET_CAPABILITIES)
         default:
             return "Unknown PDU";
     }
diff -Naur '--exclude=.git' bluedroid-orig/btif/src/list.c bluedroid/btif/src/list.c
--- bluedroid-orig/btif/src/list.c	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/btif/src/list.c	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,284 @@
+#include <assert.h>
+
+#include "list.h"
+
+typedef struct list_node_t {
+  struct list_node_t *next;
+  void *data;
+} list_node_t;
+
+typedef struct list_t {
+  list_node_t *head;
+  list_node_t *tail;
+  size_t length;
+  list_free_cb free_cb;
+} list_t;
+
+static list_node_t *list_free_node_(list_t *list, list_node_t *node);
+
+// Returns a new, empty list. Returns NULL if not enough memory could be allocated
+// for the list structure. The returned list must be freed with |list_free|. The
+// |callback| specifies a function to be called whenever a list element is removed
+// from the list. It can be used to release resources held by the list element, e.g.
+// memory or file descriptor. |callback| may be NULL if no cleanup is necessary on
+// element removal.
+list_t *list_new(list_free_cb callback) {
+  list_t *list = (list_t *)calloc(sizeof(list_t), 1);
+  if (list)
+    list->free_cb = callback;
+  return list;
+}
+
+// Frees the list. This function accepts NULL as an argument, in which case it
+// behaves like a no-op.
+void list_free(list_t *list) {
+  if (list != NULL)
+    list_clear(list);
+
+  free(list);
+}
+
+// Returns true if the list is empty (has no elements), false otherwise.
+// Note that a NULL list is not the same as an empty list. This function
+// does not accept a NULL list.
+bool list_is_empty(const list_t *list) {
+  assert(list != NULL);
+  if (list)
+    return (list->length == 0);
+  else
+    return true;
+}
+
+// Returns the length of the list. This function does not accept a NULL list.
+size_t list_length(const list_t *list) {
+  assert(list != NULL);
+  if (list)
+    return list->length;
+  else
+    return 0;
+}
+
+// Returns the first element in the list without removing it. |list| may not
+// be NULL or empty.
+void *list_front(const list_t *list) {
+  assert(list != NULL);
+  assert(!list_is_empty(list));
+  if (list && list->head)
+    return list->head->data;
+  return NULL;
+}
+
+// Returns the last element in the list without removing it. |list| may not
+// be NULL or empty.
+void *list_back(const list_t *list) {
+  assert(list != NULL);
+  assert(!list_is_empty(list));
+  if (list && list->tail)
+    return list->tail->data;
+  return NULL;
+}
+
+bool list_insert_after(list_t *list, list_node_t *prev_node, void *data) {
+  assert(list != NULL);
+  assert(prev_node != NULL);
+  assert(data != NULL);
+  if (!list || !prev_node)
+    return false;
+  list_node_t *node = (list_node_t *)malloc(sizeof(list_node_t));
+  if (!node)
+    return false;
+
+  node->next = prev_node->next;
+  node->data = data;
+  prev_node->next = node;
+  if (list->tail == prev_node)
+    list->tail = node;
+  ++list->length;
+  return true;
+}
+
+// Inserts |data| at the beginning of |list|. Neither |data| nor |list| may be NULL.
+// This function does not make a copy of |data| so the pointer must remain valid
+// at least until the element is removed from the list or the list is freed.
+// Returns true if |data| could be inserted, false otherwise (e.g. out of memory).
+bool list_prepend(list_t *list, void *data) {
+  assert(list != NULL);
+  assert(data != NULL);
+  if (!list)
+    return false;
+  list_node_t *node = (list_node_t *)malloc(sizeof(list_node_t));
+  if (!node)
+    return false;
+  node->next = list->head;
+  node->data = data;
+  list->head = node;
+  if (list->tail == NULL)
+    list->tail = list->head;
+  ++list->length;
+  return true;
+}
+
+// Inserts |data| at the end of |list|. Neither |data| nor |list| may be NULL.
+// This function does not make a copy of |data| so the pointer must remain valid
+// at least until the element is removed from the list or the list is freed.
+// Returns true if |data| could be inserted, false otherwise (e.g. out of memory).
+bool list_append(list_t *list, void *data) {
+  assert(list != NULL);
+  assert(data != NULL);
+  if (!list)
+    return false;
+  list_node_t *node = (list_node_t *)malloc(sizeof(list_node_t));
+  if (!node)
+    return false;
+  node->next = NULL;
+  node->data = data;
+  if (list->tail == NULL) {
+    list->head = node;
+    list->tail = node;
+  } else {
+    list->tail->next = node;
+    list->tail = node;
+  }
+  ++list->length;
+  return true;
+}
+
+// Removes |data| from the list. Neither |list| nor |data| may be NULL. If |data|
+// is inserted multiple times in the list, this function will only remove the first
+// instance. If a free function was specified in |list_new|, it will be called back
+// with |data|. This function returns true if |data| was found in the list and removed,
+// false otherwise.
+bool list_remove(list_t *list, void *data) {
+  list_node_t *prev;
+  list_node_t *node;
+  assert(list != NULL);
+  assert(data != NULL);
+
+  if (!list || list_is_empty(list))
+    return false;
+
+  if (list->head->data == data) {
+    list_node_t *next = list_free_node_(list, list->head);
+    if (list->tail == list->head)
+      list->tail = next;
+    list->head = next;
+    return true;
+  }
+
+  for (prev = list->head, node = list->head->next; node; prev = node, node = node->next)
+    if (node->data == data) {
+      prev->next = list_free_node_(list, node);
+      if (list->tail == node)
+        list->tail = prev;
+      return true;
+    }
+
+  return false;
+}
+
+// Removes all elements in the list. Calling this function will return the list to the
+// same state it was in after |list_new|. |list| may not be NULL.
+void list_clear(list_t *list) {
+  list_node_t *node;
+  assert(list != NULL);
+  if (list){
+    for (node = list->head; node; )
+      node = list_free_node_(list, node);
+    list->head = NULL;
+    list->tail = NULL;
+    list->length = 0;
+  }
+}
+
+// Iterates through the entire |list| and calls |callback| for each data element.
+// If the list is empty, |callback| will never be called. It is safe to mutate the
+// list inside the callback. If an element is added before the node being visited,
+// there will be no callback for the newly-inserted node. Neither |list| nor
+// |callback| may be NULL.
+void list_foreach(const list_t *list, list_iter_cb callback) {
+  list_node_t *node;
+  assert(list != NULL);
+  assert(callback != NULL);
+  if (list)
+    for (node = list->head; node; ) {
+      list_node_t *next = node->next;
+      callback(node->data);
+      node = next;
+    }
+}
+
+// Iterates through the entire |list| and calls |callback| for each data element.
+// Passes the caller provided data along with node
+// If the list is empty, |callback| will never be called. It is safe to mutate the
+// list inside the callback. If an element is added before the node being visited,
+// there will be no callback for the newly-inserted node. Neither |list| nor
+// |callback| may be NULL.
+void list_foreach_ext(const list_t *list, list_iter_cb_ext callback, void *cb_data) {
+  list_node_t *node;
+  assert(list != NULL);
+  assert(callback != NULL);
+  if (list)
+    for (node = list->head; node; ) {
+      list_node_t *next = node->next;
+      callback(node->data, cb_data);
+      node = next;
+    }
+}
+
+// Returns an iterator to the first element in |list|. |list| may not be NULL.
+// The returned iterator is valid as long as it does not equal the value returned
+// by |list_end|.
+list_node_t *list_begin(const list_t *list) {
+  assert(list != NULL);
+  if (list)
+    return list->head;
+  else
+    return NULL;
+}
+
+// Returns an iterator that points past the end of the list. In other words,
+// this function returns the value of an invalid iterator for the given list.
+// When an iterator has the same value as what's returned by this function, you
+// may no longer call |list_next| with the iterator. |list| may not be NULL.
+list_node_t *list_end(const list_t *list) {
+  assert(list != NULL);
+  return NULL;
+}
+
+// Given a valid iterator |node|, this function returns the next value for the
+// iterator. If the returned value equals the value returned by |list_end|, the
+// iterator has reached the end of the list and may no longer be used for any
+// purpose.
+list_node_t *list_next(const list_node_t *node) {
+  assert(node != NULL);
+  if (node)
+    return node->next;
+  else
+    return NULL;
+}
+
+// Returns the value stored at the location pointed to by the iterator |node|.
+// |node| must not equal the value returned by |list_end|.
+void *list_node(const list_node_t *node) {
+  assert(node != NULL);
+  if (node)
+    return node->data;
+  return false;
+}
+
+static list_node_t *list_free_node_(list_t *list, list_node_t *node) {
+  assert(list != NULL);
+  assert(node != NULL);
+
+  list_node_t *next = node ?node->next: NULL;
+
+  if (list && node)
+  {
+    if (list->free_cb)
+      list->free_cb(node->data);
+    free(node);
+    --list->length;
+  }
+
+  return next;
+}
diff -Naur '--exclude=.git' bluedroid-orig/CMakeLists.txt bluedroid/CMakeLists.txt
--- bluedroid-orig/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/CMakeLists.txt	2015-09-24 16:31:36.000000000 +0800
@@ -0,0 +1,24 @@
+cmake_minimum_required(VERSION 2.6)
+
+# Cross-Compiler
+#set(CMAKE_C_COMPILER "arm-none-linux-gnueabi-gcc")
+#set(CMAKE_CXX_COMPILER "arm-none-linux-gnueabi-g++")
+
+add_definitions("-DHAS_NO_BDROID_BUILDCFG -DX86_BUILD")
+
+add_subdirectory(stack)
+
+add_subdirectory(gki)
+
+add_subdirectory(bta)
+
+add_subdirectory(utils)
+
+add_subdirectory(hci)
+
+add_subdirectory(embdrv/sbc/decoder)
+
+add_subdirectory(main)
+
+add_subdirectory(test/bluedroidtest)
+
diff -Naur '--exclude=.git' bluedroid-orig/conf/bt_stack.conf bluedroid/conf/bt_stack.conf
--- bluedroid-orig/conf/bt_stack.conf	2015-09-24 16:33:43.536227643 +0800
+++ bluedroid/conf/bt_stack.conf	2015-09-24 16:31:37.000000000 +0800
@@ -2,11 +2,16 @@
 # valid value : true, false
 BtSnoopLogOutput=false
 BtSnoopExtDump=false
-
 # BtSnoop log output file
 BtSnoopFileName=/sdcard/btsnoop_hci.log
 
-# A2DP BIT RATE config
+# SSVD configurations
+#EnableTestMode=true
+#UnconditionalPatchUpgrade=true
+#Disable3DD=true
+#DisableInterlacedScan=true 
+
+# A2DP BIT RATE config          
 SbcHighBitrate=true
 
 # Enable trace level reconfiguration function
diff -Naur '--exclude=.git' bluedroid-orig/embdrv/sbc/decoder/Android.mk bluedroid/embdrv/sbc/decoder/Android.mk
--- bluedroid-orig/embdrv/sbc/decoder/Android.mk	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/embdrv/sbc/decoder/Android.mk	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,28 @@
+LOCAL_PATH:= $(call my-dir)
+include $(CLEAR_VARS)
+
+# sbc decoder
+LOCAL_SRC_FILES+= \
+        ./srce/alloc.c \
+        ./srce/bitalloc.c \
+        ./srce/bitalloc-sbc.c \
+        ./srce/bitstream-decode.c \
+        ./srce/decoder-oina.c \
+        ./srce/decoder-private.c \
+        ./srce/decoder-sbc.c \
+        ./srce/dequant.c \
+        ./srce/framing.c \
+        ./srce/framing-sbc.c \
+        ./srce/oi_codec_version.c \
+        ./srce/synthesis-sbc.c \
+        ./srce/synthesis-dct8.c \
+        ./srce/synthesis-8-generated.c \
+
+LOCAL_C_INCLUDES += $(LOCAL_PATH)/include
+LOCAL_C_INCLUDES += $(LOCAL_PATH)/srce
+
+LOCAL_MODULE:= libbt-qcom_sbc_decoder
+LOCAL_MODULE_TAGS := optional
+LOCAL_MODULE_CLASS := STATIC_LIBRARIES
+
+include $(BUILD_STATIC_LIBRARY)
diff -Naur '--exclude=.git' bluedroid-orig/embdrv/sbc/decoder/CMakeLists.txt bluedroid/embdrv/sbc/decoder/CMakeLists.txt
--- bluedroid-orig/embdrv/sbc/decoder/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/embdrv/sbc/decoder/CMakeLists.txt	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,56 @@
+CMAKE_MINIMUM_REQUIRED(VERSION 2.6)
+PROJECT(bt-qcom_sbc_decoder C)
+
+set(SRCS
+    ./srce/alloc.c
+    ./srce/bitalloc.c
+    ./srce/bitalloc-sbc.c
+    ./srce/bitstream-decode.c
+    ./srce/decoder-oina.c
+    ./srce/decoder-private.c
+    ./srce/decoder-sbc.c
+    ./srce/dequant.c
+    ./srce/framing.c
+    ./srce/framing-sbc.c
+    ./srce/oi_codec_version.c
+    ./srce/synthesis-sbc.c
+    ./srce/synthesis-dct8.c
+    ./srce/synthesis-8-generated.c
+)
+
+
+SET(PREFIX ${CMAKE_INSTALL_PREFIX})
+SET(EXEC_PREFIX "\${prefix}")
+SET(LIBDIR "\${prefix}/lib")
+SET(INCLUDEDIR "\${prefix}/include")
+SET(VERSION_MAJOR 1)
+SET(VERSION ${VERSION_MAJOR}.0.0)
+
+
+set(LOCAL_C_INCLUDES
+    ./include
+    ./srce
+    ${bdroid_C_INCLUDES} )
+include_directories(${LOCAL_C_INCLUDES})
+
+FOREACH(flag ${packages_CFLAGS})
+    SET(EXTRA_CFLAGS "${EXTRA_CFLAGS} ${flag}")
+ENDFOREACH(flag)
+
+#SET(EXTRA_CFLAGS "${EXTRA_CFLAGS} -fvisibility=hidden -Wall")
+SET(EXTRA_CFLAGS "${EXTRA_CFLAGS} -g ")
+
+SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${EXTRA_CFLAGS} -fPIC")
+
+FIND_PROGRAM(UNAME NAMES uname)
+EXEC_PROGRAM("${UNAME}" ARGS "-m" OUTPUT_VARIABLE "ARCH")
+IF("${ARCH}" STREQUAL "arm")
+    ADD_DEFINITIONS("-DTARGET")
+    MESSAGE("add -DTARGET")
+ENDIF("${ARCH}" STREQUAL "arm")
+
+ADD_LIBRARY(${PROJECT_NAME} STATIC ${SRCS})
+SET_TARGET_PROPERTIES(${PROJECT_NAME} PROPERTIES SOVERSION ${VERSION_MAJOR})
+SET_TARGET_PROPERTIES(${PROJECT_NAME} PROPERTIES VERSION ${VERSION})
+TARGET_LINK_LIBRARIES(${PROJECT_NAME} ${packages_LDFLAGS})
+INSTALL(TARGETS ${PROJECT_NAME} DESTINATION lib)
diff -Naur '--exclude=.git' bluedroid-orig/embdrv/sbc/decoder/include/oi_assert.h bluedroid/embdrv/sbc/decoder/include/oi_assert.h
--- bluedroid-orig/embdrv/sbc/decoder/include/oi_assert.h	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/embdrv/sbc/decoder/include/oi_assert.h	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,86 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2014 The Android Open Source Project
+ *  Copyright 2002 - 2004 Open Interface North America, Inc. All rights reserved.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#ifndef _OI_ASSERT_H
+#define _OI_ASSERT_H
+/** @file
+  This file provides macros and functions for compile-time and run-time assertions.
+
+  When the OI_DEBUG preprocessor value is defined, the macro OI_ASSERT is compiled into
+  the program, providing for a runtime assertion failure check.
+  C_ASSERT is a macro that can be used to perform compile time checks.
+*/
+/**********************************************************************************
+  $Revision: #1 $
+***********************************************************************************/
+
+
+/** \addtogroup Debugging Debugging APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#ifdef OI_DEBUG
+
+/** The macro OI_ASSERT takes a condition argument. If the asserted condition
+    does not evaluate to true, the OI_ASSERT macro calls the host-dependent function,
+    OI_AssertFail(), which reports the failure and generates a runtime error.
+*/
+void OI_AssertFail(char* file, int line, char* reason);
+
+
+#define OI_ASSERT(condition) \
+    { if (!(condition)) OI_AssertFail(__FILE__, __LINE__, #condition); }
+
+#define OI_ASSERT_FAIL(msg) \
+    { OI_AssertFail(__FILE__, __LINE__, msg); }
+
+#else
+
+
+#define OI_ASSERT(condition)
+#define OI_ASSERT_FAIL(msg)
+
+#endif
+
+
+/**
+   C_ASSERT() can be used to perform many compile-time assertions: type sizes, field offsets, etc.
+   An assertion failure results in compile time error C2118: negative subscript.
+   Unfortunately, this elegant macro doesn't work with GCC, so it's all commented out
+   for now. Perhaps later.....
+*/
+
+#ifndef C_ASSERT
+// #define C_ASSERT(e) typedef char __C_ASSERT__[(e)?1:-1]
+// #define C_ASSERT(e)
+#endif
+
+
+/*****************************************************************************/
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_ASSERT_H */
+
diff -Naur '--exclude=.git' bluedroid-orig/embdrv/sbc/decoder/include/oi_bitstream.h bluedroid/embdrv/sbc/decoder/include/oi_bitstream.h
--- bluedroid-orig/embdrv/sbc/decoder/include/oi_bitstream.h	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/embdrv/sbc/decoder/include/oi_bitstream.h	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,123 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2014 The Android Open Source Project
+ *  Copyright 2003 - 2004 Open Interface North America, Inc. All rights reserved.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#ifndef _OI_BITSTREAM_H
+#define _OI_BITSTREAM_H
+
+/**********************************************************************************
+  $Revision: #1 $
+***********************************************************************************/
+
+
+/**
+@file
+Function prototypes and macro definitions for manipulating input and output
+bitstreams.
+
+@ingroup codec_internal
+*/
+
+/**
+@addtogroup codec_internal
+@{
+*/
+
+#include "oi_codec_sbc_private.h"
+#include "oi_stddefs.h"
+
+INLINE void OI_BITSTREAM_ReadInit(OI_BITSTREAM *bs, const OI_BYTE *buffer);
+
+INLINE void OI_BITSTREAM_WriteInit(OI_BITSTREAM *bs, OI_BYTE *buffer);
+
+INLINE OI_UINT32 OI_BITSTREAM_ReadUINT(OI_BITSTREAM *bs, OI_UINT bits);
+
+INLINE OI_UINT8 OI_BITSTREAM_ReadUINT4Aligned(OI_BITSTREAM *bs);
+
+INLINE OI_UINT8 OI_BITSTREAM_ReadUINT8Aligned(OI_BITSTREAM *bs);
+
+INLINE void OI_BITSTREAM_WriteUINT(OI_BITSTREAM *bs,
+                                   OI_UINT16 value,
+                                   OI_UINT bits);
+
+/*
+ * Use knowledge that the bitstream is aligned to optimize the write of a byte
+ */
+PRIVATE void OI_BITSTREAM_WriteUINT8Aligned(OI_BITSTREAM *bs,
+                                            OI_UINT8 datum);
+
+/*
+ * Use knowledge that the bitstream is aligned to optimize the write pair of nibbles
+ */
+PRIVATE void OI_BITSTREAM_Write2xUINT4Aligned(OI_BITSTREAM *bs,
+                                              OI_UINT8 datum1,
+                                              OI_UINT8 datum2);
+
+/** Internally the bitstream looks ahead in the stream. When
+ * OI_SBC_ReadScalefactors() goes to temporarily break the abstraction, it will
+ * need to know where the "logical" pointer is in the stream.
+ */
+#define OI_BITSTREAM_GetWritePtr(bs) ((bs)->ptr.w - 3)
+#define OI_BITSTREAM_GetReadPtr(bs) ((bs)->ptr.r - 3)
+
+/** This is declared here as a macro because decoder.c breaks the bitsream
+ * encapsulation for efficiency reasons.
+ */
+#define OI_BITSTREAM_READUINT(result, bits, ptr, value, bitPtr) \
+do { \
+    OI_ASSERT((bits) <= 16); \
+    OI_ASSERT((bitPtr) < 16); \
+    OI_ASSERT((bitPtr) >= 8); \
+    \
+    result = (value) << (bitPtr); \
+    result >>= 32 - (bits); \
+    \
+    bitPtr += (bits); \
+    while (bitPtr >= 16) { \
+        value = ((value) << 8) | *ptr++; \
+        bitPtr -= 8; \
+    } \
+    OI_ASSERT((bits == 0) || (result < (1u << (bits)))); \
+} while (0)
+
+
+#define OI_BITSTREAM_WRITEUINT(ptr, value, bitPtr, datum, bits) \
+do {\
+    bitPtr -= bits;\
+    value |= datum << bitPtr;\
+    \
+    while (bitPtr <= 16) {\
+        bitPtr += 8;\
+        *ptr++ = (OI_UINT8)(value >> 24);\
+        value <<= 8;\
+    }\
+} while (0)
+
+#define OI_BITSTREAM_WRITEFLUSH(ptr, value, bitPtr) \
+do {\
+    while (bitPtr < 32) {\
+        bitPtr += 8;\
+        *ptr++ = (OI_UINT8)(value >> 24);\
+        value <<= 8;\
+    }\
+} while (0)
+
+/**
+@}
+*/
+
+#endif /* _OI_BITSTREAM_H */
diff -Naur '--exclude=.git' bluedroid-orig/embdrv/sbc/decoder/include/oi_bt_spec.h bluedroid/embdrv/sbc/decoder/include/oi_bt_spec.h
--- bluedroid-orig/embdrv/sbc/decoder/include/oi_bt_spec.h	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/embdrv/sbc/decoder/include/oi_bt_spec.h	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,229 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2014 The Android Open Source Project
+ *  Copyright 2002 - 2004 Open Interface North America, Inc. All rights reserved.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#ifndef _OI_BT_SPEC_H
+#define _OI_BT_SPEC_H
+/**
+ * @file
+ *
+ * This file contains common definitions from the Bluetooth specification.
+ *
+ */
+
+/**********************************************************************************
+  $Revision: #1 $
+***********************************************************************************/
+
+#include "oi_stddefs.h"
+
+/** \addtogroup Misc Miscellaneous APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** The maximum number of active slaves in a piconet. */
+#define OI_BT_MAX_ACTIVE_SLAVES 7
+
+/** the number of bytes in a Bluetooth device address (BD_ADDR) */
+#define OI_BD_ADDR_BYTE_SIZE   6
+
+/**
+ * 48-bit Bluetooth device address
+ *
+ * Because 48-bit integers may not be supported on all platforms, the
+ * address is defined as an array of bytes. This array is big-endian,
+ * meaning that
+ *  - array[0] contains bits 47-40,
+ *  - array[1] contains bits 39-32,
+ *  - array[2] contains bits 31-24,
+ *  - array[3] contains bits 23-16,
+ *  - array[4] contains bits 15-8, and
+ *  - array[5] contains bits 7-0.
+ */
+typedef struct  {
+    OI_UINT8    addr[OI_BD_ADDR_BYTE_SIZE] ;   /**< Bluetooth device address represented as an array of 8-bit values */
+} OI_BD_ADDR ;
+
+/**
+ * @name Data types for working with UUIDs
+ * UUIDs are 16 bytes (128 bits).
+ *
+ * To avoid having to pass around 128-bit values all the time, 32-bit and 16-bit
+ * UUIDs are defined, along with a mapping from the shorter versions to the full
+ * version.
+ *
+ * @{
+ */
+
+/**
+ * 16-bit representation of a 128-bit UUID
+ */
+typedef OI_UINT16 OI_UUID16;
+
+/**
+ * 32-bit representation of a 128-bit UUID
+ */
+typedef OI_UINT32 OI_UUID32;
+
+/**
+ * number of bytes in a 128 bit UUID
+ */
+#define OI_BT_UUID128_SIZE  16
+
+/**
+ * number of bytes in IPv6 style addresses
+ */
+#define OI_BT_IPV6ADDR_SIZE  16
+
+/**
+ * type definition for a 128-bit UUID
+ *
+ * To simplify conversion between 128-bit UUIDs and 16-bit and 32-bit UUIDs,
+ * the most significant 32 bits are stored with the same endian-ness as is
+ * native on the target (local) device. The remainder of the 128-bit UUID is
+ * stored as bytes in big-endian order.
+ */
+typedef struct {
+    OI_UINT32 ms32bits;                                    /**< most significant 32 bits of 128-bit UUID */
+    OI_UINT8 base[OI_BT_UUID128_SIZE - sizeof(OI_UINT32)]; /**< remainder of 128-bit UUID, array of 8-bit values */
+} OI_UUID128;
+
+/** @} */
+
+/** number of bytes in a link key */
+#define OI_BT_LINK_KEY_SIZE    16
+
+/**
+ * type definition for a baseband link key
+ *
+ * Because 128-bit integers may not be supported on all platforms, we define
+ * link keys as an array of bytes. Unlike the Bluetooth device address,
+ * the link key is stored in little-endian order, meaning that
+ *  - array[0]  contains bits 0  - 7,
+ *  - array[1]  contains bits 8  - 15,
+ *  - array[2]  contains bits 16 - 23,
+ *  - array[3]  contains bits 24 - 31,
+ *  - array[4]  contains bits 32 - 39,
+ *  - array[5]  contains bits 40 - 47,
+ *  - array[6]  contains bits 48 - 55,
+ *  - array[7]  contains bits 56 - 63,
+ *  - array[8]  contains bits 64 - 71,
+ *  - array[9]  contains bits 72 - 79,
+ *  - array[10] contains bits 80 - 87,
+ *  - array[11] contains bits 88 - 95,
+ *  - array[12] contains bits 96 - 103,
+ *  - array[13] contains bits 104- 111,
+ *  - array[14] contains bits 112- 119, and
+ *  - array[15] contains bits 120- 127.
+ */
+typedef struct {
+    OI_UINT8    key[OI_BT_LINK_KEY_SIZE] ;   /**< link key represented as an array of 8-bit values */
+} OI_LINK_KEY ;
+
+
+/** Out-of-band data size - C and R values are 16-bytes each */
+#define OI_BT_OOB_NUM_BYTES     16
+
+typedef struct {
+    OI_UINT8    value[OI_BT_OOB_NUM_BYTES] ;   /**< same struct used for C and R values */
+} OI_OOB_DATA ;
+
+
+/**
+ * link key types
+ */
+typedef enum  {
+    OI_LINK_KEY_TYPE_COMBO              = 0,    /**< combination key */
+    OI_LINK_KEY_TYPE_LOCAL_UNIT         = 1,    /**< local unit key */
+    OI_LINK_KEY_TYPE_REMOTE_UNIT        = 2,    /**< remote unit key */
+    OI_LINK_KEY_TYPE_DEBUG_COMBO        = 3,    /**< debug combination key */
+    OI_LINK_KEY_TYPE_UNAUTHENTICATED    = 4,    /**< Unauthenticated */
+    OI_LINK_KEY_TYPE_AUTHENTICATED      = 5,    /**< Authenticated */
+    OI_LINK_KEY_TYPE_CHANGED_COMBO      = 6     /**< Changed */
+
+} OI_BT_LINK_KEY_TYPE ;
+
+
+/** amount of space allocated for a PIN (personal indentification number) in bytes */
+#define OI_BT_PIN_CODE_SIZE    16
+
+/** data type for a PIN (PINs are treated as strings, so endianness does not apply.) */
+typedef struct  {
+    OI_UINT8    pin[OI_BT_PIN_CODE_SIZE] ; /**< PIN represented as an array of 8-bit values */
+} OI_PIN_CODE ;
+
+/** maximum number of SCO connections per device, which is 3 as of version 2.0+EDR
+    of the Bluetooth specification (see sec 4.3 of vol 2 part B) */
+#define OI_BT_MAX_SCO_CONNECTIONS  3
+
+/** data type for clock offset */
+typedef OI_UINT16   OI_BT_CLOCK_OFFSET ;
+
+/** data type for a LM handle */
+typedef OI_UINT16 OI_HCI_LM_HANDLE;
+
+/** opaque data type for a SCO or ACL connection handle */
+typedef struct _OI_HCI_CONNECTION *OI_HCI_CONNECTION_HANDLE;
+
+/** data type for HCI Error Code, as defined in oi_hcispec.h */
+typedef OI_UINT8    OI_HCI_ERROR_CODE ;
+
+/**
+ * The Bluetooth device type is indicated by a 24-bit bitfield, represented as a
+ * 32-bit number in the stack. The bit layout and values for device class are specified
+ * in the file oi_bt_assigned_nos.h and in the Bluetooth "Assigned Numbers" specification
+ * at http://www.bluetooth.org/assigned-numbers/.
+ */
+typedef OI_UINT32   OI_BT_DEVICE_CLASS ;
+
+#define OI_BT_DEV_CLASS_FORMAT_MASK        0x000003    /**< Bits 0-1 contain format type. */
+#define OI_BT_DEV_CLASS_MINOR_DEVICE_MASK  0x0000FC    /**< Bits 2-7 contain minor device class value. */
+#define OI_BT_DEV_CLASS_MAJOR_DEVICE_MASK  0x001F00    /**< Bits 8-12 contain major device class value. */
+#define OI_BT_DEV_CLASS_MAJOR_SERVICE_MASK 0xFFE000    /**< Bits 13-23 contain major service class value. */
+
+/** There is currently only one device class format defined, type 00. */
+#define OI_BT_DEV_CLASS_FORMAT_TYPE        00
+
+/** Bit 13 in device class indicates limited discoverability mode (GAP v2.0+EDR, section 4.1.2.2) */
+#define OI_BT_DEV_CLASS_LIMITED_DISCO_BIT  BIT13
+
+/** macro to test validity of the Device Class Format */
+#define OI_BT_VALID_DEVICE_CLASS_FORMAT(class) (OI_BT_DEV_CLASS_FORMAT_TYPE == ((class) & OI_BT_DEV_CLASS_FORMAT_MASK))
+
+/** the time between baseband clock ticks, currently 625 microseconds (one slot) */
+#define OI_BT_TICK 625
+/** some macros to convert to/from baseband clock ticks - use no floating point! */
+#define OI_SECONDS_TO_BT_TICKS(secs)    ((secs)*1600)
+#define OI_BT_TICKS_TO_SECONDS(ticks)   ((ticks)/1600)
+#define OI_MSECS_TO_BT_TICKS(msecs)     (((msecs)*8)/5)
+#define OI_BT_TICKS_TO_MSECS(ticks)     (((ticks)*5)/8)
+
+/** EIR byte order */
+#define OI_EIR_BYTE_ORDER   OI_LITTLE_ENDIAN_BYTE_ORDER
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+/*****************************************************************************/
+#endif /* _OI_BT_SPEC_H */
diff -Naur '--exclude=.git' bluedroid-orig/embdrv/sbc/decoder/include/oi_codec_sbc.h bluedroid/embdrv/sbc/decoder/include/oi_codec_sbc.h
--- bluedroid-orig/embdrv/sbc/decoder/include/oi_codec_sbc.h	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/embdrv/sbc/decoder/include/oi_codec_sbc.h	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,484 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2014 The Android Open Source Project
+ *  Copyright 2003 - 2004 Open Interface North America, Inc. All rights reserved.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/**********************************************************************************
+  $Revision: #1 $
+***********************************************************************************/
+
+#ifndef _OI_CODEC_SBC_CORE_H
+#define _OI_CODEC_SBC_CORE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+@file
+Declarations of codec functions, data types, and macros.
+
+@ingroup codec_lib
+*/
+
+/**
+@addtogroup codec_lib
+@{
+*/
+
+/* Non-BM3 users of of the codec must include oi_codec_sbc_bm3defs.h prior to
+ * including this file, or else these includes will fail because the BM3 SDK is
+ * not in the include path */
+#ifndef _OI_CODEC_SBC_BM3DEFS_H
+#include "oi_stddefs.h"
+#include "oi_status.h"
+#endif
+
+#include <stdint.h>
+
+#define SBC_MAX_CHANNELS 2
+#define SBC_MAX_BANDS 8
+#define SBC_MAX_BLOCKS 16
+#define SBC_MIN_BITPOOL 2   /**< Minimum size of the bit allocation pool used to encode the stream */
+#define SBC_MAX_BITPOOL 250 /**< Maximum size of the bit allocation pool used to encode the stream */
+#define SBC_MAX_ONE_CHANNEL_BPS 320000
+#define SBC_MAX_TWO_CHANNEL_BPS 512000
+
+
+#define SBC_WBS_BITRATE 62000
+#define SBC_WBS_BITPOOL 27
+#define SBC_WBS_NROF_BLOCKS 16
+#define SBC_WBS_FRAME_LEN 62
+#define SBC_WBS_SAMPLES_PER_FRAME 128
+
+
+#define SBC_HEADER_LEN 4
+#define SBC_MAX_FRAME_LEN (SBC_HEADER_LEN + \
+                             ((SBC_MAX_BANDS * SBC_MAX_CHANNELS / 2) + \
+                              (SBC_MAX_BANDS + SBC_MAX_BLOCKS * SBC_MAX_BITPOOL + 7)/8))
+#define SBC_MAX_SAMPLES_PER_FRAME   (SBC_MAX_BANDS * SBC_MAX_BLOCKS)
+
+#define SBC_MAX_SCALEFACTOR_BYTES ((4*(SBC_MAX_CHANNELS * SBC_MAX_BANDS) + 7)/8)
+
+#define OI_SBC_SYNCWORD 0x9c
+#define OI_SBC_ENHANCED_SYNCWORD 0x9d
+
+/**@name Sampling frequencies */
+/**@{*/
+#define SBC_FREQ_16000 0 /**< The sampling frequency is 16 kHz. One possible value for the @a frequency parameter of OI_CODEC_SBC_EncoderConfigure() */
+#define SBC_FREQ_32000 1 /**< The sampling frequency is 32 kHz. One possible value for the @a frequency parameter of OI_CODEC_SBC_EncoderConfigure() */
+#define SBC_FREQ_44100 2 /**< The sampling frequency is 44.1 kHz. One possible value for the @a frequency parameter of OI_CODEC_SBC_EncoderConfigure() */
+#define SBC_FREQ_48000 3 /**< The sampling frequency is 48 kHz. One possible value for the @a frequency parameter of OI_CODEC_SBC_EncoderConfigure() */
+/**@}*/
+
+/**@name Channel modes */
+/**@{*/
+#define SBC_MONO 0         /**< The mode of the encoded channel is mono. One possible value for the @a mode parameter of OI_CODEC_SBC_EncoderConfigure() */
+#define SBC_DUAL_CHANNEL 1 /**< The mode of the encoded channel is dual-channel. One possible value for the @a mode parameter of OI_CODEC_SBC_EncoderConfigure() */
+#define SBC_STEREO 2       /**< The mode of the encoded channel is stereo. One possible value for the @a mode parameter of OI_CODEC_SBC_EncoderConfigure() */
+#define SBC_JOINT_STEREO 3 /**< The mode of the encoded channel is joint stereo. One possible value for the @a mode parameter of OI_CODEC_SBC_EncoderConfigure() */
+/**@}*/
+
+/**@name Subbands */
+/**@{*/
+#define SBC_SUBBANDS_4  0 /**< The encoded stream has 4 subbands. One possible value for the @a subbands parameter of OI_CODEC_SBC_EncoderConfigure()*/
+#define SBC_SUBBANDS_8  1 /**< The encoded stream has 8 subbands. One possible value for the @a subbands parameter of OI_CODEC_SBC_EncoderConfigure() */
+/**@}*/
+
+/**@name Block lengths */
+/**@{*/
+#define SBC_BLOCKS_4    0 /**< A block size of 4 blocks was used to encode the stream. One possible value for the @a blocks parameter of OI_CODEC_SBC_EncoderConfigure() */
+#define SBC_BLOCKS_8    1 /**< A block size of 8 blocks was used to encode the stream is. One possible value for the @a blocks parameter of OI_CODEC_SBC_EncoderConfigure() */
+#define SBC_BLOCKS_12   2 /**< A block size of 12 blocks was used to encode the stream. One possible value for the @a blocks parameter of OI_CODEC_SBC_EncoderConfigure() */
+#define SBC_BLOCKS_16   3 /**< A block size of 16 blocks was used to encode the stream. One possible value for the @a blocks parameter of OI_CODEC_SBC_EncoderConfigure() */
+/**@}*/
+
+/**@name Bit allocation methods */
+/**@{*/
+#define SBC_LOUDNESS 0    /**< The bit allocation method. One possible value for the @a loudness parameter of OI_CODEC_SBC_EncoderConfigure() */
+#define SBC_SNR 1         /**< The bit allocation method. One possible value for the @a loudness parameter of OI_CODEC_SBC_EncoderConfigure() */
+/**@}*/
+
+/**
+@}
+
+@addtogroup codec_internal
+@{
+*/
+
+typedef OI_INT16 SBC_BUFFER_T;
+
+
+/** Used internally. */
+typedef struct {
+    OI_UINT16 frequency;    /**< The sampling frequency. Input parameter. */
+    OI_UINT8 freqIndex;
+
+    OI_UINT8 nrof_blocks;   /**< The block size used to encode the stream. Input parameter. */
+    OI_UINT8 blocks;
+
+
+    OI_UINT8 nrof_subbands; /**< The number of subbands of the encoded stream. Input parameter. */
+    OI_UINT8 subbands;
+
+    OI_UINT8 mode;          /**< The mode of the encoded channel. Input parameter. */
+    OI_UINT8 nrof_channels; /**< The number of channels of the encoded stream. */
+
+    OI_UINT8 alloc;         /**< The bit allocation method. Input parameter. */
+    OI_UINT8 bitpool;       /**< Size of the bit allocation pool used to encode the stream. Input parameter. */
+    OI_UINT8 crc;           /**< Parity check byte used for error detection. */
+    OI_UINT8 join;          /**< Whether joint stereo has been used. */
+    OI_UINT8 enhanced;
+    OI_UINT8 min_bitpool;   /**< This value is only used when encoding. SBC_MAX_BITPOOL if variable
+                                 bitpools are disallowed, otherwise the minimum bitpool size that will
+                                 be used by the bit allocator.  */
+
+    OI_UINT8 cachedInfo;    /**< Information about the previous frame */
+} OI_CODEC_SBC_FRAME_INFO;
+
+/** Used internally. */
+typedef struct {
+    const OI_CHAR *codecInfo;
+    OI_CODEC_SBC_FRAME_INFO frameInfo;
+    OI_INT8 scale_factor[SBC_MAX_CHANNELS*SBC_MAX_BANDS];
+    OI_UINT32 frameCount;
+    OI_INT32 *subdata;
+
+    SBC_BUFFER_T *filterBuffer[SBC_MAX_CHANNELS];
+    OI_INT32 filterBufferLen;
+    OI_UINT filterBufferOffset;
+
+    union {
+        OI_UINT8 uint8[SBC_MAX_CHANNELS*SBC_MAX_BANDS];
+        OI_UINT32 uint32[SBC_MAX_CHANNELS*SBC_MAX_BANDS/4];
+    } bits;
+    OI_UINT8 maxBitneed;    /**< Running maximum bitneed */
+    OI_BYTE formatByte;
+    OI_UINT8 pcmStride;
+    OI_UINT8 maxChannels;
+} OI_CODEC_SBC_COMMON_CONTEXT;
+
+
+/*
+ * A smaller value reduces RAM usage at the expense of increased CPU usage. Values in the range
+ * 27..50 are recommended, beyond 50 there is a diminishing return on reduced CPU usage.
+ */
+#define SBC_CODEC_MIN_FILTER_BUFFERS 16
+#define SBC_CODEC_FAST_FILTER_BUFFERS 27
+
+/* Expands to the number of OI_UINT32s needed to ensure enough memory to encode
+ * or decode streams of numChannels channels, using numBuffers buffers.
+ * Example:
+ * OI_UINT32 decoderData[CODEC_DATA_WORDS(SBC_MAX_CHANNELS, SBC_DECODER_FAST_SYNTHESIS_BUFFERS)];
+ * */
+#define CODEC_DATA_WORDS(numChannels, numBuffers) \
+    ((\
+        (sizeof(OI_INT32) * SBC_MAX_BLOCKS * numChannels * SBC_MAX_BANDS) \
+         + (sizeof(SBC_BUFFER_T) * SBC_MAX_CHANNELS * SBC_MAX_BANDS * numBuffers) \
+         + (sizeof (OI_UINT32) - 1) \
+    ) / sizeof(OI_UINT32))
+
+/** Opaque parameter to decoding functions; maintains decoder context. */
+typedef struct {
+    OI_CODEC_SBC_COMMON_CONTEXT common;
+    OI_UINT8 limitFrameFormat;              /* Boolean, set by OI_CODEC_SBC_DecoderLimit() */
+    OI_UINT8 restrictSubbands;
+    OI_UINT8 enhancedEnabled;
+    OI_UINT8 bufferedBlocks;
+} OI_CODEC_SBC_DECODER_CONTEXT;
+
+typedef struct {
+    OI_UINT32 data[CODEC_DATA_WORDS(1, SBC_CODEC_FAST_FILTER_BUFFERS)];
+} OI_CODEC_SBC_CODEC_DATA_MONO;
+
+typedef struct {
+    OI_UINT32 data[CODEC_DATA_WORDS(2, SBC_CODEC_FAST_FILTER_BUFFERS)];
+} OI_CODEC_SBC_CODEC_DATA_STEREO;
+
+/**
+@}
+
+@addtogroup codec_lib
+@{
+*/
+
+/**
+ * This function resets the decoder. The context must be reset when
+ * changing streams, or if the following stream parameters change:
+ * number of subbands, stereo mode, or frequency.
+ *
+ * @param context   Pointer to the decoder context structure to be reset.
+ *
+ * @param enhanced  If true, enhanced SBC operation is enabled. If enabled,
+ *                  the codec will recognize the alternative syncword for
+ *                  decoding an enhanced SBC stream. Enhancements should not
+ *                  be enabled unless the stream is known to be generated
+ *                  by an enhanced encoder, or there is a small possibility
+ *                  for decoding glitches if synchronization were to be lost.
+ */
+OI_STATUS OI_CODEC_SBC_DecoderReset(OI_CODEC_SBC_DECODER_CONTEXT *context,
+                                    OI_UINT32 *decoderData,
+                                    OI_UINT32 decoderDataBytes,
+                                    OI_UINT8 maxChannels,
+                                    OI_UINT8 pcmStride,
+                                    OI_BOOL enhanced);
+
+/**
+ * This function restricts the kind of SBC frames that the Decoder will
+ * process.  Its use is optional.  If used, it must be called after
+ * calling OI_CODEC_SBC_DecoderReset(). After it is called, any calls
+ * to OI_CODEC_SBC_DecodeFrame() with SBC frames that do not conform
+ * to the Subband and Enhanced SBC setting will be rejected with an
+ * OI_STATUS_INVALID_PARAMETERS return.
+ *
+ * @param context   Pointer to the decoder context structure to be limited.
+ *
+ * @param enhanced  If true, all frames passed to the decoder must be
+ *                  Enhanced SBC frames. If false, all frames must be
+ *                  standard SBC frames.
+ *
+ * @param subbands  May be set to SBC_SUBBANDS_4 or SBC_SUBBANDS_8. All
+ *                  frames passed to the decoder must be encoded with
+ *                  the requested number of subbands.
+ *
+ */
+OI_STATUS OI_CODEC_SBC_DecoderLimit(OI_CODEC_SBC_DECODER_CONTEXT *context,
+                                    OI_BOOL enhanced,
+                                    OI_UINT8 subbands);
+
+/**
+ * This function sets the decoder parameters for a raw decode where the decoder parameters are not
+ * available in the sbc data stream. OI_CODEC_SBC_DecoderReset must be called
+ * prior to calling this function.
+ *
+ * @param context        Decoder context structure. This must be the context must be
+ *                       used each time a frame is decoded.
+ *
+ * @param enhanced       Set to TRUE to enable Qualcomm proprietary
+ *                       quality enhancements.
+ *
+ * @param frequency      One of SBC_FREQ_16000, SBC_FREQ_32000, SBC_FREQ_44100,
+ *                       SBC_FREQ_48000
+ *
+ * @param mode           One of SBC_MONO, SBC_DUAL_CHANNEL, SBC_STEREO,
+ *                       SBC_JOINT_STEREO
+ *
+ * @param subbands       One of SBC_SUBBANDS_4, SBC_SUBBANDS_8
+ *
+ * @param blocks         One of SBC_BLOCKS_4, SBC_BLOCKS_8, SBC_BLOCKS_12,
+ *                       SBC_BLOCKS_16
+ *
+ * @param alloc          One of SBC_LOUDNESS, SBC_SNR
+ *
+ * @param maxBitpool     The maximum bitpool size for this context
+ */
+OI_STATUS OI_CODEC_SBC_DecoderConfigureRaw(OI_CODEC_SBC_DECODER_CONTEXT *context,
+                                           OI_BOOL enhanced,
+                                           OI_UINT8 frequency,
+                                           OI_UINT8 mode,
+                                           OI_UINT8 subbands,
+                                           OI_UINT8 blocks,
+                                           OI_UINT8 alloc,
+                                           OI_UINT8 maxBitpool);
+
+/**
+ * Decode one SBC frame. The frame has no header bytes. The context must have been previously
+ * initialized by calling  OI_CODEC_SBC_DecoderConfigureRaw().
+ *
+ * @param context       Pointer to a decoder context structure. The same context
+ *                      must be used each time when decoding from the same stream.
+ *
+ * @param bitpool       The actual bitpool size for this frame. Must be <= the maxbitpool specified
+ *                      in the call to OI_CODEC_SBC_DecoderConfigureRaw(),
+ *
+ * @param frameData     Address of a pointer to the SBC data to decode. This
+ *                      value will be updated to point to the next frame after
+ *                      successful decoding.
+ *
+ * @param frameBytes    Pointer to a UINT32 containing the number of available
+ *                      bytes of frame data. This value will be updated to reflect
+ *                      the number of bytes remaining after a decoding operation.
+ *
+ * @param pcmData       Address of an array of OI_INT16 pairs, which will be
+ *                      populated with the decoded audio data. This address
+ *                      is not updated.
+ *
+ * @param pcmBytes      Pointer to a UINT32 in/out parameter. On input, it
+ *                      should contain the number of bytes available for pcm
+ *                      data. On output, it will contain the number of bytes
+ *                      written. Note that this differs from the semantics of
+ *                      frameBytes.
+ */
+OI_STATUS OI_CODEC_SBC_DecodeRaw(OI_CODEC_SBC_DECODER_CONTEXT *context,
+                                 OI_UINT8 bitpool,
+                                 const OI_BYTE **frameData,
+                                 OI_UINT32 *frameBytes,
+                                 OI_INT16 *pcmData,
+                                 OI_UINT32 *pcmBytes);
+
+/**
+ * Decode one SBC frame.
+ *
+ * @param context       Pointer to a decoder context structure. The same context
+ *                      must be used each time when decoding from the same stream.
+ *
+ * @param frameData     Address of a pointer to the SBC data to decode. This
+ *                      value will be updated to point to the next frame after
+ *                      successful decoding.
+ *
+ * @param frameBytes    Pointer to a UINT32 containing the number of available
+ *                      bytes of frame data. This value will be updated to reflect
+ *                      the number of bytes remaining after a decoding operation.
+ *
+ * @param pcmData       Address of an array of OI_INT16 pairs, which will be
+ *                      populated with the decoded audio data. This address
+ *                      is not updated.
+ *
+ * @param pcmBytes      Pointer to a UINT32 in/out parameter. On input, it
+ *                      should contain the number of bytes available for pcm
+ *                      data. On output, it will contain the number of bytes
+ *                      written. Note that this differs from the semantics of
+ *                      frameBytes.
+ */
+OI_STATUS OI_CODEC_SBC_DecodeFrame(OI_CODEC_SBC_DECODER_CONTEXT *context,
+                                   const OI_BYTE **frameData,
+                                   OI_UINT32 *frameBytes,
+                                   OI_INT16 *pcmData,
+                                   OI_UINT32 *pcmBytes);
+
+/**
+ * Calculate the number of SBC frames but don't decode. CRC's are not checked,
+ * but the Sync word is found prior to count calculation.
+ *
+ * @param frameData     Pointer to the SBC data.
+ *
+ * @param frameBytes    Number of bytes avaiable in the frameData buffer
+ *
+ */
+OI_UINT8 OI_CODEC_SBC_FrameCount(OI_BYTE  *frameData,
+                                 OI_UINT32 frameBytes);
+
+/**
+ * Analyze an SBC frame but don't do the decode.
+ *
+ * @param context       Pointer to a decoder context structure. The same context
+ *                      must be used each time when decoding from the same stream.
+ *
+ * @param frameData     Address of a pointer to the SBC data to decode. This
+ *                      value will be updated to point to the next frame after
+ *                      successful decoding.
+ *
+ * @param frameBytes    Pointer to a UINT32 containing the number of available
+ *                      bytes of frame data. This value will be updated to reflect
+ *                      the number of bytes remaining after a decoding operation.
+ *
+ */
+OI_STATUS OI_CODEC_SBC_SkipFrame(OI_CODEC_SBC_DECODER_CONTEXT *context,
+                                 const OI_BYTE **frameData,
+                                 OI_UINT32 *frameBytes);
+
+/* Common functions */
+
+/**
+  Calculate the frame length.
+
+  @param frame The frame whose length to calculate
+
+  @return the length of an individual encoded frame in
+  bytes
+  */
+OI_UINT16 OI_CODEC_SBC_CalculateFramelen(OI_CODEC_SBC_FRAME_INFO *frame);
+
+
+/**
+ * Calculate the maximum bitpool size that fits within a given frame length.
+ *
+ * @param frame     The frame to calculate the bitpool size for
+ * @param frameLen  The frame length to fit the bitpool to
+ *
+ * @return the maximum bitpool that will fit in the specified frame length
+ */
+OI_UINT16 OI_CODEC_SBC_CalculateBitpool(OI_CODEC_SBC_FRAME_INFO *frame,
+                                        OI_UINT16 frameLen);
+
+/**
+  Calculate the bit rate.
+
+  @param frame The frame whose bit rate to calculate
+
+  @return the approximate bit rate in bits per second,
+  assuming that stream parameters are constant
+  */
+OI_UINT32 OI_CODEC_SBC_CalculateBitrate(OI_CODEC_SBC_FRAME_INFO *frame);
+
+/**
+  Calculate decoded audio data length for one frame.
+
+  @param frame The frame whose audio data length to calculate
+
+  @return length of decoded audio data for a
+  single frame, in bytes
+  */
+OI_UINT16 OI_CODEC_SBC_CalculatePcmBytes(OI_CODEC_SBC_COMMON_CONTEXT *common);
+
+/**
+ * Get the codec version text.
+ *
+ * @return  pointer to text string containing codec version text
+ *
+ */
+OI_CHAR *OI_CODEC_Version(void);
+
+
+/**
+@}
+
+@addtogroup codec_internal
+@{
+*/
+
+extern const OI_CHAR* const OI_CODEC_SBC_FreqText[];
+extern const OI_CHAR* const OI_CODEC_SBC_ModeText[];
+extern const OI_CHAR* const OI_CODEC_SBC_SubbandsText[];
+extern const OI_CHAR* const OI_CODEC_SBC_BlocksText[];
+extern const OI_CHAR* const OI_CODEC_SBC_AllocText[];
+
+/**
+@}
+
+@addtogroup codec_lib
+@{
+*/
+
+#ifdef OI_DEBUG
+void OI_CODEC_SBC_DumpConfig(OI_CODEC_SBC_FRAME_INFO *frameInfo);
+#else
+#define OI_CODEC_SBC_DumpConfig(f)
+#endif
+
+/**
+@}
+*/
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* _OI_CODEC_SBC_CORE_H */
+
+
diff -Naur '--exclude=.git' bluedroid-orig/embdrv/sbc/decoder/include/oi_codec_sbc_private.h bluedroid/embdrv/sbc/decoder/include/oi_codec_sbc_private.h
--- bluedroid-orig/embdrv/sbc/decoder/include/oi_codec_sbc_private.h	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/embdrv/sbc/decoder/include/oi_codec_sbc_private.h	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,229 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2014 The Android Open Source Project
+ *  Copyright 2003 - 2004 Open Interface North America, Inc. All rights reserved.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#ifndef _OI_CODEC_SBC_PRIVATE_H
+#define _OI_CODEC_SBC_PRIVATE_H
+
+/**********************************************************************************
+  $Revision: #1 $
+***********************************************************************************/
+
+/**
+@file
+Function prototypes and macro definitions used internally by the codec.
+
+@ingroup codec_internal
+*/
+
+/**
+@addtogroup codec_internal
+@{
+*/
+
+#ifdef USE_RESTRICT_KEYWORD
+#define RESTRICT restrict
+#else
+#define RESTRICT
+#endif
+
+#ifdef CODEC_DEBUG
+#include <stdio.h>
+#define ERROR(x) do { printf x; printf("\n"); } while (0)
+#else
+#define ERROR(x)
+#endif
+
+#ifdef TRACE_EXECUTION
+#define TRACE(x) do { printf x; printf("\n"); } while (0)
+#else
+#define TRACE(x)
+#endif
+
+#ifndef PRIVATE
+#define PRIVATE
+#endif
+
+#ifndef INLINE
+#define INLINE
+#endif
+
+#include "oi_assert.h"
+#include "oi_codec_sbc.h"
+
+#ifndef OI_SBC_SYNCWORD
+#define OI_SBC_SYNCWORD 0x9c
+#endif
+
+#ifndef DIVIDE
+#define DIVIDE(a, b) ((a) / (b))
+#endif
+
+typedef union {
+    OI_UINT8 uint8[SBC_MAX_BANDS];
+    OI_UINT32 uint32[SBC_MAX_BANDS / 4];
+} BITNEED_UNION1;
+
+typedef union {
+    OI_UINT8 uint8[2 * SBC_MAX_BANDS];
+    OI_UINT32 uint32[2 * SBC_MAX_BANDS / 4];
+} BITNEED_UNION2;
+
+static const OI_UINT16 freq_values[] =    { 16000, 32000, 44100, 48000 };
+static const OI_UINT8 block_values[] =    { 4, 8, 12, 16 };
+static const OI_UINT8 channel_values[] =  { 1, 2, 2, 2 };
+static const OI_UINT8 band_values[] =     { 4, 8 };
+
+
+#define TEST_MODE_SENTINEL "OINA"
+#define TEST_MODE_SENTINEL_LENGTH 4
+
+/** Used internally. */
+typedef struct {
+    union {
+        const OI_UINT8 *r;
+        OI_UINT8 *w;
+    } ptr;
+    OI_UINT32 value;
+    OI_UINT bitPtr;
+} OI_BITSTREAM;
+
+
+#define VALID_INT16(x) (((x) >= OI_INT16_MIN) && ((x) <= OI_INT16_MAX))
+#define VALID_INT32(x) (((x) >= OI_INT32_MIN) && ((x) <= OI_INT32_MAX))
+
+#define DCTII_8_SHIFT_IN 0
+#define DCTII_8_SHIFT_OUT 16-DCTII_8_SHIFT_IN
+
+#define DCTII_8_SHIFT_0 (DCTII_8_SHIFT_OUT)
+#define DCTII_8_SHIFT_1 (DCTII_8_SHIFT_OUT)
+#define DCTII_8_SHIFT_2 (DCTII_8_SHIFT_OUT)
+#define DCTII_8_SHIFT_3 (DCTII_8_SHIFT_OUT)
+#define DCTII_8_SHIFT_4 (DCTII_8_SHIFT_OUT)
+#define DCTII_8_SHIFT_5 (DCTII_8_SHIFT_OUT)
+#define DCTII_8_SHIFT_6 (DCTII_8_SHIFT_OUT-1)
+#define DCTII_8_SHIFT_7 (DCTII_8_SHIFT_OUT-2)
+
+#define DCT_SHIFT 15
+
+#define DCTIII_4_SHIFT_IN 2
+#define DCTIII_4_SHIFT_OUT 15
+
+#define DCTIII_8_SHIFT_IN 3
+#define DCTIII_8_SHIFT_OUT 14
+
+OI_UINT computeBitneed(OI_CODEC_SBC_COMMON_CONTEXT *common,
+                              OI_UINT8 *bitneeds,
+                              OI_UINT ch,
+                              OI_UINT *preferredBitpool);
+
+void oneChannelBitAllocation(OI_CODEC_SBC_COMMON_CONTEXT *common,
+                                    BITNEED_UNION1 *bitneeds,
+                                    OI_UINT ch,
+                                    OI_UINT bitcount);
+
+
+OI_INT adjustToFitBitpool(const OI_UINT bitpool,
+                                 OI_UINT32 *bitneeds,
+                                 const OI_UINT subbands,
+                                 OI_UINT bitcount,
+                                 OI_UINT *excess);
+
+INLINE OI_INT allocAdjustedBits(OI_UINT8 *dest,
+                                OI_INT bits,
+                                OI_INT excess);
+
+INLINE OI_INT allocExcessBits(OI_UINT8 *dest,
+                              OI_INT excess);
+
+PRIVATE OI_UINT32 internal_CalculateBitrate(OI_CODEC_SBC_FRAME_INFO *frame);
+
+PRIVATE OI_UINT16 internal_CalculateFramelen(OI_CODEC_SBC_FRAME_INFO *frame);
+
+void monoBitAllocation(OI_CODEC_SBC_COMMON_CONTEXT *common);
+
+typedef void (*BIT_ALLOC)(OI_CODEC_SBC_COMMON_CONTEXT *common);
+
+PRIVATE OI_STATUS internal_DecodeRaw(OI_CODEC_SBC_DECODER_CONTEXT *context,
+                                     OI_UINT8 bitpool,
+                                     const OI_BYTE **frameData,
+                                     OI_UINT32 *frameBytes,
+                                     OI_INT16 *pcmData,
+                                     OI_UINT32 *pcmBytes);
+
+INLINE OI_STATUS internal_DecoderReset(OI_CODEC_SBC_DECODER_CONTEXT *context,
+                                       OI_UINT32 *decoderData,
+                                       OI_UINT32 decoderDataBytes,
+                                       OI_BYTE maxChannels,
+                                       OI_BYTE pcmStride,
+                                       OI_BOOL enhanced);
+
+INLINE OI_UINT16 OI_SBC_CalculateFrameAndHeaderlen(OI_CODEC_SBC_FRAME_INFO *frame, OI_UINT *headerLen_);
+
+PRIVATE OI_UINT32 OI_SBC_MaxBitpool(OI_CODEC_SBC_FRAME_INFO *frame);
+
+PRIVATE void OI_SBC_ComputeBitAllocation(OI_CODEC_SBC_COMMON_CONTEXT *frame);
+PRIVATE OI_UINT8 OI_SBC_CalculateChecksum(OI_CODEC_SBC_FRAME_INFO *frame, OI_BYTE const *data);
+
+/* Transform functions */
+PRIVATE void shift_buffer(SBC_BUFFER_T *dest, SBC_BUFFER_T *src, OI_UINT wordCount);
+PRIVATE void cosineModulateSynth4(SBC_BUFFER_T * RESTRICT out, OI_INT32 const * RESTRICT in);
+PRIVATE void SynthWindow40_int32_int32_symmetry_with_sum(OI_INT16 *pcm, SBC_BUFFER_T buffer[80], OI_UINT strideShift);
+
+INLINE void dct3_4(OI_INT32 * RESTRICT out, OI_INT32 const * RESTRICT in);
+PRIVATE void analyze4_generated(SBC_BUFFER_T analysisBuffer[RESTRICT 40],
+                                OI_INT16 *pcm,
+                                OI_UINT strideShift,
+                                OI_INT32 subband[4]);
+
+INLINE void dct3_8(OI_INT32 * RESTRICT out, OI_INT32 const * RESTRICT in);
+
+PRIVATE void analyze8_generated(SBC_BUFFER_T analysisBuffer[RESTRICT 80],
+                                OI_INT16 *pcm,
+                                OI_UINT strideShift,
+                                OI_INT32 subband[8]);
+
+#ifdef SBC_ENHANCED
+PRIVATE void analyze8_enhanced_generated(SBC_BUFFER_T analysisBuffer[RESTRICT 112],
+                                         OI_INT16 *pcm,
+                                         OI_UINT strideShift,
+                                         OI_INT32 subband[8]);
+#endif
+
+/* Decoder functions */
+
+INLINE  void OI_SBC_ReadHeader(OI_CODEC_SBC_COMMON_CONTEXT *common, const OI_BYTE *data);
+PRIVATE void OI_SBC_ReadScalefactors(OI_CODEC_SBC_COMMON_CONTEXT *common, const OI_BYTE *b, OI_BITSTREAM *bs);
+PRIVATE void OI_SBC_ReadSamples(OI_CODEC_SBC_DECODER_CONTEXT *common, OI_BITSTREAM *ob);
+PRIVATE void OI_SBC_ReadSamplesJoint(OI_CODEC_SBC_DECODER_CONTEXT *common, OI_BITSTREAM *global_bs);
+PRIVATE void OI_SBC_SynthFrame(OI_CODEC_SBC_DECODER_CONTEXT *context, OI_INT16 *pcm, OI_UINT start_block, OI_UINT nrof_blocks);
+INLINE OI_INT32 OI_SBC_Dequant(OI_UINT32 raw, OI_UINT scale_factor, OI_UINT bits);
+PRIVATE OI_BOOL OI_SBC_ExamineCommandPacket(OI_CODEC_SBC_DECODER_CONTEXT *context, const OI_BYTE *data, OI_UINT32 len);
+PRIVATE void OI_SBC_GenerateTestSignal(OI_INT16 pcmData[][2], OI_UINT32 sampleCount);
+
+PRIVATE void OI_SBC_ExpandFrameFields(OI_CODEC_SBC_FRAME_INFO *frame);
+PRIVATE OI_STATUS OI_CODEC_SBC_Alloc(OI_CODEC_SBC_COMMON_CONTEXT *common,
+                                     OI_UINT32 *codecDataAligned,
+                                     OI_UINT32 codecDataBytes,
+                                     OI_UINT8 maxChannels,
+                                     OI_UINT8 pcmStride);
+/**
+@}
+*/
+
+#endif /* _OI_CODEC_SBC_PRIVATE_H */
+
diff -Naur '--exclude=.git' bluedroid-orig/embdrv/sbc/decoder/include/oi_common.h bluedroid/embdrv/sbc/decoder/include/oi_common.h
--- bluedroid-orig/embdrv/sbc/decoder/include/oi_common.h	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/embdrv/sbc/decoder/include/oi_common.h	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,43 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2014 The Android Open Source Project
+ *  Copyright 2002 - 2004 Open Interface North America, Inc. All rights reserved.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#ifndef _OI_COMMON_H
+#define _OI_COMMON_H
+/**
+ * @file
+ *
+ * This file is used to group commonly used BLUEmagic 3.0 software
+ * header files.
+ *
+ * This file should be included in application source code along with the header
+ * files for the specific modules of the protocol stack being used.
+ */
+
+/**********************************************************************************
+  $Revision: #1 $
+***********************************************************************************/
+
+#include "oi_bt_spec.h"
+#include "oi_stddefs.h"
+#include "oi_status.h"
+#include "oi_time.h"
+#include "oi_osinterface.h"
+
+
+/*****************************************************************************/
+#endif /* _OI_COMMON_H */
diff -Naur '--exclude=.git' bluedroid-orig/embdrv/sbc/decoder/include/oi_cpu_dep.h bluedroid/embdrv/sbc/decoder/include/oi_cpu_dep.h
--- bluedroid-orig/embdrv/sbc/decoder/include/oi_cpu_dep.h	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/embdrv/sbc/decoder/include/oi_cpu_dep.h	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,505 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2014 The Android Open Source Project
+ *  Copyright 2002 - 2004 Open Interface North America, Inc. All rights reserved.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#ifndef _OI_CPU_DEP_H
+#define _OI_CPU_DEP_H
+/**
+ * @file
+ * This file contains definitions for characteristics of the target CPU and
+ * compiler, including primitive data types and endianness.
+ *
+ * This file defines the byte order and primitive data types for various
+ * CPU families. The preprocessor symbol 'CPU' must be defined to be an
+ * appropriate value or this header will generate a compile-time error.
+ *
+ * @note The documentation for this header file uses the x86 family of processors
+ * as an illustrative example for CPU/compiler-dependent data type definitions.
+ * Go to the source code of this header file to see the details of primitive type
+ * definitions for each platform.
+ *
+ * Additional information is available in the @ref data_types_docpage section.
+ */
+
+/**********************************************************************************
+  $Revision: #1 $
+***********************************************************************************/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** \addtogroup Misc Miscellaneous APIs */
+/**@{*/
+
+/** @name Definitions indicating family of target OI_CPU_TYPE
+ *  @{
+ */
+
+#define OI_CPU_X86         1 /**< x86 processor family */
+#define OI_CPU_ARM         2 /**< ARM processor family.
+                                  @deprecated Use #OI_CPU_ARM7_LEND or
+                                  #OI_CPU_ARM7_BEND. */
+#define OI_CPU_ARC         3 /**< ARC processor family.
+                                  @deprecated Use #OI_CPU_ARC_LEND or
+                                  #OI_CPU_ARC_BEND. */
+#define OI_CPU_SH3         4 /**< Hitachi SH-3 processor family */
+#define OI_CPU_H8          5 /**< Hitachi H8 processor family */
+#define OI_CPU_MIPS        6 /**< MIPS processor family */
+#define OI_CPU_SPARC       7 /**< SPARC processor family */
+#define OI_CPU_M68000      8 /**< Motorola M68000 processor family */
+#define OI_CPU_PPC         9 /**< PowerPC (PPC) processor family */
+#define OI_CPU_SH4_7750   10 /**< Hitachi SH7750 series in SH-4 processor family */
+#define OI_CPU_SH2        11 /**< Hitachi SH-2 processor family */
+#define OI_CPU_ARM7_LEND  12 /**< ARM7, little-endian */
+#define OI_CPU_ARM7_BEND  13 /**< ARM7, big-endian */
+#define OI_CPU_GDM1202    14 /**< GCT GDM1202 */
+#define OI_CPU_ARC_LEND   15 /**< ARC processor family, little-endian */
+#define OI_CPU_ARC_BEND   16 /**< ARC processor family, big-endian */
+#define OI_CPU_M30833F    17 /**< Mitsubishi M308 processor family */
+#define OI_CPU_CR16C      18 /**< National Semiconductor 16 bit processor family */
+#define OI_CPU_M64111     19 /**< Renesas M64111 processor (M32R family) */
+#define OI_CPU_ARMV5_LEND 20 //*< ARM5, little-endian */
+
+#define OI_CPU_TYPE 12
+
+#ifndef OI_CPU_TYPE
+    #error "OI_CPU_TYPE type not defined"
+#endif
+
+/**@}*/
+
+
+/** @name Definitions indicating byte-wise endianness of target CPU
+ *  @{
+ */
+
+#define OI_BIG_ENDIAN_BYTE_ORDER    0  /**< Multiple-byte values are stored in memory beginning with the most significant byte at the lowest address.  */
+#define OI_LITTLE_ENDIAN_BYTE_ORDER 1  /**< Multiple-byte values are stored in memory beginning with the least significant byte at the lowest address. */
+
+/**@}*/
+
+
+/** @name  CPU/compiler-independent primitive data type definitions
+ *  @{
+ */
+
+typedef int             OI_BOOL;  /**< Boolean values use native integer data type for target CPU. */
+typedef int             OI_INT;   /**< Integer values use native integer data type for target CPU. */
+typedef unsigned int    OI_UINT;  /**< Unsigned integer values use native unsigned integer data type for target CPU. */
+typedef unsigned char   OI_BYTE;  /**< Raw bytes type uses native character data type for target CPU. */
+
+/**@}*/
+
+
+
+/*********************************************************************************/
+
+#if OI_CPU_TYPE==OI_CPU_X86
+
+#define OI_CPU_BYTE_ORDER OI_LITTLE_ENDIAN_BYTE_ORDER  /**< x86 platform byte ordering is little-endian */
+
+/** @name CPU/compiler-dependent primitive data type definitions for x86 processor family
+ *  @{
+ */
+typedef signed char     OI_INT8;   /**< 8-bit signed integer values use native signed character data type for x86 processor. */
+typedef signed short    OI_INT16;  /**< 16-bit signed integer values use native signed short integer data type for x86 processor. */
+typedef signed long     OI_INT32;  /**< 32-bit signed integer values use native signed long integer data type for x86 processor. */
+typedef unsigned char   OI_UINT8;  /**< 8-bit unsigned integer values use native unsigned character data type for x86 processor. */
+typedef unsigned short  OI_UINT16; /**< 16-bit unsigned integer values use native unsigned short integer data type for x86 processor. */
+typedef unsigned long   OI_UINT32; /**< 32-bit unsigned integer values use native unsigned long integer data type for x86 processor. */
+
+typedef OI_UINT32 OI_ELEMENT_UNION; /**< Type for first element of a union to support all data types up to pointer width. */
+
+/**@}*/
+
+#endif
+
+/*********************************************************************************/
+
+#if OI_CPU_TYPE==OI_CPU_ARM
+/* This CPU type is deprecated (removed from use). Instead, use OI_CPU_ARM7_LEND or OI_CPU_ARM7_BEND for
+   little-endian or big-endian configurations of the ARM7, respectively. */
+#error OI_CPU_ARM is deprecated
+#endif
+
+/*********************************************************************************/
+
+#if OI_CPU_TYPE==OI_CPU_ARC
+/* This CPU type is deprecated (removed from use). Instead, use OI_CPU_ARC_LEND or OI_CPU_ARC_BEND for
+   little-endian or big-endian configurations of the ARC, respectively. */
+#error OI_CPU_ARC is deprecated
+#endif
+
+/*********************************************************************************/
+
+#if OI_CPU_TYPE==OI_CPU_SH3
+/* The Hitachi SH C compiler defines _LIT or _BIG, depending on the endianness
+    specified to the compiler on the command line. */
+#if defined(_LIT)
+    #define OI_CPU_BYTE_ORDER OI_LITTLE_ENDIAN_BYTE_ORDER  /**< If _LIT is defined, SH-3 platform byte ordering is little-endian. */
+#elif defined(_BIG)
+    #define OI_CPU_BYTE_ORDER OI_BIG_ENDIAN_BYTE_ORDER     /**< If _BIG is defined, SH-3 platform byte ordering is big-endian. */
+#else
+    #error SH compiler endianness undefined
+#endif
+
+/** @name CPU/compiler-dependent primitive data type definitions for SH-3 processor family
+ *  @{
+ */
+
+typedef signed char     OI_INT8;   /**< 8-bit signed integer values use native signed character data type for SH-3 processor. */
+typedef signed short    OI_INT16;  /**< 16-bit signed integer values use native signed short integer data type for SH-3 processor. */
+typedef signed long     OI_INT32;  /**< 32-bit signed integer values use native signed long integer data type for SH-3 processor. */
+typedef unsigned char   OI_UINT8;  /**< 8-bit unsigned integer values use native unsigned character data type for SH-3 processor. */
+typedef unsigned short  OI_UINT16; /**< 16-bit unsigned integer values use native unsigned short integer data type for SH-3 processor. */
+typedef unsigned long   OI_UINT32; /**< 32-bit unsigned integer values use native unsigned long integer data type for SH-3 processor. */
+
+typedef OI_UINT32 OI_ELEMENT_UNION; /**< Type for first element of a union to support all data types up to pointer width. */
+
+/**@}*/
+
+#endif
+/*********************************************************************************/
+
+#if OI_CPU_TYPE==OI_CPU_SH2
+
+#define OI_CPU_BYTE_ORDER OI_BIG_ENDIAN_BYTE_ORDER /**< SH-2 platform byte ordering is big-endian. */
+
+/** @name  CPU/compiler-dependent primitive data type definitions for SH-2 processor family
+ *  @{
+ */
+
+typedef signed char     OI_INT8;   /**< 8-bit signed integer values use native signed character data type for SH-2 processor. */
+typedef signed short    OI_INT16;  /**< 16-bit signed integer values use native signed short integer data type for SH-2 processor. */
+typedef signed long     OI_INT32;  /**< 32-bit signed integer values use native signed long integer data type for SH-2 processor. */
+typedef unsigned char   OI_UINT8;  /**< 8-bit unsigned integer values use native unsigned character data type for SH-2 processor. */
+typedef unsigned short  OI_UINT16; /**< 16-bit unsigned integer values use native unsigned short integer data type for SH-2 processor. */
+typedef unsigned long   OI_UINT32; /**< 32-bit unsigned integer values use native unsigned long integer data type for SH-2 processor. */
+
+typedef OI_UINT32 OI_ELEMENT_UNION; /**< Type for first element of a union to support all data types up to pointer width. */
+
+/**@}*/
+
+#endif
+/*********************************************************************************/
+
+#if OI_CPU_TYPE==OI_CPU_H8
+#define OI_CPU_BYTE_ORDER OI_BIG_ENDIAN_BYTE_ORDER
+#error basic types not defined
+#endif
+
+/*********************************************************************************/
+
+#if OI_CPU_TYPE==OI_CPU_MIPS
+#define OI_CPU_BYTE_ORDER OI_LITTLE_ENDIAN_BYTE_ORDER
+/** @name  CPU/compiler-dependent primitive data type definitions for MIPS processor family
+ *  @{
+ */
+typedef signed char     OI_INT8;   /**< 8-bit signed integer values use native signed character data type for ARM7 processor. */
+typedef signed short    OI_INT16;  /**< 16-bit signed integer values use native signed short integer data type for ARM7 processor. */
+typedef signed long     OI_INT32;  /**< 32-bit signed integer values use native signed long integer data type for ARM7 processor. */
+typedef unsigned char   OI_UINT8;  /**< 8-bit unsigned integer values use native unsigned character data type for ARM7 processor. */
+typedef unsigned short  OI_UINT16; /**< 16-bit unsigned integer values use native unsigned short integer data type for ARM7 processor. */
+typedef unsigned long   OI_UINT32; /**< 32-bit unsigned integer values use native unsigned long integer data type for ARM7 processor. */
+
+typedef OI_UINT32 OI_ELEMENT_UNION; /**< Type for first element of a union to support all data types up to pointer width. */
+
+/**@}*/
+
+#endif
+
+/*********************************************************************************/
+
+#if OI_CPU_TYPE==OI_CPU_SPARC
+#define OI_CPU_BYTE_ORDER OI_LITTLE_ENDIAN_BYTE_ORDER
+#error basic types not defined
+#endif
+
+/*********************************************************************************/
+
+#if OI_CPU_TYPE==OI_CPU_M68000
+#define OI_CPU_BYTE_ORDER OI_BIG_ENDIAN_BYTE_ORDER  /**< M68000 platform byte ordering is big-endian. */
+
+/** @name  CPU/compiler-dependent primitive data type definitions for M68000 processor family
+ *  @{
+ */
+
+typedef signed char     OI_INT8;   /**< 8-bit signed integer values use native signed character data type for M68000 processor. */
+typedef signed short    OI_INT16;  /**< 16-bit signed integer values use native signed short integer data type for M68000 processor. */
+typedef signed long     OI_INT32;  /**< 32-bit signed integer values use native signed long integer data type for M68000 processor. */
+typedef unsigned char   OI_UINT8;  /**< 8-bit unsigned integer values use native unsigned character data type for M68000 processor. */
+typedef unsigned short  OI_UINT16; /**< 16-bit unsigned integer values use native unsigned short integer data type for M68000 processor. */
+typedef unsigned long   OI_UINT32; /**< 32-bit unsigned integer values use native unsigned long integer data type for M68000 processor. */
+
+typedef OI_UINT32 OI_ELEMENT_UNION; /**< Type for first element of a union to support all data types up to pointer width. */
+
+/**@}*/
+
+#endif
+
+/*********************************************************************************/
+
+#if OI_CPU_TYPE==OI_CPU_PPC
+#define OI_CPU_BYTE_ORDER OI_BIG_ENDIAN_BYTE_ORDER
+
+
+/** @name  CPU/compiler-dependent primitive data type definitions for PPC 8XX processor family
+ *  @{
+ */
+
+typedef signed char     OI_INT8;   /**< 8-bit signed integer values use native signed character data type for PPC8XX processor. */
+typedef signed short    OI_INT16;  /**< 16-bit signed integer values use native signed short integer data type for PPC8XX processor. */
+typedef signed long     OI_INT32;  /**< 32-bit signed integer values use native signed long integer data type for PPC8XX processor. */
+typedef unsigned char   OI_UINT8;  /**< 8-bit unsigned integer values use native unsigned character data type for PPC8XX processor. */
+typedef unsigned short  OI_UINT16; /**< 16-bit unsigned integer values use native unsigned short integer data type for PPC8XX processor. */
+typedef unsigned long   OI_UINT32; /**< 32-bit unsigned integer values use native unsigned long integer data type for PPC8XX processor. */
+
+typedef OI_UINT32 OI_ELEMENT_UNION; /**< Type for first element of a union to support all data types up to pointer width. */
+
+/**@}*/
+
+#endif
+
+/*********************************************************************************/
+
+#if OI_CPU_TYPE==OI_CPU_SH4_7750
+#define OI_CPU_BYTE_ORDER OI_BIG_ENDIAN_BYTE_ORDER  /**< SH7750 platform byte ordering is big-endian. */
+
+/** @name   CPU/compiler-dependent primitive data type definitions for SH7750 processor series of the SH-4 processor family
+ *  @{
+ */
+
+typedef signed char     OI_INT8;   /**< 8-bit signed integer values use native signed character data type for SH7750 SH-4 processor. */
+typedef signed short    OI_INT16;  /**< 16-bit signed integer values use native signed short integer data type for SH7750 SH-4 processor. */
+typedef signed long     OI_INT32;  /**< 32-bit signed integer values use native signed long integer data type for SH7750 SH-4 processor. */
+typedef unsigned char   OI_UINT8;  /**< 8-bit unsigned integer values use native unsigned character data type for SH7750 SH-4 processor. */
+typedef unsigned short  OI_UINT16; /**< 16-bit unsigned integer values use native unsigned short integer data type for SH7750 SH-4 processor. */
+typedef unsigned long   OI_UINT32; /**< 32-bit unsigned integer values use native unsigned long integer data type for SH7750 SH-4 processor. */
+
+typedef OI_UINT32 OI_ELEMENT_UNION; /**< Type for first element of a union to support all data types up to pointer width. */
+
+/**@}*/
+
+#endif
+
+/*********************************************************************************/
+
+#if OI_CPU_TYPE==OI_CPU_ARM7_LEND
+#define OI_CPU_BYTE_ORDER OI_LITTLE_ENDIAN_BYTE_ORDER
+
+/** @name   little-endian CPU/compiler-dependent primitive data type definitions for the ARM7 processor family
+ *  @{
+ */
+
+typedef signed char     OI_INT8;   /**< 8-bit signed integer values use native signed character data type for ARM7 processor. */
+typedef signed short    OI_INT16;  /**< 16-bit signed integer values use native signed short integer data type for ARM7 processor. */
+typedef signed long     OI_INT32;  /**< 32-bit signed integer values use native signed long integer data type for ARM7 processor. */
+typedef unsigned char   OI_UINT8;  /**< 8-bit unsigned integer values use native unsigned character data type for ARM7 processor. */
+typedef unsigned short  OI_UINT16; /**< 16-bit unsigned integer values use native unsigned short integer data type for ARM7 processor. */
+typedef unsigned long   OI_UINT32; /**< 32-bit unsigned integer values use native unsigned long integer data type for ARM7 processor. */
+
+typedef void * OI_ELEMENT_UNION; /**< Type for first element of a union to support all data types up to pointer width. */
+
+/**@}*/
+
+#endif
+
+/*********************************************************************************/
+
+#if OI_CPU_TYPE==OI_CPU_ARM7_BEND
+#define OI_CPU_BYTE_ORDER OI_BIG_ENDIAN_BYTE_ORDER
+/** @name   big-endian CPU/compiler-dependent primitive data type definitions for the ARM7 processor family
+ *  @{
+ */
+typedef signed char     OI_INT8;   /**< 8-bit signed integer values use native signed character data type for ARM7 processor. */
+typedef signed short    OI_INT16;  /**< 16-bit signed integer values use native signed short integer data type for ARM7 processor. */
+typedef signed long     OI_INT32;  /**< 32-bit signed integer values use native signed long integer data type for ARM7 processor. */
+typedef unsigned char   OI_UINT8;  /**< 8-bit unsigned integer values use native unsigned character data type for ARM7 processor. */
+typedef unsigned short  OI_UINT16; /**< 16-bit unsigned integer values use native unsigned short integer data type for ARM7 processor. */
+typedef unsigned long   OI_UINT32; /**< 32-bit unsigned integer values use native unsigned long integer data type for ARM7 processor. */
+
+typedef void * OI_ELEMENT_UNION; /**< Type for first element of a union to support all data types up to pointer width. */
+
+/**@}*/
+
+#endif
+
+/*********************************************************************************/
+
+#if OI_CPU_TYPE==OI_CPU_GDM1202
+#define OI_CPU_BYTE_ORDER OI_BIG_ENDIAN_BYTE_ORDER
+
+typedef signed char     OI_INT8;   /**< 8-bit signed integer. */
+typedef signed short    OI_INT16;  /**< 16-bit signed integer. */
+typedef signed long     OI_INT32;  /**< 32-bit signed integer. */
+typedef unsigned char   OI_UINT8;  /**< 8-bit unsigned integer. */
+typedef unsigned short  OI_UINT16; /**< 16-bit unsigned integer. */
+typedef unsigned long   OI_UINT32; /**< 32-bit unsigned integer. */
+
+typedef OI_UINT32 OI_ELEMENT_UNION; /**< Type for first element of a union to support all data types up to pointer width. */
+
+#endif
+
+/*********************************************************************************/
+
+#if OI_CPU_TYPE==OI_CPU_ARC_LEND
+
+#define OI_CPU_BYTE_ORDER OI_LITTLE_ENDIAN_BYTE_ORDER
+
+/** @name CPU/compiler-dependent primitive data type definitions for ARC processor family
+ *  @{
+ */
+
+typedef signed char     OI_INT8;   /**< 8-bit signed integer values use native signed character data type for ARC processor. */
+typedef signed short    OI_INT16;  /**< 16-bit signed integer values use native signed short integer data type for ARC processor. */
+typedef signed long     OI_INT32;  /**< 32-bit signed integer values use native signed long integer data type for ARC processor. */
+typedef unsigned char   OI_UINT8;  /**< 8-bit unsigned integer values use native unsigned character data type for ARC processor. */
+typedef unsigned short  OI_UINT16; /**< 16-bit unsigned integer values use native unsigned short integer data type for ARC processor. */
+typedef unsigned long   OI_UINT32; /**< 32-bit unsigned integer values use native unsigned long integer data type for ARC processor. */
+
+typedef OI_UINT32 OI_ELEMENT_UNION; /**< Type for first element of a union to support all data types up to pointer width. */
+
+/**@}*/
+#endif
+
+/*********************************************************************************/
+
+#if OI_CPU_TYPE==OI_CPU_ARC_BEND
+
+#define OI_CPU_BYTE_ORDER OI_BIG_ENDIAN_BYTE_ORDER
+
+/** @name CPU/compiler-dependent primitive data type definitions for ARC processor family
+ *  @{
+ */
+
+typedef signed char     OI_INT8;   /**< 8-bit signed integer values use native signed character data type for ARC processor. */
+typedef signed short    OI_INT16;  /**< 16-bit signed integer values use native signed short integer data type for ARC processor. */
+typedef signed long     OI_INT32;  /**< 32-bit signed integer values use native signed long integer data type for ARC processor. */
+typedef unsigned char   OI_UINT8;  /**< 8-bit unsigned integer values use native unsigned character data type for ARC processor. */
+typedef unsigned short  OI_UINT16; /**< 16-bit unsigned integer values use native unsigned short integer data type for ARC processor. */
+typedef unsigned long   OI_UINT32; /**< 32-bit unsigned integer values use native unsigned long integer data type for ARC processor. */
+
+typedef OI_UINT32 OI_ELEMENT_UNION; /**< Type for first element of a union to support all data types up to pointer width. */
+
+/**@}*/
+#endif
+
+/*********************************************************************************/
+
+#if OI_CPU_TYPE==OI_CPU_M30833F
+
+#define OI_CPU_BYTE_ORDER OI_LITTLE_ENDIAN_BYTE_ORDER
+
+/** @name CPU/compiler-dependent primitive data type definitions for Mitsubishi M308 processor family
+ *  @{
+ */
+
+typedef signed char     OI_INT8;   /**< 8-bit signed integer values use native signed character data type for M308 processor. */
+typedef signed short    OI_INT16;  /**< 16-bit signed integer values use native signed short integer data type for M308 processor. */
+typedef signed long     OI_INT32;  /**< 32-bit signed integer values use native signed long integer data type for M308 processor. */
+typedef unsigned char   OI_UINT8;  /**< 8-bit unsigned integer values use native unsigned character data type for M308 processor. */
+typedef unsigned short  OI_UINT16; /**< 16-bit unsigned integer values use native unsigned short integer data type for M308 processor. */
+typedef unsigned long   OI_UINT32; /**< 32-bit unsigned integer values use native unsigned long integer data type for M308 processor. */
+
+typedef OI_UINT32 OI_ELEMENT_UNION; /**< Type for first element of a union to support all data types up to pointer width. */
+
+/**@}*/
+#endif
+
+/*********************************************************************************/
+
+#if OI_CPU_TYPE==OI_CPU_CR16C
+
+#define OI_CPU_BYTE_ORDER OI_LITTLE_ENDIAN_BYTE_ORDER
+
+/** @name CPU/compiler-dependent primitive data type definitions for National Semicnductor processor family
+ *  @{
+ */
+
+typedef signed char     OI_INT8;   /**< 8-bit signed integer values use native signed character data type for CR16C processor. */
+typedef signed short    OI_INT16;  /**< 16-bit signed integer values use native signed short integer data type for CR16C processor. */
+typedef signed long     OI_INT32;  /**< 32-bit signed integer values use native signed long integer data type for CR16C processor. */
+typedef unsigned char   OI_UINT8;  /**< 8-bit unsigned integer values use native unsigned character data type for CR16C processor. */
+typedef unsigned short  OI_UINT16; /**< 16-bit unsigned integer values use native unsigned short integer data type for CR16C processor. */
+typedef unsigned long   OI_UINT32; /**< 32-bit unsigned integer values use native unsigned long integer data type for CR16C processor. */
+
+typedef OI_UINT32 OI_ELEMENT_UNION; /**< Type for first element of a union to support all data types up to pointer width. */
+
+/**@}*/
+#endif
+
+/*********************************************************************************/
+
+#if OI_CPU_TYPE==OI_CPU_M64111
+
+#define OI_CPU_BYTE_ORDER OI_BIG_ENDIAN_BYTE_ORDER
+
+/** @name CPU/compiler-dependent primitive data type definitions for Renesas M32R processor family
+ *  @{
+ */
+
+typedef signed char     OI_INT8;   /**< 8-bit signed integer values use native signed character data type for M64111 processor. */
+typedef signed short    OI_INT16;  /**< 16-bit signed integer values use native signed short integer data type for M64111 processor. */
+typedef signed long     OI_INT32;  /**< 32-bit signed integer values use native signed long integer data type for M64111 processor. */
+typedef unsigned char   OI_UINT8;  /**< 8-bit unsigned integer values use native unsigned character data type for M64111 processor. */
+typedef unsigned short  OI_UINT16; /**< 16-bit unsigned integer values use native unsigned short integer data type for M64111 processor. */
+typedef unsigned long   OI_UINT32; /**< 32-bit unsigned integer values use native unsigned long integer data type for M64111 processor. */
+
+typedef OI_UINT32 OI_ELEMENT_UNION; /**< Type for first element of a union to support all data types up to pointer width. */
+
+/**@}*/
+#endif
+
+/*********************************************************************************/
+
+#if OI_CPU_TYPE==OI_CPU_ARMV5_LEND
+#define OI_CPU_BYTE_ORDER OI_LITTLE_ENDIAN_BYTE_ORDER
+
+/** @name   little-endian CPU/compiler-dependent primitive data type definitions for the ARM7 processor family
+ *  @{
+ */
+
+typedef signed char     OI_INT8;   /**< 8-bit signed integer values use native signed character data type for ARM7 processor. */
+typedef signed short    OI_INT16;  /**< 16-bit signed integer values use native signed short integer data type for ARM7 processor. */
+typedef signed long     OI_INT32;  /**< 32-bit signed integer values use native signed long integer data type for ARM7 processor. */
+typedef unsigned char   OI_UINT8;  /**< 8-bit unsigned integer values use native unsigned character data type for ARM7 processor. */
+typedef unsigned short  OI_UINT16; /**< 16-bit unsigned integer values use native unsigned short integer data type for ARM7 processor. */
+typedef unsigned long   OI_UINT32; /**< 32-bit unsigned integer values use native unsigned long integer data type for ARM7 processor. */
+
+typedef OI_UINT32 OI_ELEMENT_UNION; /**< Type for first element of a union to support all data types up to pointer width. */
+
+/**@}*/
+
+#endif
+
+/*********************************************************************************/
+
+
+#ifndef OI_CPU_BYTE_ORDER
+    #error "Byte order (endian-ness) not defined"
+#endif
+
+
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*********************************************************************************/
+#endif /* _OI_CPU_DEP_H */
diff -Naur '--exclude=.git' bluedroid-orig/embdrv/sbc/decoder/include/oi_modules.h bluedroid/embdrv/sbc/decoder/include/oi_modules.h
--- bluedroid-orig/embdrv/sbc/decoder/include/oi_modules.h	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/embdrv/sbc/decoder/include/oi_modules.h	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,171 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2014 The Android Open Source Project
+ *  Copyright 2002 - 2004 Open Interface North America, Inc. All rights reserved.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#ifndef _OI_MODULES_H
+#define _OI_MODULES_H
+/**
+ * @file
+ *
+ * Enumeration type defining the inidivual stack components.
+ *
+ */
+
+/**********************************************************************************
+  $Revision: #1 $
+***********************************************************************************/
+
+
+/** \addtogroup Misc Miscellaneous APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/**
+ * This enumeration lists constants for referencing the components of
+ * the BLUEmagic 3.0 protocol stack, profiles, and other functionalities.
+ *
+ * In order to distinguish types of modules, items are grouped with markers to
+ * delineate start and end of the groups
+ *
+ * The module type is used for various purposes:
+ *      identification in debug print statements
+ *      access to initialization flags
+ *      access to the configuration table
+ */
+
+typedef enum {
+    /* profiles and protocols  --> Updates to oi_debug.c and oi_config_table.c */
+
+                                /*   XX --> Keep Enum values up-to-date! */
+    OI_MODULE_AT,               /**< 00 AT command processing */
+    OI_MODULE_A2DP,             /**< 01 Advanced Audio Distribution Profile */
+    OI_MODULE_AVCTP,            /**< 02 Audio-Visual Control Transport Profile */
+    OI_MODULE_AVDTP,            /**< 03 Audio-Visual Distribution Protocol */
+    OI_MODULE_AVRCP,            /**< 04 Audio-Visual Remote Control Profile */
+    OI_MODULE_BIP_CLI,          /**< 05 Basic Imaging Profile protocol client */
+    OI_MODULE_BIP_SRV,          /**< 06 Basic Imaging Profile protocol server */
+    OI_MODULE_BNEP,             /**< 07 Bluetooth Network Encapsulation Protocol */
+    OI_MODULE_BPP_SENDER,       /**< 08 Basic Printing Profile */
+    OI_MODULE_BPP_PRINTER,      /**< 09 Basic Printing Profile */
+    OI_MODULE_CTP,              /**< 10 Cordless Telephony Profile */
+    OI_MODULE_DUN,              /**< 11 Dial-Up Networking Profile */
+    OI_MODULE_FAX,              /**< 12 Fax Profile */
+    OI_MODULE_FTP_CLI,          /**< 13 File Transfer Profile protocol client */
+    OI_MODULE_FTP_SRV,          /**< 14 File Transfer Profile protocol server */
+    OI_MODULE_HANDSFREE,        /**< 15 Hands-Free Profile */
+    OI_MODULE_HANDSFREE_AG,     /**< 16 Hands-Free Profile */
+    OI_MODULE_HCRP_CLI,         /**< 17 Hardcopy Cable Replacement Profile */
+    OI_MODULE_HCRP_SRV,         /**< 18 Hardcopy Cable Replacement Profile */
+    OI_MODULE_HEADSET,          /**< 19 Headset Profile */
+    OI_MODULE_HEADSET_AG,       /**< 20 Headset Profile */
+    OI_MODULE_HID,              /**< 21 Human Interface Device profile */
+    OI_MODULE_INTERCOM,         /**< 22 Intercom Profile */
+    OI_MODULE_OBEX_CLI,         /**< 23 OBEX protocol client, Generic Object Exchange Profile */
+    OI_MODULE_OBEX_SRV,         /**< 24 OBEX protocol server, Generic Object Exchange Profile */
+    OI_MODULE_OPP_CLI,          /**< 25 Object Push Profile protocol client */
+    OI_MODULE_OPP_SRV,          /**< 26 Object Push Profile protocol server */
+    OI_MODULE_PAN,              /**< 27 PAN profile */
+    OI_MODULE_PBAP_CLI,         /**< 28 Phonebook Access Profile client */
+    OI_MODULE_PBAP_SRV,         /**< 29 Phonebook Access Profile server */
+    OI_MODULE_SAP_CLI,          /**< 30 SIM Access Profile */
+    OI_MODULE_SAP_SRV,          /**< 31 SIM Access Profile */
+    OI_MODULE_SPP,              /**< 32 Serial Port Profile */
+    OI_MODULE_SYNC_CLI,         /**< 33 Synchronization Profile */
+    OI_MODULE_SYNC_SRV,         /**< 34 Synchronization Profile */
+    OI_MODULE_SYNC_CMD_CLI,     /**< 35 Synchronization Profile */
+    OI_MODULE_SYNC_CMD_SRV,     /**< 36 Synchronization Profile */
+    OI_MODULE_SYNCML,           /**< 37 SyncML Profile */
+    OI_MODULE_TCS,              /**< 38 TCS Binary */
+    OI_MODULE_VDP,              /**< 39 Video Distribution Profile */
+
+    /* corestack components   --> Updates to oi_debug.c and oi_config_table.c */
+
+    OI_MODULE_COMMON_CONFIG,    /**< 40 Common configuration, module has no meaning other than for config struct */
+    OI_MODULE_CMDCHAIN,         /**< 41 Command chaining utility */
+    OI_MODULE_DISPATCH,         /**< 42 Dispatcher */
+    OI_MODULE_DATAELEM,         /**< 43 Data Elements, marshaller */
+    OI_MODULE_DEVMGR,           /**< 44 Device Manager */
+    OI_MODULE_DEVMGR_MODES,     /**< 45 Device Manager connectability/discoverability modes */
+    OI_MODULE_HCI,              /**< 46 Host Controller Interface command layer */
+    OI_MODULE_L2CAP,            /**< 47 L2CAP */
+    OI_MODULE_MEMMGR,           /**< 48 modules that do memory management */
+    OI_MODULE_POLICYMGR,        /**< 49 Policy Manager */
+    OI_MODULE_RFCOMM,           /**< 50 RFCOMM */
+    OI_MODULE_RFCOMM_SD,        /**< 51 RFCOMM Service discovery */
+    OI_MODULE_SDP_CLI,          /**< 52 Service Discovery Protocol client */
+    OI_MODULE_SDP_SRV,          /**< 53 Service Discovery Protocol server */
+    OI_MODULE_SDPDB,            /**< 54 Service Discovery Protocol database */
+    OI_MODULE_SECMGR,           /**< 55 Security Manager */
+    OI_MODULE_SNIFFLOG,         /**< 56 sniff log */
+    OI_MODULE_SUPPORT,          /**< 57 support functions, including CThru Dispatcher, time functions, and stack initialization */
+    OI_MODULE_TRANSPORT,        /**< 58 transport layer between HCI command layer and driver */
+    OI_MODULE_TEST,             /**< 59 used to debug output from internal test programs */
+    OI_MODULE_XML,              /**< 60 XML/CSS parser */
+
+    OI_MODULE_DI,               /**< 61 Device Identification Profile */
+
+    // bhapi components  --> Updates to oi_debug.c
+
+    OI_MODULE_BHAPI,            /**< 62 BLUEmagic Host API generic */
+    OI_MODULE_BHCLI,            /**< 63 BLUEmagic Host API client side */
+    OI_MODULE_BHSRV,            /**< 64 BLUEmagic Host API server side */
+    OI_MODULE_MSGQ,             /**< 65 module that handles message queuing */
+    OI_MODULE_BHAPI_TRANSPORT,  /**< 66 module that handles message queuing */
+    OI_MODULE_BLST_SRV,         /**< 67 module that provides server side BHAPI Lightweight Serial Transport */
+    OI_MODULE_BLST_CLI,         /**< 68 module that provides client side BHAPI Lightweight Serial Transport */
+
+    // OEM files --> Updates to oi_debug.c
+    OI_MODULE_OEM,              /**< 69 Application Memory allocation */
+
+    // Application glue --> Updates to oi_debug.c
+    OI_MODULE_APP,              /**< 70 Application Memory allocation */
+
+    /* various pieces of code depend on these last 2 elements occuring in a specific order:
+       OI_MODULE_ALL must be the 2nd to last element
+       OI_MODULE_UNKNOWN must be the last element
+       */
+    OI_MODULE_ALL,              /**< 71 special value identifying all modules - used for control of debug print statements */
+    OI_MODULE_UNKNOWN           /**< 72 special value - used for debug print statements */
+} OI_MODULE;
+
+/**
+ * This constant is the number of actual modules in the list.  ALL and UNKNOWN are
+ * special values that are not actually modules.
+ * Used for debug print and memmgr profiling
+ */
+#define OI_NUM_MODULES  OI_MODULE_ALL
+
+
+/**
+ * This constant is the number of profile and core components.  It is used to size
+ * the initialization and configuration tables.
+ */
+#define OI_NUM_STACK_MODULES    OI_MODULE_BHAPI
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_MODULES_H */
+
diff -Naur '--exclude=.git' bluedroid-orig/embdrv/sbc/decoder/include/oi_osinterface.h bluedroid/embdrv/sbc/decoder/include/oi_osinterface.h
--- bluedroid-orig/embdrv/sbc/decoder/include/oi_osinterface.h	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/embdrv/sbc/decoder/include/oi_osinterface.h	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,197 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2014 The Android Open Source Project
+ *  Copyright 2002 - 2004 Open Interface North America, Inc. All rights reserved.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#ifndef _OI_OSINTERFACE_H
+#define _OI_OSINTERFACE_H
+/**
+ @file
+ * This file provides the platform-independent interface for functions for which
+ * implementation is platform-specific.
+ *
+ * The functions in this header file define the operating system or hardware
+ * services needed by the BLUEmagic 3.0 protocol stack. The
+ * actual implementation of these services is platform-dependent.
+ *
+ */
+
+/**********************************************************************************
+  $Revision: #1 $
+***********************************************************************************/
+
+#include "oi_stddefs.h"
+#include "oi_time.h"
+#include "oi_status.h"
+#include "oi_modules.h"
+
+/** \addtogroup Misc Miscellaneous APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/**
+ * Terminates execution.
+ *
+ * @param reason  Reason for termination
+ */
+void OI_FatalError(OI_STATUS reason);
+
+/**
+ * This function logs an error.
+ *
+ * When built for release mode, BLUEmagic 3 errors are logged to
+ * this function. (in debug mode, errors are logged via
+ * OI_Print()).
+ *
+ * @param module Module in which the error was detected (see
+ *                oi_modules.h)
+ * @param lineno Line number of the C file OI_SLOG_ERROR called
+ * @param status Status code associated with the error event
+ */
+void OI_LogError(OI_MODULE module, OI_INT lineno, OI_STATUS status);
+
+/**
+ * This function initializes the debug code handling.
+ *
+ * When built for debug mode, this function performs platform
+ * dependent initialization to handle message codes passed in
+ * via OI_SetMsgCode().
+ */
+void OI_InitDebugCodeHandler(void);
+
+
+/**
+ * This function reads the time from the real time clock.
+ *
+ * All timing in BM3 is relative, typically a granularity
+ * of 5 or 10 msecs is adequate.
+ *
+ * @param[out] now  Pointer to the buffer to which the current
+ *       time will be returned
+ */
+void OI_Time_Now(OI_TIME *now);
+
+/**
+ * This function causes the current thread to sleep for the
+ * specified amount of time. This function must be called
+ * without the stack access token.
+ *
+ * @note BM3 corestack and profiles never suspend and never call
+ * OI_Sleep. The use of OI_Sleep is limited to applications and
+ * platform-specific code.
+ *
+ * If your port and applications never use OI_Sleep, this function can be left unimplemented.
+ *
+ * @param milliseconds  Number of milliseconds to sleep
+ */
+void OI_Sleep(OI_UINT32 milliseconds);
+
+
+/**
+ * Defines for message type codes.
+ */
+#define OI_MSG_CODE_APPLICATION               0   /**< Application output */
+#define OI_MSG_CODE_ERROR                     1   /**< Error message output */
+#define OI_MSG_CODE_WARNING                   2   /**< Warning message output */
+#define OI_MSG_CODE_TRACE                     3   /**< User API function trace output */
+#define OI_MSG_CODE_PRINT1                    4   /**< Catagory 1 debug print output */
+#define OI_MSG_CODE_PRINT2                    5   /**< Catagory 2 debug print output */
+#define OI_MSG_CODE_HEADER                    6   /**< Error/Debug output header */
+
+/**
+ * This function is used to indicate the type of text being output with
+ * OI_Print(). For the Linux and Win32 platforms, it will set
+ * the color of the text. Other possible uses could be to insert
+ * HTML style tags, add some other message type indication, or
+ * be completely ignored altogether.
+ *
+ * @param code  OI_MSG_CODE_* indicating setting the message type.
+ */
+void OI_SetMsgCode(OI_UINT8 code);
+
+/**
+ * All output from OI_Printf() and all debug output is sent to OI_Print.
+ * Typically, if the platform has a console, OI_Print() is sent to stdout.
+ * Embedded platforms typically send OI_Print() output to a serial port.
+ *
+ * @param str  String to print
+ */
+void OI_Print(OI_CHAR const *str);
+
+/**
+ *  In cases where OI_Print() is sending output to a logfile in addition to console,
+ *  it is desirable to also put console input into the logfile.
+ *  This function can be called by the console input process.
+ *
+ *  @note This is an optional API which is strictly
+ *  between the platform-specific stack_console and osinterface
+ *  modules. This API need only be implemented on those
+ *  platforms where is serves a useful purpose, e.g., win32.
+ *
+ * @param str  Console input string
+ */
+
+void OI_Print_ConsoleInput(OI_CHAR const *str);
+
+/**
+ *  This function computes the CRC16 of the program image.
+ */
+OI_UINT16  OI_ProgramImageCRC16(void);
+
+/**
+ * Writes an integer to stdout in hex. This macro is intended
+ * for selective use when debugging in small memory
+ * configurations or other times when it is not possible to use
+ * OI_DBGPRINT.
+ *
+ * @param n  the integer to print
+ */
+
+#define OI_Print_Int(n) \
+{ \
+    static const OI_CHAR _digits[] = "0123456789ABCDEF"; \
+    OI_CHAR _buf[9]; \
+    OI_CHAR *_str = &_buf[8]; \
+    OI_UINT32 _i = n; \
+    *_str = 0; \
+    do { *(--_str) = _digits[(_i & 0xF)]; _i >>= 4; } while (_i); \
+    OI_Print(_str); \
+}
+
+/**
+ *  Application Dynamic Memory allocation.
+ *
+ *  These APIs are provided for application use on those
+ *  platforms which have no dynamic memory support. Memory is
+ *  allocated from the pool-based heap managed by the stack's
+ *  internal memory manager.
+ */
+void *OI_APP_Malloc(OI_INT32 size);
+void OI_APP_Free(void *ptr);
+
+/*****************************************************************************/
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_OSINTERFACE_H */
+
diff -Naur '--exclude=.git' bluedroid-orig/embdrv/sbc/decoder/include/oi_status.h bluedroid/embdrv/sbc/decoder/include/oi_status.h
--- bluedroid-orig/embdrv/sbc/decoder/include/oi_status.h	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/embdrv/sbc/decoder/include/oi_status.h	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,579 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2014 The Android Open Source Project
+ *  Copyright 2002 - 2004 Open Interface North America, Inc. All rights reserved.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#ifndef _OI_STATUS_H
+#define _OI_STATUS_H
+/**
+ * @file
+ * This file contains status codes for BLUEmagic 3.0 software.
+ */
+
+#include "oi_stddefs.h"
+
+/** \addtogroup Misc Miscellaneous APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+   /** test it **/
+
+/**
+ * OI_STATUS must fit in 16 bits, so status codes can range from 0 to 66535, inclusive.
+ */
+
+typedef enum {
+    OI_STATUS_SUCCESS                      = 0,   /**< function call succeeded alias for #OI_OK */
+    OI_OK                                  = 0,   /**< function call succeeded alias for #OI_STATUS_SUCCESS */
+    OI_STATUS_INVALID_PARAMETERS           = 101, /**< invalid function input parameters */
+    OI_STATUS_NOT_IMPLEMENTED              = 102, /**< attempt to use an unimplemented function */
+    OI_STATUS_NOT_INITIALIZED              = 103, /**< data not initialized */
+    OI_STATUS_NO_RESOURCES                 = 104, /**< generic resource allocation failure status */
+    OI_STATUS_INTERNAL_ERROR               = 105, /**< internal inconsistency */
+    OI_STATUS_OUT_OF_MEMORY                = 106, /**< generally, OI_Malloc failed */
+    OI_ILLEGAL_REENTRANT_CALL              = 107, /**< violation of non-reentrant module policy */
+    OI_STATUS_INITIALIZATION_FAILED        = 108, /**< module initialization failed */
+    OI_STATUS_INITIALIZATION_PENDING       = 109, /**< inititialization not yet complete */
+    OI_STATUS_NO_SCO_SUPPORT               = 110, /**< SCO operation rejected; system not configured for SCO */
+    OI_STATUS_OUT_OF_STATIC_MEMORY         = 111, /**< static malloc failed */
+    OI_TIMEOUT                             = 112, /**< generic timeout */
+    OI_OS_ERROR                            = 113, /**< some operating system error */
+    OI_FAIL                                = 114, /**< generic failure */
+    OI_STRING_FORMAT_ERROR                 = 115, /**< error in VarString formatting string */
+    OI_STATUS_PENDING                      = 116, /**< The operation is pending. */
+    OI_STATUS_INVALID_COMMAND              = 117, /**< The command was invalid. */
+    OI_BUSY_FAIL                           = 118, /**< command rejected due to busy */
+    OI_STATUS_ALREADY_REGISTERED           = 119, /**< The registration has already been performed. */
+    OI_STATUS_NOT_FOUND                    = 120, /**< The referenced resource was not found. */
+    OI_STATUS_NOT_REGISTERED               = 121, /**< not registered */
+    OI_STATUS_NOT_CONNECTED                = 122, /**< not connected */
+    OI_CALLBACK_FUNCTION_REQUIRED          = 123, /**< A callback function parameter was required. */
+    OI_STATUS_MBUF_OVERFLOW                = 124, /**< There is no room to add another buffer to an mbuf. */
+    OI_STATUS_MBUF_UNDERFLOW               = 125, /**< There was an attempt to pull too many bytes from an mbuf. */
+    OI_STATUS_CONNECTION_EXISTS            = 126, /**< connection exists */
+    OI_STATUS_NOT_CONFIGURED               = 127, /**< module not configured */
+    OI_LOWER_STACK_ERROR                   = 128, /**< An error was reported by lower stack API. This is used for embedded platforms. */
+    OI_STATUS_RESET_IN_PROGRESS            = 129, /**< Request failed/rejected because we're busy resetting. */
+    OI_STATUS_ACCESS_DENIED                = 130, /**< Generic access denied error. */
+    OI_STATUS_DATA_ERROR                   = 131, /**< Generic data error. */
+    OI_STATUS_INVALID_ROLE                 = 132, /**< The requested role was invalid. */
+    OI_STATUS_ALREADY_CONNECTED            = 133, /**< The requested connection is already established. */
+    OI_STATUS_PARSE_ERROR                  = 134, /**< Parse error */
+    OI_STATUS_END_OF_FILE                  = 135, /**< End of file */
+    OI_STATUS_READ_ERROR                   = 136, /**< Generic read error */
+    OI_STATUS_WRITE_ERROR                  = 137, /**< Generic write error */
+    OI_STATUS_NEGOTIATION_FAILURE          = 138, /**< Error in negotiation */
+    OI_STATUS_READ_IN_PROGRESS             = 139, /**< A read is already in progress */
+    OI_STATUS_ALREADY_INITIALIZED          = 140, /**< Initialization has already been done */
+    OI_STATUS_STILL_CONNECTED              = 141, /**< The service cannot be shutdown because there are still active connections. */
+    OI_STATUS_MTU_EXCEEDED                 = 142, /**< The packet is too big */
+    OI_STATUS_LINK_TERMINATED              = 143, /**< The link was terminated */
+    OI_STATUS_PIN_CODE_TOO_LONG            = 144, /**< Application gave us a pin code that is too long */
+    OI_STATUS_STILL_REGISTERED             = 145, /**< The service cannot be shutdown because there are still active registrations. */
+    OI_STATUS_SPEC_VIOLATION               = 146, /**< Some application behavior contrary to BT specifications */
+
+
+    OI_STATUS_PSM_ALREADY_REGISTERED       = 402, /**< L2CAP: The specified PSM has already been registered. */
+    OI_STATUS_INVALID_CID                  = 403, /**< L2CAP: CID is invalid or no longer valid (connection terminated) */
+    OI_STATUS_CID_NOT_FOUND                = 404, /**< L2CAP: CID does not represent a current connection */
+    OI_STATUS_CHANNEL_NOT_FOUND            = 406, /**< L2CAP: CID does not represent a current connection */
+    OI_STATUS_PSM_NOT_FOUND                = 407, /**< L2CAP: PSM not found */
+    OI_STATUS_INVALID_STATE                = 408, /**< L2CAP: invalid state */
+    OI_STATUS_WRITE_IN_PROGRESS            = 410, /**< L2CAP: write in progress */
+    OI_STATUS_INVALID_PACKET               = 411, /**< L2CAP: invalid packet */
+    OI_STATUS_SEND_COMPLETE                = 412, /**< L2CAP: send is complete */
+    OI_STATUS_INVALID_HANDLE               = 414, /**< L2CAP: handle is invalid */
+    OI_STATUS_GROUP_FULL                   = 418, /**< L2CAP: No more members can be added to the specified group. */
+    OI_STATUS_DEVICE_ALREADY_IN_GROUP      = 423, /**< L2CAP: The device already exists in the group. */
+    OI_STATUS_DUPLICATE_GROUP              = 425, /**< L2CAP: attempt to add more than one group */
+    OI_STATUS_EMPTY_GROUP                  = 426, /**< L2CAP: group is empty */
+    OI_STATUS_PACKET_NOT_FOUND             = 427, /**< L2CAP: packet not found */
+    OI_STATUS_BUFFER_TOO_SMALL             = 428, /**< L2CAP: The buffer size is too small. */
+    OI_STATUS_IDENTIFIER_NOT_FOUND         = 429, /**< L2CAP: identifier not found */
+
+    OI_L2CAP_DISCONNECT_LOWER_LAYER        = 430, /**< L2CAP: The lower level forced a disconnect. */
+    OI_L2CAP_DISCONNECT_REMOTE_REQUEST     = 431, /**< L2CAP: The remote device requested a disconnect. */
+    OI_L2CAP_GROUP_ADD_CONNECT_FAIL        = 433, /**< L2CAP: Group add connect faiL */
+    OI_L2CAP_GROUP_REMOVE_FAILURE          = 434, /**< L2CAP: Group remove failure */
+    OI_L2CAP_DATA_WRITE_ERROR_LINK_TERM    = 435, /**< L2CAP: Data write error LINK_TERM */
+    OI_L2CAP_DISCONNECT_LOCAL_REQUEST      = 436, /**< L2CAP: Disconnect local request */
+
+    OI_L2CAP_CONNECT_TIMEOUT               = 437, /**< L2CAP: Connect timeout */
+    OI_L2CAP_DISCONNECT_TIMEOUT            = 439, /**< L2CAP: Disconnect timeout */
+    OI_L2CAP_PING_TIMEOUT                  = 440, /**< L2CAP: Ping timeout */
+    OI_L2CAP_GET_INFO_TIMEOUT              = 441, /**< L2CAP: Get info timeout */
+    OI_L2CAP_INVALID_ADDRESS               = 444, /**< L2CAP: Invalid address */
+    OI_L2CAP_CMD_REJECT_RCVD               = 445, /**< L2CAP: remote sent us 'command reject' response */
+
+    OI_L2CAP_CONNECT_BASE                  = 450, /**< L2CAP: Connect base */
+    OI_L2CAP_CONNECT_PENDING               = 451, /**< L2CAP: Connect pending */
+    OI_L2CAP_CONNECT_REFUSED_INVALID_PSM   = 452, /**< L2CAP: Connect refused invalid PSM */
+    OI_L2CAP_CONNECT_REFUSED_SECURITY      = 453, /**< L2CAP: Connect refused security */
+    OI_L2CAP_CONNECT_REFUSED_NO_RESOURCES  = 454, /**< L2CAP: Connect refused no resources */
+
+    OI_L2CAP_CONFIG_BASE                   = 460, /**< L2CAP: Config base */
+    OI_L2CAP_CONFIG_FAIL_INVALID_PARAMETERS= 461, /**< L2CAP: Config fail invalid parameters */
+    OI_L2CAP_CONFIG_FAIL_NO_REASON         = 462, /**< L2CAP: Config fail no reason */
+    OI_L2CAP_CONFIG_FAIL_UNKNOWN_OPTIONS   = 463, /**< L2CAP: Config fail unknown options */
+
+    OI_L2CAP_GET_INFO_BASE                 = 470, /**< L2CAP: Get info base */
+    OI_L2CAP_GET_INFO_NOT_SUPPORTED        = 471, /**< L2CAP: Get info not supported */
+    OI_L2CAP_MTU_EXCEEDED                  = 472, /**< L2CAP: The MTU of the channel was exceeded */
+    OI_L2CAP_INVALID_PSM                   = 482, /**< L2CAP: Invalid PSM */
+    OI_L2CAP_INVALID_MTU                   = 483, /**< L2CAP: Invalid MTU */
+    OI_L2CAP_INVALID_FLUSHTO               = 484, /**< L2CAP: Invalid flush timeout */
+
+    OI_HCI_NO_SUCH_CONNECTION               = 601, /**< HCI: caller specified a non-existent connection handle */
+    OI_HCI_CB_LIST_FULL                     = 603, /**< HCI: callback list is full, cannot attempt to send command */
+    OI_HCI_EVENT_UNDERRUN                   = 605, /**< HCI: parsing event packet, premature end-of-parameters */
+    OI_HCI_UNKNOWN_EVENT_CODE               = 607, /**< HCI: event received - event code is unknown */
+    OI_HCI_BAD_EVENT_PARM_LEN               = 608, /**< HCI: event - parameter length is incorrect */
+    OI_HCI_CMD_QUEUE_FULL                   = 611, /**< HCI: command queue is full */
+    OI_HCI_SHORT_EVENT                      = 612, /**< HCI: event received, missing event code and/or parm len */
+    OI_HCI_TRANSMIT_NOT_READY               = 613, /**< HCI: ACL/SCO transmit request failed - busy or no buffers available */
+    OI_HCI_ORPHAN_SENT_EVENT                = 614, /**< HCI: got spurious 'sent' event from transport layer */
+    OI_HCI_CMD_TABLE_ERROR                  = 615, /**< HCI: inconsistency in the internal command table */
+    OI_HCI_UNKNOWN_CMD_ID                   = 616, /**< HCI: HciApi Command - unknown command id */
+    OI_HCI_UNEXPECTED_EVENT                 = 619, /**< HCI: event received which only occurs in response to our cmd */
+    OI_HCI_EVENT_TABLE_ERROR                = 620, /**< HCI: inconsistency in the internal event table */
+    OI_HCI_EXPECTED_EVENT_TIMOUT            = 621, /**< HCI: timed out waiting for an expected event */
+    OI_HCI_NO_CMD_DESC_FOR_OPCODE           = 622, /**< HCI: event opcode is not known */
+    OI_HCI_INVALID_OPCODE_ERROR             = 623, /**< HCI: command opcode is invalid */
+    OI_HCI_FLOW_CONTROL_DISABLED            = 624, /**< HCI: can not use host flow control APIs if disabled in configuration */
+    OI_HCI_TX_COMPLETE                      = 625, /**< HCI: packet delivery to Host Controler complete */
+    OI_HCI_TX_ERROR                         = 626, /**< HCI: failed to deliver packet to Host Controler */
+    OI_HCI_DEVICE_NOT_INITIALIZED           = 627, /**< HCI: commands from upper layers disallowed until device is up and running */
+    OI_HCI_UNSUPPORTED_COMMAND              = 628, /**< HCI: command requested is not supported by local device */
+    OI_HCI_PASSTHROUGH_ERROR                = 629, /**< HCI: Error processing passthrough command */
+    OI_HCI_PASSTHROUGH_ALREADY_SET          = 630, /**< HCI: Passthrough mode already enabled */
+    OI_HCI_RESET_FAILURE                    = 631, /**< HCI: failed to reset the device/baseband */
+    OI_HCI_TRANSPORT_RESET                  = 632, /**< HCI: some operation failed because of a reset in the transport */
+    OI_HCIERR_HCIIFC_INIT_FAILURE           = 633, /**< HCI: failed to initialize transport layer interface */
+
+    OI_HCIERR_FIRST_ERROR_VALUE                = 701, /**< marker for first HCI protocol error */
+    OI_HCIERR_UNKNOWN_HCI_COMMAND              = 701, /**< HCI: protocol error 0x01 */
+    OI_HCIERR_NO_CONNECTION                    = 702, /**< HCI: protocol error 0x02 */
+    OI_HCIERR_HARDWARE_FAILURE                 = 703, /**< HCI: protocol error 0x03 */
+    OI_HCIERR_PAGE_TIMEOUT                     = 704, /**< HCI: protocol error 0x04 */
+    OI_HCIERR_AUTHENTICATION_FAILURE           = 705, /**< HCI: protocol error 0x05 */
+    OI_HCIERR_KEY_MISSING                      = 706, /**< HCI: protocol error 0x06 */
+    OI_HCIERR_MEMORY_FULL                      = 707, /**< HCI: protocol error 0x07 */
+    OI_HCIERR_CONNECTION_TIMEOUT               = 708, /**< HCI: protocol error 0x08 */
+    OI_HCIERR_MAX_NUM_OF_CONNECTIONS           = 709, /**< HCI: protocol error 0x09 */
+    OI_HCIERR_MAX_NUM_OF_SCO_CONNECTIONS       = 710, /**< HCI: protocol error 0x0A */
+    OI_HCIERR_ACL_CONNECTION_ALREADY_EXISTS    = 711, /**< HCI: protocol error 0x0B */
+    OI_HCIERR_COMMAND_DISALLOWED               = 712, /**< HCI: protocol error 0x0C */
+    OI_HCIERR_HOST_REJECTED_RESOURCES          = 713, /**< HCI: protocol error 0x0D */
+    OI_HCIERR_HOST_REJECTED_SECURITY           = 714, /**< HCI: protocol error 0x0E */
+    OI_HCIERR_HOST_REJECTED_PERSONAL_DEVICE    = 715, /**< HCI: protocol error 0x0F */
+    OI_HCIERR_HOST_TIMEOUT                     = 716, /**< HCI: protocol error 0x10 */
+    OI_HCIERR_UNSUPPORTED                      = 717, /**< HCI: protocol error 0x11 */
+    OI_HCIERR_INVALID_PARAMETERS               = 718, /**< HCI: protocol error 0x12 */
+    OI_HCIERR_OTHER_END_USER_DISCONNECT        = 719, /**< HCI: protocol error 0x13 */
+    OI_HCIERR_OTHER_END_LOW_RESOURCES          = 720, /**< HCI: protocol error 0x14 */
+    OI_HCIERR_OTHER_END_POWERING_OFF           = 721, /**< HCI: protocol error 0x15 */
+    OI_HCIERR_CONNECTION_TERMINATED_LOCALLY    = 722, /**< HCI: protocol error 0x16 */
+    OI_HCIERR_REPEATED_ATTEMPTS                = 723, /**< HCI: protocol error 0x17 */
+    OI_HCIERR_PAIRING_NOT_ALLOWED              = 724, /**< HCI: protocol error 0x18 */
+    OI_HCIERR_UNKNOWN_LMP_PDU                  = 725, /**< HCI: protocol error 0x19 */
+    OI_HCIERR_UNSUPPORTED_REMOTE_FEATURE       = 726, /**< HCI: protocol error 0x1A */
+    OI_HCIERR_SCO_OFFSET_REJECTED              = 727, /**< HCI: protocol error 0x1B */
+    OI_HCIERR_SCO_INTERVAL_REJECTED            = 728, /**< HCI: protocol error 0x1C */
+    OI_HCIERR_SCO_AIR_MODE_REJECTED            = 729, /**< HCI: protocol error 0x1D */
+    OI_HCIERR_INVALID_LMP_PARMS                = 730, /**< HCI: protocol error 0x1E */
+    OI_HCIERR_UNSPECIFIED_ERROR                = 731, /**< HCI: protocol error 0x1F */
+    OI_HCIERR_UNSUPPORTED_LMP_PARAMETERS       = 732, /**< HCI: protocol error 0x20 */
+    OI_HCIERR_ROLE_CHANGE_NOT_ALLOWED          = 733, /**< HCI: protocol error 0x21 */
+    OI_HCIERR_LMP_RESPONSE_TIMEOUT             = 734, /**< HCI: protocol error 0x22 */
+    OI_HCIERR_LMP_ERROR_TRANS_COLLISION        = 735, /**< HCI: protocol error 0x23 */
+    OI_HCIERR_LMP_PDU_NOT_ALLOWED              = 736, /**< HCI: protocol error 0x24 */
+    OI_HCIERR_ENCRYPTION_MODE_NOT_ACCEPTABLE   = 737, /**< HCI: protocol error 0x25 */
+    OI_HCIERR_UNIT_KEY_USED                    = 738, /**< HCI: protocol error 0x26 */
+    OI_HCIERR_QOS_NOT_SUPPORTED                = 739, /**< HCI: protocol error 0x27 */
+    OI_HCIERR_INSTANT_PASSED                   = 740, /**< HCI: protocol error 0x28 */
+    OI_HCIERR_UNIT_KEY_PAIRING_UNSUPPORTED     = 741, /**< HCI: protocol error 0x29 */
+    OI_HCIERR_DIFFERENT_TRANS_COLLISION        = 742, /**< HCI: protocol error 0x2A */
+    OI_HCIERR_RESERVED_2B                      = 743, /**< HCI: protocol error 0x2B */
+    OI_HCIERR_QOS_UNACCEPTABLE_PARAMETER       = 744, /**< HCI: protocol error 0x2C */
+    OI_HCIERR_QOS_REJECTED                     = 745, /**< HCI: protocol error 0x2D */
+    OI_HCIERR_CHANNEL_CLASSIFICATION_NS        = 746, /**< HCI: protocol error 0x2E */
+    OI_HCIERR_INSUFFICIENT_SECURITY            = 747, /**< HCI: protocol error 0x2F */
+    OI_HCIERR_PARM_OUT_OF_MANDATORY_RANGE      = 748, /**< HCI: protocol error 0x30 */
+    OI_HCIERR_RESERVED_31                      = 749, /**< HCI: protocol error 0x31 */
+    OI_HCIERR_ROLE_SWITCH_PENDING              = 750, /**< HCI: protocol error 0x32 */
+    OI_HCIERR_RESERVED_33                      = 751, /**< HCI: protocol error 0x33 */
+    OI_HCIERR_RESERVED_SLOT_VIOLATION          = 752, /**< HCI: protocol error 0x34 */
+    OI_HCIERR_ROLE_SWITCH_FAILED               = 753, /**< HCI: protocol error 0x35 */
+    OI_HCIERR_EIR_TOO_LARGE                    = 754, /**< HCI: protocol error 0x36 */
+    OI_HCIERR_SSP_NOT_SUPPORTED_BY_HOST        = 755, /**< HCI: protocol error 0x37 */
+    OI_HCIERR_HOST_BUSY_PAIRING                = 756, /**< HCI: protocol error 0x38 */
+
+    OI_HCIERR_UNKNOWN_ERROR                    = 757, /**< HCI: unknown error code */
+    OI_HCIERR_LAST_ERROR_VALUE                 = 757, /**< marker for last HCI protocol error */
+
+    OI_SDP_SPEC_ERROR                    = 800, /**< SDP: Base error status for mapping OI_STATUS codes to SDP errors */
+    OI_SDP_INVALID_SERVICE_RECORD_HANDLE = (OI_SDP_SPEC_ERROR + 2), /**< SDP: protocol error Invalid Service Record Handle */
+    OI_SDP_INVALID_REQUEST_SYNTAX        = (OI_SDP_SPEC_ERROR + 3), /**< SDP: protocol error Invalid Request Syntax */
+    OI_SDP_INVALID_PDU_SIZE              = (OI_SDP_SPEC_ERROR + 4), /**< SDP: protocol error Invalid PDU Size */
+    OI_SDP_INVALID_CONTINUATION_STATE    = (OI_SDP_SPEC_ERROR + 5), /**< SDP: protocol error Invalid Continuation State */
+    OI_SDP_INSUFFICIENT_RESOURCES        = (OI_SDP_SPEC_ERROR + 6), /**< SDP: protocol error Insufficient Resources */
+    OI_SDP_ERROR                         = 807, /**< SDP: server returned an error code */
+    OI_SDP_CORRUPT_DATA_ELEMENT          = 808, /**< SDP: Invalid or corrupt data element representation */
+    OI_SDP_SERVER_NOT_CONNECTED          = 810, /**< SDP: Attempt to disconnect from an unconnected server */
+    OI_SDP_ACCESS_DENIED                 = 811, /**< SDP: Server denied access to server */
+    OI_SDP_ATTRIBUTES_OUT_OF_ORDER       = 812, /**< SDP: Attributes in attribute list not in ascending order */
+    OI_SDP_DEVICE_DOES_NOT_SUPPORT_SDP   = 813, /**< SDP: Tried to connect to a device that does not support SDP */
+    OI_SDP_NO_MORE_DATA                  = 815, /**< SDP: Server does not have more continuation data */
+    OI_SDP_REQUEST_PARAMS_TOO_LONG       = 816, /**< SDP: Parameters for a request exceed the L2CAP buffer size */
+    OI_SDP_REQUEST_PENDING               = 817, /**< SDP: Cannot make a request when another request is being processed */
+    OI_SDP_SERVER_CONNECT_FAILED         = 819, /**< SDP: Failed attempt to connect to an SDP server */
+    OI_SDP_SERVER_TOO_MANY_CONNECTIONS   = 821, /**< SDP: Exceeded maximum number of simultaneous server connections */
+    OI_SDP_NO_MATCHING_SERVICE_RECORD    = 823, /**< SDP: No service record matched the UUID list */
+    OI_SDP_PARTIAL_RESPONSE              = 824, /**< SDP: Internal use only */
+    OI_SDP_ILLEGAL_ARGUMENT              = 825, /**< SDP: Illegal argument passed to an SDP function */
+    OI_SDP_ATTRIBUTE_NOT_FOUND           = 826, /**< SDP: A requested attribute was not found in a service record */
+    OI_SDP_DATABASE_OUT_OF_RESOURCES     = 827, /**< SDP: server database is out of memory */
+    OI_SDP_SHORT_PDU                     = 829, /**< SDP: Not enough bytes in the packet */
+    OI_SDP_TRANSACTION_ID_MISMATCH       = 830, /**< SDP: Transaction Id was not as expected */
+    OI_SDP_UNEXPECTED_RESPONSE_PDU_ID    = 831, /**< SDP: Did not expect this response PDU */
+    OI_SDP_REQUEST_TIMEOUT               = 832, /**< SDP: Did not get a response within the timeout period */
+    OI_SDP_INVALID_RESPONSE_SYNTAX       = 833, /**< SDP: Response is not correctly formatted */
+    OI_SDP_CONNECTION_TIMEOUT            = 834, /**< SDP: Connection attempt timed out at a lower layer */
+    OI_SDP_RESPONSE_DATA_ERROR           = 835, /**< SDP: Response to a service request appears to be corrupt */
+    OI_SDP_TOO_MANY_ATTRIBUTE_BYTES      = 836, /**< SDP: Response contained more bytes than requested. */
+    OI_SDP_TOO_MANY_SERVICE_RECORDS      = 837, /**< SDP: Response contained more service records than requested. */
+    OI_SDP_INVALID_CONNECTION_ID         = 838, /**< SDP: Invalid connection ID in an SDP request */
+    OI_SDP_CANNOT_SET_ATTRIBUTE          = 839, /**< SDP: Attempt to set a dynamic attribute value failed */
+    OI_SDP_BADLY_FORMED_ATTRIBUTE_VALUE  = 840, /**< SDP: An attribute value has the wrong type or structure */
+    OI_SDP_NO_ATTRIBUTE_LIST_TO_REMOVE   = 841, /**< SDP: Attempt to remove a non-existent attribute list from a service record */
+    OI_SDP_ATTRIBUTE_LIST_ALREADY_ADDED  = 842, /**< SDP: An attribute list has already been added to the service record */
+    OI_SDP_DATA_ELEMENT_TRUNCATED        = 843, /**< SDP: Data element truncated (too few bytes) */
+
+    OI_RFCOMM_WRITE_IN_PROGRESS          = 901, /**< RFCOMM: Write in progress */
+    OI_RFCOMM_INVALID_BAUDRATE           = 903, /**< RFCOMM: Invalid baudrate */
+    OI_RFCOMM_INVALID_DATABIT            = 904, /**< RFCOMM: Invalid databit */
+    OI_RFCOMM_INVALID_STOPBIT            = 905, /**< RFCOMM: Invalid stopbit */
+    OI_RFCOMM_INVALID_PARITY             = 906, /**< RFCOMM: Invalid parity */
+    OI_RFCOMM_INVALID_PARITYTYPE         = 907, /**< RFCOMM: Invalid paritytype */
+    OI_RFCOMM_INVALID_FLOWCONTROL        = 908, /**< RFCOMM: Invalid flowcontrol */
+    OI_RFCOMM_SESSION_EXISTS             = 909, /**< RFCOMM: Session exists */
+    OI_RFCOMM_INVALID_CHANNEL            = 910, /**< RFCOMM: Invalid channel */
+    OI_RFCOMM_DLCI_EXISTS                = 911, /**< RFCOMM: DLCI exists */
+    OI_RFCOMM_LINK_NOT_FOUND             = 912, /**< RFCOMM: Link not found */
+    OI_RFCOMM_REMOTE_REJECT              = 913, /**< RFCOMM: Remote reject */
+    OI_RFCOMM_TEST_IN_PROGRESS           = 915, /**< RFCOMM: Test in progress */
+    OI_RFCOMM_SESSION_NOT_FOUND          = 916, /**< RFCOMM: Session not found */
+    OI_RFCOMM_INVALID_PACKET             = 917, /**< RFCOMM: Invalid packet */
+    OI_RFCOMM_FRAMESIZE_EXCEEDED         = 918, /**< RFCOMM: Framesize exceeded */
+    OI_RFCOMM_INVALID_DLCI               = 920, /**< RFCOMM: Invalid dlci */
+    OI_RFCOMM_SERVER_NOT_REGISTERED      = 921, /**< RFCOMM: Server not registered */
+    OI_RFCOMM_CREDIT_ERROR               = 922, /**< RFCOMM: Credit error */
+    OI_RFCOMM_NO_CHANNEL_NUMBER          = 923, /**< RFCOMM: No channel number */
+    OI_RFCOMM_QUERY_IN_PROGRESS          = 924, /**< RFCOMM: Query in progress */
+    OI_RFCOMM_SESSION_SHUTDOWN           = 925, /**< RFCOMM: Session shutdown */
+    OI_RFCOMM_LOCAL_DEVICE_DISCONNECTED  = 926, /**< RFCOMM: Local device disconnected */
+    OI_RFCOMM_REMOTE_DEVICE_DISCONNECTED = 927, /**< RFCOMM: Remote device disconnected */
+    OI_RFCOMM_OUT_OF_SERVER_CHANNELS     = 928, /**< RFCOMM: Out of server channels */
+
+    OI_DISPATCH_INVALID_CB_HANDLE        = 1001, /**< Dispatcher was handed an invalid callback handle */
+    OI_DISPATCH_TABLE_OVERFLOW           = 1002, /**< Dispatcher table is full */
+
+    OI_TEST_UNKNOWN_TEST                 = 1101, /**< TEST: Unknown test */
+    OI_TEST_FAIL                         = 1102, /**< TEST: Fail */
+
+    OI_HCITRANS_CANNOT_CONNECT_TO_DEVICE   = 1201, /**< TRANSPORT: Cannot connect to device */
+    OI_HCITRANS_BUFFER_TOO_SMALL           = 1203, /**< TRANSPORT: Buffer too small */
+    OI_HCITRANS_NULL_DEVICE_HANDLE         = 1204, /**< TRANSPORT: Null device handle */
+    OI_HCITRANS_IO_ERROR                   = 1205, /**< TRANSPORT: IO error */
+    OI_HCITRANS_DEVICE_NOT_READY           = 1206, /**< TRANSPORT: Device not ready */
+    OI_HCITRANS_FUNCTION_NOT_SUPPORTED     = 1207, /**< TRANSPORT: Function not supporteD */
+    OI_HCITRANS_ACCESS_DENIED              = 1209, /**< TRANSPORT: win32 */
+    OI_HCITRANS_ACL_DATA_ERROR             = 1210, /**< TRANSPORT: ACL data error */
+    OI_HCITRANS_SCO_DATA_ERROR             = 1211, /**< TRANSPORT: SCO data error */
+    OI_HCITRANS_EVENT_DATA_ERROR           = 1212, /**< TRANSPORT: HCI event data error */
+    OI_HCITRANS_INTERNAL_ERROR             = 1214, /**< TRANSPORT: Internal error in the transport */
+    OI_HCITRANS_LINK_NOT_ACTIVE            = 1215, /**< TRANSPORT: Link to the device is not currently active */
+    OI_HCITRANS_INITIALIZING               = 1216, /**< TRANSPORT: Transport is initializing */
+
+    OI_DEVMGR_NO_CONNECTION                = 1301, /**< DEVMGR: No connection */
+    OI_DEVMGR_HARDWARE_ERROR               = 1305, /**< DEVMGR: error reported by HCI */
+    OI_DEVMGR_PENDING_CONNECT_LIST_FULL    = 1307, /**< DEVMGR: Pending connect list full */
+    OI_DEVMGR_CONNECTION_LIST_FULL         = 1309, /**< DEVMGR: Connection list full */
+    OI_DEVMGR_NO_SUCH_CONNECTION           = 1310, /**< DEVMGR: No such connection */
+    OI_DEVMGR_INQUIRY_IN_PROGRESS          = 1311, /**< DEVMGR: Inquiry in progress */
+    OI_DEVMGR_PERIODIC_INQUIRY_ACTIVE      = 1312, /**< DEVMGR: Periodic inquiry active */
+    OI_DEVMGR_NO_INQUIRIES_ACTIVE          = 1313, /**< DEVMGR: can not cancel/exit if not active */
+    OI_DEVMGR_DUPLICATE_CONNECTION         = 1314, /**< DEVMGR: internal error */
+    OI_DEVMGR_DUPLICATE_EVENT_CALLBACK     = 1316, /**< DEVMGR: attempt to register same callback twice */
+    OI_DEVMGR_EVENT_CALLBACK_LIST_FULL     = 1317, /**< DEVMGR: can not register event callback, list is full */
+    OI_DEVMGR_EVENT_CALLBACK_NOT_FOUND     = 1318, /**< DEVMGR: attempt to unregister callback failed */
+    OI_DEVMGR_BUSY                         = 1319, /**< DEVMGR: some operations can only execute one at a time */
+    OI_DEVMGR_ENUM_UNEXPECTED_INQ_COMPLETE = 1320, /**< DEVMGR: inquiry complete event in inappropriate enumeration state */
+    OI_DEVMGR_ENUM_UNEXPECTED_INQ_RESULT   = 1321, /**< DEVMGR: inquiry result event in inappropriate enumeration state */
+    OI_DEVMGR_ENUM_DATABASE_FULL           = 1322, /**< DEVMGR: device enumeration, database is full, couldn't add a new device */
+    OI_DEVMGR_ENUM_INQUIRIES_OVERLAP       = 1323, /**< DEVMGR: device enumeration, periodic inquiries occurring too close together */
+    OI_DEVMGR_UNKNOWN_LINK_TYPE            = 1324, /**< DEVMGR: HCI connect request with unkown link type */
+    OI_DEVMGR_PARAM_IO_ACTIVE              = 1325, /**< DEVMGR: request for parameter read/write while param read/write active */
+    OI_DEVMGR_UNKNOWN_IAC_LAP              = 1326, /**< DEVMGR: unrecognized IAC LAP */
+    OI_DEVMGR_SCO_ALREADY_REGISTERED       = 1327, /**< DEVMGR: only one application can use SCO */
+    OI_DEVMGR_SCO_NOT_REGISTERED           = 1328, /**< DEVMGR: SCO applications must register before using the API */
+    OI_DEVMGR_SCO_WITHOUT_ACL              = 1329, /**< DEVMGR: Got SCO connection but there is no underlying ACL connection */
+    OI_DEVMGR_NO_SUPPORT                   = 1330, /**< DEVMGR: Request is not supported by the device */
+    OI_DEVMGR_WRITE_POLICY_FAILED          = 1331, /**< DEVMGR: connection attempt failed - unable to write link policy */
+    OI_DEVMGR_NOT_IN_MASTER_MODE           = 1332, /**< DEVMGR: OI_DEVMGR EndMasterMode without prior OI_DEVMGR_BeginMasterMode */
+    OI_DEVMGR_POLICY_VIOLATION             = 1333, /**< DEVMGR: low-power request is rejected - link policy does not allow it */
+    OI_DEVMGR_BUSY_TIMEOUT                 = 1334, /**< DEVMGR: queued operation timed out while in the queue; \n
+        timeout configurable via @ref OI_CONFIG_DEVMGR::connectQueueTimeoutSecs "connectQueueTimeoutSecs" */
+    OI_DEVMGR_REENCRYPT_FAILED             = 1335, /**< DEVMGR: failed to re-encrypt link after role switch */
+    OI_DEVMGR_ROLE_POLICY_CONFLICT         = 1336, /**< DEVMGR: requested role conflicts with current policy */
+    OI_DEVMGR_BAD_INTERVAL                 = 1337, /**< DEVMGR: current linkTO outside range of requested min/max interval */
+    OI_DEVMGR_INVALID_SCO_HANDLE           = 1338, /**< DEVMGR: HCI SCO event, invalid handle */
+    OI_DEVMGR_CONNECTION_OVERLAP           = 1339, /**< DEVMGR: Connection failed due to race condition with remote side */
+    OI_DEVMGR_ORPHAN_SUBRATE_COMPLETE      = 1340, /**< DEVMGR: sniff subrate complete, but no callback */
+    OI_DEVMGR_EIR_RESPONSE_2_LARGE         = 1341, /**< DEVMGR: eir builder, response length would exceed spec max */
+
+    OI_SECMGR_NO_POLICY                    = 1401, /**< SECMGR: no security policy has been established */
+    OI_SECMGR_INTERNAL_ERROR               = 1402, /**< SECMGR: internal inconsistency */
+    OI_SECMGR_ORPHANED_CALLBACK            = 1403, /**< SECMGR: we've been called back, but CB context is gone */
+    OI_SECMGR_BUSY                         = 1404, /**< SECMGR: configure and access request cannot be concurrent */
+    OI_SECMGR_DEVICE_NOT_TRUSTED           = 1405, /**< SECMGR: l2cap access denied - device is not trusted */
+    OI_SECMGR_DEVICE_ENCRYPT_FAIL          = 1407, /**< SECMGR: l2cap access denied - failed to start encryption */
+    OI_SECMGR_DISCONNECTED_FAIL            = 1408, /**< SECMGR: l2cap access denied - disconnected */
+    OI_SECMGR_ACCESS_PENDING               = 1409, /**< SECMGR: l2cap access request is still pending  */
+    OI_SECMGR_PIN_CODE_TOO_SHORT           = 1410, /**< SECMGR: Higher-layer process gave us a pin code that is too short */
+    OI_SECMGR_UNKNOWN_ENCRYPT_VALUE        = 1411, /**< SECMGR: got EncryptionChange event, unknown encryption enable value */
+    OI_SECMGR_INVALID_POLICY               = 1412, /**< SECMGR: the specified security policy is not valid for security mode */
+    OI_SECMGR_AUTHORIZATION_FAILED         = 1413, /**< SECMGR: device authorization failed */
+    OI_SECMGR_ENCRYPTION_FAILED            = 1414, /**< SECMGR: device encryption failed */
+    OI_SECMGR_UNIT_KEY_UNSUPPORTED         = 1415, /**< SECMGR: authentication failed due to non-support of unit keys */
+    OI_SECMGR_NOT_REGISTERED               = 1416, /**< SECMGR: required registrations have not yet occurred */
+    OI_SECMGR_ILLEGAL_WRITE_SSP_MODE       = 1417, /**< SECMGR: 2.1 HCI spec does not allow SSP mode to be disabled */
+    OI_SECMGR_INVALID_SEC_LEVEL            = 1418, /**< SECMGR: security level for a service is not a valid value */
+    OI_SECMGR_INSUFFICIENT_LINK_KEY        = 1419, /**< SECMGR: link key type is not sufficient to meet service requirements */
+    OI_SECMGR_INVALID_KEY_TYPE             = 1420, /**< SECMGR: link key type is not a valid value */
+    OI_SECMGR_SSP_NOT_ENCRYPTED            = 1421, /**< SECMGR: ssp required encryption on incoming link */
+    OI_SECMGR_ORPHAN_EVENT                 = 1422, /**< SECMGR: some HCI security event unrelated to current processes */
+    OI_SECMGR_NOT_BONDABLE                 = 1423, /**< SECMGR: not in bondable mode */
+
+    OI_TCS_INVALID_ELEMENT_TYPE            = 1602, /**< TCS: element type is invalid */
+    OI_TCS_INVALID_PACKET                  = 1603, /**< TCS: packet is invalide */
+    OI_TCS_CALL_IN_PROGRESS                = 1604, /**< TCS: call is in progress */
+    OI_TCS_NO_CALL_IN_PROGRESS             = 1605, /**< TCS: no call in progress */
+
+    OI_OBEX_CONTINUE                       = 1701, /**< OBEX: Continue processing OBEX request */
+    OI_OBEX_COMMAND_ERROR                  = 1702, /**< OBEX: An unrecognized OBEX command opcode */
+    OI_OBEX_CONNECTION_TIMEOUT             = 1703, /**< OBEX: Timeout waiting for a response to a request */
+    OI_OBEX_CONNECT_FAILED                 = 1704, /**< OBEX: An OBEX connection request did not succeed */
+    OI_OBEX_DISCONNECT_FAILED              = 1705, /**< OBEX: A disconnect failed probably because the connection did not exist */
+    OI_OBEX_ERROR                          = 1706, /**< OBEX: Unspecified OBEX error */
+    OI_OBEX_INCOMPLETE_PACKET              = 1707, /**< OBEX: Packet too short or corrupt */
+    OI_OBEX_LENGTH_REQUIRED                = 1708, /**< OBEX: Length header required in OBEX command */
+    OI_OBEX_NOT_CONNECTED                  = 1709, /**< OBEX: No connection to OBEX server */
+    OI_OBEX_NO_MORE_CONNECTIONS            = 1710, /**< OBEX: Reached max connections limit */
+    OI_OBEX_OPERATION_IN_PROGRESS          = 1711, /**< OBEX: Another operation is still in progress on a connection */
+    OI_OBEX_PUT_RESPONSE_ERROR             = 1712, /**< OBEX: An error in the response to a PUT command */
+    OI_OBEX_GET_RESPONSE_ERROR             = 1713, /**< OBEX: An error in the response to a GET command */
+    OI_OBEX_REQUIRED_HEADER_NOT_FOUND      = 1714, /**< OBEX: packet was missing a required header */
+    OI_OBEX_SERVICE_UNAVAILABLE            = 1715, /**< OBEX: Unown OBEX target or required service */
+    OI_OBEX_TOO_MANY_HEADER_BYTES          = 1716, /**< OBEX: Headers will not fit in single OBEX packet */
+    OI_OBEX_UNKNOWN_COMMAND                = 1717, /**< OBEX: Unrecognized OBEX command */
+    OI_OBEX_UNSUPPORTED_VERSION            = 1718, /**< OBEX: Version mismatch */
+    OI_OBEX_CLIENT_ABORTED_COMMAND         = 1719, /**< OBEX: server received abort command */
+    OI_OBEX_BAD_PACKET                     = 1720, /**< OBEX: Any malformed OBEX packet */
+    OI_OBEX_BAD_REQUEST                    = 1721, /**< OBEX: Maps to OBEX response of the same name */
+    OI_OBEX_OBJECT_OVERFLOW                = 1723, /**< OBEX: Too many bytes received. */
+    OI_OBEX_NOT_FOUND                      = 1724, /**< OBEX: Maps to obex response of same name */
+    OI_OBEX_ACCESS_DENIED                  = 1735, /**< OBEX: Object could not be read or written. */
+    OI_OBEX_VALUE_NOT_ACCEPTABLE           = 1736, /**< OBEX: Value in a command was not in the acceptable range. */
+    OI_OBEX_PACKET_OVERFLOW                = 1737, /**< OBEX: Buffer will not fit in a single OBEX packet. */
+    OI_OBEX_NO_SUCH_FOLDER                 = 1738, /**< OBEX: Error returned by a setpath operation. */
+    OI_OBEX_NAME_REQUIRED                  = 1739, /**< OBEX: Name must be non-null and non-empty. */
+    OI_OBEX_PASSWORD_TOO_LONG              = 1740, /**< OBEX: Password exceeds implementation imposed length limit. */
+    OI_OBEX_PRECONDITION_FAILED            = 1741, /**< OBEX: response Precondition Failed */
+    OI_OBEX_UNAUTHORIZED                   = 1742, /**< OBEX: authentication was not successful. */
+    OI_OBEX_NOT_IMPLEMENTED                = 1743, /**< OBEX: Unimplemented feature. */
+    OI_OBEX_INVALID_AUTH_DIGEST            = 1744, /**< OBEX: An authentication digest was bad. */
+    OI_OBEX_INVALID_OPERATION              = 1745, /**< OBEX: Operation not allowed at this time. */
+    OI_OBEX_DATABASE_FULL                  = 1746, /**< OBEX: Sync database full. */
+    OI_OBEX_DATABASE_LOCKED                = 1747, /**< OBEX: Sync database locked. */
+    OI_OBEX_INTERNAL_SERVER_ERROR          = 1748, /**< OBEX: response Internal Server Error */
+    OI_OBEX_UNSUPPORTED_MEDIA_TYPE         = 1749, /**< OBEX: response Unsupported Media Type */
+    OI_OBEX_PARTIAL_CONTENT                = 1750, /**< OBEX: response Partial Content */
+    OI_OBEX_METHOD_NOT_ALLOWED             = 1751, /**< OBEX: response Method Not Allowed */
+    OI_OBEXSRV_INCOMPLETE_GET              = 1752, /**< OBEX: Indicates to a GET handler that the request phase is still in progress */
+    OI_OBEX_FOLDER_BROWSING_NOT_ALLOWED    = 1753, /**< OBEX: Indicates that an FTP server does not allow folder browsing */
+    OI_OBEX_SERVER_FORCED_DISCONNECT       = 1754, /**< OBEX: connection was forcibly terminated by the server */
+    OI_OBEX_OFS_ERROR                      = 1755, /**< OBEX: OPP object file system error occurred */
+    OI_OBEX_FILEOP_ERROR                   = 1756, /**< OBEX: FTP/PBAP file operation system error occurred */
+    OI_OBEX_USERID_TOO_LONG                = 1757, /**< OBEX: User Id exceeds spec limited length limit. */
+
+    OI_HANDSFREE_EVENT_REPORTING_DISABLED  = 1801, /**< HANDSFREE: Event reporting disabled */
+    OI_HANDSFREE_NOT_CONNECTED             = 1802, /**< HANDSFREE: Not connected */
+    OI_HANDSFREE_SERVICE_NOT_STARTED       = 1803, /**< HANDSFREE: Cannot connect to handsfree AG if handsfree service not started */
+    OI_HANDSFREE_AG_SERVICE_NOT_STARTED    = 1804, /**< HANDSFREE: Cannot connect to handsfree device if handsfree AG service not started */
+    OI_HANDSFREE_COMMAND_IN_PROGRESS       = 1805, /**< HANDSFREE: Cannot accept a command at this time */
+    OI_HANDSFREE_AUDIO_ALREADY_CONNECTED   = 1806, /**< HANDSFREE: Audio is already connected */
+    OI_HANDSFREE_AUDIO_NOT_CONNECTED       = 1807, /**< HANDSFREE: Audio is not connected */
+    OI_HANDSFREE_FEATURE_NOT_SUPPORTED     = 1808, /**< HANDSFREE: Local or remote feature not supported for requested command */
+
+    OI_HEADSET_SERVICE_NOT_STARTED         = 1901, /**< HEADSET: Cannot connect to headset AG if headset service not started */
+    OI_HEADSET_AG_SERVICE_NOT_STARTED      = 1902, /**< HEADSET: Cannot connect to headset device if headset AG service not started */
+    OI_HEADSET_COMMAND_IN_PROGRESS         = 1903, /**< HEADSET: Cannot accept a command at this time */
+
+    OI_BNEP_INVALID_MTU                             = 2001, /**< BNEP: The remote device cannot support the minimum BNEP MTU */
+    OI_BNEP_SETUP_TIMEOUT                           = 2002, /**< BNEP: The setup request timed out. */
+    OI_BNEP_SERVICE_NOT_REGISTERED                  = 2003, /**< BNEP: The requested service was not found. */
+    OI_BNEP_INVALID_HANDLE                          = 2004, /**< BNEP: The specified connection handle is not valid. */
+    OI_BNEP_RESPONSE_TIMEOUT                        = 2005, /**< BNEP: The timer for receiving a response has expired. */
+    OI_BNEP_INVALID_CONNECTION                      = 2006, /**< BNEP: Invalid connection */
+    OI_BNEP_INVALID_FILTER                          = 2007, /**< BNEP: The supplied filter was invalid. */
+    OI_BNEP_CONNECTION_EXISTS                       = 2008, /**< BNEP: An attempt was made to create a duplicate connection. */
+    OI_BNEP_NOT_INITIALIZED                         = 2009, /**< BNEP: Init has not been called */
+    OI_BNEP_CONNECT_BASE                            = 2010, /**< BNEP: connection response codes */
+    OI_BNEP_CONNECT_FAILED_INVALID_DEST_UUID        = 2011, /**< BNEP: connect response code Invalid Dest UUID */
+    OI_BNEP_CONNECT_FAILED_INVALID_SOURCE_UUID      = 2012, /**< BNEP: connect response code Invalid Source UUID */
+    OI_BNEP_CONNECT_FAILED_INVALID_UUID_SIZE        = 2013, /**< BNEP: connect response code Invalid UUID Size */
+    OI_BNEP_CONNECT_FAILED_NOT_ALLOWED              = 2014, /**< BNEP: connect response code Not Allowed */
+    OI_BNEP_FILTER_NET_BASE                         = 2020, /**< BNEP: filter response codes */
+    OI_BNEP_FILTER_NET_UNSUPPORTED_REQUEST          = 2021, /**< BNEP: filter response code Unsupported Request */
+    OI_BNEP_FILTER_NET_FAILED_INVALID_PROTOCOL_TYPE = 2022, /**< BNEP: filter response code Invalid Protocol Type */
+    OI_BNEP_FILTER_NET_FAILED_MAX_LIMIT_REACHED     = 2023, /**< BNEP: filter response code Max Limit Reached */
+    OI_BNEP_FILTER_NET_FAILED_SECURITY              = 2024, /**< BNEP: filter response code Security */
+    OI_BNEP_FILTER_MULTI_BASE                       = 2030, /**< BNEP: multicast response codes */
+    OI_BNEP_FILTER_MULTI_UNSUPPORTED_REQUEST        = 2031, /**< BNEP: multicast response code Unsupported Request */
+    OI_BNEP_FILTER_MULTI_FAILED_INVALID_ADDRESS     = 2032, /**< BNEP: multicast response code Invalid Address */
+    OI_BNEP_FILTER_MULTI_FAILED_MAX_LIMIT_REACHED   = 2033, /**< BNEP: multicast response code Max Limit Reached */
+    OI_BNEP_FILTER_MULTI_FAILED_SECURITY            = 2034, /**< BNEP: multicast response code Security */
+    OI_BNEP_LOCAL_DEVICE_MUST_BE_MASTER             = 2040, /**< BNEP: Device must be master of the piconet for this function */
+    OI_BNEP_PACKET_FILTERED_OUT                     = 2041, /**< BNEP: Packet did not pass current filters */
+
+    OI_NETIFC_UP_FAILED                    = 2101, /**< NETIFC: Could not bring up network interface */
+    OI_NETIFC_COULD_NOT_CREATE_THREAD      = 2102, /**< NETIFC: Network interface could not create a read thread */
+    OI_NETIFC_INITIALIZATION_FAILED        = 2103, /**< NETIFC: Error in network interface initialization */
+    OI_NETIFC_INTERFACE_ALREADY_UP         = 2104, /**< NETIFC: Network interface is already up */
+    OI_NETIFC_INTERFACE_NOT_UP             = 2105, /**< NETIFC: Network interface is not up */
+    OI_NETIFC_PACKET_TOO_BIG               = 2106, /**< NETIFC: The packet is too big */
+
+    OI_PAN_ROLE_ALREADY_REGISTERED         = 2201, /**< PAN: This PAN role was already registered */
+    OI_PAN_ROLE_NOT_ALLOWED                = 2202, /**< PAN: The PAN role is not currently allowed */
+    OI_PAN_INCOMPATIBLE_ROLES              = 2203, /**< PAN: Only certain local and remote role combinations are permitted */
+    OI_PAN_INVALID_ROLE                    = 2204, /**< PAN: Role specified is not one the defined PAN roles */
+    OI_PAN_CONNECTION_IN_PROGRESS          = 2205, /**< PAN: A PAN connection is currently being established */
+    OI_PAN_USER_ALREADY_CONNECTED          = 2206, /**< PAN: PAN user role only allows a single connection */
+    OI_PAN_DEVICE_CONNECTED                = 2207, /**< PAN: A PAN connection already exists to specified device */
+
+    OI_CODEC_SBC_NO_SYNCWORD               = 2301, /**< CODEC: Couldn't find an SBC SYNCWORD */
+    OI_CODEC_SBC_NOT_ENOUGH_HEADER_DATA    = 2302, /**< CODEC: Not enough data provided to decode an SBC header */
+    OI_CODEC_SBC_NOT_ENOUGH_BODY_DATA      = 2303, /**< CODEC: Decoded the header, but not enough data to contain the rest of the frame */
+    OI_CODEC_SBC_NOT_ENOUGH_AUDIO_DATA     = 2304, /**< CODEC: Not enough audio data for this frame */
+    OI_CODEC_SBC_CHECKSUM_MISMATCH         = 2305, /**< CODEC: The frame header didn't match the checksum */
+    OI_CODEC_SBC_PARTIAL_DECODE            = 2306, /**< CODEC: Decoding was successful, but frame data still remains. Next call will provide audio without consuming input data. */
+
+    OI_FIFOQ_QUEUE_NOT_ALIGNED             = 2401, /**< FIFOQ: queue must be 32-bit aligned */
+    OI_FIFOQ_INVALID_Q                     = 2402, /**< FIFOQ: queue parameter is not a valid queue */
+    OI_FIFOQ_BUF_TOO_LARGE                 = 2403, /**< FIFOQ: attempt to queue a buffer which is too large */
+    OI_FIFOQ_FULL                          = 2404, /**< FIFOQ: enqueue() failed, queue is full */
+    OI_FIFOQ_NOT_ALLOCATED                 = 2405, /**< FIFOQ: Enqueue QBuf() failed, buffer not allocated */
+    OI_FIFOQ_INVALID_DATA_PTR              = 2406, /**< FIFOQ: Enqueue QBuf() failed, data pointer does not match */
+
+    OI_HID_HOST_SERVICE_NOT_STARTED        = 2601, /**< HID: Cannot connect to a HID device unless HID host is started */
+    OI_HID_DEVICE_SERVICE_NOT_STARTED      = 2602, /**< HID: Cannot connect to a HID host unless HID device is started */
+
+    OI_AT_ERROR                            = 2701, /**< AT: ERROR response */
+    OI_AT_NO_CARRIER                       = 2702, /**< AT: NO CARRIER response */
+    OI_AT_BUSY                             = 2703, /**< AT: BUSY response */
+    OI_AT_NO_ANSWER                        = 2704, /**< AT: NO ANSWER response */
+    OI_AT_DELAYED                          = 2705, /**< AT: DELAYED response */
+    OI_AT_BLACKLISTED                      = 2706, /**< AT: BLACKLISTED response */
+    OI_AT_CME_ERROR                        = 2707, /**< AT: +CME ERROR response */
+    OI_AT_CMS_ERROR                        = 2708, /**< AT: +CMS ERROR response */
+
+    OI_BLST_CHARACTER_TIMEOUT              = 2801, /**< BLST: Timeout expired while waiting for a character from the client. */
+    OI_BLST_ACKNOWLDGE_TIMEOUT             = 2802, /**< BLST: Timeout expired while waiting for event acknowledgment from the client */
+    OI_BLST_TX_NOT_READY                   = 2803, /**< BLST: BLST is not ready to send a BHAPI message to the client. */
+    OI_BLST_TX_BUSY                        = 2804, /**< BLST: BLST transmit buffer is in use. */
+
+    OI_AVDTP_CONNECTION_SEQ_ERROR          = 2901, /**< AVDTP: sequencing of signalling/media channel connections broken. */
+    OI_AVDTP_OUT_OF_RESOURCES              = 2902, /**< AVDTP: Tried to allocate too many endpoints or signalling channels. */
+
+    OI_PBAP_REPOSITORY_NOT_SET             = 3001, /**< PBAP: Phonebook repository must be set for operation to complete. */
+    OI_PBAP_PHONEBOOK_NOT_SET              = 3002, /**< PBAP: Phonebook be set for operation to complete. */
+
+    OI_AADP_BAD_ENDPOINT                   = 3101, /**< AADP: Invalid local endpoint specified */
+    OI_AADP_BAD_STATE                      = 3102, /**< AADP: AADP State is not correct for this operation. */
+
+    OI_UNICODE_INVALID_SOURCE              = 3200, /**< Unicode Conversion: Source string has invalid character encoding. */
+    OI_UNICODE_SOURCE_EXHAUSTED            = 3201, /**< Unicode Conversion: Incomplete Unicode character at end of source buffer. */
+    OI_UNICODE_DESTINATION_EXHAUSTED       = 3202, /**< Unicode Conversion: Destination buffer not large enough to hold resulting Unicode string. */
+
+    OI_AVRCP_TOO_MANY_CONNECTIONS          = 3300, /**< AVRCP: Exceeded maximum number of simultaneous AVCTP connections. */
+    OI_AVRCP_NOT_IMPLEMENTED               = 3301, /**< AVRCP: The target does not implement the command specified by the opcode and operand. */
+    OI_AVRCP_REJECTED                      = 3302, /**< AVRCP: The target cannot respond because of invalid operands in command packet. */
+    OI_AVRCP_INVALID_RESPONSE              = 3303, /**< AVRCP: The controller received the response with invalid parameters */
+    OI_AVRCP_RESPONSE_PACKET_OVERFLOW      = 3304, /**< AVRCP: The response message does not fir in one AVRCP packet (512 bytes), has to be fragmented. */
+    OI_AVRCP_RESPONSE_INVALID_PDU          = 3305, /**< AVRCP: Command rejected: target received a PDU that it did not understand. */
+    OI_AVRCP_RESPONSE_INVALID_PARAMETER    = 3306, /**< AVRCP: Command rejected: target received a PDU with a parameter ID that it did not understand. */
+    OI_AVRCP_RESPONSE_PARAMETER_NOT_FOUND  = 3307, /**< AVRCP: Command rejected: specified parameter not found, sent if the parameter ID is understood, but content is wrong or corrupted.*/
+    OI_AVRCP_RESPONSE_INTERNAL_ERROR       = 3308, /**< AVRCP: Command rejected: target detected other error conditions. */
+    OI_MAX_BM3_STATUS_VAL,       /* Maximum BM3 status code */
+
+    /* Status code values reserved for BM3 SDK platform-specific implementations */
+    OI_STATUS_RESERVED_FOR_BCOT = 9000,
+
+    /* Status code values reserved for BHAPI products */
+    OI_STATUS_RESERVED_FOR_BHAPI = 9200,
+
+    /* Status code values reserved for Soundabout products */
+    OI_STATUS_RESERVED_FOR_SOUNDABOUT= 9400,
+
+    /*
+     * Status code values greater than or equal to this value are reserved for use by applications.
+     * However, because of differences between compilers, and differences between 16-bit and 32-bit
+     * platforms custom status codes should be in the 16-bit range, so status codes can range from 0
+     * to 65534, inclusive (65535 is reserved)
+     */
+    OI_STATUS_RESERVED_FOR_APPS = 10000,
+
+
+
+    OI_STATUS_NONE = 0xffff     /**< Special status code to indicate that there is no status. (Only to be used for special cases involving OI_SLOG_ERROR() and OI_SLOG_WARNING().) */
+
+} OI_STATUS;
+
+
+/* Remeber to update the #define below when new reserved blocks are added to
+ * the list above. */
+#define OI_NUM_RESERVED_STATUS_BLOCKS 4 /**< Number of status code blocks reserved, including user apps */
+
+
+/**
+ * Test for success
+ */
+#define OI_SUCCESS(x)    ((x) == OI_OK)
+
+/*****************************************************************************/
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_STATUS_H */
+
diff -Naur '--exclude=.git' bluedroid-orig/embdrv/sbc/decoder/include/oi_stddefs.h bluedroid/embdrv/sbc/decoder/include/oi_stddefs.h
--- bluedroid-orig/embdrv/sbc/decoder/include/oi_stddefs.h	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/embdrv/sbc/decoder/include/oi_stddefs.h	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,232 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2014 The Android Open Source Project
+ *  Copyright 2002 - 2004 Open Interface North America, Inc. All rights reserved.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#ifndef OI_STDDEFS_H
+#define OI_STDDEFS_H
+/**
+ * @file
+ * This file contains BM3 standard type definitions.
+ *
+ */
+
+/**********************************************************************************
+  $Revision: #1 $
+***********************************************************************************/
+
+#include "oi_cpu_dep.h"
+
+/** \addtogroup Misc Miscellaneous APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef FALSE
+#define FALSE 0         /**< This define statement sets FALSE as a preprocessor alias for 0. */
+#endif
+
+#ifndef TRUE
+#define TRUE (!FALSE)  /**< This define statement sets TRUE as a preprocessor alias for !FALSE. */
+#endif
+
+#ifdef HEW_TOOLCHAIN
+    #ifdef NULL
+        #undef NULL         /**< Override HEW toolchain NULL definition */
+    #endif
+    #define NULL 0          /**< HEW toolchain does not allow us to compare (void*) type to function pointer */
+#else
+    #ifndef NULL
+        #define NULL ((void*)0) /**< This define statement sets NULL as a preprocessor alias for (void*)0 */
+    #endif
+#endif
+
+/**
+ * @name  Maximum and minimum values for basic types
+ * @{
+ */
+#define OI_INT8_MIN   ((OI_INT8)0x80)          /**< decimal value: -128 */
+#define OI_INT8_MAX   ((OI_INT8)0x7F)          /**< decimal value: 127 */
+#define OI_INT16_MIN  ((OI_INT16)0x8000)       /**< decimal value: -32768 */
+#define OI_INT16_MAX  ((OI_INT16)0x7FFF)       /**< decimal value: 32767 */
+#define OI_INT32_MIN  ((OI_INT32)0x80000000)   /**< decimal value: -2,147,483,648 */
+#define OI_INT32_MAX  ((OI_INT32)0x7FFFFFFF)   /**< decimal value: 2,147,483,647 */
+#define OI_UINT8_MIN  ((OI_UINT8)0)            /**< decimal value: 0 */
+#define OI_UINT8_MAX  ((OI_UINT8)0xFF)         /**< decimal value: 255 */
+#define OI_UINT16_MIN ((OI_UINT16)0)           /**< decimal value: 0 */
+#define OI_UINT16_MAX ((OI_UINT16)0xFFFF)      /**< decimal value: 65535 */
+#define OI_UINT32_MIN ((OI_UINT32)0)           /**< decimal value: 0 */
+#define OI_UINT32_MAX ((OI_UINT32)0xFFFFFFFF)  /**< decimal value: 4,294,967,295 */
+
+/**
+ * @}
+ */
+
+/**
+ * @name  Integer types required by the Service Discovery Protocol
+ * @{
+ */
+
+/** unsigned 64-bit integer as a structure of two unsigned 32-bit integers */
+typedef struct {
+    OI_UINT32 I1; /**< most significant 32 bits */
+    OI_UINT32 I2; /**< least significant 32 bits */
+} OI_UINT64;
+
+#define OI_UINT64_MIN { (OI_UINT32)0x00000000, (OI_UINT32)0x00000000 }
+#define OI_UINT64_MAX { (OI_UINT32)0XFFFFFFFF, (OI_UINT32)0XFFFFFFFF }
+
+/** signed 64-bit integer as a structure of one unsigned 32-bit integer and one signed 32-bit integer */
+typedef struct {
+    OI_INT32  I1; /**< most significant 32 bits  as a signed integer */
+    OI_UINT32 I2; /**< least significant 32 bits as an unsigned integer */
+} OI_INT64;
+
+#define OI_INT64_MIN { (OI_INT32)0x80000000, (OI_UINT32)0x00000000 }
+#define OI_INT64_MAX { (OI_INT32)0X7FFFFFFF, (OI_UINT32)0XFFFFFFFF }
+
+/** unsigned 128-bit integer as a structure of four unsigned 32-bit integers */
+typedef struct {
+    OI_UINT32 I1; /**< most significant 32 bits */
+    OI_UINT32 I2; /**< second-most significant 32 bits */
+    OI_UINT32 I3; /**< third-most significant 32 bits */
+    OI_UINT32 I4; /**< least significant 32 bits */
+} OI_UINT128;
+
+#define OI_UINT128_MIN { (OI_UINT32)0x00000000, (OI_UINT32)0x00000000,  (OI_UINT32)0x00000000, (OI_UINT32)0x00000000 }
+#define OI_UINT128_MAX { (OI_UINT32)0XFFFFFFFF, (OI_UINT32)0XFFFFFFFF,  (OI_UINT32)0XFFFFFFFF, (OI_UINT32)0XFFFFFFFF }
+
+/** signed 128-bit integer as a structure of three unsigned 32-bit integers and one signed 32-bit integer */
+typedef struct {
+    OI_INT32  I1;  /**< most significant 32 bits as a signed integer */
+    OI_UINT32 I2;  /**< second-most significant 32 bits as an unsigned integer */
+    OI_UINT32 I3;  /**< third-most significant 32 bits as an unsigned integer */
+    OI_UINT32 I4;  /**< least significant 32 bits as an unsigned integer */
+} OI_INT128;
+
+#define OI_INT128_MIN { (OI_UINT32)0x80000000, (OI_UINT32)0x00000000,  (OI_UINT32)0x00000000, (OI_UINT32)0x00000000 }
+#define OI_INT128_MAX { (OI_UINT32)0X7FFFFFFF, (OI_UINT32)0XFFFFFFFF,  (OI_UINT32)0XFFFFFFFF, (OI_UINT32)0XFFFFFFFF }
+
+/**
+ * @}
+ */
+
+
+/**
+ * type for ASCII character data items
+ */
+typedef char OI_CHAR;
+
+/**
+ * type for double-byte character data items
+ */
+typedef OI_UINT16 OI_CHAR16;
+
+/**
+ * types for UTF encoded strings.
+ */
+typedef OI_UINT8  OI_UTF8;
+typedef OI_UINT16 OI_UTF16;
+typedef OI_UINT32 OI_UTF32;
+
+
+/**
+ * @name Single-bit operation macros
+ * @{
+ * In these macros, x is the data item for which a bit is to be tested or set and y specifies which bit
+ * is to be tested or set.
+ */
+
+/** This macro's value is TRUE if the bit specified by y is set in data item x. */
+#define OI_BIT_TEST(x,y)   ((x) & (y))
+
+/** This macro's value is TRUE if the bit specified by y is not set in data item x. */
+#define OI_BIT_CLEAR_TEST(x,y)  (((x) & (y)) == 0)
+
+/** This macro sets the bit specified by y in data item x. */
+#define OI_BIT_SET(x,y)    ((x) |= (y))
+
+/** This macro clears the bit specified by y in data item x. */
+#define OI_BIT_CLEAR(x,y)  ((x) &= ~(y))
+
+/** @} */
+
+/**
+ * The OI_ARRAYSIZE macro is set to the number of elements in an array
+ * (instead of the number of bytes, which is returned by sizeof()).
+ */
+
+#ifndef OI_ARRAYSIZE
+#define OI_ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))
+#endif
+
+/**
+ * @name Preprocessor aliases for individual bit positions
+ *      Bits are defined here only if they are not already defined.
+ * @{
+ */
+
+#ifndef BIT0
+
+#define BIT0   0x00000001  /**< preprocessor alias for 32-bit value with bit 0 set, used to specify this single bit */
+#define BIT1   0x00000002  /**< preprocessor alias for 32-bit value with bit 1 set, used to specify this single bit */
+#define BIT2   0x00000004  /**< preprocessor alias for 32-bit value with bit 2 set, used to specify this single bit */
+#define BIT3   0x00000008  /**< preprocessor alias for 32-bit value with bit 3 set, used to specify this single bit */
+#define BIT4   0x00000010  /**< preprocessor alias for 32-bit value with bit 4 set, used to specify this single bit */
+#define BIT5   0x00000020  /**< preprocessor alias for 32-bit value with bit 5 set, used to specify this single bit */
+#define BIT6   0x00000040  /**< preprocessor alias for 32-bit value with bit 6 set, used to specify this single bit */
+#define BIT7   0x00000080  /**< preprocessor alias for 32-bit value with bit 7 set, used to specify this single bit */
+#define BIT8   0x00000100  /**< preprocessor alias for 32-bit value with bit 8 set, used to specify this single bit */
+#define BIT9   0x00000200  /**< preprocessor alias for 32-bit value with bit 9 set, used to specify this single bit */
+#define BIT10  0x00000400  /**< preprocessor alias for 32-bit value with bit 10 set, used to specify this single bit */
+#define BIT11  0x00000800  /**< preprocessor alias for 32-bit value with bit 11 set, used to specify this single bit */
+#define BIT12  0x00001000  /**< preprocessor alias for 32-bit value with bit 12 set, used to specify this single bit */
+#define BIT13  0x00002000  /**< preprocessor alias for 32-bit value with bit 13 set, used to specify this single bit */
+#define BIT14  0x00004000  /**< preprocessor alias for 32-bit value with bit 14 set, used to specify this single bit */
+#define BIT15  0x00008000  /**< preprocessor alias for 32-bit value with bit 15 set, used to specify this single bit */
+#define BIT16  0x00010000  /**< preprocessor alias for 32-bit value with bit 16 set, used to specify this single bit */
+#define BIT17  0x00020000  /**< preprocessor alias for 32-bit value with bit 17 set, used to specify this single bit */
+#define BIT18  0x00040000  /**< preprocessor alias for 32-bit value with bit 18 set, used to specify this single bit */
+#define BIT19  0x00080000  /**< preprocessor alias for 32-bit value with bit 19 set, used to specify this single bit */
+#define BIT20  0x00100000  /**< preprocessor alias for 32-bit value with bit 20 set, used to specify this single bit */
+#define BIT21  0x00200000  /**< preprocessor alias for 32-bit value with bit 21 set, used to specify this single bit */
+#define BIT22  0x00400000  /**< preprocessor alias for 32-bit value with bit 22 set, used to specify this single bit */
+#define BIT23  0x00800000  /**< preprocessor alias for 32-bit value with bit 23 set, used to specify this single bit */
+#define BIT24  0x01000000  /**< preprocessor alias for 32-bit value with bit 24 set, used to specify this single bit */
+#define BIT25  0x02000000  /**< preprocessor alias for 32-bit value with bit 25 set, used to specify this single bit */
+#define BIT26  0x04000000  /**< preprocessor alias for 32-bit value with bit 26 set, used to specify this single bit */
+#define BIT27  0x08000000  /**< preprocessor alias for 32-bit value with bit 27 set, used to specify this single bit */
+#define BIT28  0x10000000  /**< preprocessor alias for 32-bit value with bit 28 set, used to specify this single bit */
+#define BIT29  0x20000000  /**< preprocessor alias for 32-bit value with bit 29 set, used to specify this single bit */
+#define BIT30  0x40000000  /**< preprocessor alias for 32-bit value with bit 30 set, used to specify this single bit */
+#define BIT31  0x80000000  /**< preprocessor alias for 32-bit value with bit 31 set, used to specify this single bit */
+
+#endif  /* BIT0 et al */
+
+
+/** @} */
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+/*****************************************************************************/
+#endif /* OI_STDDEFS_H */
diff -Naur '--exclude=.git' bluedroid-orig/embdrv/sbc/decoder/include/oi_string.h bluedroid/embdrv/sbc/decoder/include/oi_string.h
--- bluedroid-orig/embdrv/sbc/decoder/include/oi_string.h	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/embdrv/sbc/decoder/include/oi_string.h	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,208 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2014 The Android Open Source Project
+ *  Copyright 2002 - 2004 Open Interface North America, Inc. All rights reserved.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#ifndef OI_STRING_H
+#define OI_STRING_H
+/**
+ * @file
+ * This file contains BM3 supplied portable string.h functions
+ *
+ */
+
+/**********************************************************************************
+  $Revision: #1 $
+***********************************************************************************/
+
+#include "oi_cpu_dep.h"
+#include "oi_stddefs.h"
+
+#if defined(USE_NATIVE_MEMCPY) || defined(USE_NATIVE_MALLOC)
+#include <string.h>
+#endif
+
+/** \addtogroup Misc Miscellaneous APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/*
+ * If we are using Native malloc(), we must also use
+ * native Ansi string.h functions for memory manipulation.
+ */
+#ifdef USE_NATIVE_MALLOC
+#ifndef USE_NATIVE_MEMCPY
+#define USE_NATIVE_MEMCPY
+#endif
+#endif
+
+#ifdef USE_NATIVE_MEMCPY
+
+#define OI_MemCopy(to, from, size)    memcpy((to), (from), (size))
+#define OI_MemSet(block, val, size)   memset((block), (val), (size))
+#define OI_MemZero(block, size)       memset((block), 0, (size))
+#define OI_MemCmp(s1, s2, n)          memcmp((s1), (s2), (n))
+#define OI_Strcpy(dest, src)          strcpy((dest),(src))
+#define OI_Strcat(dest, src)          strcat((dest),(src))
+#define OI_StrLen(str)                strlen((str))
+#define OI_Strcmp(s1, s2)             strcmp((s1), (s2))
+#define OI_Strncmp(s1, s2, n)         strncmp((s1), (s2), (n))
+
+#else
+
+/*
+ * OI_MemCopy
+ *
+ * Copy an arbitrary number of bytes from one memory address to another.
+ * The underlying implementation is the ANSI memmove() or equivalant, so
+ * overlapping memory copies will work correctly.
+ */
+void OI_MemCopy(void *To, void const *From, OI_UINT32 Size);
+
+
+/*
+ * OI_MemSet
+ *
+ * Sets all bytes in a block of memory to the same value
+ */
+void OI_MemSet(void *Block, OI_UINT8 Val, OI_UINT32 Size);
+
+
+/*
+ * OI_MemZero
+ *
+ * Sets all bytes in a block of memory to zero
+ */
+void OI_MemZero(void *Block, OI_UINT32 Size);
+
+
+/*
+ * OI_MemCmp
+ *
+ * Compare two blocks of memory
+ *
+ * Returns:
+ *        0, if s1 == s2
+ *      < 0, if s1 < s2
+ *      > 0, if s2 > s2
+ */
+OI_INT OI_MemCmp(void const *s1, void const *s2, OI_UINT32 n);
+
+/*
+ * OI_Strcpy
+ *
+ * Copies the Null terminated string from pStr to pDest, and
+ * returns pDest.
+ */
+
+OI_CHAR* OI_Strcpy(OI_CHAR *pDest,
+                   OI_CHAR const *pStr);
+
+/*
+ * OI_Strcat
+ *
+ * Concatonates the pStr string to the end of pDest, and
+ * returns pDest.
+ */
+
+OI_CHAR* OI_Strcat(OI_CHAR *pDest,
+                   OI_CHAR const *pStr) ;
+
+/*
+ * OI_StrLen
+ *
+ * Calculates the number of OI_CHARs in pStr (not including
+ * the Null terminator) and returns the value.
+ */
+OI_UINT OI_StrLen(OI_CHAR const *pStr) ;
+
+/*
+ * OI_Strcmp
+ *
+ * Compares two Null terminated strings
+ *
+ * Returns:
+ *        0, if s1 == s2
+ *      < 0, if s1 < s2
+ *      > 0, if s2 > s2
+ */
+OI_INT OI_Strcmp(OI_CHAR const *s1,
+                 OI_CHAR const *s2);
+
+/*
+ * OI_Strncmp
+ *
+ * Compares the first "len" OI_CHARs of strings s1 and s2.
+ *
+ * Returns:
+ *        0, if s1 == s2
+ *      < 0, if s1 < s2
+ *      > 0, if s2 > s2
+ */
+OI_INT OI_Strncmp(OI_CHAR const *s1,
+                  OI_CHAR const *s2,
+                  OI_UINT32      len);
+
+
+#endif /* USE_NATIVE_MEMCPY */
+
+/*
+ * OI_StrcmpInsensitive
+ *
+ * Compares two Null terminated strings, treating
+ * the Upper and Lower case of 'A' through 'Z' as
+ * equivilent.
+ *
+ * Returns:
+ *        0, if s1 == s2
+ *      < 0, if s1 < s2
+ *      > 0, if s2 > s2
+ */
+OI_INT OI_StrcmpInsensitive(OI_CHAR const *s1,
+                            OI_CHAR const *s2);
+
+/*
+ * OI_StrncmpInsensitive
+ *
+ * Compares the first "len" OI_CHARs of strings s1 and s2,
+ * treating the Upper and Lower case of 'A' through 'Z' as
+ * equivilent.
+ *
+ *
+ * Returns:
+ *        0, if s1 == s2
+ *      < 0, if s1 < s2
+ *      > 0, if s2 > s2
+ */
+OI_INT OI_StrncmpInsensitive(OI_CHAR const *s1,
+                             OI_CHAR const *s2,
+                             OI_UINT        len);
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/** @} */
+
+/*****************************************************************************/
+#endif /* OI_STRING_H */
+
diff -Naur '--exclude=.git' bluedroid-orig/embdrv/sbc/decoder/include/oi_time.h bluedroid/embdrv/sbc/decoder/include/oi_time.h
--- bluedroid-orig/embdrv/sbc/decoder/include/oi_time.h	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/embdrv/sbc/decoder/include/oi_time.h	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,200 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2014 The Android Open Source Project
+ *  Copyright 2002 - 2004 Open Interface North America, Inc. All rights reserved.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#ifndef _OI_TIME_H
+#define _OI_TIME_H
+/** @file
+ *
+ * This file provides time type definitions and interfaces to time-related functions.
+ *
+ * The stack maintains a 64-bit real-time millisecond clock. The choice of
+ * milliseconds is for convenience, not accuracy.
+ *
+ * Timeouts are specified as tenths of seconds in a 32-bit value. Timeout values
+ * specified by the Bluetooth specification are usually muliple seconds, so
+ * accuracy to a tenth of a second is more than adequate.
+ *
+ * This file also contains macros to convert between seconds and the Link
+ * Manager's 1.28-second units.
+ *
+ */
+
+/**********************************************************************************
+  $Revision: #1 $
+***********************************************************************************/
+
+#include "oi_stddefs.h"
+
+
+/** \addtogroup Misc Miscellaneous APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+
+/**
+ * Within the core stack timeouts are specified in intervals of tenths of seconds
+ */
+
+typedef OI_UINT16 OI_INTERVAL;
+#define OI_INTERVALS_PER_SECOND     10
+#define MSECS_PER_OI_INTERVAL       (1000 / OI_INTERVALS_PER_SECOND)
+
+/** maximum interval (54 min 36.7 sec) */
+#define OI_MAX_INTERVAL   0x7fff
+
+
+/**
+ * Macro to convert seconds to OI_INTERVAL time units
+ */
+
+#define OI_SECONDS(n)    ((OI_INTERVAL) ((n) * OI_INTERVALS_PER_SECOND))
+
+/**
+ * Macro to convert milliseconds to OI_INTERVAL time units (Rounded Up)
+ */
+
+#define OI_MSECONDS(n)   ((OI_INTERVAL) ((n + MSECS_PER_OI_INTERVAL - 1) / MSECS_PER_OI_INTERVAL))
+
+/**
+ * Macro to convert minutes to OI_INTERVAL time units
+ */
+
+#define OI_MINUTES(n)    ((OI_INTERVAL) ((n) * OI_SECONDS(60)))
+
+/** Convert an OI_INTERVAL to milliseconds. */
+#define OI_INTERVAL_TO_MILLISECONDS(i) ((i) * MSECS_PER_OI_INTERVAL)
+
+/**
+ * The stack depends on relative not absolute time. Any mapping between the
+ * stack's real-time clock and absolute time and date is implementation-dependent.
+ */
+
+typedef struct {
+    OI_INT32 seconds;
+    OI_INT16 mseconds;
+} OI_TIME;
+
+/**
+ * Convert an OI_TIME to milliseconds.
+ *
+ * @param t  the time to convert
+ *
+ * @return the time in milliseconds
+ */
+OI_UINT32 OI_Time_ToMS(OI_TIME *t);
+
+
+/**
+ * This function compares two time values.
+ *
+ * @param T1 first time to compare.
+ *
+ * @param T2 second time to compare.
+ *
+ * @return
+ @verbatim
+     -1 if t1 < t2
+      0 if t1 = t2
+     +1 if t1 > t2
+ @endverbatim
+ */
+
+OI_INT16 OI_Time_Compare(OI_TIME *T1,
+                         OI_TIME *T2);
+
+
+/**
+ * This function returns the interval between two times to a granularity of 0.1 seconds.
+ *
+ * @param Sooner a time value more recent that Later
+ *
+ * @param Later a time value later than Sooner
+ *
+ * @note The result is an OI_INTERVAL value so this function only works for time intervals
+ * that are less than about 71 minutes.
+ *
+ * @return the time interval between the two times = (Later - Sooner)
+ */
+
+OI_INTERVAL OI_Time_Interval(OI_TIME *Sooner,
+                             OI_TIME *Later);
+
+
+
+/**
+ * This function returns the interval between two times to a granularity of milliseconds.
+ *
+ * @param Sooner a time value more recent that Later
+ *
+ * @param Later a time value later than Sooner
+ *
+ * @note The result is an OI_UINT32 value so this function only works for time intervals
+ * that are less than about 50 days.
+ *
+ * @return the time interval between the two times = (Later - Sooner)
+ */
+
+OI_UINT32 OI_Time_IntervalMsecs(OI_TIME *Sooner,
+                                OI_TIME *Later);
+
+
+
+/**
+ * This function answers the question, Have we reached or gone past the target time?
+ *
+ * @param pTargetTime   target time
+ *
+ * @return  TRUE means time now is at or past target time
+ *          FALSE means target time is still some time in the future
+ */
+
+OI_BOOL  OI_Time_NowReachedTime(OI_TIME *pTargetTime);
+
+/**
+ *  Convert seconds to the Link Manager 1.28-second units
+ *  Approximate by using 1.25 conversion factor.
+ */
+
+#define OI_SECONDS_TO_LM_TIME_UNITS(lmUnits) ((lmUnits)<4?(lmUnits):(lmUnits)-((lmUnits)>>2))
+
+
+/**
+ *  Convert Link Manager 1.28-second units to seconds.
+ *  Approximate by using 1.25 conversion factor.
+ */
+
+#define OI_LM_TIME_UNITS_TO_SECONDS(lmUnits) ((lmUnits) + ((lmUnits)>>2))
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+/* Include for OI_Time_Now() prototype
+ * Must be included at end to obtain OI_TIME typedef
+ */
+#include "oi_osinterface.h"
+
+/*****************************************************************************/
+#endif /* _OI_TIME_H */
+
diff -Naur '--exclude=.git' bluedroid-orig/embdrv/sbc/decoder/include/oi_utils.h bluedroid/embdrv/sbc/decoder/include/oi_utils.h
--- bluedroid-orig/embdrv/sbc/decoder/include/oi_utils.h	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/embdrv/sbc/decoder/include/oi_utils.h	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,377 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2014 The Android Open Source Project
+ *  Copyright 2002 - 2004 Open Interface North America, Inc. All rights reserved.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#ifndef _OI_UTILS_H
+#define _OI_UTILS_H
+/**
+ * @file
+ *
+ * This file provides the interface for utility functions.
+ * Among the utilities are strlen (string length), strcmp (string compare), and
+ * other string manipulation functions. These are provided for those plaforms
+ * where this functionality is not available in stdlib.
+ */
+
+/**********************************************************************************
+  $Revision: #1 $
+***********************************************************************************/
+
+#include <stdarg.h>
+#include "oi_common.h"
+#include "oi_string.h"
+#include "oi_bt_spec.h"
+
+/** \addtogroup Misc Miscellaneous APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * Opaque type for a callback function handle. See OI_ScheduleCallbackFunction()
+ */
+typedef OI_UINT32 OI_CALLBACK_HANDLE;
+
+
+/**
+ * Function prototype for a timed procedure callback.
+ *
+ * @param arg                 Value that was passed into the OI_ScheduleCallback() function
+ *
+ */
+typedef void (*OI_SCHEDULED_CALLBACK)(void *arg);
+
+
+/**
+ * Registers a function to be called when a timeout expires. This API uses BLUEmagic's internal
+ * function dispatch mechanism, so applications that make extensive use of this facility may need to
+ * increase the value of DispatchTableSize in the configuration block for the dispatcher (see
+ * oi_bt_stack_config.h).
+ *
+ * @param callbackFunction    The function that will be called when the timeout expires
+ *
+ * @param arg                 Value that will be returned as the parameter to the callback function.
+ *
+ * @param timeout             A timeout expressed in OI_INTERVALs (tenths of seconds). This can be
+ *                            zero in which case the callback function will be called as soon as
+ *                            possible.
+ *
+ * @param handle              NULL or a pointer receive the callback handle.
+ *
+ * @return                    OI_OK if the function was reqistered, or an error status.
+ */
+OI_STATUS OI_ScheduleCallbackFunction(OI_SCHEDULED_CALLBACK callbackFunction,
+                                      void                 *arg,
+                                      OI_INTERVAL           timeout,
+                                      OI_CALLBACK_HANDLE   *handle);
+
+
+/**
+ * Cancels a function registered with OI_ScheduleCallbackFunction() before its timer expires.
+ *
+ * @param handle              handle returned by  OI_ScheduleCallbackFunction().
+ *
+ * @return                    OI_OK if the function was cancelled, or an error status.
+ */
+OI_STATUS OI_CancelCallbackFunction(OI_CALLBACK_HANDLE handle);
+
+
+/**
+ * Registers a function to be called when a timeout expires. This version does not return a handle
+ * so can only be canceled by calling OI_CancelCallback().
+ *
+ * @param callbackFunction    The function that will be called when the timeout expires
+ *
+ * @param arg                 Value that will be returned as the parameter to the callback function.
+ *
+ * @param timeout             A timeout expressed in OI_INTERVALs (tenths of seconds). This can be
+ *                            zero in which case the callback function will be called as soon as
+ *                            possible.
+ *
+ * @return                    OI_OK if the function was reqistered, or an error status.
+ */
+#define OI_ScheduleCallback(f, a, t)  OI_ScheduleCallbackFunction(f, a, t, NULL);
+
+
+/**
+ * Cancels a function registered with OI_ScheduleCallback() before its timer expires. This
+ * function will cancel the first entry matches the indicated callback function pointer.
+ *
+ * @param callbackFunction    The function that was originally registered
+ *
+ * @return                    OI_OK if the function was cancelled, or an error status.
+ */
+OI_STATUS OI_CancelCallback(OI_SCHEDULED_CALLBACK callbackFunction);
+
+
+/**
+ * Parse a Bluetooth device address from the specified string.
+ *
+ * @param str   the string to parse
+ * @param addr  the parsed address, if successful
+ *
+ * @return TRUE if an address was successfully parsed, FALSE otherwise
+ */
+
+OI_BOOL OI_ParseBdAddr(const OI_CHAR *str,
+                       OI_BD_ADDR    *addr) ;
+
+/**
+ * Printf function for platforms which have no stdio or printf available.
+ * OI_Printf supports the basic formatting types, with the exception of
+ * floating point types. Additionally, OI_Printf supports several formats
+ * specific to BLUEmagic 3.0 software:
+ *
+ * \%!   prints the string for an #OI_STATUS value.
+ *       @code OI_Printf("There was an error %!", status); @endcode
+ *
+ * \%@   prints a hex dump of a buffer.
+ *       Requires a pointer to the buffer and a signed integer length
+ *       (0 for default length). If the buffer is large, only an excerpt will
+ *       be printed.
+ *       @code OI_Printf("Contents of buffer %@", buffer, sizeof(buffer)); @endcode
+ *
+ * \%:   prints a Bluetooth address in the form "HH:HH:HH:HH:HH:HH".
+ *       Requires a pointer to an #OI_BD_ADDR.
+ *       @code OI_Printf("Bluetooth address %:", &bdaddr); @endcode
+ *
+ * \%^   decodes and prints a data element as formatted XML.
+ *       Requires a pointer to an #OI_DATAELEM.
+ *       @code OI_Printf("Service attribute list is:\n%^", &attributes); @endcode
+ *
+ * \%/   prints the base file name of a path, that is, the final substring
+ *       following a '/' or '\\' character. Requires a pointer to a null
+ *       terminated string.
+ *       @code OI_Printf("File %/", "c:\\dir1\\dir2\\file.txt"); @endcode
+ *
+ * \%~   prints a string, escaping characters as needed to display it in
+ *       ASCII. Requires a pointer to an #OI_PSTR and an #OI_UNICODE_ENCODING
+ *       parameter.
+ *       @code OI_Printf("Identifier %~", &id, OI_UNICODE_UTF16_BE); @endcode
+ *
+ * \%[   inserts an ANSI color escape sequence. Requires a single character
+ *       identifying the color to select. Colors are red (r/R), green (g/G),
+ *       blue (b/B), yellow (y/Y), cyan (c/C), magenta (m/M), white (W),
+ *       light-gray (l/L), dark-gray (d/D), and black (0). The lower case is
+ *       dim, the upper case is bright (except in the case of light-gray and
+ *       dark-gray, where bright and dim are identical). Any other value will
+ *       select the default color.
+ *       @code OI_Printf("%[red text %[black %[normal\n", 'r', '0', 0); @endcode
+ *
+ * \%a   same as \%s, except '\\r' and '\\n' are output as "<cr>" and "<lf>".
+ *       \%?a is valid, but \%la is not.
+ *
+ * \%b   prints an integer in base 2.
+ *       @code OI_Printf("Bits are %b", I); @endcode
+ *
+ * \%lb  prints a long integer in base 2.
+ *
+ * \%?b  prints the least significant N bits of an integer (or long integer)
+ *       in base 2. Requires the integer and a length N.
+ *       @code OI_Printf("Bottom 4 bits are: %?b", I, 4); @endcode
+ *
+ * \%B   prints an integer as boolean text, "TRUE" or "FALSE".
+ *       @code OI_Printf("The value 0 is %B, the value 1 is %B", 0, 1); @endcode
+ *
+ * \%?s  prints a substring up to a specified maximum length.
+ *       Requires a pointer to a string and a length parameter.
+ *       @code OI_Printf("String prefix is %?s", str, 3); @endcode
+ *
+ * \%ls  same as \%S.
+ *
+ * \%S   prints a UTF16 string as UTF8 (plain ASCII, plus 8-bit char sequences
+ *       where needed). Requires a pointer to #OI_CHAR16. \%?S is valid. The
+ *       length parameter is in OI_CHAR16 characters.
+ *
+ * \%T   prints time, formatted as "secs.msecs".
+ *       Requires pointer to #OI_TIME struct, NULL pointer prints current time.
+ *       @code OI_Printf("The time now is %T", NULL); @endcode
+ *
+ *  @param format   The format string
+ *
+ */
+void OI_Printf(const OI_CHAR *format, ...);
+
+
+/**
+ * Var-args version OI_Printf
+ *
+ * @param format   Same as for OI_Printf.
+ *
+ * @param argp     Var-args list.
+ */
+void OI_VPrintf(const OI_CHAR *format, va_list argp);
+
+
+/**
+ * Writes a formatted string to a buffer. This function supports the same format specifiers as
+ * OI_Printf().
+ *
+ * @param buffer   Destination buffer for the formatted string.
+ *
+ * @param bufLen   The length of the destination buffer.
+ *
+ * @param format   The format string
+ *
+ * @return   Number of characters written or -1 in the case of an error.
+ */
+OI_INT32 OI_SNPrintf(OI_CHAR *buffer,
+                    OI_UINT16 bufLen,
+                    const OI_CHAR* format, ...);
+
+
+/**
+ * Var-args version OI_SNPrintf
+ *
+ * @param buffer   Destination buffer for the formatted string.
+ *
+ * @param bufLen   The length of the destination buffer.
+ *
+ * @param format   The format string
+ *
+ * @param argp     Var-args list.
+ *
+ * @return   Number of characters written or -1 in the case of an error.
+ */
+OI_INT32 OI_VSNPrintf(OI_CHAR *buffer,
+                     OI_UINT16 bufLen,
+                     const OI_CHAR *format, va_list argp);
+
+
+/**
+ * Convert a string to an integer.
+ *
+ * @param str  the string to parse
+ *
+ * @return the integer value of the string or 0 if the string could not be parsed
+ */
+OI_INT OI_atoi(const OI_CHAR *str);
+
+
+/**
+ * Parse a signed integer in a string.
+ *
+ * Skips leading whitespace (space and tabs only) and parses a decimal or hex string. Hex string
+ * must be prefixed by "0x". Returns pointer to first character following the integer. Returns the
+ * pointer passed in if the string does not describe an integer.
+ *
+ * @param str    String to parse.
+ *
+ * @param val    Pointer to receive the parsed integer value.
+ *
+ * @return       A pointer to the first character following the integer or the pointer passed in.
+ */
+const OI_CHAR* OI_ScanInt(const OI_CHAR *str,
+                          OI_INT32 *val);
+
+
+/**
+ * Parse an unsigned integer in a string.
+ *
+ * Skips leading whitespace (space and tabs only) and parses a decimal or hex string. Hex string
+ * must be prefixed by "0x". Returns pointer to first character following the integer. Returns the
+ * pointer passed in if the string does not describe an integer.
+ *
+ * @param str    String to parse.
+ *
+ * @param val    Pointer to receive the parsed unsigned integer value.
+ *
+ * @return       A pointer to the first character following the unsigned integer or the pointer passed in.
+ */
+const OI_CHAR* OI_ScanUInt(const OI_CHAR *str,
+                           OI_UINT32 *val);
+
+/**
+ * Parse a whitespace delimited substring out of a string.
+ *
+ * @param str     Input string to parse.
+ * @param outStr  Buffer to return the substring
+ * @param len     Length of outStr
+ *
+ *
+ * @return       A pointer to the first character following the substring or the pointer passed in.
+ */
+const OI_CHAR* OI_ScanStr(const OI_CHAR *str,
+                          OI_CHAR *outStr,
+                          OI_UINT16 len);
+
+
+/**
+ * Parse a string for one of a set of alternative value. Skips leading whitespace (space and tabs
+ * only) and parses text matching one of the alternative strings. Returns pointer to first character
+ * following the matched text.
+ *
+ * @param str    String to parse.
+ *
+ * @param alts   Alternative matching strings separated by '|'
+ *
+ * @param index  Pointer to receive the index of the matching alternative, return value is -1 if
+ *               there is no match.
+ *
+ * @return       A pointer to the first character following the matched value or the pointer passed in
+ *               if there was no matching text.
+ */
+const OI_CHAR* OI_ScanAlt(const OI_CHAR *str,
+                          const OI_CHAR *alts,
+                          OI_INT *index);
+
+/**
+ * Parse a string for a BD Addr. Skips leading whitespace (space and tabs only) and parses a
+ * Bluetooth device address with nibbles optionally separated by colons. Return pointet to first
+ * character following the BD Addr.
+ *
+ * @param str    String to parse.
+ *
+ * @param addr   Pointer to receive the Bluetooth device address
+ *
+ * @return       A pointer to the first character following the BD Addr or the pointer passed in.
+ */
+const OI_CHAR* OI_ScanBdAddr(const OI_CHAR *str,
+                             OI_BD_ADDR *addr);
+
+
+/** Get a character from a digit integer value (0 - 9). */
+#define OI_DigitToChar(d) ((d) + '0')
+
+/**
+ * Determine Maximum and Minimum between two arguments.
+ *
+ * @param a  1st value
+ * @param b  2nd value
+ *
+ * @return the max or min value between a & b
+ */
+#define OI_MAX(a, b) (((a) < (b)) ? (b) : (a) )
+#define OI_MIN(a, b) (((a) > (b)) ? (b) : (a) )
+
+/**
+ * Compare two BD_ADDRs
+ * SAME_BD_ADDR - Boolean: TRUE if they are the same address
+ */
+
+#define SAME_BD_ADDR(x, y)      (0 == OI_MemCmp((x),(y),OI_BD_ADDR_BYTE_SIZE) )
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_UTILS_H */
+
diff -Naur '--exclude=.git' bluedroid-orig/embdrv/sbc/decoder/srce/alloc.c bluedroid/embdrv/sbc/decoder/srce/alloc.c
--- bluedroid-orig/embdrv/sbc/decoder/srce/alloc.c	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/embdrv/sbc/decoder/srce/alloc.c	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,78 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2014 The Android Open Source Project
+ *  Copyright 2003 - 2004 Open Interface North America, Inc. All rights reserved.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#include <stdlib.h>
+#include <oi_codec_sbc_private.h>
+
+/**********************************************************************************
+  $Revision: #1 $
+***********************************************************************************/
+
+PRIVATE OI_STATUS OI_CODEC_SBC_Alloc(OI_CODEC_SBC_COMMON_CONTEXT *common,
+                                     OI_UINT32 *codecDataAligned,
+                                     OI_UINT32 codecDataBytes,
+                                     OI_UINT8 maxChannels,
+                                     OI_UINT8 pcmStride)
+{
+    int i;
+    size_t filterBufferCount;
+    size_t subdataSize;
+    OI_BYTE *codecData = (OI_BYTE*)codecDataAligned;
+
+    if (maxChannels < 1 || maxChannels > 2) {
+        return OI_STATUS_INVALID_PARAMETERS;
+    }
+
+    if (pcmStride < 1 || pcmStride > maxChannels) {
+        return OI_STATUS_INVALID_PARAMETERS;
+    }
+
+    common->maxChannels = maxChannels;
+    common->pcmStride = pcmStride;
+
+    /* Compute sizes needed for the memory regions, and bail if we don't have
+     * enough memory for them. */
+    subdataSize = maxChannels * sizeof(common->subdata[0]) * SBC_MAX_BANDS * SBC_MAX_BLOCKS;
+    if (subdataSize > codecDataBytes) {
+        return OI_STATUS_OUT_OF_MEMORY;
+    }
+
+    filterBufferCount = (codecDataBytes - subdataSize) / (sizeof(common->filterBuffer[0][0]) * SBC_MAX_BANDS * maxChannels);
+    if (filterBufferCount < SBC_CODEC_MIN_FILTER_BUFFERS) {
+        return OI_STATUS_OUT_OF_MEMORY;
+    }
+    common->filterBufferLen = filterBufferCount * SBC_MAX_BANDS;
+
+    /* Allocate memory for the subband data */
+    common->subdata = (OI_INT32*)codecData;
+    codecData += subdataSize;
+    OI_ASSERT(codecDataBytes >= subdataSize);
+    codecDataBytes -= subdataSize;
+
+    /* Allocate memory for the synthesis buffers */
+    for (i = 0; i < maxChannels; ++i) {
+        size_t allocSize = common->filterBufferLen * sizeof(common->filterBuffer[0][0]);
+        common->filterBuffer[i] = (SBC_BUFFER_T*)codecData;
+        OI_ASSERT(codecDataBytes >= allocSize);
+        codecData += allocSize;
+        codecDataBytes -= allocSize;
+    }
+
+    return OI_OK;
+}
diff -Naur '--exclude=.git' bluedroid-orig/embdrv/sbc/decoder/srce/bitalloc.c bluedroid/embdrv/sbc/decoder/srce/bitalloc.c
--- bluedroid-orig/embdrv/sbc/decoder/srce/bitalloc.c	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/embdrv/sbc/decoder/srce/bitalloc.c	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,392 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2014 The Android Open Source Project
+ *  Copyright 2003 - 2004 Open Interface North America, Inc. All rights reserved.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/**********************************************************************************
+  $Revision: #1 $
+ ***********************************************************************************/
+
+/**
+@file
+
+The functions in this file relate to the allocation of available bits to
+subbands within the SBC/eSBC frame, along with support functions for computing
+frame length and bitrate.
+
+@ingroup codec_internal
+*/
+
+/**
+@addtogroup codec_internal
+@{
+*/
+
+#include "oi_utils.h"
+#include <oi_codec_sbc_private.h>
+
+OI_UINT32 OI_SBC_MaxBitpool(OI_CODEC_SBC_FRAME_INFO *frame)
+{
+    switch (frame->mode) {
+        case SBC_MONO:
+        case SBC_DUAL_CHANNEL:
+            return 16 * frame->nrof_subbands;
+        case SBC_STEREO:
+        case SBC_JOINT_STEREO:
+            return 32 * frame->nrof_subbands;
+    }
+
+    ERROR(("Invalid frame mode %d", frame->mode));
+    OI_ASSERT(FALSE);
+    return 0; /* Should never be reached */
+}
+
+
+PRIVATE OI_UINT16 internal_CalculateFramelen(OI_CODEC_SBC_FRAME_INFO *frame)
+{
+    OI_UINT16 nbits = frame->nrof_blocks * frame->bitpool;
+    OI_UINT16 nrof_subbands = frame->nrof_subbands;
+    OI_UINT16 result = nbits;
+
+    if (frame->mode == SBC_JOINT_STEREO) {
+        result += nrof_subbands + (8 * nrof_subbands);
+    } else {
+        if (frame->mode == SBC_DUAL_CHANNEL) { result += nbits; }
+        if (frame->mode == SBC_MONO) { result += 4*nrof_subbands; } else { result += 8*nrof_subbands; }
+    }
+    return SBC_HEADER_LEN + (result + 7) / 8;
+}
+
+
+PRIVATE OI_UINT32 internal_CalculateBitrate(OI_CODEC_SBC_FRAME_INFO *frame)
+{
+    OI_UINT blocksbands;
+    blocksbands = frame->nrof_subbands * frame->nrof_blocks;
+
+    return DIVIDE(8 * internal_CalculateFramelen(frame) * frame->frequency, blocksbands);
+}
+
+
+INLINE OI_UINT16 OI_SBC_CalculateFrameAndHeaderlen(OI_CODEC_SBC_FRAME_INFO *frame, OI_UINT *headerLen_)
+{
+    OI_UINT headerLen = SBC_HEADER_LEN + frame->nrof_subbands * frame->nrof_channels/2;
+
+    if (frame->mode == SBC_JOINT_STEREO) { headerLen++; }
+
+    *headerLen_ = headerLen;
+    return internal_CalculateFramelen(frame);
+}
+
+
+#define MIN(x, y)  ((x) < (y) ? (x) : (y))
+
+
+/*
+ * Computes the bit need for each sample and as also returns a counts of bit needs that are greater
+ * than one. This count is used in the first phase of bit allocation.
+ *
+ * We also compute a preferred bitpool value that this is the minimum bitpool needed to guarantee
+ * lossless representation of the audio data. The preferred bitpool may be larger than the bits
+ * actually required but the only input we have are the scale factors. For example, it takes 2 bits
+ * to represent values in the range -1 .. +1 but the scale factor is 0. To guarantee lossless
+ * representation we add 2 to each scale factor and sum them to come up with the preferred bitpool.
+ * This is not ideal because 0 requires 0 bits but we currently have no way of knowing this.
+ *
+ * @param bitneed       Array to return bitneeds for each subband
+ *
+ * @param ch            Channel 0 or 1
+ *
+ * @param preferredBitpool  Returns the number of reserved bits
+ *
+ * @return              The SBC bit need
+ *
+ */
+OI_UINT computeBitneed(OI_CODEC_SBC_COMMON_CONTEXT *common,
+                              OI_UINT8 *bitneeds,
+                              OI_UINT ch,
+                              OI_UINT *preferredBitpool)
+{
+    static const OI_INT8 offset4[4][4] = {
+        { -1, 0, 0, 0 },
+        { -2, 0, 0, 1 },
+        { -2, 0, 0, 1 },
+        { -2, 0, 0, 1 }
+    };
+
+    static const OI_INT8 offset8[4][8] = {
+        { -2, 0, 0, 0, 0, 0, 0, 1 },
+        { -3, 0, 0, 0, 0, 0, 1, 2 },
+        { -4, 0, 0, 0, 0, 0, 1, 2 },
+        { -4, 0, 0, 0, 0, 0, 1, 2 }
+    };
+
+    const OI_UINT nrof_subbands = common->frameInfo.nrof_subbands;
+    OI_UINT sb;
+    OI_INT8 *scale_factor = &common->scale_factor[ch ? nrof_subbands : 0];
+    OI_UINT bitcount = 0;
+    OI_UINT8 maxBits = 0;
+    OI_UINT8 prefBits = 0;
+
+    if (common->frameInfo.alloc == SBC_SNR) {
+        for (sb = 0; sb < nrof_subbands; sb++) {
+            OI_INT bits = scale_factor[sb];
+            if (bits > maxBits) {
+                maxBits = bits;
+            }
+            if ((bitneeds[sb] = bits) > 1) {
+                bitcount += bits;
+            }
+            prefBits += 2 + bits;
+        }
+    } else {
+        const OI_INT8 *offset;
+        if (nrof_subbands == 4) {
+            offset = offset4[common->frameInfo.freqIndex];
+        } else {
+            offset = offset8[common->frameInfo.freqIndex];
+        }
+        for (sb = 0; sb < nrof_subbands; sb++) {
+            OI_INT bits = scale_factor[sb];
+            if (bits > maxBits) {
+                maxBits = bits;
+            }
+            prefBits += 2 + bits;
+            if (bits) {
+                bits -= offset[sb];
+                if (bits > 0) {
+                    bits /= 2;
+                }
+                bits += 5;
+            }
+            if ((bitneeds[sb] = bits) > 1) {
+                bitcount += bits;
+            }
+        }
+    }
+    common->maxBitneed = OI_MAX(maxBits, common->maxBitneed);
+    *preferredBitpool += prefBits;
+    return bitcount;
+}
+
+
+/*
+ * Explanation of the adjustToFitBitpool inner loop.
+ *
+ * The inner loop computes the effect of adjusting the bit allocation up or
+ * down. Allocations must be 0 or in the range 2..16. This is accomplished by
+ * the following code:
+ *
+ *           for (s = bands - 1; s >= 0; --s) {
+ *              OI_INT bits = bitadjust + bitneeds[s];
+ *              bits = bits < 2 ? 0 : bits;
+ *              bits = bits > 16 ? 16 : bits;
+ *              count += bits;
+ *          }
+ *
+ * This loop can be optimized to perform 4 operations at a time as follows:
+ *
+ * Adjustment is computed as a 7 bit signed value and added to the bitneed.
+ *
+ * Negative allocations are zeroed by masking. (n & 0x40) >> 6 puts the
+ * sign bit into bit 0, adding this to 0x7F give us a mask of 0x80
+ * for -ve values and 0x7F for +ve values.
+ *
+ * n &= 0x7F + (n & 0x40) >> 6)
+ *
+ * Allocations greater than 16 are truncated to 16. Adjusted allocations are in
+ * the range 0..31 so we know that bit 4 indicates values >= 16. We use this bit
+ * to create a mask that zeroes bits 0 .. 3 if bit 4 is set.
+ *
+ * n &= (15 + (n >> 4))
+ *
+ * Allocations of 1 are disallowed. Add and shift creates a mask that
+ * eliminates the illegal value
+ *
+ * n &= ((n + 14) >> 4) | 0x1E
+ *
+ * These operations can be performed in 8 bits without overflowing so we can
+ * operate on 4 values at once.
+ */
+
+
+/*
+ * Encoder/Decoder
+ *
+ * Computes adjustment +/- of bitneeds to fill bitpool and returns overall
+ * adjustment and excess bits.
+ *
+ * @param bitpool   The bitpool we have to work within
+ *
+ * @param bitneeds  An array of bit needs (more acturately allocation prioritities) for each
+ *                  subband across all blocks in the SBC frame
+ *
+ * @param subbands  The number of subbands over which the adkustment is calculated. For mono and
+ *                  dual mode this is 4 or 8, for stereo or joint stereo this is 8 or 16.
+ *
+ * @param bitcount  A starting point for the adjustment
+ *
+ * @param excess    Returns the excess bits after the adjustment
+ *
+ * @return   The adjustment.
+ */
+OI_INT adjustToFitBitpool(const OI_UINT bitpool,
+                                 OI_UINT32 *bitneeds,
+                                 const OI_UINT subbands,
+                                 OI_UINT bitcount,
+                                 OI_UINT *excess)
+{
+    OI_INT maxBitadjust = 0;
+    OI_INT bitadjust = (bitcount > bitpool) ? -8 : 8;
+    OI_INT chop = 8;
+
+    /*
+     * This is essentially a binary search for the optimal adjustment value.
+     */
+    while ((bitcount != bitpool) && chop) {
+        OI_UINT32 total = 0;
+        OI_UINT count;
+        OI_UINT32 adjust4;
+        OI_INT i;
+
+        adjust4 = bitadjust & 0x7F;
+        adjust4 |= (adjust4 << 8);
+        adjust4 |= (adjust4 << 16);
+
+        for (i = (subbands / 4 - 1); i >= 0; --i) {
+            OI_UINT32 mask;
+            OI_UINT32 n = bitneeds[i] + adjust4;
+            mask = 0x7F7F7F7F + ((n & 0x40404040) >> 6);
+            n &= mask;
+            mask = 0x0F0F0F0F + ((n & 0x10101010) >> 4);
+            n &= mask;
+            mask = (((n + 0x0E0E0E0E) >> 4) | 0x1E1E1E1E);
+            n &= mask;
+            total += n;
+        }
+
+        count = (total & 0xFFFF) + (total >> 16);
+        count = (count & 0xFF) + (count >> 8);
+
+        chop >>= 1;
+        if (count > bitpool) {
+            bitadjust -= chop;
+        } else {
+            maxBitadjust = bitadjust;
+            bitcount = count;
+            bitadjust += chop;
+        }
+    }
+
+    *excess = bitpool - bitcount;
+
+    return maxBitadjust;
+}
+
+
+/*
+ * The bit allocator trys to avoid single bit allocations except as a last resort. So in the case
+ * where a bitneed of 1 was passed over during the adsjustment phase 2 bits are now allocated.
+ */
+INLINE OI_INT allocAdjustedBits(OI_UINT8 *dest,
+                                OI_INT bits,
+                                OI_INT excess)
+{
+    if (bits < 16) {
+        if (bits > 1) {
+            if (excess) {
+                ++bits;
+                --excess;
+            }
+        } else if ((bits == 1) && (excess > 1)) {
+            bits = 2;
+            excess -= 2;
+        } else {
+            bits  = 0;
+        }
+    } else {
+        bits = 16;
+    }
+    *dest = (OI_UINT8)bits;
+    return excess;
+}
+
+
+/*
+ * Excess bits not allocated by allocaAdjustedBits are allocated round-robin.
+ */
+INLINE OI_INT allocExcessBits(OI_UINT8 *dest,
+                              OI_INT excess)
+{
+    if (*dest < 16) {
+        *dest += 1;
+        return excess - 1;
+    } else {
+        return excess;
+    }
+}
+
+void oneChannelBitAllocation(OI_CODEC_SBC_COMMON_CONTEXT *common,
+                                    BITNEED_UNION1 *bitneeds,
+                                    OI_UINT ch,
+                                    OI_UINT bitcount)
+{
+    const OI_UINT8 nrof_subbands = common->frameInfo.nrof_subbands;
+    OI_UINT excess;
+    OI_UINT sb;
+    OI_INT bitadjust;
+    OI_UINT8 RESTRICT *allocBits;
+
+
+    {
+        OI_UINT ex;
+        bitadjust = adjustToFitBitpool(common->frameInfo.bitpool, bitneeds->uint32, nrof_subbands, bitcount, &ex);
+        /* We want the compiler to put excess into a register */
+        excess = ex;
+    }
+
+    /*
+     * Allocate adjusted bits
+     */
+    allocBits = &common->bits.uint8[ch ? nrof_subbands : 0];
+
+    sb = 0;
+    while (sb < nrof_subbands) {
+        excess = allocAdjustedBits(&allocBits[sb], bitneeds->uint8[sb] + bitadjust, excess);
+        ++sb;
+    }
+    sb = 0;
+    while (excess) {
+        excess = allocExcessBits(&allocBits[sb], excess);
+        ++sb;
+    }
+}
+
+
+void monoBitAllocation(OI_CODEC_SBC_COMMON_CONTEXT *common)
+{
+    BITNEED_UNION1 bitneeds;
+    OI_UINT bitcount;
+    OI_UINT bitpoolPreference = 0;
+
+    bitcount = computeBitneed(common, bitneeds.uint8, 0, &bitpoolPreference);
+
+    oneChannelBitAllocation(common, &bitneeds, 0, bitcount);
+}
+
+/**
+@}
+*/
diff -Naur '--exclude=.git' bluedroid-orig/embdrv/sbc/decoder/srce/bitalloc-sbc.c bluedroid/embdrv/sbc/decoder/srce/bitalloc-sbc.c
--- bluedroid-orig/embdrv/sbc/decoder/srce/bitalloc-sbc.c	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/embdrv/sbc/decoder/srce/bitalloc-sbc.c	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,165 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2014 The Android Open Source Project
+ *  Copyright 2003 - 2004 Open Interface North America, Inc. All rights reserved.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/**********************************************************************************
+  $Revision: #1 $
+***********************************************************************************/
+
+/** @file
+@ingroup codec_internal
+*/
+
+/**@addgroup codec_internal*/
+/**@{*/
+
+#include <oi_codec_sbc_private.h>
+
+static void dualBitAllocation(OI_CODEC_SBC_COMMON_CONTEXT *common)
+{
+    OI_UINT bitcountL;
+    OI_UINT bitcountR;
+    OI_UINT bitpoolPreferenceL = 0;
+    OI_UINT bitpoolPreferenceR = 0;
+    BITNEED_UNION1 bitneedsL;
+    BITNEED_UNION1 bitneedsR;
+
+    bitcountL = computeBitneed(common, bitneedsL.uint8, 0, &bitpoolPreferenceL);
+    bitcountR = computeBitneed(common, bitneedsR.uint8, 1, &bitpoolPreferenceR);
+
+    oneChannelBitAllocation(common, &bitneedsL, 0, bitcountL);
+    oneChannelBitAllocation(common, &bitneedsR, 1, bitcountR);
+}
+
+static void stereoBitAllocation(OI_CODEC_SBC_COMMON_CONTEXT *common)
+{
+    const OI_UINT nrof_subbands = common->frameInfo.nrof_subbands;
+    BITNEED_UNION2 bitneeds;
+    OI_UINT excess;
+    OI_INT bitadjust;
+    OI_UINT bitcount;
+    OI_UINT sbL;
+    OI_UINT sbR;
+    OI_UINT bitpoolPreference = 0;
+
+    bitcount = computeBitneed(common, &bitneeds.uint8[0], 0, &bitpoolPreference);
+    bitcount += computeBitneed(common, &bitneeds.uint8[nrof_subbands], 1, &bitpoolPreference);
+
+    {
+        OI_UINT ex;
+        bitadjust = adjustToFitBitpool(common->frameInfo.bitpool, bitneeds.uint32, 2 * nrof_subbands, bitcount, &ex);
+        /* We want the compiler to put excess into a register */
+        excess = ex;
+    }
+    sbL = 0;
+    sbR = nrof_subbands;
+    while (sbL < nrof_subbands) {
+        excess = allocAdjustedBits(&common->bits.uint8[sbL], bitneeds.uint8[sbL] + bitadjust, excess);
+        ++sbL;
+        excess = allocAdjustedBits(&common->bits.uint8[sbR], bitneeds.uint8[sbR] + bitadjust, excess);
+        ++sbR;
+    }
+    sbL = 0;
+    sbR = nrof_subbands;
+    while (excess) {
+        excess = allocExcessBits(&common->bits.uint8[sbL], excess);
+        ++sbL;
+        if (!excess) {
+            break;
+        }
+        excess = allocExcessBits(&common->bits.uint8[sbR], excess);
+        ++sbR;
+    }
+
+}
+
+static const BIT_ALLOC balloc[] = {
+    monoBitAllocation,    /* SBC_MONO */
+    dualBitAllocation,    /* SBC_DUAL_CHANNEL */
+    stereoBitAllocation,  /* SBC_STEREO */
+    stereoBitAllocation   /* SBC_JOINT_STEREO */
+};
+
+
+PRIVATE void OI_SBC_ComputeBitAllocation(OI_CODEC_SBC_COMMON_CONTEXT *common)
+{
+    OI_ASSERT(common->frameInfo.bitpool <= OI_SBC_MaxBitpool(&common->frameInfo));
+    OI_ASSERT(common->frameInfo.mode < OI_ARRAYSIZE(balloc));
+
+    /*
+     * Using an array of function pointers prevents the compiler from creating a suboptimal
+     * monolithic inlined bit allocation function.
+     */
+    balloc[common->frameInfo.mode](common);
+}
+
+OI_UINT32 OI_CODEC_SBC_CalculateBitrate(OI_CODEC_SBC_FRAME_INFO *frame)
+{
+    return internal_CalculateBitrate(frame);
+}
+
+/*
+ * Return the current maximum bitneed and clear it.
+ */
+OI_UINT8 OI_CODEC_SBC_GetMaxBitneed(OI_CODEC_SBC_COMMON_CONTEXT *common)
+{
+    OI_UINT8 max = common->maxBitneed;
+
+    common->maxBitneed = 0;
+    return max;
+}
+
+/*
+ * Calculates the bitpool size for a given frame length
+ */
+OI_UINT16 OI_CODEC_SBC_CalculateBitpool(OI_CODEC_SBC_FRAME_INFO *frame,
+                                        OI_UINT16 frameLen)
+{
+    OI_UINT16 nrof_subbands = frame->nrof_subbands;
+    OI_UINT16 nrof_blocks = frame->nrof_blocks;
+    OI_UINT16 hdr;
+    OI_UINT16 bits;
+
+    if (frame->mode == SBC_JOINT_STEREO) {
+        hdr = 9 * nrof_subbands;
+    } else {
+        if (frame->mode == SBC_MONO) {
+            hdr = 4 * nrof_subbands;
+        } else {
+            hdr = 8 * nrof_subbands;
+        }
+        if (frame->mode == SBC_DUAL_CHANNEL) {
+            nrof_blocks *= 2;
+        }
+    }
+    bits = 8 * (frameLen - SBC_HEADER_LEN) - hdr;
+    return DIVIDE(bits, nrof_blocks);
+}
+
+OI_UINT16 OI_CODEC_SBC_CalculatePcmBytes(OI_CODEC_SBC_COMMON_CONTEXT *common)
+{
+    return sizeof(OI_INT16) * common->pcmStride * common->frameInfo.nrof_subbands * common->frameInfo.nrof_blocks;
+}
+
+
+OI_UINT16 OI_CODEC_SBC_CalculateFramelen(OI_CODEC_SBC_FRAME_INFO *frame)
+{
+    return internal_CalculateFramelen(frame);
+}
+
+/**@}*/
diff -Naur '--exclude=.git' bluedroid-orig/embdrv/sbc/decoder/srce/bitstream-decode.c bluedroid/embdrv/sbc/decoder/srce/bitstream-decode.c
--- bluedroid-orig/embdrv/sbc/decoder/srce/bitstream-decode.c	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/embdrv/sbc/decoder/srce/bitstream-decode.c	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,92 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2014 The Android Open Source Project
+ *  Copyright 2003 - 2004 Open Interface North America, Inc. All rights reserved.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/**********************************************************************************
+  $Revision: #1 $
+***********************************************************************************/
+
+/**
+@file
+Functions for manipulating input bitstreams.
+
+@ingroup codec_internal
+*/
+
+/**
+@addtogroup codec_internal
+@{
+*/
+
+#include "oi_stddefs.h"
+#include "oi_bitstream.h"
+#include "oi_assert.h"
+
+PRIVATE void OI_BITSTREAM_ReadInit(OI_BITSTREAM *bs,
+                                   const OI_BYTE *buffer)
+{
+    bs->value = ((OI_INT32)buffer[0] << 16) | ((OI_INT32)buffer[1] << 8) | (buffer[2]);
+    bs->ptr.r = buffer + 3;
+    bs->bitPtr = 8;
+}
+
+PRIVATE OI_UINT32 OI_BITSTREAM_ReadUINT(OI_BITSTREAM *bs, OI_UINT bits)
+{
+    OI_UINT32 result;
+
+    OI_BITSTREAM_READUINT(result, bits, bs->ptr.r, bs->value, bs->bitPtr);
+
+    return result;
+}
+
+PRIVATE OI_UINT8 OI_BITSTREAM_ReadUINT4Aligned(OI_BITSTREAM *bs)
+{
+    OI_UINT32 result;
+
+    OI_ASSERT(bs->bitPtr < 16);
+    OI_ASSERT(bs->bitPtr % 4 == 0);
+
+    if (bs->bitPtr == 8) {
+        result = bs->value << 8;
+        bs->bitPtr = 12;
+    } else {
+        result = bs->value << 12;
+        bs->value = (bs->value << 8) | *bs->ptr.r++;
+        bs->bitPtr = 8;
+    }
+    result >>= 28;
+    OI_ASSERT(result < (1u << 4));
+    return (OI_UINT8)result;
+}
+
+PRIVATE OI_UINT8 OI_BITSTREAM_ReadUINT8Aligned(OI_BITSTREAM *bs)
+{
+    OI_UINT32 result;
+    OI_ASSERT(bs->bitPtr == 8);
+
+    result = bs->value >> 16;
+    bs->value = (bs->value << 8) | *bs->ptr.r++;
+
+    return (OI_UINT8)result;
+}
+
+/**
+@}
+*/
+
+
diff -Naur '--exclude=.git' bluedroid-orig/embdrv/sbc/decoder/srce/decoder-oina.c bluedroid/embdrv/sbc/decoder/srce/decoder-oina.c
--- bluedroid-orig/embdrv/sbc/decoder/srce/decoder-oina.c	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/embdrv/sbc/decoder/srce/decoder-oina.c	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,140 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2014 The Android Open Source Project
+ *  Copyright 2006 Open Interface North America, Inc. All rights reserved.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/**********************************************************************************
+  $Revision: #1 $
+ ***********************************************************************************/
+
+/**
+@file
+This file exposes OINA-specific interfaces to decoder functions.
+
+@ingroup codec_internal
+*/
+
+/**
+@addtogroup codec_internal
+@{
+*/
+
+
+#include <oi_codec_sbc_private.h>
+
+OI_STATUS OI_CODEC_SBC_DecoderConfigureRaw(OI_CODEC_SBC_DECODER_CONTEXT *context,
+                                           OI_BOOL enhanced,
+                                           OI_UINT8 frequency,
+                                           OI_UINT8 mode,
+                                           OI_UINT8 subbands,
+                                           OI_UINT8 blocks,
+                                           OI_UINT8 alloc,
+                                           OI_UINT8 maxBitpool)
+{
+    if (frequency > SBC_FREQ_48000) {
+        return OI_STATUS_INVALID_PARAMETERS;
+    }
+
+    if (enhanced) {
+#ifdef SBC_ENHANCED
+        if (subbands != SBC_SUBBANDS_8) {
+            return OI_STATUS_INVALID_PARAMETERS;
+        }
+#else
+        return OI_STATUS_INVALID_PARAMETERS;
+#endif
+    }
+
+    if (mode > SBC_JOINT_STEREO) {
+        return OI_STATUS_INVALID_PARAMETERS;
+    }
+
+    if (subbands > SBC_SUBBANDS_8) {
+        return OI_STATUS_INVALID_PARAMETERS;
+    }
+
+    if (blocks > SBC_BLOCKS_16) {
+        return OI_STATUS_INVALID_PARAMETERS;
+    }
+
+    if (alloc > SBC_SNR) {
+        return OI_STATUS_INVALID_PARAMETERS;
+    }
+
+#ifdef SBC_ENHANCED
+    context->common.frameInfo.enhanced = enhanced;
+#else
+    context->common.frameInfo.enhanced = FALSE;
+#endif
+    context->common.frameInfo.freqIndex = frequency;
+    context->common.frameInfo.mode = mode;
+    context->common.frameInfo.subbands = subbands;
+    context->common.frameInfo.blocks = blocks;
+    context->common.frameInfo.alloc = alloc;
+    context->common.frameInfo.bitpool = maxBitpool;
+
+    OI_SBC_ExpandFrameFields(&context->common.frameInfo);
+
+    if (context->common.frameInfo.nrof_channels >= context->common.pcmStride) {
+        return OI_STATUS_INVALID_PARAMETERS;
+    }
+
+    return OI_OK;
+}
+
+
+
+OI_STATUS OI_CODEC_SBC_DecodeRaw(OI_CODEC_SBC_DECODER_CONTEXT *context,
+                                 OI_UINT8 bitpool,
+                                 const OI_BYTE **frameData,
+                                 OI_UINT32 *frameBytes,
+                                 OI_INT16 *pcmData,
+                                 OI_UINT32 *pcmBytes)
+{
+    return internal_DecodeRaw(context,
+                              bitpool,
+                              frameData,
+                              frameBytes,
+                              pcmData,
+                              pcmBytes);
+}
+
+OI_STATUS OI_CODEC_SBC_DecoderLimit(OI_CODEC_SBC_DECODER_CONTEXT *context,
+                                    OI_BOOL                       enhanced,
+                                    OI_UINT8                      subbands)
+{
+	if (enhanced)
+	{
+#ifdef SBC_ENHANCED
+        context->enhancedEnabled = TRUE;
+#else
+        context->enhancedEnabled = FALSE;
+#endif
+	}
+	else
+	{
+        context->enhancedEnabled = FALSE;
+	}
+    context->restrictSubbands = subbands;
+    context->limitFrameFormat = TRUE;
+    return OI_OK;
+}
+
+
+/**
+@}
+*/
diff -Naur '--exclude=.git' bluedroid-orig/embdrv/sbc/decoder/srce/decoder-private.c bluedroid/embdrv/sbc/decoder/srce/decoder-private.c
--- bluedroid-orig/embdrv/sbc/decoder/srce/decoder-private.c	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/embdrv/sbc/decoder/srce/decoder-private.c	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,227 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2014 The Android Open Source Project
+ *  Copyright 2003 - 2004 Open Interface North America, Inc. All rights reserved.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/**********************************************************************************
+  $Revision: #1 $
+ ***********************************************************************************/
+
+/**
+@file
+This file drives SBC decoding.
+
+@ingroup codec_internal
+*/
+
+/**
+@addtogroup codec_internal
+@{
+*/
+
+#include "oi_codec_sbc_private.h"
+#include "oi_bitstream.h"
+#include <stdio.h>
+
+OI_CHAR * const OI_Codec_Copyright = "Copyright 2002-2007 Open Interface North America, Inc. All rights reserved";
+
+INLINE OI_STATUS internal_DecoderReset(OI_CODEC_SBC_DECODER_CONTEXT *context,
+                                       OI_UINT32 *decoderData,
+                                       OI_UINT32 decoderDataBytes,
+                                       OI_BYTE maxChannels,
+                                       OI_BYTE pcmStride,
+                                       OI_BOOL enhanced)
+{
+    OI_UINT i;
+    OI_STATUS status;
+
+    for (i = 0; i < sizeof(*context); i++) {
+        ((char *)context)[i] = 0;
+    }
+
+#ifdef SBC_ENHANCED
+    context->enhancedEnabled = enhanced ? TRUE : FALSE;
+#else
+    context->enhancedEnabled = FALSE;
+    if (enhanced){
+        return OI_STATUS_INVALID_PARAMETERS;
+    }
+#endif
+
+    status = OI_CODEC_SBC_Alloc(&context->common, decoderData, decoderDataBytes, maxChannels, pcmStride);
+
+    if (!OI_SUCCESS(status)) {
+        return status;
+    }
+
+    context->common.codecInfo = OI_Codec_Copyright;
+    context->common.maxBitneed = 0;
+    context->limitFrameFormat = FALSE;
+    OI_SBC_ExpandFrameFields(&context->common.frameInfo);
+
+    /*PLATFORM_DECODER_RESET(context);*/
+
+    return OI_OK;
+}
+
+
+
+
+/**
+ * Read the SBC header up to but not including the joint stereo mask.  The syncword has already been
+ * examined, and the enhanced mode flag set, by FindSyncword.
+ */
+INLINE void OI_SBC_ReadHeader(OI_CODEC_SBC_COMMON_CONTEXT *common, const OI_BYTE *data)
+{
+    OI_CODEC_SBC_FRAME_INFO *frame = &common->frameInfo;
+    OI_UINT8 d1;
+
+
+    OI_ASSERT(data[0] == OI_SBC_SYNCWORD || data[0] == OI_SBC_ENHANCED_SYNCWORD);
+
+    /* Avoid filling out all these strucutures if we already remember the values
+     * from last time. Just in case we get a stream corresponding to data[1] ==
+     * 0, DecoderReset is responsible for ensuring the lookup table entries have
+     * already been populated
+     */
+    d1 = data[1];
+    if (d1 != frame->cachedInfo) {
+
+        frame->freqIndex = (d1 & (BIT7 | BIT6)) >> 6;
+        frame->frequency = freq_values[frame->freqIndex];
+
+        frame->blocks = (d1 & (BIT5 | BIT4)) >> 4;
+        frame->nrof_blocks = block_values[frame->blocks];
+
+        frame->mode = (d1 & (BIT3 | BIT2)) >> 2;
+        frame->nrof_channels = channel_values[frame->mode];
+
+        frame->alloc = (d1 & BIT1) >> 1;
+
+        frame->subbands = (d1 & BIT0);
+        frame->nrof_subbands = band_values[frame->subbands];
+
+        frame->cachedInfo = d1;
+    }
+    /*
+     * For decode, the bit allocator needs to know the bitpool value
+     */
+    frame->bitpool = data[2];
+    frame->crc = data[3];
+}
+
+
+#define LOW(x)  ((x)& 0xf)
+#define HIGH(x) ((x) >> 4)
+
+/*
+ * Read scalefactor values and prepare the bitstream for OI_SBC_ReadSamples
+ */
+PRIVATE void OI_SBC_ReadScalefactors(OI_CODEC_SBC_COMMON_CONTEXT *common,
+                             const OI_BYTE *b,
+                             OI_BITSTREAM *bs)
+{
+    OI_UINT i = common->frameInfo.nrof_subbands * common->frameInfo.nrof_channels;
+    OI_INT8 *scale_factor = common->scale_factor;
+    OI_UINT f;
+
+    if (common->frameInfo.nrof_subbands == 8 || common->frameInfo.mode != SBC_JOINT_STEREO) {
+        if (common->frameInfo.mode == SBC_JOINT_STEREO) {
+            common->frameInfo.join = *b++;
+        } else {
+            common->frameInfo.join = 0;
+        }
+        i /= 2;
+        do {
+            *scale_factor++ = HIGH(f = *b++);
+            *scale_factor++ = LOW(f);
+        } while (--i);
+        /*
+         * In this case we know that the scale factors end on a byte boundary so all we need to do
+         * is initialize the bitstream.
+         */
+        OI_BITSTREAM_ReadInit(bs, b);
+    } else {
+        OI_ASSERT(common->frameInfo.nrof_subbands == 4 && common->frameInfo.mode == SBC_JOINT_STEREO);
+        common->frameInfo.join = HIGH(f = *b++);
+        i = (i - 1) / 2;
+        do {
+            *scale_factor++ = LOW(f);
+            *scale_factor++ = HIGH(f = *b++);
+        } while (--i);
+        *scale_factor++ = LOW(f);
+        /*
+         * In 4-subband joint stereo mode, the joint stereo information ends on a half-byte
+         * boundary, so it's necessary to use the bitstream abstraction to read it, since
+         * OI_SBC_ReadSamples will need to pick up in mid-byte.
+         */
+        OI_BITSTREAM_ReadInit(bs, b);
+        *scale_factor++ = OI_BITSTREAM_ReadUINT4Aligned(bs);
+    }
+}
+
+/** Read quantized subband samples from the input bitstream and expand them. */
+PRIVATE void OI_SBC_ReadSamples(OI_CODEC_SBC_DECODER_CONTEXT *context, OI_BITSTREAM *global_bs)
+{
+    OI_CODEC_SBC_COMMON_CONTEXT *common = &context->common;
+    OI_UINT nrof_blocks = common->frameInfo.nrof_blocks;
+    OI_INT32 * RESTRICT s = common->subdata;
+    OI_UINT8 *ptr = global_bs->ptr.w;
+    OI_UINT32 value = global_bs->value;
+    OI_UINT bitPtr = global_bs->bitPtr;
+
+    const OI_UINT iter_count = common->frameInfo.nrof_channels * common->frameInfo.nrof_subbands / 4;
+    do {
+        OI_UINT i;
+        for (i = 0; i < iter_count; ++i) {
+            OI_UINT32 sf_by4 = ((OI_UINT32*)common->scale_factor)[i];
+            OI_UINT32 bits_by4 = common->bits.uint32[i];
+            OI_UINT n;
+            for (n = 0; n < 4; ++n) {
+                OI_INT32 dequant;
+                OI_UINT bits;
+                OI_INT sf;
+
+                if (OI_CPU_BYTE_ORDER == OI_LITTLE_ENDIAN_BYTE_ORDER) {
+                    bits = bits_by4 & 0xFF;
+                    bits_by4 >>= 8;
+                    sf = sf_by4 & 0xFF;
+                    sf_by4 >>= 8;
+                } else {
+                    bits = (bits_by4 >> 24) & 0xFF;
+                    bits_by4 <<= 8;
+                    sf = (sf_by4 >> 24) & 0xFF;
+                    sf_by4 <<= 8;
+                }
+                if (bits) {
+                    OI_UINT32 raw;
+                    OI_BITSTREAM_READUINT(raw, bits, ptr, value, bitPtr);
+                    dequant = OI_SBC_Dequant(raw, sf, bits);
+                } else {
+                    dequant = 0;
+                }
+                *s++ = dequant;
+            }
+        }
+    } while (--nrof_blocks);
+}
+
+
+
+/**
+@}
+*/
diff -Naur '--exclude=.git' bluedroid-orig/embdrv/sbc/decoder/srce/decoder-sbc.c bluedroid/embdrv/sbc/decoder/srce/decoder-sbc.c
--- bluedroid-orig/embdrv/sbc/decoder/srce/decoder-sbc.c	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/embdrv/sbc/decoder/srce/decoder-sbc.c	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,465 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2014 The Android Open Source Project
+ *  Copyright 2006 Open Interface North America, Inc. All rights reserved.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/**********************************************************************************
+  $Revision: #1 $
+ ***********************************************************************************/
+
+/** @file
+@ingroup codec_internal
+*/
+
+/**@addtogroup codec_internal */
+/**@{*/
+
+#include "oi_codec_sbc_private.h"
+#include "oi_bitstream.h"
+
+#define SPECIALIZE_READ_SAMPLES_JOINT
+
+/**
+ * Scans through a buffer looking for a codec syncword. If the decoder has been
+ * set for enhanced operation using OI_CODEC_SBC_DecoderReset(), it will search
+ * for both a standard and an enhanced syncword.
+ */
+PRIVATE OI_STATUS FindSyncword(OI_CODEC_SBC_DECODER_CONTEXT *context,
+                               const OI_BYTE **frameData,
+                               OI_UINT32 *frameBytes)
+{
+#ifdef SBC_ENHANCED
+    OI_BYTE search1 = OI_SBC_SYNCWORD;
+    OI_BYTE search2 = OI_SBC_ENHANCED_SYNCWORD;
+#endif // SBC_ENHANCED
+
+    if (*frameBytes == 0) {
+        return OI_CODEC_SBC_NOT_ENOUGH_HEADER_DATA;
+    }
+
+#ifdef SBC_ENHANCED
+    if (context->limitFrameFormat && context->enhancedEnabled){
+        /* If the context is restricted, only search for specified SYNCWORD */
+        search1 = search2;
+    } else if (context->enhancedEnabled == FALSE) {
+        /* If enhanced is not enabled, only search for classic SBC SYNCWORD*/
+        search2 = search1;
+    }
+    while (*frameBytes && (**frameData != search1) && (**frameData != search2)) {
+        (*frameBytes)--;
+        (*frameData)++;
+    }
+    if (*frameBytes) {
+        /* Syncword found, *frameData points to it, and *frameBytes correctly
+         * reflects the number of bytes available to read, including the
+         * syncword. */
+        context->common.frameInfo.enhanced = (**frameData == OI_SBC_ENHANCED_SYNCWORD);
+        return OI_OK;
+    } else {
+        /* No syncword was found anywhere in the provided input data.
+         * *frameData points past the end of the original input, and
+         * *frameBytes is 0. */
+        return OI_CODEC_SBC_NO_SYNCWORD;
+    }
+#else  // SBC_ENHANCED
+    while (*frameBytes && (**frameData != OI_SBC_SYNCWORD)) {
+        (*frameBytes)--;
+        (*frameData)++;
+    }
+    if (*frameBytes) {
+        /* Syncword found, *frameData points to it, and *frameBytes correctly
+         * reflects the number of bytes available to read, including the
+         * syncword. */
+        context->common.frameInfo.enhanced = FALSE;
+        return OI_OK;
+    } else {
+        /* No syncword was found anywhere in the provided input data.
+         * *frameData points past the end of the original input, and
+         * *frameBytes is 0. */
+        return OI_CODEC_SBC_NO_SYNCWORD;
+    }
+#endif // SBC_ENHANCED
+}
+
+static OI_STATUS DecodeBody(OI_CODEC_SBC_DECODER_CONTEXT *context,
+                            const OI_BYTE *bodyData,
+                            OI_INT16 *pcmData,
+                            OI_UINT32 *pcmBytes,
+                            OI_BOOL allowPartial)
+{
+    OI_BITSTREAM bs;
+    OI_UINT frameSamples = context->common.frameInfo.nrof_blocks * context->common.frameInfo.nrof_subbands;
+    OI_UINT decode_block_count;
+
+    /*
+     * Based on the header data, make sure that there is enough room to write the output samples.
+     */
+    if (*pcmBytes < (sizeof(OI_INT16) * frameSamples * context->common.pcmStride) && !allowPartial) {
+        /* If we're not allowing partial decodes, we need room for the entire
+         * codec frame */
+        TRACE(("-OI_CODEC_SBC_Decode: OI_CODEC_SBC_NOT_ENOUGH_AUDIO_DATA"));
+        return OI_CODEC_SBC_NOT_ENOUGH_AUDIO_DATA;
+    } else if (*pcmBytes < sizeof (OI_INT16) * context->common.frameInfo.nrof_subbands * context->common.pcmStride) {
+        /* Even if we're allowing partials, we can still only decode on a frame
+         * boundary */
+        return OI_CODEC_SBC_NOT_ENOUGH_AUDIO_DATA;
+    }
+
+    if (context->bufferedBlocks == 0) {
+        TRACE(("Reading scalefactors"));
+        OI_SBC_ReadScalefactors(&context->common, bodyData, &bs);
+
+        TRACE(("Computing bit allocation"));
+        OI_SBC_ComputeBitAllocation(&context->common);
+
+        TRACE(("Reading samples"));
+        if (context->common.frameInfo.mode == SBC_JOINT_STEREO) {
+            OI_SBC_ReadSamplesJoint(context, &bs);
+        } else {
+            OI_SBC_ReadSamples(context, &bs);
+        }
+
+        context->bufferedBlocks = context->common.frameInfo.nrof_blocks;
+    }
+
+    if (allowPartial) {
+        decode_block_count = *pcmBytes / sizeof(OI_INT16) / context->common.pcmStride / context->common.frameInfo.nrof_subbands;
+
+        if (decode_block_count > context->bufferedBlocks) {
+            decode_block_count = context->bufferedBlocks;
+        }
+
+    } else {
+        decode_block_count = context->common.frameInfo.nrof_blocks;
+    }
+
+    TRACE(("Synthesizing frame"));
+    {
+        OI_UINT start_block = context->common.frameInfo.nrof_blocks - context->bufferedBlocks;
+        OI_SBC_SynthFrame(context, pcmData, start_block, decode_block_count);
+    }
+
+    OI_ASSERT(context->bufferedBlocks >= decode_block_count);
+    context->bufferedBlocks -= decode_block_count;
+
+    frameSamples = decode_block_count * context->common.frameInfo.nrof_subbands;
+
+    /*
+     * When decoding mono into a stride-2 array, copy pcm data to second channel
+     */
+    if (context->common.frameInfo.nrof_channels == 1 && context->common.pcmStride == 2) {
+        OI_UINT i;
+        for (i = 0; i < frameSamples; ++i) {
+            pcmData[2*i+1] = pcmData[2*i];
+        }
+    }
+
+    /*
+     * Return number of pcm bytes generated by the decode operation.
+     */
+    *pcmBytes = frameSamples * sizeof(OI_INT16) * context->common.pcmStride;
+    if (context->bufferedBlocks > 0) {
+        return OI_CODEC_SBC_PARTIAL_DECODE;
+    } else {
+        return OI_OK;
+    }
+}
+
+PRIVATE OI_STATUS internal_DecodeRaw(OI_CODEC_SBC_DECODER_CONTEXT *context,
+                                     OI_UINT8 bitpool,
+                                     const OI_BYTE **frameData,
+                                     OI_UINT32 *frameBytes,
+                                     OI_INT16 *pcmData,
+                                     OI_UINT32 *pcmBytes)
+{
+    OI_STATUS status;
+    OI_UINT bodyLen;
+
+    TRACE(("+OI_CODEC_SBC_DecodeRaw"));
+
+    if (context->bufferedBlocks == 0) {
+        /*
+         * The bitallocator needs to know the bitpool value.
+         */
+        context->common.frameInfo.bitpool = bitpool;
+        /*
+         * Compute the frame length and check we have enough frame data to proceed
+         */
+        bodyLen = OI_CODEC_SBC_CalculateFramelen(&context->common.frameInfo) - SBC_HEADER_LEN;
+        if (*frameBytes < bodyLen) {
+            TRACE(("-OI_CODEC_SBC_Decode: OI_CODEC_SBC_NOT_ENOUGH_BODY_DATA"));
+            return OI_CODEC_SBC_NOT_ENOUGH_BODY_DATA;
+        }
+    } else {
+        bodyLen = 0;
+    }
+    /*
+     * Decode the SBC data. Pass TRUE to DecodeBody to allow partial decoding of
+     * tones.
+     */
+    status = DecodeBody(context, *frameData, pcmData, pcmBytes, TRUE);
+    if (OI_SUCCESS(status) || status == OI_CODEC_SBC_PARTIAL_DECODE) {
+        *frameData += bodyLen;
+        *frameBytes -= bodyLen;
+    }
+    TRACE(("-OI_CODEC_SBC_DecodeRaw: %d", status));
+    return status;
+}
+
+OI_STATUS OI_CODEC_SBC_DecoderReset(OI_CODEC_SBC_DECODER_CONTEXT *context,
+                                    OI_UINT32 *decoderData,
+                                    OI_UINT32 decoderDataBytes,
+                                    OI_UINT8 maxChannels,
+                                    OI_UINT8 pcmStride,
+                                    OI_BOOL enhanced)
+{
+    return internal_DecoderReset(context, decoderData, decoderDataBytes, maxChannels, pcmStride, enhanced);
+}
+
+OI_STATUS OI_CODEC_SBC_DecodeFrame(OI_CODEC_SBC_DECODER_CONTEXT *context,
+                                   const OI_BYTE **frameData,
+                                   OI_UINT32 *frameBytes,
+                                   OI_INT16 *pcmData,
+                                   OI_UINT32 *pcmBytes)
+{
+    OI_STATUS status;
+    OI_UINT framelen;
+    OI_UINT8 crc;
+
+    TRACE(("+OI_CODEC_SBC_DecodeFrame"));
+
+    TRACE(("Finding syncword"));
+    status = FindSyncword(context, frameData, frameBytes);
+    if (!OI_SUCCESS(status)) {
+        return status;
+    }
+
+    /* Make sure enough data remains to read the header. */
+    if (*frameBytes < SBC_HEADER_LEN) {
+        TRACE(("-OI_CODEC_SBC_DecodeFrame: OI_CODEC_SBC_NOT_ENOUGH_HEADER_DATA"));
+        return OI_CODEC_SBC_NOT_ENOUGH_HEADER_DATA;
+    }
+
+    TRACE(("Reading Header"));
+    OI_SBC_ReadHeader(&context->common, *frameData);
+
+    /*
+     * Some implementations load the decoder into RAM and use overlays for 4 vs 8 subbands. We need
+     * to ensure that the SBC parameters for this frame are compatible with the restrictions imposed
+     * by the loaded overlays.
+     */
+    if (context->limitFrameFormat && (context->common.frameInfo.subbands != context->restrictSubbands)) {
+        ERROR(("SBC parameters incompatible with loaded overlay"));
+        return OI_STATUS_INVALID_PARAMETERS;
+    }
+
+    if (context->common.frameInfo.nrof_channels > context->common.maxChannels) {
+        ERROR(("SBC parameters incompatible with number of channels specified during reset"));
+        return OI_STATUS_INVALID_PARAMETERS;
+    }
+
+    if (context->common.pcmStride < 1 || context->common.pcmStride > 2) {
+        ERROR(("PCM stride not set correctly during reset"));
+        return OI_STATUS_INVALID_PARAMETERS;
+    }
+
+    /*
+     * At this point a header has been read. However, it's possible that we found a false syncword,
+     * so the header data might be invalid. Make sure we have enough bytes to read in the
+     * CRC-protected header, but don't require we have the whole frame. That way, if it turns out
+     * that we're acting on bogus header data, we don't stall the decoding process by waiting for
+     * data that we don't actually need.
+     */
+    framelen = OI_CODEC_SBC_CalculateFramelen(&context->common.frameInfo);
+    if (*frameBytes < framelen) {
+        TRACE(("-OI_CODEC_SBC_DecodeFrame: OI_CODEC_SBC_NOT_ENOUGH_BODY_DATA"));
+        return OI_CODEC_SBC_NOT_ENOUGH_BODY_DATA;
+    }
+
+    TRACE(("Calculating checksum"));
+
+    crc = OI_SBC_CalculateChecksum(&context->common.frameInfo, *frameData);
+    if (crc != context->common.frameInfo.crc) {
+        TRACE(("CRC Mismatch:  calc=%02x read=%02x\n", crc, context->common.frameInfo.crc));
+        TRACE(("-OI_CODEC_SBC_DecodeFrame: OI_CODEC_SBC_CHECKSUM_MISMATCH"));
+        return OI_CODEC_SBC_CHECKSUM_MISMATCH;
+    }
+
+#ifdef OI_DEBUG
+    /*
+     * Make sure the bitpool values are sane.
+     */
+    if ((context->common.frameInfo.bitpool < SBC_MIN_BITPOOL) && !context->common.frameInfo.enhanced) {
+        ERROR(("Bitpool too small: %d (must be >= 2)", context->common.frameInfo.bitpool));
+        return OI_STATUS_INVALID_PARAMETERS;
+    }
+    if (context->common.frameInfo.bitpool > OI_SBC_MaxBitpool(&context->common.frameInfo)) {
+        ERROR(("Bitpool too large: %d (must be <= %ld)", context->common.frameInfo.bitpool, OI_SBC_MaxBitpool(&context->common.frameInfo)));
+        return OI_STATUS_INVALID_PARAMETERS;
+    }
+#endif
+
+    /*
+     * Now decode the SBC data. Partial decode is not yet implemented for an SBC
+     * stream, so pass FALSE to decode body to have it enforce the old rule that
+     * you have to decode a whole packet at a time.
+     */
+    status = DecodeBody(context, *frameData + SBC_HEADER_LEN, pcmData, pcmBytes, FALSE);
+    if (OI_SUCCESS(status)) {
+        *frameData += framelen;
+        *frameBytes -= framelen;
+    }
+    TRACE(("-OI_CODEC_SBC_DecodeFrame: %d", status));
+
+    return status;
+}
+
+OI_STATUS OI_CODEC_SBC_SkipFrame(OI_CODEC_SBC_DECODER_CONTEXT *context,
+                                 const OI_BYTE **frameData,
+                                 OI_UINT32 *frameBytes)
+{
+    OI_STATUS status;
+    OI_UINT framelen;
+    OI_UINT headerlen;
+    OI_UINT8 crc;
+
+    status = FindSyncword(context, frameData, frameBytes);
+    if (!OI_SUCCESS(status)) {
+        return status;
+    }
+    if (*frameBytes < SBC_HEADER_LEN) {
+        return OI_CODEC_SBC_NOT_ENOUGH_HEADER_DATA;
+    }
+    OI_SBC_ReadHeader(&context->common, *frameData);
+    framelen = OI_SBC_CalculateFrameAndHeaderlen(&context->common.frameInfo, &headerlen);
+    if (*frameBytes < headerlen) {
+        return OI_CODEC_SBC_NOT_ENOUGH_HEADER_DATA;
+    }
+    crc = OI_SBC_CalculateChecksum(&context->common.frameInfo, *frameData);
+    if (crc != context->common.frameInfo.crc) {
+        return OI_CODEC_SBC_CHECKSUM_MISMATCH;
+    }
+    if (*frameBytes < framelen) {
+        return OI_CODEC_SBC_NOT_ENOUGH_BODY_DATA;
+    }
+    context->bufferedBlocks = 0;
+    *frameData += framelen;
+    *frameBytes -= framelen;
+    return OI_OK;
+}
+
+OI_UINT8 OI_CODEC_SBC_FrameCount(OI_BYTE  *frameData,
+                                 OI_UINT32 frameBytes)
+{
+    OI_UINT8 mode;
+    OI_UINT8 blocks;
+    OI_UINT8 subbands;
+    OI_UINT8 frameCount = 0;
+    OI_UINT  frameLen;
+
+    while (frameBytes){
+        while (frameBytes && ((frameData[0] & 0xFE) != 0x9C)){
+            frameData++;
+            frameBytes--;
+        }
+
+        if (frameBytes < SBC_HEADER_LEN) {
+            return frameCount;
+        }
+
+        /* Extract and translate required fields from Header */
+        subbands = mode = blocks = frameData[1];;
+        mode = (mode & (BIT3 | BIT2)) >> 2;
+        blocks = block_values[(blocks & (BIT5 | BIT4)) >> 4];
+        subbands = band_values[(subbands & BIT0)];
+
+        /* Inline logic to avoid corrupting context */
+        frameLen = blocks * frameData[2];
+        switch (mode){
+            case SBC_JOINT_STEREO:
+                frameLen += subbands + (8 * subbands);
+                break;
+
+            case SBC_DUAL_CHANNEL:
+                frameLen *= 2;
+                /* fall through */
+
+            default:
+                if (mode == SBC_MONO){
+                    frameLen += 4*subbands;
+                } else {
+                    frameLen += 8*subbands;
+                }
+        }
+
+        frameCount++;
+        frameLen = SBC_HEADER_LEN + (frameLen + 7) / 8;
+        if (frameBytes > frameLen){
+            frameBytes -= frameLen;
+            frameData += frameLen;
+        } else {
+            frameBytes = 0;
+        }
+    }
+    return frameCount;
+}
+
+/** Read quantized subband samples from the input bitstream and expand them. */
+
+#ifdef SPECIALIZE_READ_SAMPLES_JOINT
+
+PRIVATE void OI_SBC_ReadSamplesJoint4(OI_CODEC_SBC_DECODER_CONTEXT *context, OI_BITSTREAM *global_bs)
+{
+#define NROF_SUBBANDS 4
+#include "readsamplesjoint.inc"
+#undef NROF_SUBBANDS
+}
+
+PRIVATE void OI_SBC_ReadSamplesJoint8(OI_CODEC_SBC_DECODER_CONTEXT *context, OI_BITSTREAM *global_bs)
+{
+#define NROF_SUBBANDS 8
+#include "readsamplesjoint.inc"
+#undef NROF_SUBBANDS
+}
+
+typedef void (*READ_SAMPLES)(OI_CODEC_SBC_DECODER_CONTEXT *context, OI_BITSTREAM *global_bs);
+
+static const READ_SAMPLES SpecializedReadSamples[] = {
+    OI_SBC_ReadSamplesJoint4,
+    OI_SBC_ReadSamplesJoint8
+};
+
+#endif /* SPECIALIZE_READ_SAMPLES_JOINT */
+
+
+PRIVATE void OI_SBC_ReadSamplesJoint(OI_CODEC_SBC_DECODER_CONTEXT *context, OI_BITSTREAM *global_bs)
+{
+    OI_CODEC_SBC_COMMON_CONTEXT *common = &context->common;
+    OI_UINT nrof_subbands = common->frameInfo.nrof_subbands;
+#ifdef SPECIALIZE_READ_SAMPLES_JOINT
+    OI_ASSERT((nrof_subbands >> 3u) <= 1u);
+    SpecializedReadSamples[nrof_subbands >> 3](context, global_bs);
+#else
+
+#define NROF_SUBBANDS nrof_subbands
+#include "readsamplesjoint.inc"
+#undef NROF_SUBBANDS
+#endif /* SPECIALIZE_READ_SAMPLES_JOINT */
+}
+
+/**@}*/
+
diff -Naur '--exclude=.git' bluedroid-orig/embdrv/sbc/decoder/srce/dequant.c bluedroid/embdrv/sbc/decoder/srce/dequant.c
--- bluedroid-orig/embdrv/sbc/decoder/srce/dequant.c	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/embdrv/sbc/decoder/srce/dequant.c	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,210 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2014 The Android Open Source Project
+ *  Copyright 2003 - 2004 Open Interface North America, Inc. All rights reserved.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/**********************************************************************************
+  $Revision: #1 $
+***********************************************************************************/
+
+/**
+ @file
+
+ Dequantizer for SBC decoder; reconstructs quantized representation of subband samples.
+
+ @ingroup codec_internal
+ */
+
+/**
+@addtogroup codec_internal
+@{
+*/
+
+/**
+ This function is a fixed-point approximation of a modification of the following
+ dequantization operation defined in the spec, as inferred from section 12.6.4:
+
+ @code
+ dequant = 2^(scale_factor+1) * ((raw * 2.0 + 1.0) / ((2^bits) - 1) - 1)
+
+ 2 <= bits <= 16
+ 0 <= raw < (2^bits)-1   (the -1 is because quantized values with all 1's are forbidden)
+
+ -65535 < dequant < 65535
+ @endcode
+
+ The code below computes the dequantized value divided by a scaling constant
+ equal to about 1.38. This constant is chosen to ensure that the entry in the
+ dequant_long_scaled table for 16 bits is as accurate as possible, since it has
+ the least relative precision available to it due to its small magnitude.
+
+ This routine outputs in Q16.15 format.
+
+ The helper array dequant_long is defined as follows:
+
+ @code
+ dequant_long_long[bits] = round(2^31 * 1/((2^bits - 1) / 1.38...)  for 2 <= bits <= 16
+ @endcode
+
+
+ Additionally, the table entries have the following property:
+
+ @code
+ dequant_long_scaled[bits] <= 2^31 / ((2^bits - 1))  for 2 <= bits <= 16
+ @endcode
+
+ Therefore
+
+ @code
+ d = 2 * raw + 1              1 <= d <= 2^bits - 2
+
+ d' = d * dequant_long[bits]
+
+                  d * dequant_long_scaled[bits] <= (2^bits - 2) * (2^31 / (2^bits - 1))
+                  d * dequant_long_scaled[bits] <= 2^31 * (2^bits - 2)/(2^bits - 1) < 2^31
+ @endcode
+
+ Therefore, d' doesn't overflow a signed 32-bit value.
+
+ @code
+
+ d' =~ 2^31 * (raw * 2.0 + 1.0) / (2^bits - 1) / 1.38...
+
+ result = d' - 2^31/1.38... =~ 2^31 * ((raw * 2.0 + 1.0) / (2^bits - 1) - 1) / 1.38...
+
+ result is therefore a scaled approximation to dequant. It remains only to
+ turn 2^31 into 2^(scale_factor+1). Since we're aiming for Q16.15 format,
+ this is achieved by shifting right by (15-scale_factor):
+
+  (2^31 * x) >> (15-scale_factor) =~ 2^(31-15+scale_factor) * x = 2^15 * 2^(1+scale_factor) * x
+ @endcode
+
+ */
+
+#include <oi_codec_sbc_private.h>
+
+#ifndef SBC_DEQUANT_LONG_SCALED_OFFSET
+#define SBC_DEQUANT_LONG_SCALED_OFFSET 1555931970
+#endif
+
+#ifndef SBC_DEQUANT_LONG_UNSCALED_OFFSET
+#define SBC_DEQUANT_LONG_UNSCALED_OFFSET 2147483648
+#endif
+
+#ifndef SBC_DEQUANT_SCALING_FACTOR
+#define SBC_DEQUANT_SCALING_FACTOR 1.38019122262781f
+#endif
+
+extern const OI_UINT32 dequant_long_scaled[17];
+extern const OI_UINT32 dequant_long_unscaled[17];
+
+/** Scales x by y bits to the right, adding a rounding factor.
+ */
+#ifndef SCALE
+#define SCALE(x, y) (((x) + (1 <<((y)-1))) >> (y))
+#endif
+
+#ifdef DEBUG_DEQUANTIZATION
+
+#include <math.h>
+
+INLINE float dequant_float(OI_UINT32 raw, OI_UINT scale_factor, OI_UINT bits)
+{
+    float result = (1 << (scale_factor+1)) * ((raw * 2.0f + 1.0f) / ((1 << bits) - 1.0f) - 1.0f);
+
+    result /= SBC_DEQUANT_SCALING_FACTOR;
+
+    /* Unless the encoder screwed up, all correct dequantized values should
+     * satisfy this inequality. Non-compliant encoders which generate quantized
+     * values with all 1-bits set can, theoretically, trigger this assert. This
+     * is unlikely, however, and only an issue in debug mode.
+     */
+    OI_ASSERT(fabs(result) < 32768 * 1.6);
+
+    return result;
+}
+
+#endif
+
+
+INLINE OI_INT32 OI_SBC_Dequant(OI_UINT32 raw, OI_UINT scale_factor, OI_UINT bits)
+{
+    OI_UINT32 d;
+    OI_INT32 result;
+
+    OI_ASSERT(scale_factor <= 15);
+    OI_ASSERT(bits <= 16);
+
+    if (bits <= 1) {
+        return 0;
+    }
+
+    d = (raw * 2) + 1;
+    d *= dequant_long_scaled[bits];
+    result = d - SBC_DEQUANT_LONG_SCALED_OFFSET;
+
+#ifdef DEBUG_DEQUANTIZATION
+    {
+        OI_INT32 integerized_float_result;
+        float float_result;
+
+        float_result = dequant_float(raw, scale_factor, bits);
+        integerized_float_result = (OI_INT32)floor(0.5f+float_result * (1 << 15));
+
+        /* This detects overflow */
+        OI_ASSERT(((result >= 0) && (integerized_float_result >= 0)) ||
+                  ((result <= 0) && (integerized_float_result <= 0)));
+    }
+#endif
+    return result >> (15 - scale_factor);
+}
+
+/* This version of Dequant does not incorporate the scaling factor of 1.38. It
+ * is intended for use with implementations of the filterbank which are
+ * hard-coded into a DSP. Output is Q16.4 format, so that after joint stereo
+ * processing (which leaves the most significant bit equal to the sign bit if
+ * the encoder is conformant) the result will fit a 24 bit fixed point signed
+ * value.*/
+
+INLINE OI_INT32 OI_SBC_Dequant_Unscaled(OI_UINT32 raw, OI_UINT scale_factor, OI_UINT bits)
+{
+    OI_UINT32 d;
+    OI_INT32 result;
+
+    OI_ASSERT(scale_factor <= 15);
+    OI_ASSERT(bits <= 16);
+
+
+    if (bits <= 1) {
+        return 0;
+    }
+    if (bits == 16) {
+        result = (raw << 16) + raw - 0x7fff7fff;
+        return SCALE(result, 24 - scale_factor);
+    }
+
+
+    d = (raw * 2) + 1;
+    d *= dequant_long_unscaled[bits];
+    result = d - 0x80000000;
+
+    return SCALE(result, 24 - scale_factor);
+}
+
+/**
+@}
+*/
diff -Naur '--exclude=.git' bluedroid-orig/embdrv/sbc/decoder/srce/framing.c bluedroid/embdrv/sbc/decoder/srce/framing.c
--- bluedroid-orig/embdrv/sbc/decoder/srce/framing.c	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/embdrv/sbc/decoder/srce/framing.c	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,249 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2014 The Android Open Source Project
+ *  Copyright 2003 - 2004 Open Interface North America, Inc. All rights reserved.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/**********************************************************************************
+  $Revision: #1 $
+***********************************************************************************/
+
+/**
+@file
+Checksum and header-related functions.
+
+@ingroup codec_internal
+*/
+
+/**
+@addtogroup codec_internal
+@{
+*/
+
+#include "oi_codec_sbc_private.h"
+#include "oi_assert.h"
+
+
+/* asdasd */
+
+#define USE_NIBBLEWISE_CRC
+
+/* #define PRINT_SAMPLES */
+/* #define PRINT_SCALEFACTORS */
+/* #define DEBUG_CRC */
+
+/*
+ * CRC-8 table for X^8 + X^4 + X^3 + X^2 + 1; byte-wise lookup
+ */
+#ifdef USE_WIDE_CRC
+/* Save space if a char is 16 bits, such as on the C54x */
+const OI_BYTE crc8_wide[128] = {
+    0x001d, 0x3a27, 0x7469, 0x4e53, 0xe8f5, 0xd2cf, 0x9c81, 0xa6bb, 0xcdd0, 0xf7ea, 0xb9a4, 0x839e, 0x2538, 0x1f02, 0x514c, 0x6b76, 0x879a, 0xbda0, 0xf3ee, 0xc9d4, 0x6f72, 0x5548, 0x1b06, 0x213c, 0x4a57, 0x706d, 0x3e23, 0x0419, 0xa2bf, 0x9885, 0xd6cb, 0xecf1, 0x130e, 0x2934, 0x677a, 0x5d40, 0xfbe6, 0xc1dc, 0x8f92, 0xb5a8, 0xdec3, 0xe4f9, 0xaab7, 0x908d, 0x362b, 0x0c11, 0x425f, 0x7865, 0x9489, 0xaeb3, 0xe0fd, 0xdac7, 0x7c61, 0x465b, 0x0815, 0x322f, 0x5944, 0x637e, 0x2d30, 0x170a, 0xb1ac, 0x8b96, 0xc5d8, 0xffe2, 0x263b, 0x1c01, 0x524f, 0x6875, 0xced3, 0xf4e9, 0xbaa7, 0x809d, 0xebf6, 0xd1cc, 0x9f82, 0xa5b8, 0x031e, 0x3924, 0x776a, 0x4d50, 0xa1bc, 0x9b86, 0xd5c8, 0xeff2, 0x4954, 0x736e, 0x3d20, 0x071a, 0x6c71, 0x564b, 0x1805, 0x223f, 0x8499, 0xbea3, 0xf0ed, 0xcad7, 0x3528, 0x0f12, 0x415c, 0x7b66, 0xddc0, 0xe7fa, 0xa9b4, 0x938e, 0xf8e5, 0xc2df, 0x8c91, 0xb6ab, 0x100d, 0x2a37, 0x6479, 0x5e43, 0xb2af, 0x8895, 0xc6db, 0xfce1, 0x5a47, 0x607d, 0x2e33, 0x1409, 0x7f62, 0x4558, 0x0b16, 0x312c, 0x978a, 0xadb0, 0xe3fe, 0xd9c4,
+};
+#elif defined(USE_NIBBLEWISE_CRC)
+const OI_BYTE crc8_narrow[16] = {
+    0x00, 0x1d, 0x3a, 0x27, 0x74, 0x69, 0x4e, 0x53, 0xe8, 0xf5, 0xd2, 0xcf, 0x9c, 0x81, 0xa6, 0xbb
+};
+#else
+const OI_BYTE crc8_narrow[256] = {
+    0x00, 0x1d, 0x3a, 0x27, 0x74, 0x69, 0x4e, 0x53, 0xe8, 0xf5, 0xd2, 0xcf, 0x9c, 0x81, 0xa6, 0xbb, 0xcd, 0xd0, 0xf7, 0xea, 0xb9, 0xa4, 0x83, 0x9e, 0x25, 0x38, 0x1f, 0x02, 0x51, 0x4c, 0x6b, 0x76, 0x87, 0x9a, 0xbd, 0xa0, 0xf3, 0xee, 0xc9, 0xd4, 0x6f, 0x72, 0x55, 0x48, 0x1b, 0x06, 0x21, 0x3c, 0x4a, 0x57, 0x70, 0x6d, 0x3e, 0x23, 0x04, 0x19, 0xa2, 0xbf, 0x98, 0x85, 0xd6, 0xcb, 0xec, 0xf1, 0x13, 0x0e, 0x29, 0x34, 0x67, 0x7a, 0x5d, 0x40, 0xfb, 0xe6, 0xc1, 0xdc, 0x8f, 0x92, 0xb5, 0xa8, 0xde, 0xc3, 0xe4, 0xf9, 0xaa, 0xb7, 0x90, 0x8d, 0x36, 0x2b, 0x0c, 0x11, 0x42, 0x5f, 0x78, 0x65, 0x94, 0x89, 0xae, 0xb3, 0xe0, 0xfd, 0xda, 0xc7, 0x7c, 0x61, 0x46, 0x5b, 0x08, 0x15, 0x32, 0x2f, 0x59, 0x44, 0x63, 0x7e, 0x2d, 0x30, 0x17, 0x0a, 0xb1, 0xac, 0x8b, 0x96, 0xc5, 0xd8, 0xff, 0xe2, 0x26, 0x3b, 0x1c, 0x01, 0x52, 0x4f, 0x68, 0x75, 0xce, 0xd3, 0xf4, 0xe9, 0xba, 0xa7, 0x80, 0x9d, 0xeb, 0xf6, 0xd1, 0xcc, 0x9f, 0x82, 0xa5, 0xb8, 0x03, 0x1e, 0x39, 0x24, 0x77, 0x6a, 0x4d, 0x50, 0xa1, 0xbc, 0x9b, 0x86, 0xd5, 0xc8, 0xef, 0xf2, 0x49, 0x54, 0x73, 0x6e, 0x3d, 0x20, 0x07, 0x1a, 0x6c, 0x71, 0x56, 0x4b, 0x18, 0x05, 0x22, 0x3f, 0x84, 0x99, 0xbe, 0xa3, 0xf0, 0xed, 0xca, 0xd7, 0x35, 0x28, 0x0f, 0x12, 0x41, 0x5c, 0x7b, 0x66, 0xdd, 0xc0, 0xe7, 0xfa, 0xa9, 0xb4, 0x93, 0x8e, 0xf8, 0xe5, 0xc2, 0xdf, 0x8c, 0x91, 0xb6, 0xab, 0x10, 0x0d, 0x2a, 0x37, 0x64, 0x79, 0x5e, 0x43, 0xb2, 0xaf, 0x88, 0x95, 0xc6, 0xdb, 0xfc, 0xe1, 0x5a, 0x47, 0x60, 0x7d, 0x2e, 0x33, 0x14, 0x09, 0x7f, 0x62, 0x45, 0x58, 0x0b, 0x16, 0x31, 0x2c, 0x97, 0x8a, 0xad, 0xb0, 0xe3, 0xfe, 0xd9, 0xc4
+};
+#endif
+const OI_UINT32 dequant_long_scaled[17] = {
+    0,
+    0,
+    0x1ee9e116,  /* bits=2  0.24151243  1/3      * (1/1.38019122262781) (0x00000008)*/
+    0x0d3fa99c,  /* bits=3  0.10350533  1/7      * (1/1.38019122262781) (0x00000013)*/
+    0x062ec69e,  /* bits=4  0.04830249  1/15     * (1/1.38019122262781) (0x00000029)*/
+    0x02fddbfa,  /* bits=5  0.02337217  1/31     * (1/1.38019122262781) (0x00000055)*/
+    0x0178d9f5,  /* bits=6  0.01150059  1/63     * (1/1.38019122262781) (0x000000ad)*/
+    0x00baf129,  /* bits=7  0.00570502  1/127    * (1/1.38019122262781) (0x0000015e)*/
+    0x005d1abe,  /* bits=8  0.00284132  1/255    * (1/1.38019122262781) (0x000002bf)*/
+    0x002e760d,  /* bits=9  0.00141788  1/511    * (1/1.38019122262781) (0x00000582)*/
+    0x00173536,  /* bits=10 0.00070825  1/1023   * (1/1.38019122262781) (0x00000b07)*/
+    0x000b9928,  /* bits=11 0.00035395  1/2047   * (1/1.38019122262781) (0x00001612)*/
+    0x0005cc37,  /* bits=12 0.00017693  1/4095   * (1/1.38019122262781) (0x00002c27)*/
+    0x0002e604,  /* bits=13 0.00008846  1/8191   * (1/1.38019122262781) (0x00005852)*/
+    0x000172fc,  /* bits=14 0.00004422  1/16383  * (1/1.38019122262781) (0x0000b0a7)*/
+    0x0000b97d,  /* bits=15 0.00002211  1/32767  * (1/1.38019122262781) (0x00016150)*/
+    0x00005cbe,  /* bits=16 0.00001106  1/65535  * (1/1.38019122262781) (0x0002c2a5)*/
+};
+
+
+const OI_UINT32 dequant_long_unscaled[17] = {
+    0,
+    0,
+    0x2aaaaaab,  /* bits=2  0.33333333  1/3      (0x00000005)*/
+    0x12492492,  /* bits=3  0.14285714  1/7      (0x0000000e)*/
+    0x08888889,  /* bits=4  0.06666667  1/15     (0x0000001d)*/
+    0x04210842,  /* bits=5  0.03225806  1/31     (0x0000003e)*/
+    0x02082082,  /* bits=6  0.01587302  1/63     (0x0000007e)*/
+    0x01020408,  /* bits=7  0.00787402  1/127    (0x000000fe)*/
+    0x00808081,  /* bits=8  0.00392157  1/255    (0x000001fd)*/
+    0x00402010,  /* bits=9  0.00195695  1/511    (0x000003fe)*/
+    0x00200802,  /* bits=10 0.00097752  1/1023   (0x000007fe)*/
+    0x00100200,  /* bits=11 0.00048852  1/2047   (0x00000ffe)*/
+    0x00080080,  /* bits=12 0.00024420  1/4095   (0x00001ffe)*/
+    0x00040020,  /* bits=13 0.00012209  1/8191   (0x00003ffe)*/
+    0x00020008,  /* bits=14 0.00006104  1/16383  (0x00007ffe)*/
+    0x00010002,  /* bits=15 0.00003052  1/32767  (0x0000fffe)*/
+    0x00008001,  /* bits=16 0.00001526  1/65535  (0x0001fffc)*/
+};
+
+#if defined(OI_DEBUG) || defined(PRINT_SAMPLES) || defined(PRINT_SCALEFACTORS)
+#include <stdio.h>
+#endif
+
+#ifdef USE_WIDE_CRC
+INLINE OI_CHAR crc_iterate(OI_UINT8 oldcrc, OI_UINT8 next)
+{
+    OI_UINT crc;
+    OI_UINT idx;
+    idx = oldcrc^next;
+    crc = crc8_wide[idx >> 1];
+    if (idx%2) {
+        crc &= 0xff;
+    } else {
+        crc >>= 8;
+    }
+
+    return crc;
+}
+
+INLINE OI_CHAR crc_iterate_top4(OI_UINT8 oldcrc, OI_UINT8 next)
+{
+    OI_UINT crc;
+    OI_UINT idx;
+    idx = (oldcrc ^ next) >> 4;
+    crc = crc8_wide[idx>>1];
+    if (idx%2) {
+        crc &= 0xff;
+    } else {
+        crc >>= 8;
+    }
+
+    return (oldcrc << 4) ^ crc;
+}
+
+#else // USE_WIDE_CRC
+
+INLINE OI_UINT8 crc_iterate_top4(OI_UINT8 oldcrc, OI_UINT8 next)
+{
+    return (oldcrc << 4) ^ crc8_narrow[(oldcrc^next) >> 4];
+}
+
+#ifdef USE_NIBBLEWISE_CRC
+INLINE OI_UINT8 crc_iterate(OI_UINT8 crc, OI_UINT8 next)
+{
+    crc = (crc << 4) ^ crc8_narrow[(crc^next) >> 4];
+    crc = (crc << 4) ^ crc8_narrow[((crc>>4)^next)&0xf];
+
+    return crc;
+}
+
+#else   // USE_NIBBLEWISE_CRC
+INLINE OI_UINT8 crc_iterate(OI_UINT8 crc, OI_UINT8 next)
+{
+  return crc8_narrow[crc^next];
+}
+
+#endif  // USE_NIBBLEWISE_CRC
+
+#endif // USE_WIDE_CRC
+
+
+PRIVATE OI_UINT8 OI_SBC_CalculateChecksum(OI_CODEC_SBC_FRAME_INFO *frame, OI_BYTE const *data)
+{
+    OI_UINT i;
+    OI_UINT8 crc = 0x0f;
+    /* Count is the number of whole bytes subject to CRC. Actually, it's one
+     * more than this number, because data[3] is the CRC field itself, which is
+     * explicitly skipped. Since crc_iterate (should be) inlined, it's cheaper
+     * spacewise to include the check in the loop. This shouldn't be much of a
+     * bottleneck routine in the first place. */
+    OI_UINT count = (frame->nrof_subbands * frame->nrof_channels / 2u) + 4;
+
+    if (frame->mode == SBC_JOINT_STEREO && frame->nrof_subbands == 8) {
+        count++;
+    }
+
+    for (i = 1; i < count; i++) {
+        if (i != 3) {
+            crc = crc_iterate(crc,data[i]);
+        }
+    }
+
+    if (frame->mode == SBC_JOINT_STEREO && frame->nrof_subbands == 4) {
+        crc = crc_iterate_top4(crc, data[i]);
+    }
+
+    return crc;
+}
+
+void OI_SBC_ExpandFrameFields(OI_CODEC_SBC_FRAME_INFO *frame)
+{
+    frame->nrof_blocks = block_values[frame->blocks];
+    frame->nrof_subbands = band_values[frame->subbands];
+
+    frame->frequency = freq_values[frame->freqIndex];
+    frame->nrof_channels = channel_values[frame->mode];
+}
+
+/**
+ * Unrolled macro to copy 4 32-bit aligned 32-bit values backward in memory
+ */
+#define COPY4WORDS_BACK(_dest, _src)            \
+    do {                                        \
+            OI_INT32 _a, _b, _c, _d;            \
+            _a = *--_src;                       \
+            _b = *--_src;                       \
+            _c = *--_src;                       \
+            _d = *--_src;                       \
+            *--_dest = _a;                      \
+            *--_dest = _b;                      \
+            *--_dest = _c;                      \
+            *--_dest = _d;                      \
+    } while (0)
+
+
+#if defined(USE_PLATFORM_MEMMOVE) || defined(USE_PLATFORM_MEMCPY)
+#include <string.h>
+#endif
+PRIVATE void shift_buffer(SBC_BUFFER_T *dest, SBC_BUFFER_T *src, OI_UINT wordCount)
+{
+#ifdef USE_PLATFORM_MEMMOVE
+    memmove(dest, src, wordCount * sizeof(SBC_BUFFER_T));
+#elif defined(USE_PLATFORM_MEMCPY)
+    OI_ASSERT(((OI_CHAR *)(dest) - (OI_CHAR *)(src)) >= wordCount*sizeof(*dest));
+    memcpy(dest, src, wordCount * sizeof(SBC_BUFFER_T));
+#else
+    OI_UINT n;
+    OI_INT32 *d;
+    OI_INT32 *s;
+    n = wordCount / 4 / (sizeof(OI_INT32)/sizeof(*dest));
+    OI_ASSERT((n * 4 * (sizeof(OI_INT32)/sizeof(*dest))) == wordCount);
+
+    d = (void*)(dest + wordCount);
+    s = (void*)(src + wordCount);
+
+    do {
+        COPY4WORDS_BACK(d, s);
+    } while (--n);
+#endif
+}
+/**
+@}
+*/
diff -Naur '--exclude=.git' bluedroid-orig/embdrv/sbc/decoder/srce/framing-sbc.c bluedroid/embdrv/sbc/decoder/srce/framing-sbc.c
--- bluedroid-orig/embdrv/sbc/decoder/srce/framing-sbc.c	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/embdrv/sbc/decoder/srce/framing-sbc.c	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,54 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2014 The Android Open Source Project
+ *  Copyright 2003 - 2004 Open Interface North America, Inc. All rights reserved.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/**********************************************************************************
+  $Revision: #1 $
+***********************************************************************************/
+
+/** @file
+@ingroup codec_internal
+*/
+
+/**@addgroup codec_internal*/
+/**@{*/
+
+#include "oi_codec_sbc_private.h"
+
+const OI_CHAR* const OI_CODEC_SBC_FreqText[] =     { "SBC_FREQ_16000", "SBC_FREQ_32000", "SBC_FREQ_44100", "SBC_FREQ_48000" };
+const OI_CHAR* const OI_CODEC_SBC_ModeText[] =     { "SBC_MONO", "SBC_DUAL_CHANNEL", "SBC_STEREO", "SBC_JOINT_STEREO" };
+const OI_CHAR* const OI_CODEC_SBC_SubbandsText[] = { "SBC_SUBBANDS_4", "SBC_SUBBANDS_8" };
+const OI_CHAR* const OI_CODEC_SBC_BlocksText[] =   { "SBC_BLOCKS_4", "SBC_BLOCKS_8", "SBC_BLOCKS_12", "SBC_BLOCKS_16" };
+const OI_CHAR* const OI_CODEC_SBC_AllocText[] =    { "SBC_LOUDNESS", "SBC_SNR" };
+
+#ifdef OI_DEBUG
+void OI_CODEC_SBC_DumpConfig(OI_CODEC_SBC_FRAME_INFO *frameInfo)
+{
+    printf("SBC configuration\n");
+    printf("  enhanced:  %s\n", frameInfo->enhanced ? "TRUE" : "FALSE");
+    printf("  frequency: %d\n", frameInfo->frequency);
+    printf("  subbands:  %d\n", frameInfo->nrof_subbands);
+    printf("  blocks:    %d\n", frameInfo->nrof_blocks);
+    printf("  channels:  %d\n", frameInfo->nrof_channels);
+    printf("  mode:      %s\n", OI_CODEC_SBC_ModeText[frameInfo->mode]);
+    printf("  alloc:     %s\n", OI_CODEC_SBC_AllocText[frameInfo->alloc]);
+    printf("  bitpool:   %d\n", frameInfo->bitpool);
+}
+#endif /* OI_DEBUG */
+
+/**@}*/
diff -Naur '--exclude=.git' bluedroid-orig/embdrv/sbc/decoder/srce/oi_codec_version.c bluedroid/embdrv/sbc/decoder/srce/oi_codec_version.c
--- bluedroid-orig/embdrv/sbc/decoder/srce/oi_codec_version.c	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/embdrv/sbc/decoder/srce/oi_codec_version.c	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,57 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2014 The Android Open Source Project
+ *  Copyright 2002 - 2004 Open Interface North America, Inc. All rights reserved.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/**
+@file
+This file contains a single function, which returns a string indicating the
+version number of the eSBC codec
+
+@ingroup codec_internal
+*/
+
+/**
+@addtogroup codec_internal
+@{
+*/
+
+/**********************************************************************************
+  $Revision: #1 $
+***********************************************************************************/
+
+#include "oi_stddefs.h"
+#include "oi_codec_sbc_private.h"
+
+/** Version string for the BLUEmagic 3.0 protocol stack and profiles */
+PRIVATE OI_CHAR * const codecVersion = "v1.5"
+#ifdef OI_SBC_EVAL
+" (Evaluation version)"
+#endif
+;
+
+/** This function returns the version string for the BLUEmagic 3.0 protocol stack
+    and profiles */
+OI_CHAR *OI_CODEC_Version(void) {
+    return codecVersion;
+}
+
+/**********************************************************************************/
+
+/**
+@}
+*/
diff -Naur '--exclude=.git' bluedroid-orig/embdrv/sbc/decoder/srce/readsamplesjoint.inc bluedroid/embdrv/sbc/decoder/srce/readsamplesjoint.inc
--- bluedroid-orig/embdrv/sbc/decoder/srce/readsamplesjoint.inc	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/embdrv/sbc/decoder/srce/readsamplesjoint.inc	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,111 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2014 The Android Open Source Project
+ *  Copyright 2003 - 2004 Open Interface North America, Inc. All rights reserved.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/*******************************************************************************
+ * @file readsamplesjoint.inc
+ *
+ * This is the body of the generic version of OI_SBC_ReadSamplesJoint().
+ * It is designed to be \#included into a function as follows:
+    \code
+    void OI_SBC_ReadSamplesJoint4(OI_CODEC_SBC_COMMON_CONTEXT *common, OI_BITSTREAM *global_bs)
+    {
+        #define NROF_SUBBANDS 4
+        #include "readsamplesjoint.inc"
+        #undef NROF_SUBBANDS
+    }
+
+    void OI_SBC_ReadSamplesJoint8(OI_CODEC_SBC_COMMON_CONTEXT *common, OI_BITSTREAM *global_bs)
+    {
+        #define NROF_SUBBANDS 8
+        #include "readsamplesjoint.inc"
+        #undef NROF_SUBBANDS
+    }
+    \endcode
+ * Or to make a generic version:
+    \code
+    void OI_SBC_ReadSamplesJoint(OI_CODEC_SBC_COMMON_CONTEXT *common, OI_BITSTREAM *global_bs)
+    {
+        OI_UINT nrof_subbands = common->frameInfo.nrof_subbands;
+
+        #define NROF_SUBBANDS nrof_subbands
+        #include "readsamplesjoint.inc"
+        #undef NROF_SUBBANDS
+    }
+    \endcode
+ * @ingroup codec_internal
+ *******************************************************************************/
+
+/**********************************************************************************
+  $Revision: #1 $
+***********************************************************************************/
+
+{
+    OI_CODEC_SBC_COMMON_CONTEXT *common = &context->common;
+    OI_UINT bl = common->frameInfo.nrof_blocks;
+    OI_INT32 * RESTRICT s = common->subdata;
+    OI_UINT8 *ptr = global_bs->ptr.w;
+    OI_UINT32 value = global_bs->value;
+    OI_UINT bitPtr = global_bs->bitPtr;
+    OI_UINT8 jmask = common->frameInfo.join << (8 - NROF_SUBBANDS);
+
+    do {
+        OI_INT8 *sf_array = &common->scale_factor[0];
+        OI_UINT8 *bits_array = &common->bits.uint8[0];
+        OI_UINT8 joint = jmask;
+        OI_UINT sb;
+        /*
+         * Left channel
+         */
+        sb = NROF_SUBBANDS;
+        do {
+            OI_UINT32 raw;
+            OI_INT32 dequant;
+            OI_UINT8 bits = *bits_array++;
+            OI_INT sf = *sf_array++;
+
+            OI_BITSTREAM_READUINT(raw, bits, ptr, value, bitPtr);
+            dequant = OI_SBC_Dequant(raw, sf, bits);
+            *s++ = dequant;
+        } while (--sb);
+        /*
+         * Right channel
+         */
+        sb = NROF_SUBBANDS;
+        do {
+            OI_UINT32 raw;
+            OI_INT32 dequant;
+            OI_UINT8 bits = *bits_array++;
+            OI_INT sf = *sf_array++;
+
+            OI_BITSTREAM_READUINT(raw, bits, ptr, value, bitPtr);
+            dequant = OI_SBC_Dequant(raw, sf, bits);
+            /*
+             * Check if we need to do mid/side
+             */
+            if (joint & 0x80) {
+                OI_INT32 mid = *(s - NROF_SUBBANDS);
+                OI_INT32 side = dequant;
+                *(s - NROF_SUBBANDS) = mid + side;
+                dequant = mid - side;
+            }
+            joint <<= 1;
+            *s++ = dequant;
+        } while (--sb);
+    } while (--bl);
+}
diff -Naur '--exclude=.git' bluedroid-orig/embdrv/sbc/decoder/srce/synthesis-8-generated.c bluedroid/embdrv/sbc/decoder/srce/synthesis-8-generated.c
--- bluedroid-orig/embdrv/sbc/decoder/srce/synthesis-8-generated.c	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/embdrv/sbc/decoder/srce/synthesis-8-generated.c	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,135 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2014 The Android Open Source Project
+ *  Copyright 2003 - 2004 Open Interface North America, Inc. All rights reserved.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/**
+ @file
+
+ DO NOT EDIT THIS FILE DIRECTLY
+
+ This file is automatically generated by the "synthesis-gen.pl" script.
+ Any changes to this generated file will be lost when the script is re-run.
+
+ These functions are called by functions in synthesis.c to perform the synthesis
+ filterbank computations for the SBC decoder.
+
+
+ */
+
+#include <oi_codec_sbc_private.h>
+
+#ifndef CLIP_INT16
+#define CLIP_INT16(x) do { if (x > OI_INT16_MAX) { x = OI_INT16_MAX; } else if (x < OI_INT16_MIN) { x = OI_INT16_MIN; } } while (0)
+#endif
+
+#define MUL_16S_16S(_x, _y) ((_x) * (_y))
+
+PRIVATE void SynthWindow80_generated(OI_INT16 *pcm, SBC_BUFFER_T const * RESTRICT buffer, OI_UINT strideShift)
+{
+    OI_INT32 pcm_a, pcm_b;
+    /* 1 - stage 0 */ pcm_b = 0;
+    /* 1 - stage 0 */ pcm_b +=(MUL_16S_16S(8235, buffer[ 12]))>> 3;
+    /* 1 - stage 0 */ pcm_b +=(MUL_16S_16S(-23167, buffer[ 20]))>> 3;
+    /* 1 - stage 0 */ pcm_b +=(MUL_16S_16S(26479, buffer[ 28]))>> 2;
+    /* 1 - stage 0 */ pcm_b +=(MUL_16S_16S(-17397, buffer[ 36]))<< 1;
+    /* 1 - stage 0 */ pcm_b +=(MUL_16S_16S(9399, buffer[ 44]))<< 3;
+    /* 1 - stage 0 */ pcm_b +=(MUL_16S_16S(17397, buffer[ 52]))<< 1;
+    /* 1 - stage 0 */ pcm_b +=(MUL_16S_16S(26479, buffer[ 60]))>> 2;
+    /* 1 - stage 0 */ pcm_b +=(MUL_16S_16S(23167, buffer[ 68]))>> 3;
+    /* 1 - stage 0 */ pcm_b +=(MUL_16S_16S(8235, buffer[ 76]))>> 3;
+    /* 1 - stage 0 */ pcm_b /= 32768; CLIP_INT16(pcm_b); pcm[0<<strideShift] = (OI_INT16)pcm_b;
+    /* 1 - stage 1 */ pcm_a = 0;
+    /* 1 - stage 1 */ pcm_b = 0;
+    /* 1 - stage 1 */ pcm_a +=(MUL_16S_16S(-3263, buffer[  5]))>> 5;
+    /* 1 - stage 1 */ pcm_b +=(MUL_16S_16S(9293, buffer[  5]))>> 3;
+    /* 1 - stage 1 */ pcm_a +=(MUL_16S_16S(29293, buffer[ 11]))>> 5;
+    /* 1 - stage 1 */ pcm_b +=(MUL_16S_16S(-6087, buffer[ 11]))>> 2;
+    /* 1 - stage 1 */ pcm_a +=(MUL_16S_16S(-5229, buffer[ 21]));
+    /* 1 - stage 1 */ pcm_b +=(MUL_16S_16S(1247, buffer[ 21]))<< 3;
+    /* 1 - stage 1 */ pcm_a +=(MUL_16S_16S(30835, buffer[ 27]))>> 3;
+    /* 1 - stage 1 */ pcm_b +=(MUL_16S_16S(-2893, buffer[ 27]))<< 3;
+    /* 1 - stage 1 */ pcm_a +=(MUL_16S_16S(-27021, buffer[ 37]))<< 1;
+    /* 1 - stage 1 */ pcm_b +=(MUL_16S_16S(23671, buffer[ 37]))<< 2;
+    /* 1 - stage 1 */ pcm_a +=(MUL_16S_16S(31633, buffer[ 43]))<< 1;
+    /* 1 - stage 1 */ pcm_b +=(MUL_16S_16S(18055, buffer[ 43]))<< 1;
+    /* 1 - stage 1 */ pcm_a +=(MUL_16S_16S(17319, buffer[ 53]))<< 1;
+    /* 1 - stage 1 */ pcm_b +=(MUL_16S_16S(11537, buffer[ 53]))>> 1;
+    /* 1 - stage 1 */ pcm_a +=(MUL_16S_16S(26663, buffer[ 59]))>> 2;
+    /* 1 - stage 1 */ pcm_b +=(MUL_16S_16S(1747, buffer[ 59]))<< 1;
+    /* 1 - stage 1 */ pcm_a +=(MUL_16S_16S(4555, buffer[ 69]))>> 1;
+    /* 1 - stage 1 */ pcm_b +=(MUL_16S_16S(685, buffer[ 69]))<< 1;
+    /* 1 - stage 1 */ pcm_a +=(MUL_16S_16S(12419, buffer[ 75]))>> 4;
+    /* 1 - stage 1 */ pcm_b +=(MUL_16S_16S(8721, buffer[ 75]))>> 7;
+    /* 1 - stage 1 */ pcm_a /= 32768; CLIP_INT16(pcm_a); pcm[1<<strideShift] = (OI_INT16)pcm_a;
+    /* 1 - stage 1 */ pcm_b /= 32768; CLIP_INT16(pcm_b); pcm[7<<strideShift] = (OI_INT16)pcm_b;
+    /* 1 - stage 2 */ pcm_a = 0;
+    /* 1 - stage 2 */ pcm_b = 0;
+    /* 1 - stage 2 */ pcm_a +=(MUL_16S_16S(-10385, buffer[  6]))>> 6;
+    /* 1 - stage 2 */ pcm_b +=(MUL_16S_16S(11167, buffer[  6]))>> 4;
+    /* 1 - stage 2 */ pcm_a +=(MUL_16S_16S(24995, buffer[ 10]))>> 5;
+    /* 1 - stage 2 */ pcm_b +=(MUL_16S_16S(-10337, buffer[ 10]))>> 4;
+    /* 1 - stage 2 */ pcm_a +=(MUL_16S_16S(-309, buffer[ 22]))<< 4;
+    /* 1 - stage 2 */ pcm_b +=(MUL_16S_16S(1917, buffer[ 22]))<< 2;
+    /* 1 - stage 2 */ pcm_a +=(MUL_16S_16S(9161, buffer[ 26]))>> 3;
+    /* 1 - stage 2 */ pcm_b +=(MUL_16S_16S(-30605, buffer[ 26]))>> 1;
+    /* 1 - stage 2 */ pcm_a +=(MUL_16S_16S(-23063, buffer[ 38]))<< 1;
+    /* 1 - stage 2 */ pcm_b +=(MUL_16S_16S(8317, buffer[ 38]))<< 3;
+    /* 1 - stage 2 */ pcm_a +=(MUL_16S_16S(27561, buffer[ 42]))<< 1;
+    /* 1 - stage 2 */ pcm_b +=(MUL_16S_16S(9553, buffer[ 42]))<< 2;
+    /* 1 - stage 2 */ pcm_a +=(MUL_16S_16S(2309, buffer[ 54]))<< 3;
+    /* 1 - stage 2 */ pcm_b +=(MUL_16S_16S(22117, buffer[ 54]))>> 4;
+    /* 1 - stage 2 */ pcm_a +=(MUL_16S_16S(12705, buffer[ 58]))>> 1;
+    /* 1 - stage 2 */ pcm_b +=(MUL_16S_16S(16383, buffer[ 58]))>> 2;
+    /* 1 - stage 2 */ pcm_a +=(MUL_16S_16S(6239, buffer[ 70]))>> 3;
+    /* 1 - stage 2 */ pcm_b +=(MUL_16S_16S(7543, buffer[ 70]))>> 3;
+    /* 1 - stage 2 */ pcm_a +=(MUL_16S_16S(9251, buffer[ 74]))>> 4;
+    /* 1 - stage 2 */ pcm_b +=(MUL_16S_16S(8603, buffer[ 74]))>> 6;
+    /* 1 - stage 2 */ pcm_a /= 32768; CLIP_INT16(pcm_a); pcm[2<<strideShift] = (OI_INT16)pcm_a;
+    /* 1 - stage 2 */ pcm_b /= 32768; CLIP_INT16(pcm_b); pcm[6<<strideShift] = (OI_INT16)pcm_b;
+    /* 1 - stage 3 */ pcm_a = 0;
+    /* 1 - stage 3 */ pcm_b = 0;
+    /* 1 - stage 3 */ pcm_a +=(MUL_16S_16S(-16457, buffer[  7]))>> 6;
+    /* 1 - stage 3 */ pcm_b +=(MUL_16S_16S(16913, buffer[  7]))>> 5;
+    /* 1 - stage 3 */ pcm_a +=(MUL_16S_16S(19083, buffer[  9]))>> 5;
+    /* 1 - stage 3 */ pcm_b +=(MUL_16S_16S(-8443, buffer[  9]))>> 7;
+    /* 1 - stage 3 */ pcm_a +=(MUL_16S_16S(-23641, buffer[ 23]))>> 2;
+    /* 1 - stage 3 */ pcm_b +=(MUL_16S_16S(3687, buffer[ 23]))<< 1;
+    /* 1 - stage 3 */ pcm_a +=(MUL_16S_16S(-29015, buffer[ 25]))>> 4;
+    /* 1 - stage 3 */ pcm_b +=(MUL_16S_16S(-301, buffer[ 25]))<< 5;
+    /* 1 - stage 3 */ pcm_a +=(MUL_16S_16S(-12889, buffer[ 39]))<< 2;
+    /* 1 - stage 3 */ pcm_b +=(MUL_16S_16S(15447, buffer[ 39]))<< 2;
+    /* 1 - stage 3 */ pcm_a +=(MUL_16S_16S(6145, buffer[ 41]))<< 3;
+    /* 1 - stage 3 */ pcm_b +=(MUL_16S_16S(10255, buffer[ 41]))<< 2;
+    /* 1 - stage 3 */ pcm_a +=(MUL_16S_16S(24211, buffer[ 55]))>> 1;
+    /* 1 - stage 3 */ pcm_b +=(MUL_16S_16S(-18233, buffer[ 55]))>> 3;
+    /* 1 - stage 3 */ pcm_a +=(MUL_16S_16S(23469, buffer[ 57]))>> 2;
+    /* 1 - stage 3 */ pcm_b +=(MUL_16S_16S(9405, buffer[ 57]))>> 1;
+    /* 1 - stage 3 */ pcm_a +=(MUL_16S_16S(21223, buffer[ 71]))>> 8;
+    /* 1 - stage 3 */ pcm_b +=(MUL_16S_16S(1499, buffer[ 71]))>> 1;
+    /* 1 - stage 3 */ pcm_a +=(MUL_16S_16S(26913, buffer[ 73]))>> 6;
+    /* 1 - stage 3 */ pcm_b +=(MUL_16S_16S(26189, buffer[ 73]))>> 7;
+    /* 1 - stage 3 */ pcm_a /= 32768; CLIP_INT16(pcm_a); pcm[3<<strideShift] = (OI_INT16)pcm_a;
+    /* 1 - stage 3 */ pcm_b /= 32768; CLIP_INT16(pcm_b); pcm[5<<strideShift] = (OI_INT16)pcm_b;
+    /* 1 - stage 4 */ pcm_a = 0;
+    /* 1 - stage 4 */ pcm_a +=(MUL_16S_16S(10445, buffer[  8]))>> 4;
+    /* 1 - stage 4 */ pcm_a +=(MUL_16S_16S(-5297, buffer[ 24]))<< 1;
+    /* 1 - stage 4 */ pcm_a +=(MUL_16S_16S(22299, buffer[ 40]))<< 2;
+    /* 1 - stage 4 */ pcm_a +=(MUL_16S_16S(10603, buffer[ 56]));
+    /* 1 - stage 4 */ pcm_a +=(MUL_16S_16S(9539, buffer[ 72]))>> 4;
+    /* 1 - stage 4 */ pcm_a /= 32768; CLIP_INT16(pcm_a); pcm[4<<strideShift] = (OI_INT16)pcm_a;
+}
diff -Naur '--exclude=.git' bluedroid-orig/embdrv/sbc/decoder/srce/synthesis-dct8.c bluedroid/embdrv/sbc/decoder/srce/synthesis-dct8.c
--- bluedroid-orig/embdrv/sbc/decoder/srce/synthesis-dct8.c	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/embdrv/sbc/decoder/srce/synthesis-dct8.c	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,305 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2014 The Android Open Source Project
+ *  Copyright 2003 - 2004 Open Interface North America, Inc. All rights reserved.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/**********************************************************************************
+  $Revision: #1 $
+***********************************************************************************/
+
+/** @file
+@ingroup codec_internal
+*/
+
+/**@addgroup codec_internal*/
+/**@{*/
+
+/*
+ * Performs an 8-point Type-II scaled DCT using the Arai-Agui-Nakajima
+ * factorization. The scaling factors are folded into the windowing
+ * constants. 29 adds and 5 16x32 multiplies per 8 samples.
+ */
+
+#include "oi_codec_sbc_private.h"
+
+#define AAN_C4_FIX (759250125)/* S1.30  759250125   0.707107*/
+
+#define AAN_C6_FIX (410903207)/* S1.30  410903207   0.382683*/
+
+#define AAN_Q0_FIX (581104888)/* S1.30  581104888   0.541196*/
+
+#define AAN_Q1_FIX (1402911301)/* S1.30 1402911301   1.306563*/
+
+/** Scales x by y bits to the right, adding a rounding factor.
+ */
+#ifndef SCALE
+#define SCALE(x, y) (((x) + (1 <<((y)-1))) >> (y))
+#endif
+
+/**
+ * Default C language implementation of a 32x32->32 multiply. This function may
+ * be replaced by a platform-specific version for speed.
+ *
+ * @param u A signed 32-bit multiplicand
+ * @param v A signed 32-bit multiplier
+
+ * @return  A signed 32-bit value corresponding to the 32 most significant bits
+ * of the 64-bit product of u and v.
+ */
+INLINE OI_INT32 default_mul_32s_32s_hi(OI_INT32 u, OI_INT32 v)
+{
+    OI_UINT32 u0, v0;
+    OI_INT32 u1, v1, w1, w2, t;
+
+    u0 = u & 0xFFFF; u1 = u >> 16;
+    v0 = v & 0xFFFF; v1 = v >> 16;
+    t = u0*v0;
+    t = u1*v0 + ((OI_UINT32)t >> 16);
+    w1 = t & 0xFFFF;
+    w2 = t >> 16;
+    w1 = u0*v1 + w1;
+    return u1*v1 + w2 + (w1 >> 16);
+}
+
+#define MUL_32S_32S_HI(_x, _y) default_mul_32s_32s_hi(_x, _y)
+
+
+#ifdef DEBUG_DCT
+PRIVATE void float_dct2_8(float * RESTRICT out, OI_INT32 const *RESTRICT in)
+{
+#define FIX(x,bits) (((int)floor(0.5f+((x)*((float)(1<<bits)))))/((float)(1<<bits)))
+#define FLOAT_BUTTERFLY(x,y) x += y; y = x - (y*2); OI_ASSERT(VALID_INT32(x)); OI_ASSERT(VALID_INT32(y));
+#define FLOAT_MULT_DCT(K, sample) (FIX(K,20) * sample)
+#define FLOAT_SCALE(x, y) (((x) / (double)(1 << (y))))
+
+    double L00,L01,L02,L03,L04,L05,L06,L07;
+    double L25;
+
+    double in0,in1,in2,in3;
+    double in4,in5,in6,in7;
+
+    in0 = FLOAT_SCALE(in[0], DCTII_8_SHIFT_IN); OI_ASSERT(VALID_INT32(in0));
+    in1 = FLOAT_SCALE(in[1], DCTII_8_SHIFT_IN); OI_ASSERT(VALID_INT32(in1));
+    in2 = FLOAT_SCALE(in[2], DCTII_8_SHIFT_IN); OI_ASSERT(VALID_INT32(in2));
+    in3 = FLOAT_SCALE(in[3], DCTII_8_SHIFT_IN); OI_ASSERT(VALID_INT32(in3));
+    in4 = FLOAT_SCALE(in[4], DCTII_8_SHIFT_IN); OI_ASSERT(VALID_INT32(in4));
+    in5 = FLOAT_SCALE(in[5], DCTII_8_SHIFT_IN); OI_ASSERT(VALID_INT32(in5));
+    in6 = FLOAT_SCALE(in[6], DCTII_8_SHIFT_IN); OI_ASSERT(VALID_INT32(in6));
+    in7 = FLOAT_SCALE(in[7], DCTII_8_SHIFT_IN); OI_ASSERT(VALID_INT32(in7));
+
+    L00 = (in0 + in7); OI_ASSERT(VALID_INT32(L00));
+    L01 = (in1 + in6); OI_ASSERT(VALID_INT32(L01));
+    L02 = (in2 + in5); OI_ASSERT(VALID_INT32(L02));
+    L03 = (in3 + in4); OI_ASSERT(VALID_INT32(L03));
+
+    L04 = (in3 - in4); OI_ASSERT(VALID_INT32(L04));
+    L05 = (in2 - in5); OI_ASSERT(VALID_INT32(L05));
+    L06 = (in1 - in6); OI_ASSERT(VALID_INT32(L06));
+    L07 = (in0 - in7); OI_ASSERT(VALID_INT32(L07));
+
+    FLOAT_BUTTERFLY(L00, L03);
+    FLOAT_BUTTERFLY(L01, L02);
+
+    L02 += L03; OI_ASSERT(VALID_INT32(L02));
+
+    L02 = FLOAT_MULT_DCT(AAN_C4_FLOAT, L02); OI_ASSERT(VALID_INT32(L02));
+
+    FLOAT_BUTTERFLY(L00, L01);
+
+    out[0] = (float)FLOAT_SCALE(L00, DCTII_8_SHIFT_0); OI_ASSERT(VALID_INT16(out[0]));
+    out[4] = (float)FLOAT_SCALE(L01, DCTII_8_SHIFT_4); OI_ASSERT(VALID_INT16(out[4]));
+
+    FLOAT_BUTTERFLY(L03, L02);
+    out[6] = (float)FLOAT_SCALE(L02, DCTII_8_SHIFT_6); OI_ASSERT(VALID_INT16(out[6]));
+    out[2] = (float)FLOAT_SCALE(L03, DCTII_8_SHIFT_2); OI_ASSERT(VALID_INT16(out[2]));
+
+    L04 += L05; OI_ASSERT(VALID_INT32(L04));
+    L05 += L06; OI_ASSERT(VALID_INT32(L05));
+    L06 += L07; OI_ASSERT(VALID_INT32(L06));
+
+    L04/=2;
+    L05/=2;
+    L06/=2;
+    L07/=2;
+
+    L05 = FLOAT_MULT_DCT(AAN_C4_FLOAT, L05); OI_ASSERT(VALID_INT32(L05));
+
+    L25 = L06 - L04; OI_ASSERT(VALID_INT32(L25));
+    L25 = FLOAT_MULT_DCT(AAN_C6_FLOAT, L25); OI_ASSERT(VALID_INT32(L25));
+
+    L04 = FLOAT_MULT_DCT(AAN_Q0_FLOAT, L04); OI_ASSERT(VALID_INT32(L04));
+    L04 -= L25; OI_ASSERT(VALID_INT32(L04));
+
+    L06 = FLOAT_MULT_DCT(AAN_Q1_FLOAT, L06); OI_ASSERT(VALID_INT32(L06));
+    L06 -= L25; OI_ASSERT(VALID_INT32(L25));
+
+    FLOAT_BUTTERFLY(L07, L05);
+
+    FLOAT_BUTTERFLY(L05, L04);
+    out[3] = (float)(FLOAT_SCALE(L04, DCTII_8_SHIFT_3-1)); OI_ASSERT(VALID_INT16(out[3]));
+    out[5] = (float)(FLOAT_SCALE(L05, DCTII_8_SHIFT_5-1)); OI_ASSERT(VALID_INT16(out[5]));
+
+    FLOAT_BUTTERFLY(L07, L06);
+    out[7] = (float)(FLOAT_SCALE(L06, DCTII_8_SHIFT_7-1)); OI_ASSERT(VALID_INT16(out[7]));
+    out[1] = (float)(FLOAT_SCALE(L07, DCTII_8_SHIFT_1-1)); OI_ASSERT(VALID_INT16(out[1]));
+}
+#undef BUTTERFLY
+#endif
+
+
+/*
+ * This function calculates the AAN DCT. Its inputs are in S16.15 format, as
+ * returned by OI_SBC_Dequant. In practice, abs(in[x]) < 52429.0 / 1.38
+ * (1244918057 integer). The function it computes is an approximation to the array defined
+ * by:
+ *
+ * diag(aan_s) * AAN= C2
+ *
+ *   or
+ *
+ * AAN = diag(1/aan_s) * C2
+ *
+ * where C2 is as it is defined in the comment at the head of this file, and
+ *
+ * aan_s[i] = aan_s = 1/(2*cos(i*pi/16)) with i = 1..7, aan_s[0] = 1;
+ *
+ * aan_s[i] = [ 1.000  0.510  0.541  0.601  0.707  0.900  1.307  2.563 ]
+ *
+ * The output ranges are shown as follows:
+ *
+ * Let Y[0..7] = AAN * X[0..7]
+ *
+ * Without loss of generality, assume the input vector X consists of elements
+ * between -1 and 1. The maximum possible value of a given output element occurs
+ * with some particular combination of input vector elements each of which is -1
+ * or 1. Consider the computation of Y[i]. Y[i] = sum t=0..7 of AAN[t,i]*X[i]. Y is
+ * maximized if the sign of X[i] matches the sign of AAN[t,i], ensuring a
+ * positive contribution to the sum. Equivalently, one may simply sum
+ * abs(AAN)[t,i] over t to get the maximum possible value of Y[i].
+ *
+ * This yields approximately [8.00  10.05   9.66   8.52   8.00   5.70   4.00   2.00]
+ *
+ * Given the maximum magnitude sensible input value of +/-37992, this yields the
+ * following vector of maximum output magnitudes:
+ *
+ * [ 303936  381820  367003  323692  303936  216555  151968   75984 ]
+ *
+ * Ultimately, these values must fit into 16 bit signed integers, so they must
+ * be scaled. A non-uniform scaling helps maximize the kept precision. The
+ * relative number of extra bits of precision maintainable with respect to the
+ * largest value is given here:
+ *
+ * [ 0  0  0  0  0  0  1  2 ]
+ *
+ */
+PRIVATE void dct2_8(SBC_BUFFER_T * RESTRICT out, OI_INT32 const *RESTRICT in)
+{
+#define BUTTERFLY(x,y) x += y; y = x - (y<<1);
+#define FIX_MULT_DCT(K, x) (MUL_32S_32S_HI(K,x)<<2)
+
+    OI_INT32 L00,L01,L02,L03,L04,L05,L06,L07;
+    OI_INT32 L25;
+
+    OI_INT32 in0,in1,in2,in3;
+    OI_INT32 in4,in5,in6,in7;
+
+#if DCTII_8_SHIFT_IN != 0
+    in0 = SCALE(in[0], DCTII_8_SHIFT_IN);
+    in1 = SCALE(in[1], DCTII_8_SHIFT_IN);
+    in2 = SCALE(in[2], DCTII_8_SHIFT_IN);
+    in3 = SCALE(in[3], DCTII_8_SHIFT_IN);
+    in4 = SCALE(in[4], DCTII_8_SHIFT_IN);
+    in5 = SCALE(in[5], DCTII_8_SHIFT_IN);
+    in6 = SCALE(in[6], DCTII_8_SHIFT_IN);
+    in7 = SCALE(in[7], DCTII_8_SHIFT_IN);
+#else
+    in0 = in[0];
+    in1 = in[1];
+    in2 = in[2];
+    in3 = in[3];
+    in4 = in[4];
+    in5 = in[5];
+    in6 = in[6];
+    in7 = in[7];
+#endif
+
+    L00 = in0 + in7;
+    L01 = in1 + in6;
+    L02 = in2 + in5;
+    L03 = in3 + in4;
+
+    L04 = in3 - in4;
+    L05 = in2 - in5;
+    L06 = in1 - in6;
+    L07 = in0 - in7;
+
+    BUTTERFLY(L00, L03);
+    BUTTERFLY(L01, L02);
+
+    L02 += L03;
+
+    L02 = FIX_MULT_DCT(AAN_C4_FIX, L02);
+
+    BUTTERFLY(L00, L01);
+
+    out[0] = (OI_INT16)SCALE(L00, DCTII_8_SHIFT_0);
+    out[4] = (OI_INT16)SCALE(L01, DCTII_8_SHIFT_4);
+
+    BUTTERFLY(L03, L02);
+    out[6] = (OI_INT16)SCALE(L02, DCTII_8_SHIFT_6);
+    out[2] = (OI_INT16)SCALE(L03, DCTII_8_SHIFT_2);
+
+    L04 += L05;
+    L05 += L06;
+    L06 += L07;
+
+    L04/=2;
+    L05/=2;
+    L06/=2;
+    L07/=2;
+
+    L05 = FIX_MULT_DCT(AAN_C4_FIX, L05);
+
+    L25 = L06 - L04;
+    L25 = FIX_MULT_DCT(AAN_C6_FIX, L25);
+
+    L04 = FIX_MULT_DCT(AAN_Q0_FIX, L04);
+    L04 -= L25;
+
+    L06 = FIX_MULT_DCT(AAN_Q1_FIX, L06);
+    L06 -= L25;
+
+    BUTTERFLY(L07, L05);
+
+    BUTTERFLY(L05, L04);
+    out[3] = (OI_INT16)SCALE(L04, DCTII_8_SHIFT_3-1);
+    out[5] = (OI_INT16)SCALE(L05, DCTII_8_SHIFT_5-1);
+
+    BUTTERFLY(L07, L06);
+    out[7] = (OI_INT16)SCALE(L06, DCTII_8_SHIFT_7-1);
+    out[1] = (OI_INT16)SCALE(L07, DCTII_8_SHIFT_1-1);
+#undef BUTTERFLY
+
+#ifdef DEBUG_DCT
+    {
+        float float_out[8];
+        float_dct2_8(float_out, in);
+    }
+#endif
+}
+
+/**@}*/
diff -Naur '--exclude=.git' bluedroid-orig/embdrv/sbc/decoder/srce/synthesis-sbc.c bluedroid/embdrv/sbc/decoder/srce/synthesis-sbc.c
--- bluedroid-orig/embdrv/sbc/decoder/srce/synthesis-sbc.c	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/embdrv/sbc/decoder/srce/synthesis-sbc.c	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,510 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2014 The Android Open Source Project
+ *  Copyright 2003 - 2004 Open Interface North America, Inc. All rights reserved.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/**********************************************************************************
+  $Revision: #1 $
+***********************************************************************************/
+
+/** @file
+
+This file, along with synthesis-generated.c, contains the synthesis
+filterbank routines. The operations performed correspond to the
+operations described in A2DP Appendix B, Figure 12.3. Several
+mathematical optimizations are performed, particularly for the
+8-subband case.
+
+One important optimization is to note that the "matrixing" operation
+can be decomposed into the product of a type II discrete cosine kernel
+and another, sparse matrix.
+
+According to Fig 12.3, in the 8-subband case,
+@code
+    N[k][i] = cos((i+0.5)*(k+4)*pi/8), k = 0..15 and i = 0..7
+@endcode
+
+N can be factored as R * C2, where C2 is an 8-point type II discrete
+cosine kernel given by
+@code
+    C2[k][i] = cos((i+0.5)*k*pi/8)), k = 0..7 and i = 0..7
+@endcode
+
+R turns out to be a sparse 16x8 matrix with the following non-zero
+entries:
+@code
+    R[k][k+4]        =  1,   k = 0..3
+    R[k][abs(12-k)]  = -1,   k = 5..15
+@endcode
+
+The spec describes computing V[0..15] as N * R.
+@code
+    V[0..15] = N * R = (R * C2) * R = R * (C2 * R)
+@endcode
+
+C2 * R corresponds to computing the discrete cosine transform of R, so
+V[0..15] can be computed by taking the DCT of R followed by assignment
+and selective negation of the DCT result into V.
+
+        Although this was derived empirically using GNU Octave, it is
+        formally demonstrated in, e.g., Liu, Chi-Min and Lee,
+        Wen-Chieh. "A Unified Fast Algorithm for Cosine Modulated
+        Filter Banks in Current Audio Coding Standards." Journal of
+        the AES 47 (December 1999): 1061.
+
+Given the shift operation performed prior to computing V[0..15], it is
+clear that V[0..159] represents a rolling history of the 10 most
+recent groups of blocks input to the synthesis operation. Interpreting
+the matrix N in light of its factorization into C2 and R, R's
+sparseness has implications for interpreting the values in V. In
+particular, there is considerable redundancy in the values stored in
+V. Furthermore, since R[4][0..7] are all zeros, one out of every 16
+values in V will be zero regardless of the input data. Within each
+block of 16 values in V, fully half of them are redundant or
+irrelevant:
+
+@code
+    V[ 0] =  DCT[4]
+    V[ 1] =  DCT[5]
+    V[ 2] =  DCT[6]
+    V[ 3] =  DCT[7]
+    V[ 4] = 0
+    V[ 5] = -DCT[7] = -V[3] (redundant)
+    V[ 6] = -DCT[6] = -V[2] (redundant)
+    V[ 7] = -DCT[5] = -V[1] (redundant)
+    V[ 8] = -DCT[4] = -V[0] (redundant)
+    V[ 9] = -DCT[3]
+    V[10] = -DCT[2]
+    V[11] = -DCT[1]
+    V[12] = -DCT[0]
+    V[13] = -DCT[1] = V[11] (redundant)
+    V[14] = -DCT[2] = V[10] (redundant)
+    V[15] = -DCT[3] = V[ 9] (redundant)
+@endcode
+
+Since the elements of V beyond 15 were originally computed the same
+way during a previous run, what holds true for V[x] also holds true
+for V[x+16]. Thus, so long as care is taken to maintain the mapping,
+we need only actually store the unique values, which correspond to the
+output of the DCT, in some cases inverted. In fact, instead of storing
+V[0..159], we could store DCT[0..79] which would contain a history of
+DCT results. More on this in a bit.
+
+Going back to figure 12.3 in the spec, it should be clear that the
+vector U need not actually be explicitly constructed, but that with
+suitable indexing into V during the window operation, the same end can
+be accomplished. In the same spirit of the pseudocode shown in the
+figure, the following is the construction of W without using U:
+
+@code
+    for i=0 to 79 do
+        W[i] = D[i]*VSIGN(i)*V[remap_V(i)] where remap_V(i) = 32*(int(i/16)) + (i % 16) + (i % 16 >= 8 ? 16 : 0)
+                                             and VSIGN(i) maps i%16 into {1, 1, 1, 1, 0, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1 }
+                                             These values correspond to the
+                                             signs of the redundant values as
+                                             shown in the explanation three
+                                             paragraphs above.
+@endcode
+
+We saw above how V[4..8,13..15] (and by extension
+V[(4..8,13..15)+16*n]) can be defined in terms of other elements
+within the subblock of V. V[0..3,9..12] correspond to DCT elements.
+
+@code
+    for i=0 to 79 do
+        W[i] = D[i]*DSIGN(i)*DCT[remap_DCT(i)]
+@endcode
+
+The DCT is calculated using the Arai-Agui-Nakajima factorization,
+which saves some computation by producing output that needs to be
+multiplied by scaling factors before being used.
+
+@code
+    for i=0 to 79 do
+        W[i] = D[i]*SCALE[i%8]*AAN_DCT[remap_DCT(i)]
+@endcode
+
+D can be premultiplied with the DCT scaling factors to yield
+
+@code
+    for i=0 to 79 do
+        W[i] = DSCALED[i]*AAN_DCT[remap_DCT(i)] where DSCALED[i] = D[i]*SCALE[i%8]
+@endcode
+
+The output samples X[0..7] are defined as sums of W:
+
+@code
+        X[j] = sum{i=0..9}(W[j+8*i])
+@endcode
+
+@ingroup codec_internal
+*/
+
+/**
+@addtogroup codec_internal
+@{
+*/
+
+#include "oi_codec_sbc_private.h"
+
+const OI_INT32 dec_window_4[21] = {
+           0,        /* +0.00000000E+00 */
+          97,        /* +5.36548976E-04 */
+         270,        /* +1.49188357E-03 */
+         495,        /* +2.73370904E-03 */
+         694,        /* +3.83720193E-03 */
+         704,        /* +3.89205149E-03 */
+         338,        /* +1.86581691E-03 */
+        -554,        /* -3.06012286E-03 */
+        1974,        /* +1.09137620E-02 */
+        3697,        /* +2.04385087E-02 */
+        5224,        /* +2.88757392E-02 */
+        5824,        /* +3.21939290E-02 */
+        4681,        /* +2.58767811E-02 */
+        1109,        /* +6.13245186E-03 */
+       -5214,        /* -2.88217274E-02 */
+      -14047,        /* -7.76463494E-02 */
+       24529,        /* +1.35593274E-01 */
+       35274,        /* +1.94987841E-01 */
+       44618,        /* +2.46636662E-01 */
+       50984,        /* +2.81828203E-01 */
+       53243,        /* +2.94315332E-01 */
+};
+
+#define DCTII_4_K06_FIX ( 11585)/* S1.14      11585   0.707107*/
+
+#define DCTII_4_K08_FIX ( 21407)/* S1.14      21407   1.306563*/
+
+#define DCTII_4_K09_FIX (-15137)/* S1.14     -15137  -0.923880*/
+
+#define DCTII_4_K10_FIX ( -8867)/* S1.14      -8867  -0.541196*/
+
+/** Scales x by y bits to the right, adding a rounding factor.
+ */
+#ifndef SCALE
+#define SCALE(x, y) (((x) + (1 <<((y)-1))) >> (y))
+#endif
+
+#ifndef CLIP_INT16
+#define CLIP_INT16(x) do { if (x > OI_INT16_MAX) { x = OI_INT16_MAX; } else if (x < OI_INT16_MIN) { x = OI_INT16_MIN; } } while (0)
+#endif
+
+/**
+ * Default C language implementation of a 16x32->32 multiply. This function may
+ * be replaced by a platform-specific version for speed.
+ *
+ * @param u A signed 16-bit multiplicand
+ * @param v A signed 32-bit multiplier
+
+ * @return  A signed 32-bit value corresponding to the 32 most significant bits
+ * of the 48-bit product of u and v.
+ */
+INLINE OI_INT32 default_mul_16s_32s_hi(OI_INT16 u, OI_INT32 v)
+{
+    OI_UINT16 v0;
+    OI_INT16 v1;
+
+    OI_INT32 w,x;
+
+    v0 = (OI_UINT16)(v & 0xffff);
+    v1 = (OI_INT16) (v >> 16);
+
+    w = v1 * u;
+    x = u * v0;
+
+    return w + (x >> 16);
+}
+
+#define MUL_16S_32S_HI(_x, _y) default_mul_16s_32s_hi(_x, _y)
+
+#define LONG_MULT_DCT(K, sample) (MUL_16S_32S_HI(K, sample)<<2)
+
+PRIVATE void SynthWindow80_generated(OI_INT16 *pcm, SBC_BUFFER_T const * RESTRICT buffer, OI_UINT strideShift);
+PRIVATE void SynthWindow112_generated(OI_INT16 *pcm, SBC_BUFFER_T const * RESTRICT buffer, OI_UINT strideShift);
+PRIVATE void dct2_8(SBC_BUFFER_T * RESTRICT out, OI_INT32 const * RESTRICT x);
+
+typedef void (*SYNTH_FRAME)(OI_CODEC_SBC_DECODER_CONTEXT *context, OI_INT16 *pcm, OI_UINT blkstart, OI_UINT blkcount);
+
+#ifndef COPY_BACKWARD_32BIT_ALIGNED_72_HALFWORDS
+#define COPY_BACKWARD_32BIT_ALIGNED_72_HALFWORDS(dest, src) do { shift_buffer(dest, src, 72); } while (0)
+#endif
+
+#ifndef DCT2_8
+#define DCT2_8(dst, src) dct2_8(dst, src)
+#endif
+
+#ifndef SYNTH80
+#define SYNTH80 SynthWindow80_generated
+#endif
+
+#ifndef SYNTH112
+#define SYNTH112 SynthWindow112_generated
+#endif
+
+PRIVATE void OI_SBC_SynthFrame_80(OI_CODEC_SBC_DECODER_CONTEXT *context, OI_INT16 *pcm, OI_UINT blkstart, OI_UINT blkcount)
+{
+    OI_UINT blk;
+    OI_UINT ch;
+    OI_UINT nrof_channels = context->common.frameInfo.nrof_channels;
+    OI_UINT pcmStrideShift = context->common.pcmStride == 1 ? 0 : 1;
+    OI_UINT offset = context->common.filterBufferOffset;
+    OI_INT32 *s = context->common.subdata + 8 * nrof_channels * blkstart;
+    OI_UINT blkstop = blkstart + blkcount;
+
+    for (blk = blkstart; blk < blkstop; blk++) {
+        if (offset == 0) {
+            COPY_BACKWARD_32BIT_ALIGNED_72_HALFWORDS(context->common.filterBuffer[0] + context->common.filterBufferLen - 72, context->common.filterBuffer[0]);
+            if (nrof_channels == 2) {
+                COPY_BACKWARD_32BIT_ALIGNED_72_HALFWORDS(context->common.filterBuffer[1] + context->common.filterBufferLen - 72, context->common.filterBuffer[1]);
+            }
+            offset = context->common.filterBufferLen - 80;
+        } else {
+            offset -= 1*8;
+        }
+
+        for (ch = 0; ch < nrof_channels; ch++) {
+            DCT2_8(context->common.filterBuffer[ch] + offset, s);
+            SYNTH80(pcm + ch, context->common.filterBuffer[ch] + offset, pcmStrideShift);
+            s += 8;
+        }
+        pcm += (8 << pcmStrideShift);
+    }
+    context->common.filterBufferOffset = offset;
+}
+
+PRIVATE void OI_SBC_SynthFrame_4SB(OI_CODEC_SBC_DECODER_CONTEXT *context, OI_INT16 *pcm, OI_UINT blkstart, OI_UINT blkcount)
+{
+    OI_UINT blk;
+    OI_UINT ch;
+    OI_UINT nrof_channels = context->common.frameInfo.nrof_channels;
+    OI_UINT pcmStrideShift = context->common.pcmStride == 1 ? 0 : 1;
+    OI_UINT offset = context->common.filterBufferOffset;
+    OI_INT32 *s = context->common.subdata + 8 * nrof_channels * blkstart;
+    OI_UINT blkstop = blkstart + blkcount;
+
+    for (blk = blkstart; blk < blkstop; blk++) {
+        if (offset == 0) {
+            COPY_BACKWARD_32BIT_ALIGNED_72_HALFWORDS(context->common.filterBuffer[0] + context->common.filterBufferLen - 72,context->common.filterBuffer[0]);
+            if (nrof_channels == 2) {
+                COPY_BACKWARD_32BIT_ALIGNED_72_HALFWORDS(context->common.filterBuffer[1] + context->common.filterBufferLen - 72,context->common.filterBuffer[1]);
+            }
+            offset =context->common.filterBufferLen - 80;
+        } else {
+            offset -= 8;
+        }
+        for (ch = 0; ch < nrof_channels; ch++) {
+            cosineModulateSynth4(context->common.filterBuffer[ch] + offset, s);
+            SynthWindow40_int32_int32_symmetry_with_sum(pcm + ch,
+                                                        context->common.filterBuffer[ch] + offset,
+                                                        pcmStrideShift);
+            s += 4;
+        }
+        pcm += (4 << pcmStrideShift);
+    }
+    context->common.filterBufferOffset = offset;
+}
+
+#ifdef SBC_ENHANCED
+
+PRIVATE void OI_SBC_SynthFrame_Enhanced(OI_CODEC_SBC_DECODER_CONTEXT *context, OI_INT16 *pcm, OI_UINT blkstart, OI_UINT blkcount)
+{
+    OI_UINT blk;
+    OI_UINT ch;
+    OI_UINT nrof_channels = context->common.frameInfo.nrof_channels;
+    OI_UINT pcmStrideShift = context->common.pcmStride == 1 ? 0 : 1;
+    OI_UINT offset = context->common.filterBufferOffset;
+    OI_INT32 *s = context->common.subdata + 8 * nrof_channels * blkstart;
+    OI_UINT blkstop = blkstart + blkcount;
+
+    for (blk = blkstart; blk < blkstop; blk++) {
+        if (offset == 0) {
+            COPY_BACKWARD_32BIT_ALIGNED_104_HALFWORDS(context->common.filterBuffer[0] +context->common.filterBufferLen - 104, context->common.filterBuffer[0]);
+            if (nrof_channels == 2) {
+                COPY_BACKWARD_32BIT_ALIGNED_104_HALFWORDS(context->common.filterBuffer[1] + context->common.filterBufferLen - 104, context->common.filterBuffer[1]);
+            }
+            offset = context->common.filterBufferLen - 112;
+        } else {
+            offset -= 8;
+        }
+        for (ch = 0; ch < nrof_channels; ++ch) {
+            DCT2_8(context->common.filterBuffer[ch] + offset, s);
+            SYNTH112(pcm + ch, context->common.filterBuffer[ch] + offset, pcmStrideShift);
+            s += 8;
+        }
+        pcm += (8 << pcmStrideShift);
+    }
+    context->common.filterBufferOffset = offset;
+}
+
+static const SYNTH_FRAME SynthFrameEnhanced[] = {
+    NULL,                       /* invalid */
+    OI_SBC_SynthFrame_Enhanced, /* mono */
+    OI_SBC_SynthFrame_Enhanced  /* stereo */
+};
+
+#endif
+
+static const SYNTH_FRAME SynthFrame8SB[] = {
+    NULL,             /* invalid */
+    OI_SBC_SynthFrame_80, /* mono */
+    OI_SBC_SynthFrame_80  /* stereo */
+};
+
+
+static const SYNTH_FRAME SynthFrame4SB[] = {
+    NULL,                  /* invalid */
+    OI_SBC_SynthFrame_4SB, /* mono */
+    OI_SBC_SynthFrame_4SB  /* stereo */
+};
+
+PRIVATE void OI_SBC_SynthFrame(OI_CODEC_SBC_DECODER_CONTEXT *context, OI_INT16 *pcm, OI_UINT start_block, OI_UINT nrof_blocks)
+{
+    OI_UINT nrof_subbands = context->common.frameInfo.nrof_subbands;
+    OI_UINT nrof_channels = context->common.frameInfo.nrof_channels;
+
+    OI_ASSERT(nrof_subbands == 4 || nrof_subbands == 8);
+    if (nrof_subbands == 4) {
+        SynthFrame4SB[nrof_channels](context, pcm, start_block, nrof_blocks);
+#ifdef SBC_ENHANCED
+    } else if (context->common.frameInfo.enhanced) {
+        SynthFrameEnhanced[nrof_channels](context, pcm, start_block, nrof_blocks);
+#endif /* SBC_ENHANCED */
+        } else {
+        SynthFrame8SB[nrof_channels](context, pcm, start_block, nrof_blocks);
+    }
+}
+
+
+void SynthWindow40_int32_int32_symmetry_with_sum(OI_INT16 *pcm, SBC_BUFFER_T buffer[80], OI_UINT strideShift)
+{
+    OI_INT32 pa;
+    OI_INT32 pb;
+
+    /* These values should be zero, since out[2] of the 4-band cosine modulation
+     * is always zero. */
+    OI_ASSERT(buffer[ 2] == 0);
+    OI_ASSERT(buffer[10] == 0);
+    OI_ASSERT(buffer[18] == 0);
+    OI_ASSERT(buffer[26] == 0);
+    OI_ASSERT(buffer[34] == 0);
+    OI_ASSERT(buffer[42] == 0);
+    OI_ASSERT(buffer[50] == 0);
+    OI_ASSERT(buffer[58] == 0);
+    OI_ASSERT(buffer[66] == 0);
+    OI_ASSERT(buffer[74] == 0);
+
+
+    pa  = dec_window_4[ 4] * (buffer[12] + buffer[76]);
+    pa += dec_window_4[ 8] * (buffer[16] - buffer[64]);
+    pa += dec_window_4[12] * (buffer[28] + buffer[60]);
+    pa += dec_window_4[16] * (buffer[32] - buffer[48]);
+    pa += dec_window_4[20] *  buffer[44];
+    pa = SCALE(-pa, 15);
+    CLIP_INT16(pa);
+    pcm[0 << strideShift] = (OI_INT16)pa;
+
+
+    pa  = dec_window_4[ 1] * buffer[ 1]; pb  = dec_window_4[ 1] * buffer[79];
+    pb += dec_window_4[ 3] * buffer[ 3]; pa += dec_window_4[ 3] * buffer[77];
+    pa += dec_window_4[ 5] * buffer[13]; pb += dec_window_4[ 5] * buffer[67];
+    pb += dec_window_4[ 7] * buffer[15]; pa += dec_window_4[ 7] * buffer[65];
+    pa += dec_window_4[ 9] * buffer[17]; pb += dec_window_4[ 9] * buffer[63];
+    pb += dec_window_4[11] * buffer[19]; pa += dec_window_4[11] * buffer[61];
+    pa += dec_window_4[13] * buffer[29]; pb += dec_window_4[13] * buffer[51];
+    pb += dec_window_4[15] * buffer[31]; pa += dec_window_4[15] * buffer[49];
+    pa += dec_window_4[17] * buffer[33]; pb += dec_window_4[17] * buffer[47];
+    pb += dec_window_4[19] * buffer[35]; pa += dec_window_4[19] * buffer[45];
+    pa = SCALE(-pa, 15);
+    CLIP_INT16(pa);
+    pcm[1 << strideShift] = (OI_INT16)(pa);
+    pb = SCALE(-pb, 15);
+    CLIP_INT16(pb);
+    pcm[3 << strideShift] = (OI_INT16)(pb);
+
+
+    pa  = dec_window_4[2] * (/*buffer[ 2] + */ buffer[78]);  /* buffer[ 2] is always zero */
+    pa += dec_window_4[6] * (buffer[14] /* + buffer[66]*/);  /* buffer[66] is always zero */
+    pa += dec_window_4[10] * (/*buffer[18] + */ buffer[62]);  /* buffer[18] is always zero */
+    pa += dec_window_4[14] * (buffer[30] /* + buffer[50]*/);  /* buffer[50] is always zero */
+    pa += dec_window_4[18] * (/*buffer[34] + */ buffer[46]);  /* buffer[34] is always zero */
+    pa = SCALE(-pa, 15);
+    CLIP_INT16(pa);
+    pcm[2 << strideShift] = (OI_INT16)(pa);
+}
+
+
+/**
+  This routine implements the cosine modulation matrix for 4-subband
+  synthesis. This is called "matrixing" in the SBC specification. This
+  matrix, M4,  can be factored into an 8-point Type II Discrete Cosine
+  Transform, DCTII_4 and a matrix S4, given here:
+
+  @code
+        __               __
+       |   0   0   1   0   |
+       |   0   0   0   1   |
+       |   0   0   0   0   |
+       |   0   0   0  -1   |
+  S4 = |   0   0  -1   0   |
+       |   0  -1   0   0   |
+       |  -1   0   0   0   |
+       |__ 0  -1   0   0 __|
+
+  M4 * in = S4 * (DCTII_4 * in)
+  @endcode
+
+  (DCTII_4 * in) is computed using a Fast Cosine Transform. The algorithm
+  here is based on an implementation computed by the SPIRAL computer
+  algebra system, manually converted to fixed-point arithmetic. S4 can be
+  implemented using only assignment and negation.
+  */
+PRIVATE void cosineModulateSynth4(SBC_BUFFER_T * RESTRICT out, OI_INT32 const * RESTRICT in)
+{
+    OI_INT32 f0, f1, f2, f3, f4, f7, f8, f9, f10;
+    OI_INT32 y0, y1, y2, y3;
+
+    f0 = (in[0] - in[3]);
+    f1 = (in[0] + in[3]);
+    f2 = (in[1] - in[2]);
+    f3 = (in[1] + in[2]);
+
+    f4 = f1 - f3;
+
+    y0 = -SCALE(f1 + f3, DCT_SHIFT);
+    y2 = -SCALE(LONG_MULT_DCT(DCTII_4_K06_FIX, f4), DCT_SHIFT);
+    f7 = f0 + f2;
+    f8 = LONG_MULT_DCT(DCTII_4_K08_FIX, f0);
+    f9 = LONG_MULT_DCT(DCTII_4_K09_FIX, f7);
+    f10 = LONG_MULT_DCT(DCTII_4_K10_FIX, f2);
+    y3 = -SCALE(f8 + f9, DCT_SHIFT);
+    y1 = -SCALE(f10 - f9, DCT_SHIFT);
+
+    out[0] = (OI_INT16)-y2;
+    out[1] = (OI_INT16)-y3;
+    out[2] = (OI_INT16)0;
+    out[3] = (OI_INT16)y3;
+    out[4] = (OI_INT16)y2;
+    out[5] = (OI_INT16)y1;
+    out[6] = (OI_INT16)y0;
+    out[7] = (OI_INT16)y1;
+}
+
+
+
+/**
+@}
+*/
diff -Naur '--exclude=.git' bluedroid-orig/embdrv/sbc/encoder/include/sbc_encoder.h bluedroid/embdrv/sbc/encoder/include/sbc_encoder.h
--- bluedroid-orig/embdrv/sbc/encoder/include/sbc_encoder.h	2015-09-24 16:33:43.536227643 +0800
+++ bluedroid/embdrv/sbc/encoder/include/sbc_encoder.h	2015-09-24 16:31:37.000000000 +0800
@@ -194,8 +194,13 @@
 extern "C"
 {
 #endif
+#ifdef PLATFORM_ANDROID // TODO Qualcomm
 SBC_API extern void SBC_Encoder(SBC_ENC_PARAMS *strEncParams);
 SBC_API extern void SBC_Encoder_Init(SBC_ENC_PARAMS *strEncParams);
+#else
+extern void SBC_Encoder(SBC_ENC_PARAMS *strEncParams);
+extern void SBC_Encoder_Init(SBC_ENC_PARAMS *strEncParams);
+#endif
 #ifdef __cplusplus
 }
 #endif
diff -Naur '--exclude=.git' bluedroid-orig/embdrv/sbc/encoder/include/sbc_types.h bluedroid/embdrv/sbc/encoder/include/sbc_types.h
--- bluedroid-orig/embdrv/sbc/encoder/include/sbc_types.h	2015-09-24 16:33:43.536227643 +0800
+++ bluedroid/embdrv/sbc/encoder/include/sbc_types.h	2015-09-24 16:31:37.000000000 +0800
@@ -39,7 +39,11 @@
 #if (SBC_FOR_EMBEDDED_LINUX == TRUE)
 typedef long long SINT64;
 #else
+#ifdef PLATFORM_ANDROID
 typedef __int64 SINT64;
+#else
+typedef long long SINT64;
+#endif
 #endif
 
 #elif (SBC_IS_64_MULT_IN_WINDOW_ACCU == TRUE) || (SBC_IS_64_MULT_IN_IDCT == TRUE)
@@ -47,7 +51,11 @@
 #if (SBC_FOR_EMBEDDED_LINUX == TRUE)
 typedef long long SINT64;
 #else
+#ifdef PLATFORM_ANDROID
 typedef __int64 SINT64;
+#else
+typedef long long SINT64;
+#endif
 #endif
 
 #endif
diff -Naur '--exclude=.git' bluedroid-orig/gki/CMakeLists.txt bluedroid/gki/CMakeLists.txt
--- bluedroid-orig/gki/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/gki/CMakeLists.txt	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,50 @@
+CMAKE_MINIMUM_REQUIRED(VERSION 2.6)
+PROJECT(bt-brcm_gki C)
+
+set(SRCS 
+    ./ulinux/gki_ulinux.c 
+    ./common/gki_debug.c 
+    ./common/gki_time.c 
+    ./common/gki_buffer.c
+)
+
+
+SET(PREFIX ${CMAKE_INSTALL_PREFIX})
+SET(EXEC_PREFIX "\${prefix}")
+SET(LIBDIR "\${prefix}/lib")
+SET(INCLUDEDIR "\${prefix}/include")
+SET(VERSION_MAJOR 1)
+SET(VERSION ${VERSION_MAJOR}.0.0)
+
+
+set(LOCAL_C_INCLUDES 
+	./common 
+	./ulinux 
+	../include 
+	../stack/include 
+	../utils/include 
+	../../../../system/core/include	
+	${bdroid_C_INCLUDES} )
+include_directories(${LOCAL_C_INCLUDES})
+
+FOREACH(flag ${packages_CFLAGS})
+	SET(EXTRA_CFLAGS "${EXTRA_CFLAGS} ${flag}")
+ENDFOREACH(flag)
+
+#SET(EXTRA_CFLAGS "${EXTRA_CFLAGS} -fvisibility=hidden -Wall")
+SET(EXTRA_CFLAGS "${EXTRA_CFLAGS} -g ")
+
+SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${EXTRA_CFLAGS} -fPIC")
+
+FIND_PROGRAM(UNAME NAMES uname)
+EXEC_PROGRAM("${UNAME}" ARGS "-m" OUTPUT_VARIABLE "ARCH")
+IF("${ARCH}" STREQUAL "arm")
+	ADD_DEFINITIONS("-DTARGET")
+	MESSAGE("add -DTARGET")
+ENDIF("${ARCH}" STREQUAL "arm")
+
+ADD_LIBRARY(${PROJECT_NAME} STATIC ${SRCS})
+SET_TARGET_PROPERTIES(${PROJECT_NAME} PROPERTIES SOVERSION ${VERSION_MAJOR})
+SET_TARGET_PROPERTIES(${PROJECT_NAME} PROPERTIES VERSION ${VERSION})
+TARGET_LINK_LIBRARIES(${PROJECT_NAME} ${packages_LDFLAGS})
+INSTALL(TARGETS ${PROJECT_NAME} DESTINATION lib)
diff -Naur '--exclude=.git' bluedroid-orig/hci/CMakeLists.txt bluedroid/hci/CMakeLists.txt
--- bluedroid-orig/hci/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/hci/CMakeLists.txt	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,52 @@
+CMAKE_MINIMUM_REQUIRED(VERSION 2.6)
+PROJECT(bt-hci C)
+
+SET(SRCS
+./src/bt_hci_bdroid.c
+./src/lpm.c
+./src/bt_hw.c
+./src/btsnoop.c
+./src/utils.c
+./src/hci_h4.c
+./src/userial.c
+./src/hci_mct.c
+./src/userial_mct.c
+)
+
+
+SET(PREFIX ${CMAKE_INSTALL_PREFIX})
+SET(EXEC_PREFIX "\${prefix}")
+SET(LIBDIR "\${prefix}/lib")
+SET(INCLUDEDIR "\${prefix}/include")
+SET(VERSION_MAJOR 1)
+SET(VERSION ${VERSION_MAJOR}.0.0)
+
+
+set(LOCAL_C_INCLUDES 
+        ./include 
+        ../utils/include
+	../../../../system/core/include)
+include_directories(${LOCAL_C_INCLUDES})
+
+
+FOREACH(flag ${packages_CFLAGS})
+	SET(EXTRA_CFLAGS "${EXTRA_CFLAGS} ${flag}")
+ENDFOREACH(flag)
+
+#SET(EXTRA_CFLAGS "${EXTRA_CFLAGS} -fvisibility=hidden -Wall")
+SET(EXTRA_CFLAGS "${EXTRA_CFLAGS} -g ")
+
+SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${EXTRA_CFLAGS} -fPIC")
+
+FIND_PROGRAM(UNAME NAMES uname)
+EXEC_PROGRAM("${UNAME}" ARGS "-m" OUTPUT_VARIABLE "ARCH")
+IF("${ARCH}" STREQUAL "arm")
+	ADD_DEFINITIONS("-DTARGET")
+	MESSAGE("add -DTARGET")
+ENDIF("${ARCH}" STREQUAL "arm")
+
+ADD_LIBRARY(${PROJECT_NAME} STATIC ${SRCS})
+SET_TARGET_PROPERTIES(${PROJECT_NAME} PROPERTIES SOVERSION ${VERSION_MAJOR})
+SET_TARGET_PROPERTIES(${PROJECT_NAME} PROPERTIES VERSION ${VERSION})
+TARGET_LINK_LIBRARIES(${PROJECT_NAME} ${packages_LDFLAGS} ${CMAKE_DL_LIBS})
+INSTALL(TARGETS ${PROJECT_NAME} DESTINATION lib)
diff -Naur '--exclude=.git' bluedroid-orig/hci/include/bt_hci_bdroid.h bluedroid/hci/include/bt_hci_bdroid.h
--- bluedroid-orig/hci/include/bt_hci_bdroid.h	2015-09-24 16:33:43.536227643 +0800
+++ bluedroid/hci/include/bt_hci_bdroid.h	2015-09-24 16:31:37.000000000 +0800
@@ -44,6 +44,11 @@
 #define TRUE   (!FALSE)
 #endif
 
+#define SCHED_NORMAL            0
+#define SCHED_OTHER             0
+#define SCHED_FIFO              1
+#define SCHED_RR                2
+
 #ifndef BTHC_LINUX_BASE_POLICY
 #define BTHC_LINUX_BASE_POLICY SCHED_NORMAL
 #endif
@@ -103,6 +108,9 @@
 #define MSG_STACK_TO_HC_HCI_ACL        0x2100 /* eq. BT_EVT_TO_LM_HCI_ACL */
 #define MSG_STACK_TO_HC_HCI_SCO        0x2200 /* eq. BT_EVT_TO_LM_HCI_SCO */
 #define MSG_STACK_TO_HC_HCI_CMD        0x2000 /* eq. BT_EVT_TO_LM_HCI_CMD */
+//#if (A2DP_KERNEL_DIRECT == TRUE)
+#define MSG_STACK_TO_IPC_LITE          0x9000 /*BT_EVT_BTU_IPC_EVT*/
+//#endif
 
 /* Local Bluetooth Controller ID for BR/EDR */
 #define LOCAL_BR_EDR_CONTROLLER_ID      0
diff -Naur '--exclude=.git' bluedroid-orig/hci/include/userial.h bluedroid/hci/include/userial.h
--- bluedroid-orig/hci/include/userial.h	2015-09-24 16:33:43.536227643 +0800
+++ bluedroid/hci/include/userial.h	2015-09-24 16:31:37.000000000 +0800
@@ -139,7 +139,13 @@
 **
 *******************************************************************************/
 typedef void (*tUSERIAL_IOCTL)(userial_ioctl_op_t op, void *p_data);
-
+/******************************************************************************
+**
+**Function         userial_write_proc
+**
+**Description     send cmd BTLITE stack via proc fs
+******************************************************************************/
+typedef void (*tUSERIAL_WRITE_PROC)(uint8_t *p_data, uint16_t len);
 typedef struct {
     tUSERIAL_INIT init;
     tUSERIAL_OPEN open;
@@ -147,8 +153,12 @@
     tUSERIAL_WRITE write;
     tUSERIAL_CLOSE close;
     tUSERIAL_IOCTL ioctl;
+    tUSERIAL_WRITE_PROC write_proc;
 } tUSERIAL_IF;
 
+uint8_t userial_open_helper(int *fd_array, uint8_t port);
+void userial_close(void);
+
 #ifdef QCOM_WCN_SSR
 uint8_t userial_dev_inreset();
 #endif
diff -Naur '--exclude=.git' bluedroid-orig/hci/src/bt_hci_bdroid.c bluedroid/hci/src/bt_hci_bdroid.c
--- bluedroid-orig/hci/src/bt_hci_bdroid.c	2015-09-24 16:33:43.540227643 +0800
+++ bluedroid/hci/src/bt_hci_bdroid.c	2015-09-24 16:31:37.000000000 +0800
@@ -30,6 +30,7 @@
 
 #define LOG_TAG "bt_hci_bdroid"
 
+#include <time.h>
 #include <utils/Log.h>
 #include <pthread.h>
 #include "bt_hci_bdroid.h"
@@ -52,7 +53,7 @@
 
 /* Vendor epilog process timeout period  */
 #ifndef EPILOG_TIMEOUT_MS
-#define EPILOG_TIMEOUT_MS 3000  // 3 seconds
+#define EPILOG_TIMEOUT_MS 200  // 200 msecs
 #endif
 
 /******************************************************************************
@@ -167,6 +168,8 @@
         status = timer_settime(hc_cb.epilog_timer_id, 0, &ts, 0);
         if (status == -1)
             ALOGE("Failed to fire epilog watchdog timer");
+        else
+            ALOGI("%s: EPILOG watchdog timer started", __func__);
     }
     else
     {
@@ -403,18 +406,22 @@
     {
         if (fwcfg_acked == TRUE)
         {
+            ALOGE("STACK-CLEANUP: [BTHCWT] STARTING EPILOG TIMER");
             epilog_wait_timer();
             bthc_signal_event(HC_EVENT_EPILOG);
         }
         else
         {
+            ALOGE("STACK-CLEANUP: [BTHCWT] SIGNAL BT HC WORKER THREAD EXIT");
             bthc_signal_event(HC_EVENT_EXIT);
         }
 
+        ALOGE("STACK-CLEANUP: [BTHCWT] WAIT FOR BT HC WORKER THREAD EXIT");
         pthread_join(hc_cb.worker_thread, NULL);
 
         if (hc_cb.epilog_timer_created == 1)
         {
+            ALOGE("STACK-CLEANUP: [BTHCWT] DELETE EPILOG WAIT TIMER");
             timer_delete(hc_cb.epilog_timer_id);
             hc_cb.epilog_timer_created = 0;
         }
@@ -422,14 +429,23 @@
 
     lib_running = 0;
 
+    ALOGE("STACK-CLEANUP: [BTHCWT] LPM CLEANUP");
     lpm_cleanup();
+
+    ALOGE("STACK-CLEANUP: [BTHCWT] USERIAL CLEANUP");
     p_userial_if->close();
+
+    ALOGE("STACK-CLEANUP: [BTHCWT] HCI CLEANUP");
     p_hci_if->cleanup();
+
+    ALOGE("STACK-CLEANUP: [BTHCWT] UTILS CLEANUP");
     utils_cleanup();
 
     /* Calling vendor-specific part */
-    if (bt_vnd_if)
+    if (bt_vnd_if) {
+        ALOGE("STACK-CLEANUP: [BTHCWT] VENDOR CLEANUP");
         bt_vnd_if->cleanup();
+    }
 
     fwcfg_acked = FALSE;
     bt_hc_cbacks = NULL;
@@ -611,8 +627,10 @@
                 break;  // equivalent to HC_EVENT_EXIT
         }
 
-        if (events & HC_EVENT_EXIT)
+        if (events & HC_EVENT_EXIT) {
+            ALOGE("Recvd. HC_EVENT_EXIT: Exiting...");
             break;
+        }
     }
 
     ALOGI("bt_hc_worker_thread exiting");
diff -Naur '--exclude=.git' bluedroid-orig/hci/src/hci_h4.c bluedroid/hci/src/hci_h4.c
--- bluedroid-orig/hci/src/hci_h4.c	2015-09-24 16:33:43.540227643 +0800
+++ bluedroid/hci/src/hci_h4.c	2015-09-24 16:31:37.000000000 +0800
@@ -163,6 +163,7 @@
                                   tINT_CMD_CBACK p_cback);
 void lpm_wake_assert(void);
 void lpm_tx_done(uint8_t is_tx_done);
+uint8_t userial_get_rx_src(void);
 
 /******************************************************************************
 **  Variables
@@ -179,9 +180,33 @@
 static tHCI_H4_CB       h4_cb;
 
 /******************************************************************************
-**  Static functions
+**  Global variables
 ******************************************************************************/
 
+int fw_upgrade_in_prog;
+
+/******************************************************************************
+**  Static functions
+******************************************************************************/
+void hci_h4_read_lite_rsp(uint8_t len, uint8_t *p_data)
+{
+    HC_BT_HDR *p_msg;
+    uint8_t *p;
+    int i;
+    ALOGE("hci_h4_read_lite_rsp = %d",len);
+    //if (len > 15) return;
+    p_msg = bt_hc_cbacks->alloc(len + BT_HC_HDR_SIZE);
+    p = (uint8_t)(p_msg + 1);
+    memcpy(p,p_data,len);
+    p = (uint8_t *)(p_msg + 1);
+    p_msg->event = MSG_STACK_TO_IPC_LITE;
+    p_msg->len   = len; //+ 2bytes for total length.
+    if (bt_hc_cbacks)
+        bt_hc_cbacks->data_ind((TRANSAC) p_msg, \
+                                   (char *) (p_msg + 1), \
+                                   p_msg->len + BT_HC_HDR_SIZE);
+    return;
+}
 /*******************************************************************************
 **
 ** Function         get_acl_data_length_cback
@@ -563,6 +588,7 @@
      */
     h4_cb.hc_acl_data_size = 1021;
     h4_cb.hc_ble_acl_data_size = 27;
+    fw_upgrade_in_prog = FALSE;
 
     btsnoop_init();
 }
@@ -614,6 +640,16 @@
         type = H4_TYPE_SCO_DATA;
     else if (event == MSG_STACK_TO_HC_HCI_CMD)
         type = H4_TYPE_COMMAND;
+    else if (event == MSG_STACK_TO_IPC_LITE)
+    {
+        //call proc_write to handle BTLITE_CMD
+        //*p = BT_EVT_BTU_IPC_BTM_EVT;
+        p = (uint8_t *)(p_msg + 1);
+        p_userial_if->write_proc(p,p_msg->len);
+        goto end;
+//        loop_back_test();
+//        return;
+    }
 
     if (sub_event == LOCAL_BR_EDR_CONTROLLER_ID)
     {
@@ -714,6 +750,12 @@
          */
          p++;
         STREAM_TO_UINT16(lay_spec, p);
+        if (lay_spec == 0xfc73) {
+            fw_upgrade_in_prog = TRUE;
+            ALOGE("%s: Sending VSC to erase the firmware...", __func__);
+        }
+        else
+            ALOGE("%s: Sending opcode: 0x%4x", __func__, lay_spec);
     }
 
     /* generate snoop trace message */
@@ -736,7 +778,11 @@
     }
 
     lpm_tx_done(TRUE);
-
+end:
+    if (bt_hc_cbacks && event == MSG_STACK_TO_IPC_LITE)
+    {
+        bt_hc_cbacks->dealloc((TRANSAC)p_msg, (char *)(p_msg+1));
+    }
     return;
 }
 
@@ -758,7 +804,38 @@
     uint16_t    msg_len, len;
     uint8_t     msg_received;
     tHCI_H4_CB  *p_cb=&h4_cb;
-
+    uint8_t     rx_fdlite;
+#if 0
+    if ((rx_fdlite = userial_get_rx_src()) == TRUE)
+    {
+        HC_BT_HDR *p_msg;
+        uint8_t *p;
+        int i;
+        p_userial_if->read(0/*dummy*/,&byte,1);
+        len = byte;
+        p_msg = bt_hc_cbacks->alloc(len + sizeof(uint16_t) + BT_HC_HDR_SIZE);
+        p = (uint8_t)(p_msg + 1);
+        *p = len;
+        ALOGE("hci_h4: rx_fdlite len 1st byte = %d",len);
+        p++;
+        p_userial_if->read(0/*dummy*/,&byte,1);// Len is 2 bytes
+        *p = byte;
+        ALOGE("hci_h4: rx_fdlite len 2nd byte = %d",*p);
+        p++;
+        p_userial_if->read(0/*dummy*/,p,len);
+        p = (uint8_t *)(p_msg + 1);
+        for (i = 0; i < len + sizeof(uint16_t); i++)
+             ALOGE("p[%d] = %x",i,*p++);
+        p_msg->event = MSG_STACK_TO_IPC_LITE;
+        p_msg->len   = len + sizeof(uint16_t); //+ 2bytes for total length.
+        bytes_read = p_msg->len;
+        if (bt_hc_cbacks)
+            bt_hc_cbacks->data_ind((TRANSAC) p_msg, \
+                                       (char *) (p_msg + 1), \
+                                       p_msg->len + BT_HC_HDR_SIZE);
+    }
+    else {
+#endif
     while (TRUE)
     {
         /* Read one byte to see if there is anything waiting to be read */
@@ -973,7 +1050,7 @@
             p_cb->p_rcv_msg = NULL;
         }
     }
-
+//    }
     return (bytes_read);
 }
 
diff -Naur '--exclude=.git' bluedroid-orig/hci/src/userial.c bluedroid/hci/src/userial.c
--- bluedroid-orig/hci/src/userial.c	2015-09-24 16:33:43.540227643 +0800
+++ bluedroid/hci/src/userial.c	2015-09-24 16:31:37.000000000 +0800
@@ -74,6 +74,7 @@
 ******************************************************************************/
 
 extern bt_vendor_interface_t *bt_vnd_if;
+extern fw_upgrade_in_prog;
 
 /******************************************************************************
 **  Local type definitions
@@ -82,7 +83,9 @@
 typedef struct
 {
     int             fd;
+    int             fd_lite;
     uint8_t         port;
+    uint8_t         rx_source; //TURE for LITE EVENT
     pthread_t       read_thread;
     BUFFER_Q        rx_q;
     HC_BT_HDR      *p_rx_hdr;
@@ -94,7 +97,10 @@
 
 static tUSERIAL_CB userial_cb;
 static volatile uint8_t userial_running = 0;
-
+static int cleanup_inprogress = 0;
+uint8_t p_lite_rsp[240];
+void hci_h4_read_lite_rsp(uint8_t len, uint8_t *p_data);
+//void userial_read_lite_rsp(uint8_t *p_data,uint16_t offset,uint16_t len);
 /******************************************************************************
 **  Static functions
 ******************************************************************************/
@@ -143,6 +149,7 @@
 }
 static inline int send_wakeup_signal(char sig_cmd)
 {
+    ALOGE("%s: Sending the wakeup signal", __func__);
     return send(signal_fds[1], &sig_cmd, sizeof(sig_cmd), 0);
 }
 static inline char reset_signal()
@@ -169,7 +176,7 @@
 **                 >=0: numbers of bytes read back from fd
 **
 *******************************************************************************/
-static int select_read(int fd, uint8_t *pbuf, int len)
+static int select_read(int fd, int fd_lite,uint8_t *pbuf, int len)
 {
     fd_set input;
     int n = 0, ret = -1;
@@ -182,11 +189,14 @@
         if (rx_flow_on == TRUE)
         {
             FD_SET(fd, &input);
+            if (fd_lite != -1)
+                FD_SET(fd_lite, &input);
         }
         int fd_max = create_signal_fds(&input);
         fd_max = fd_max > fd ? fd_max : fd;
 
         /* Do the select */
+        ALOGV("select_read = fd = %d, fd_lite = %d, fd_max = %d",fd,fd_lite,fd_max);
         n = select(fd_max+1, &input, NULL, NULL, NULL);
         if(is_signaled(&input))
         {
@@ -194,7 +204,8 @@
             if (reason == USERIAL_RX_EXIT)
             {
                 USERIALDBG("RX termination");
-                return -1;
+                ALOGE("%s: RX TERMINATION", __func__);
+                return -ENODEV;
             }
             else if (reason == USERIAL_RX_FLOW_OFF)
             {
@@ -206,6 +217,8 @@
                 USERIALDBG("RX flow ON");
                 rx_flow_on = TRUE;
             }
+            else
+                ALOGE("%s: NO FLOW ON/OFF or TERMINATION: reason: %d n: %d", __func__, reason, n);
         }
 
         if (n > 0)
@@ -213,23 +226,76 @@
             /* We might have input */
             if (FD_ISSET(fd, &input))
             {
+                ALOGE("FD received data");
+                userial_cb.rx_source = FALSE;
                 ret = read(fd, pbuf, (size_t)len);
                 if (0 == ret)
-                    ALOGW( "read() returned 0!" );
+                    ALOGE("%s: read() returned 0!", __func__);
+                else
+                    ALOGE("%s: read() returned : %d!", __func__, ret);
 
                 return ret;
             }
+            else if(fd_lite != -1 && FD_ISSET(fd_lite, &input))
+            {
+               uint8_t *p = &p_lite_rsp[0];
+               ALOGE("FD LITE received data");
+               ret = read(fd_lite, p, (size_t)len);
+               ALOGE("FDLITE read returned %d",ret);
+               if (ret == 0)
+                   ALOGW("proc read() returned 0");
+               hci_h4_read_lite_rsp(ret,p_lite_rsp);
+            }
+
         }
         else if (n < 0)
-            ALOGW( "select() Failed");
+            ALOGE( "%s: select() Failed", __func__);
         else if (n == 0)
-            ALOGW( "Got a select() TIMEOUT");
-
+            ALOGE("%s: Got a select() TIMEOUT", __func__);
+        ret = -ENODEV;
     }
-
     return ret;
 }
 
+static int allow_device_recover(int timeout)
+{
+    int fd_array[CH_MAX];
+    int i, status = 0;
+
+    for (i = 1; i <= 10; i++) {
+        ALOGE("%s: Device not yet up: Sleeping for another %dms...", __func__, timeout);
+        utils_delay(timeout);
+        if (cleanup_inprogress) {
+            ALOGE("%s: Cleanup-inprogress: No need for any recovery!!", __func__);
+            break;
+        }
+        ALOGE("%s: %d: Checking if device has come up", __func__, i);
+        status = userial_open_helper(fd_array, USERIAL_PORT_1);
+        if (status) {
+            ALOGE("%s: Device has comeup after %dms!!!", __func__, (i*timeout));
+            break;
+        }
+    }
+    return status;
+}
+static void simulate_command_complete_event(char *p)
+{
+    p[0] = 0x04; //HCI-EVENT TYPE
+    p[1] = 0x0e; //HCI-CMD-COMPLETE EVENT CODE
+    p[2] = 0x04; //EVENT LENGTH
+    p[3] = 0x01; //CMD-CREDITS
+    p[4] = 0x73; //VSC-CMD-OPCODE
+    p[5] = 0xfc; //VSC-CMD-OPCODE
+    p[6] = 0x00; //STATUS
+}
+static void hci_disconnect_event(char *p)
+{
+    p[0] = 0x04; //HCI-EVENT TYPE
+    p[1] = 0x10; //HARDWARE ERROR EVENT CODE
+    p[2] = 0x01; //EVENT LENGTH
+    p[3] = 0xFF; //HARDWARE ERROR CODE
+}
+
 /*******************************************************************************
 **
 ** Function        userial_read_thread
@@ -252,7 +318,7 @@
     userial_running = 1;
 
     raise_priority_a2dp(TASK_HIGH_USERIAL_READ);
-
+    userial_cb.rx_source = FALSE;
     while (userial_running)
     {
         if (bt_hc_cbacks)
@@ -269,7 +335,8 @@
             p_buf->layer_specific = 0;
 
             p = (uint8_t *) (p_buf + 1);
-            rx_length = select_read(userial_cb.fd, p, READ_LIMIT);
+            rx_length = select_read(userial_cb.fd, userial_cb.fd_lite,p, READ_LIMIT);
+            ALOGE("userial select read returned rx length = %d",rx_length);
         }
         else
         {
@@ -292,17 +359,58 @@
         }
         else /* either 0 or < 0 */
         {
-            ALOGW("select_read return size <=0:%d, exiting userial_read_thread",\
+            ALOGE("select_read return size <=0:%d, exiting userial_read_thread",\
                  rx_length);
-            /* if we get here, we should have a buffer */
-            bt_hc_cbacks->dealloc((TRANSAC) p_buf, (char *) (p_buf + 1));
-            /* negative value means exit thread */
-            break;
+
+            if (cleanup_inprogress || rx_length == -ENODEV) {
+                ALOGE("%s: Cleanup(%d) in progress: rx_length: %d", __func__, cleanup_inprogress, rx_length);
+                bt_hc_cbacks->dealloc((TRANSAC) p_buf, (char *) (p_buf + 1));
+                break;
+            }
+            /*
+             * In case of FW Upgrade, the device gets reset once the existing
+             * FW is erased. After a 5sec timeout check if the device is
+             * re-enumerated and if yes, allow the Stack to query the FW version
+             */
+            ALOGE("%s: FW D/L Status: %d", __func__, fw_upgrade_in_prog);
+            if(fw_upgrade_in_prog  && allow_device_recover(1000)) {
+                fw_upgrade_in_prog = FALSE;
+                ALOGE("%s: Device recover successful.", __func__);
+                ALOGE("%s: Simulating FAKE CMD-COMPLETE EVENT", __func__);
+                simulate_command_complete_event(p);
+                p_buf->event = 0x04; //HCIT_TYPE_EVENT;
+                p_buf->len = 7;
+                utils_enqueue(&(userial_cb.rx_q), p_buf);
+                bthc_signal_event(HC_EVENT_RX);
+            }
+            else {
+                /* Notify upper layers about the disconnect with HCI layer */
+                hci_disconnect_event(p);
+                p_buf->event = 0x04; //HCIT_TYPE_EVENT;
+                p_buf->len = 4;
+                utils_enqueue(&(userial_cb.rx_q), p_buf);
+                bthc_signal_event(HC_EVENT_RX);
+                break;
+            }
         }
     } /* for */
 
     userial_running = 0;
+
+    /*
+     * In case of HCI down scenario, exit the BT HC WORKER thread prior to
+     * closing the device handle. This way we can prevent the Userial from
+     * flooding the driver with ACL data from upper layers, as there is a small
+     * window available till the actual clsoing of the driver happens.
+     */
+    ALOGE("%s: TRANSPORT CLEANUP: SIGNAL BT HC WORKER THREAD EXIT", __func__);
+    bthc_signal_event(HC_EVENT_EXIT);
+
+    ALOGE("%s: TRANSPORT CLEANUP: CLOSING USB DRIVER", __func__);
+    bt_vnd_if->op(BT_VND_OP_USERIAL_CLOSE, NULL);
+
     USERIALDBG("Leaving userial_read_thread()");
+    ALOGE("%s: TRANSPORT CLEANUP: EXITING USERIAL READ THREAD", __func__);
     pthread_exit(NULL);
 
     return NULL;    // Compiler friendly
@@ -327,11 +435,61 @@
     USERIALDBG("userial_init");
     memset(&userial_cb, 0, sizeof(tUSERIAL_CB));
     userial_cb.fd = -1;
+    cleanup_inprogress = 0;
     utils_queue_init(&(userial_cb.rx_q));
     return TRUE;
 }
 
 
+uint8_t userial_open_helper(int *fd_array, uint8_t port)
+{
+    int result;
+
+    ALOGE("userial_open_helper(port:%d)", port);
+
+    if (port >= MAX_SERIAL_PORT)
+    {
+        ALOGE("Port > MAX_SERIAL_PORT");
+        return FALSE;
+    }
+
+    /* Calling vendor-specific part */
+    if (bt_vnd_if)
+    {
+        ALOGE("%s: Re-opening the BT-USB device", __func__);
+        result = bt_vnd_if->op(BT_VND_OP_USERIAL_OPEN, fd_array);
+
+        if (result != 1)
+        {
+            ALOGE("userial_open: wrong numbers of open fd in vendor lib [%d]!",
+                    result);
+            ALOGE("userial_open: HCI UART expects only one open fd");
+            return FALSE;
+        }
+
+        userial_cb.fd = fd_array[0];
+        userial_cb.fd_lite = fd_array[1];
+    }
+    else
+    {
+        ALOGE("userial_open: missing vendor lib interface !!!");
+        ALOGE("userial_open: unable to open UART port");
+        return FALSE;
+    }
+
+    if (userial_cb.fd == -1)
+    {
+        ALOGE("userial_open: failed to open UART port");
+        return FALSE;
+    }
+
+    ALOGE("%s: New fd = %d", __func__, userial_cb.fd);
+
+    userial_cb.port = port;
+    return TRUE;
+}
+
+
 /*******************************************************************************
 **
 ** Function        userial_open
@@ -344,12 +502,14 @@
 uint8_t userial_open(uint8_t port)
 {
     struct sched_param param;
-    int policy, result;
+    int policy, result,result1;
     pthread_attr_t thread_attr;
     int fd_array[CH_MAX];
+    int index;
 
     USERIALDBG("userial_open(port:%d)", port);
-
+    for(index = 0; index < CH_MAX; index++)
+        fd_array[index] = -1;
     if (userial_running)
     {
         /* Userial is open; close it first */
@@ -378,6 +538,9 @@
         }
 
         userial_cb.fd = fd_array[0];
+        userial_cb.fd_lite = fd_array[1];
+        ALOGE("userial_open: SS Driver opened successfully = %d ",userial_cb.fd);
+        ALOGE("userial_open: SS LITE Driver opened successfully = %d ",userial_cb.fd_lite);
     }
     else
     {
@@ -496,6 +659,17 @@
         log_userial_tx_timing(len);
 #endif
         ret = write(userial_cb.fd, p_data+total, len);
+        if (ret == -EINVAL) {
+            ALOGE("%s: ##### USERIAL WRITE FAILED : EINVAL #####", __func__);
+            userial_close();
+        } else if (ret == -ENODEV){
+            ALOGE("%s: ##### USERIAL WRITE FAILED : ENODEV #####", __func__);
+            userial_close();
+        } else if (ret < 0) {
+            ALOGE("%s: ##### USERIAL WRITE FAILED : RET VAL : %d #####",
+                __func__, ret);
+            return ret;
+        }
         total += ret;
         len -= ret;
     }
@@ -517,18 +691,27 @@
     int result;
     TRANSAC p_buf;
 
+    ALOGE("%s: Cleanup-inprogress...", __func__);
+    cleanup_inprogress = 1;
+
     USERIALDBG("userial_close(fd:%d)", userial_cb.fd);
+    ALOGE("userial_close(fd::%d)", userial_cb.fd);
 
     if (userial_running)
         send_wakeup_signal(USERIAL_RX_EXIT);
 
+    ALOGE("%s: Wait for USERIAL READER THREAD TO TERMINATE", __func__);
     if ((result=pthread_join(userial_cb.read_thread, NULL)) < 0)
         ALOGE( "pthread_join() FAILED result:%d", result);
 
+    ALOGE("%s: Close the handle to the USB driver", __func__);
     /* Calling vendor-specific part */
-    if (bt_vnd_if)
+    if (bt_vnd_if) {
+        ALOGE("%s: Sending BT_VND_OP_USERIAL_CLOSE", __func__);
         bt_vnd_if->op(BT_VND_OP_USERIAL_CLOSE, NULL);
+    }
 
+    ALOGE("%s: FD released!!", __func__);
     userial_cb.fd = -1;
 
     if (bt_hc_cbacks)
@@ -577,6 +760,44 @@
     }
 }
 
+void userial_write_proc (uint8_t *p_data, uint16_t len)
+{
+     //Handle writes to proc fs
+    ALOGD("Handle PROC write");
+    int ret, total = 0;
+
+    while(len != 0)
+    {
+#if defined(ENABLE_USERIAL_TIMING_LOGS) && (ENABLE_USERIAL_TIMING_LOGS==TRUE)
+        log_userial_tx_timing(len);
+#endif
+        ret = write(userial_cb.fd_lite, p_data+total, len);
+        total += ret;
+        len -= ret;
+    }
+    memset(p_lite_rsp,0,240);
+//    p_lite_rsp = bt_hc_cbacks->alloc(BTHC_USERIAL_READ_MEM_SIZE);
+}
+#if 0
+uint8_t userial_get_rx_src()
+{
+   ALOGD("userial get rx source %d",userial_cb.rx_source);
+   return userial_cb.rx_source;
+}
+#endif
+/*void userial_read_lite_rsp(uint8_t *p_data,uint16_t offset, uint16_t len)
+{
+    uint8_t *p = p_lite_rsp;
+    memcpy(p_data,p+offset,len);
+    if(len != 1)
+       *p_lite_rsp -= len;
+    if (*p_lite_rsp == 0)
+    {
+       ALOGE("userial lite rsp read complete");
+       bt_hc_cbacks->dealloc(p_lite_rsp);
+    }
+    return;
+}*/
 const tUSERIAL_IF userial_h4_func_table =
 {
     userial_init,
@@ -584,6 +805,7 @@
     userial_read,
     userial_write,
     userial_close,
-    userial_ioctl
+    userial_ioctl,
+    userial_write_proc
 };
 
diff -Naur '--exclude=.git' bluedroid-orig/include/bt_target.h bluedroid/include/bt_target.h
--- bluedroid-orig/include/bt_target.h	2015-09-24 16:33:43.540227643 +0800
+++ bluedroid/include/bt_target.h	2015-09-24 16:31:37.000000000 +0800
@@ -221,6 +221,10 @@
 #define BTA_AV_VDP_INCLUDED FALSE
 #endif
 
+#ifndef A2DP_KERNEL_DIRECT
+#define A2DP_KERNEL_DIRECT TRUE
+#endif
+
 /* defined BTA_AVK_INCLUDED in Android.mk file based on target selected*/
 
 #ifndef BTA_PBS_INCLUDED
@@ -283,6 +287,14 @@
 #define BTA_GATT_INCLUDED TRUE
 #endif
 
+#ifndef BTA_AV_SINK_INCLUDED
+#define BTA_AV_SINK_INCLUDED TRUE
+#endif
+
+#ifndef BTA_3D_INCLUDED
+#define BTA_3D_INCLUDED TRUE
+#endif
+
 #ifndef BTA_DISABLE_DELAY
 #define BTA_DISABLE_DELAY 200 /* in milliseconds */
 #endif
@@ -812,6 +824,9 @@
 #define HCI_LP_ALLOW_BT_DEVICE_SLEEP()       bte_main_lpm_allow_bt_device_sleep()
 #endif
 
+#ifndef HCI_BTU_IPC_EVT_TO_LOWER
+#define HCI_BTU_IPC_EVT_TO_LOWER(p)  bte_main_hci_send((BT_HDR *)(p), BT_EVT_BTU_IPC_EVT);
+#endif
 /* If nonzero, the upper-layer sends at most this number of HCI commands to the lower-layer. */
 #ifndef HCI_MAX_SIMUL_CMDS
 #define HCI_MAX_SIMUL_CMDS          0
@@ -1058,8 +1073,11 @@
 * MINOR_CLASS:0x0C - SMART_PHONE
 *
 */
+//XXX: Change this to a rendering display in order to function as a 3DD with legacy 3DGs
+//     If this causes issues with other devices, we will need to visit other options.
+//     (Reference table 12.1 of the 3DS specification)
 #ifndef BTA_DM_COD
-#define BTA_DM_COD {0x5A, 0x02, 0x0C}
+#define BTA_DM_COD {0x08, 0x04, 0x3C}
 #endif
 
 /* The number of SCO links. */
@@ -1355,7 +1373,7 @@
 
 /* Unicast Connectionless Data */
 #ifndef L2CAP_UCD_INCLUDED
-#define L2CAP_UCD_INCLUDED                  FALSE
+#define L2CAP_UCD_INCLUDED                  TRUE
 #endif
 
 /* Unicast Connectionless Data MTU */
@@ -3414,7 +3432,7 @@
 ******************************************************************************/
 
 #ifndef BTC_INCLUDED
-#define BTC_INCLUDED                TRUE
+#define BTC_INCLUDED                FALSE
 #endif
 
 /******************************************************************************
@@ -3570,6 +3588,10 @@
 #define AVRC_ADV_CTRL_INCLUDED      TRUE
 #endif
 
+#ifndef AVRC_CTLR_INCLUDED
+#define AVRC_CTLR_INCLUDED          TRUE
+#endif
+
 #ifndef SDP_AVRCP_1_5
 #define SDP_AVRCP_1_5               TRUE
 
diff -Naur '--exclude=.git' bluedroid-orig/main/Android.mk bluedroid/main/Android.mk
--- bluedroid-orig/main/Android.mk	2015-09-24 16:33:43.540227643 +0800
+++ bluedroid/main/Android.mk	2015-09-24 16:31:37.000000000 +0800
@@ -52,7 +52,9 @@
     ../btif/src/bluetoothTrack.cpp \
     ../btif/src/btif_l2cap.c \
     ../btif/src/btif_sdp.c \
+    ../btif/src/list.c \
     ../wipowerif/src/wipower.c \
+    ../btif/src/btif_3d.c
 
 # callouts
 LOCAL_SRC_FILES+= \
@@ -103,13 +105,15 @@
 	$(LOCAL_PATH)/../hci/include\
 	$(LOCAL_PATH)/../brcm/include \
 	$(LOCAL_PATH)/../embdrv/sbc/encoder/include \
+	$(LOCAL_PATH)/../embdrv/sbc/decoder/include \
 	$(LOCAL_PATH)/../audio_a2dp_hw \
 	$(LOCAL_PATH)/../utils/include \
 	$(LOCAL_PATH)/../wipowerif/include \
 	$(bdroid_C_INCLUDES) \
 	$(TARGET_OUT_HEADERS)/codecs/decoder/inc \
 	$(TOP)/frameworks/av/include/media \
-	external/tinyxml2
+	external/tinyxml2 \
+	$(LOCAL_PATH)/../../../../hardware/qcom/bt/libbt-vendor/include
 
 LOCAL_CFLAGS += -DBUILDCFG $(bdroid_CFLAGS) -Werror -Wno-error=maybe-uninitialized -Wno-error=uninitialized
 
@@ -141,7 +145,7 @@
     libmedia
 
 #LOCAL_WHOLE_STATIC_LIBRARIES := libbt-brcm_gki libbt-brcm_stack libbt-brcm_bta
-LOCAL_STATIC_LIBRARIES := libbt-brcm_gki libbt-brcm_bta libbt-brcm_stack libbt-btc libtinyxml2
+LOCAL_STATIC_LIBRARIES := libbt-brcm_gki libbt-brcm_bta libbt-brcm_stack libbt-btc libtinyxml2 libbt-qcom_sbc_decoder
 
 LOCAL_MODULE := bluetooth.default
 LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/hw
diff -Naur '--exclude=.git' bluedroid-orig/main/bluetooth.default.pc.in bluedroid/main/bluetooth.default.pc.in
--- bluedroid-orig/main/bluetooth.default.pc.in	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/main/bluetooth.default.pc.in	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,11 @@
+prefix=@PREFIX@
+exec_prefix=@EXEC_PREFIX@
+libdir=@LIB_INSTALL_DIR@
+includedir=@INCLUDEDIR@
+
+Name: bluetooth.default
+Description: Bluetooth default library
+Version: @VERSION@
+Requires: dlog
+Libs: -L${libdir} 
+Cflags: -I${includedir}
diff -Naur '--exclude=.git' bluedroid-orig/main/bte_conf.c bluedroid/main/bte_conf.c
--- bluedroid-orig/main/bte_conf.c	2015-09-24 16:33:43.540227643 +0800
+++ bluedroid/main/bte_conf.c	2015-09-24 16:31:37.000000000 +0800
@@ -44,6 +44,10 @@
 extern char hci_logfile[256];
 extern BOOLEAN trace_conf_enabled;
 extern BOOLEAN config_sbc_high_bitrate;
+extern BOOLEAN unconditional_patch_upgrade;
+extern BOOLEAN enable_test_mode;
+extern BOOLEAN disable_3dd;
+extern BOOLEAN disable_interlaced_scan;
 
 void bte_trace_conf(char *p_name, char *p_conf_value);
 int device_name_cfg(char *p_conf_name, char *p_conf_value);
@@ -53,6 +57,10 @@
 int logging_cfg_extdump(char *p_conf_name, char *p_conf_value);
 int trace_cfg_onoff(char *p_conf_name, char *p_conf_value);
 int set_sbc_bitrate(char *p_conf_name, char *p_conf_value);
+int unconditional_patch_upgrade_cfg(char *p_conf_name, char *p_conf_value);
+int enable_test_mode_cfg(char *p_conf_name, char *p_conf_value);
+int disable_3dd_cfg(char *p_conf_name, char *p_conf_value);
+int disable_interlaced_scan_cfg(char *p_conf_name, char *p_conf_value);
 BD_NAME local_device_default_name = BTM_DEF_LOCAL_NAME;
 DEV_CLASS local_device_default_class = {0x40, 0x02, 0x0C};
 
@@ -115,6 +123,10 @@
     {"BtSnoopFileName", logging_set_filepath},
     {"SbcHighBitrate", set_sbc_bitrate},
     {"TraceConf", trace_cfg_onoff},
+    {"UnconditionalPatchUpgrade", unconditional_patch_upgrade_cfg},
+    {"EnableTestMode", enable_test_mode_cfg},
+    {"Disable3DD", disable_3dd_cfg},
+    {"DisableInterlacedScan", disable_interlaced_scan_cfg},
     {(const char *) NULL, NULL}
 };
 
@@ -184,7 +196,6 @@
 
 int set_sbc_bitrate(char *p_conf_name, char *p_conf_value)
 {
-    config_sbc_high_bitrate = (strcmp(p_conf_value, "true") == 0) ? TRUE : FALSE;
     return 0;
 }
 
@@ -194,6 +205,27 @@
     return 0;
 }
 
+int unconditional_patch_upgrade_cfg(char *p_conf_name, char *p_conf_value)
+{
+    unconditional_patch_upgrade = (strcmp(p_conf_value, "true") == 0) ? TRUE : FALSE;
+    return 0;
+}
+
+int enable_test_mode_cfg(char *p_conf_name, char *p_conf_value)
+{
+    enable_test_mode = (strcmp(p_conf_value, "true") == 0) ? TRUE : FALSE;
+    return 0;
+}
+int disable_3dd_cfg(char *p_conf_name, char *p_conf_value)
+{
+    disable_3dd = (strcmp(p_conf_value, "true") == 0) ? TRUE : FALSE;
+    return 0;
+}
+int disable_interlaced_scan_cfg(char *p_conf_name, char *p_conf_value)
+{
+    disable_interlaced_scan = (strcmp(p_conf_value, "true") == 0) ? TRUE : FALSE;
+    return 0;
+}
 /*****************************************************************************
 **   CONF INTERFACE FUNCTIONS
 *****************************************************************************/
diff -Naur '--exclude=.git' bluedroid-orig/main/bte_init.c bluedroid/main/bte_init.c
--- bluedroid-orig/main/bte_init.c	2015-09-24 16:33:43.540227643 +0800
+++ bluedroid/main/bte_init.c	2015-09-24 16:31:37.000000000 +0800
@@ -25,7 +25,9 @@
 
 #include "bt_target.h"
 #include <string.h>
+#if (defined(BTC_INCLUDED) && BTC_INCLUDED == TRUE)
 #include "btc_common.h"
+#endif
 #ifndef BTA_INCLUDED
 #define BTA_INCLUDED FALSE
 #endif
diff -Naur '--exclude=.git' bluedroid-orig/main/bte_logmsg.c bluedroid/main/bte_logmsg.c
--- bluedroid-orig/main/bte_logmsg.c	2015-09-24 16:33:43.540227643 +0800
+++ bluedroid/main/bte_logmsg.c	2015-09-24 16:31:37.000000000 +0800
@@ -166,13 +166,42 @@
     "bt-nfa",
 };
 
+FILE* fLog=NULL;
+int bfileLogging = 0;
+
 #ifndef LINUX_NATIVE
+#if defined(PLATFORM_ANDROID) || defined(ANDROID)
 #include <cutils/log.h>
 #define LOGI0(t,s) __android_log_write(ANDROID_LOG_INFO, t, s)
 #define LOGD0(t,s) __android_log_write(ANDROID_LOG_DEBUG, t, s)
 #define LOGW0(t,s) __android_log_write(ANDROID_LOG_WARN, t, s)
 #define LOGE0(t,s) __android_log_write(ANDROID_LOG_ERROR, t, s)
+#else
+#include <cutils/log.h>
+#include <pthread.h>
+#include <syscall.h>
+int __tizen_log_write(int prio, const char *tag, const char *msg)
+{
+   __dlog_print(LOG_ID_APPS, prio, tag, msg);
+
+   if(bfileLogging)
+   {
+        struct timeval tv;
+        int  tid;
 
+        gettimeofday(&tv,NULL);
+        tid = syscall(SYS_gettid);
+
+        fprintf(fLog,"%d:%d [%d] %s %s\n",tv.tv_sec, tv.tv_usec, tid, tag, msg);
+   }
+
+   return 0;
+}
+#define LOGI0(t,s) __tizen_log_write(DLOG_ERROR, t, s)
+#define LOGD0(t,s) __tizen_log_write(DLOG_ERROR, t, s)
+#define LOGW0(t,s) __tizen_log_write(DLOG_ERROR, t, s)
+#define LOGE0(t,s) __tizen_log_write(DLOG_ERROR, t, s)
+#endif
 #else
 #undef ANDROID_USE_LOGCAT
 #endif
diff -Naur '--exclude=.git' bluedroid-orig/main/bte_main.c bluedroid/main/bte_main.c
--- bluedroid-orig/main/bte_main.c	2015-09-24 16:33:43.540227643 +0800
+++ bluedroid/main/bte_main.c	2015-09-24 16:31:37.000000000 +0800
@@ -48,7 +48,7 @@
 
 /* if not specified in .txt file then use this as default  */
 #ifndef HCI_LOGGING_FILENAME
-#define HCI_LOGGING_FILENAME  "/data/misc/bluedroid/btsnoop_hci.log"
+#define HCI_LOGGING_FILENAME  "/root/rootfs/btsnoop_hci.log"
 #endif
 
 /* Stack preload process timeout period  */
@@ -79,6 +79,8 @@
 BOOLEAN hci_logging_config = FALSE;    /* configured from bluetooth framework */
 BOOLEAN hci_ext_dump_enabled = FALSE;  /* External BT snoop */
 char hci_logfile[256] = HCI_LOGGING_FILENAME;
+BOOLEAN enable_test_mode = FALSE;  /*test mode to invoke btif APIs for test */
+BOOLEAN unconditional_patch_upgrade = FALSE;  /*allow lower version patch upgrade */
 
 
 /*******************************************************************************
@@ -225,7 +227,11 @@
 
     preload_stop_wait_timer();
     bte_hci_disable();
+
+    APPL_TRACE_ERROR1("%s: STACK-CLEANUP: DESTROY BTU TASK", __FUNCTION__);
     GKI_destroy_task(BTU_TASK);
+
+    APPL_TRACE_ERROR1("%s: STACK-CLEANUP: GKI FREEZE", __FUNCTION__);
     GKI_freeze();
 }
 
@@ -369,13 +375,17 @@
 
     if (bt_hc_if)
     {
+        APPL_TRACE_ERROR1("%s: STACK-CLEANUP: HCI CLEANUP", __FUNCTION__);
         bt_hc_if->cleanup();
+
+        APPL_TRACE_ERROR1("%s: STACK-CLEANUP: BT_HC_CHIP_PWR_OFF", __FUNCTION__);
         bt_hc_if->set_power(BT_HC_CHIP_PWR_OFF);
 
         if (hci_logging_enabled == TRUE ||  hci_logging_config == TRUE)
         {
             /* If snoop dump is handled from external process,
                pass NULL for the file name */
+            APPL_TRACE_ERROR1("%s: STACK-CLEANUP: STOP SNOOP LOGGING", __FUNCTION__);
             bt_hc_if->logging(BT_HC_LOGGING_OFF,
                 hci_ext_dump_enabled ? NULL : hci_logfile);
         }
diff -Naur '--exclude=.git' bluedroid-orig/main/CMakeLists.txt bluedroid/main/CMakeLists.txt
--- bluedroid-orig/main/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/main/CMakeLists.txt	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,155 @@
+CMAKE_MINIMUM_REQUIRED(VERSION 2.6)
+PROJECT(bluetooth.default CXX)
+
+SET(SRCS
+../btif/src/bluetooth.c
+./bte_main.c
+./bte_init.c
+./bte_version.c
+./bte_logmsg.c
+./bte_conf.c
+../btif/src/btif_core.c
+../btif/src/btif_dm.c
+../btif/src/btif_storage.c
+../btif/src/btif_util.c
+../btif/src/btif_sm.c
+../btif/src/btif_hf.c
+../btif/src/btif_hf_client.c
+../btif/src/btif_multi_hf.c
+../btif/src/btif_av.c
+../btif/src/btif_rc.c
+../btif/src/btif_media_task.c
+../btif/src/btif_hh.c
+../btif/src/btif_hd.c
+../btif/src/btif_hl.c
+../btif/src/btif_sock.c
+../btif/src/btif_sock_rfc.c
+../btif/src/btif_sock_thread.c
+../btif/src/btif_sock_sdp.c
+../btif/src/btif_sock_util.c
+../btif/src/btif_pan.c
+../btif/src/btif_mce.c
+../btif/src/btif_gatt.c
+../btif/src/btif_gatt_client.c
+../btif/src/btif_gatt_server.c
+../btif/src/btif_gatt_util.c
+../btif/src/btif_gatt_test.c
+../btif/src/btif_config.c
+../btif/src/btif_config_util.cpp
+../btif/src/btif_profile_queue.c
+../btif/src/btif_l2cap.c
+../btif/src/btif_sdp.c
+../btif/src/list.c
+../wipowerif/src/wipower.c
+../btif/src/btif_3d.c
+../btif/co/bta_sys_co.c
+../btif/co/bta_fs_co.c
+../btif/co/bta_ag_co.c
+../btif/co/bta_dm_co.c
+../btif/co/bta_av_co.c
+../btif/co/bta_hh_co.c
+../btif/co/bta_hl_co.c
+../btif/co/bta_pan_co.c
+../btif/co/bta_gattc_co.c
+../btif/co/bta_gatts_co.c
+../embdrv/sbc/encoder/srce/sbc_analysis.c
+../embdrv/sbc/encoder/srce/sbc_dct.c
+../embdrv/sbc/encoder/srce/sbc_dct_coeffs.c
+../embdrv/sbc/encoder/srce/sbc_enc_bit_alloc_mono.c
+../embdrv/sbc/encoder/srce/sbc_enc_bit_alloc_ste.c
+../embdrv/sbc/encoder/srce/sbc_enc_coeffs.c
+../embdrv/sbc/encoder/srce/sbc_encoder.c
+../embdrv/sbc/encoder/srce/sbc_packing.c
+
+../udrv/ulinux/uipc.c
+../../../tinyxml2/tinyxml2.cpp
+../../../../system/core/libcutils/socket_local_client.c
+../../../../system/core/libcutils/socket_local_server.c
+)
+
+SET(PREFIX ${CMAKE_INSTALL_PREFIX})
+SET(EXEC_PREFIX "\${prefix}")
+SET(LIBDIR "\${prefix}/lib")
+SET(INCLUDEDIR "\${prefix}/include")
+SET(VERSION_MAJOR 1)
+SET(VERSION ${VERSION_MAJOR}.0.0)
+
+set(LOCAL_C_INCLUDES
+	../bta/include 
+	../bta/sys 
+	../bta/dm 
+	../gki/common 
+	../gki/ulinux 
+	../include 
+	../stack/include 
+	../stack/l2cap 
+	../stack/a2dp 
+	../stack/btm 
+	../stack/avdt 
+	../hcis 
+	../hcis/include 
+	../hcis/patchram 
+	../udrv/include 
+	../btif/include 
+	../btif/co 
+	../hci/include
+	../brcm/include 
+	../embdrv/sbc/encoder/include 
+	../embdrv/sbc/decoder/include
+	../audio_a2dp_hw 
+	../utils/include 
+	$(bdroid_C_INCLUDES) 
+	../../../tinyxml2/
+	../../../../system/core/include
+	../../../../hardware/libhardware/include
+	../../../../bionic/libc/include
+	../../../../hardware/qcom/bt/libbt-vendor/include
+	../../../../bionic/libc/kernel/common
+	../wipowerif/include)
+include_directories(${LOCAL_C_INCLUDES})
+
+
+LINK_DIRECTORIES(${CMAKE_CURRENT_SOURCE_DIR}/../stack)
+LINK_DIRECTORIES(${CMAKE_CURRENT_SOURCE_DIR}/../gki)
+LINK_DIRECTORIES(${CMAKE_CURRENT_SOURCE_DIR}/../bta)
+LINK_DIRECTORIES(${CMAKE_CURRENT_SOURCE_DIR}/../utils)
+LINK_DIRECTORIES(${CMAKE_CURRENT_SOURCE_DIR}/../hci)
+LINK_DIRECTORIES(${CMAKE_CURRENT_SOURCE_DIR}/../embdrv/sbc/decoder)
+
+FOREACH(flag ${packages_CFLAGS})
+	SET(EXTRA_CFLAGS "${EXTRA_CFLAGS} ${flag}")
+ENDFOREACH(flag)
+
+#SET(EXTRA_CFLAGS "${EXTRA_CFLAGS} -fvisibility=hidden -Wall")
+SET(EXTRA_CFLAGS "${EXTRA_CFLAGS} -g ")
+
+SET(EXTRA_CFLAGS "${EXTRA_CFLAGS} -D__USE_GNU ")
+SET(EXTRA_CFLAGS "${EXTRA_CFLAGS} -DBUILDCFG ")
+
+SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${EXTRA_CFLAGS}")
+
+FIND_PROGRAM(UNAME NAMES uname)
+EXEC_PROGRAM("${UNAME}" ARGS "-m" OUTPUT_VARIABLE "ARCH")
+IF("${ARCH}" STREQUAL "arm")
+	ADD_DEFINITIONS("-DTARGET")
+	MESSAGE("add -DTARGET")
+ENDIF("${ARCH}" STREQUAL "arm")
+
+ADD_LIBRARY(${PROJECT_NAME} SHARED ${SRCS})
+SET_TARGET_PROPERTIES(${PROJECT_NAME} PROPERTIES SOVERSION ${VERSION_MAJOR})
+SET_TARGET_PROPERTIES(${PROJECT_NAME} PROPERTIES VERSION ${VERSION})
+#TARGET_LINK_LIBRARIES(${PROJECT_NAME} ${packages_LDFLAGS} ${CMAKE_DL_LIBS})
+TARGET_LINK_LIBRARIES(${PROJECT_NAME} -lbt-brcm_gki)
+TARGET_LINK_LIBRARIES(${PROJECT_NAME} -lbt-brcm_bta)
+TARGET_LINK_LIBRARIES(${PROJECT_NAME} -lbt-brcm_stack)
+TARGET_LINK_LIBRARIES(${PROJECT_NAME} -lbt-hci)
+TARGET_LINK_LIBRARIES(${PROJECT_NAME} -lbt-utils)
+TARGET_LINK_LIBRARIES(${PROJECT_NAME} -lbt-qcom_sbc_decoder)
+TARGET_LINK_LIBRARIES(${PROJECT_NAME} -ldlog)
+TARGET_LINK_LIBRARIES(${PROJECT_NAME} -lpthread)
+TARGET_LINK_LIBRARIES(${PROJECT_NAME} -ldl)
+TARGET_LINK_LIBRARIES(${PROJECT_NAME} -lrt)
+
+CONFIGURE_FILE(${CMAKE_CURRENT_SOURCE_DIR}/${PROJECT_NAME}.pc.in ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}.pc @ONLY)
+INSTALL(FILES ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}.pc DESTINATION lib/pkgconfig)
+INSTALL(TARGETS ${PROJECT_NAME} DESTINATION lib COMPONENT RuntimeLibraries)
diff -Naur '--exclude=.git' bluedroid-orig/stack/a2dp/a2d_api.c bluedroid/stack/a2dp/a2d_api.c
--- bluedroid-orig/stack/a2dp/a2d_api.c	2015-09-24 16:33:43.540227643 +0800
+++ bluedroid/stack/a2dp/a2d_api.c	2015-09-24 16:31:37.000000000 +0800
@@ -392,17 +392,4 @@
     a2d_cb.trace_level  = BT_TRACE_LEVEL_NONE;
 #endif
 }
-/*******************************************************************************
-**
-** Function         a2d_get_avdt_sdp_ver
-**
-** Description      This function fetches current version of AVDT.
-**
-** Returns          Current version of AVDT
-**
-*******************************************************************************/
-int a2d_get_avdt_sdp_ver ()
-{
-    return a2d_cb.avdt_sdp_ver;
-}
 
diff -Naur '--exclude=.git' bluedroid-orig/stack/a2dp/a2d_int.h bluedroid/stack/a2dp/a2d_int.h
--- bluedroid-orig/stack/a2dp/a2d_int.h	2015-09-24 16:33:43.540227643 +0800
+++ bluedroid/stack/a2dp/a2d_int.h	2015-09-24 16:31:37.000000000 +0800
@@ -76,9 +76,6 @@
 /* Used only for conformance testing */
 A2D_API extern void a2d_set_avdt_sdp_ver (UINT16 avdt_sdp_ver);
 
-/* Used to check local version of AVDTP */
-A2D_API extern int a2d_get_avdt_sdp_ver ();
-
 #ifdef __cplusplus
 }
 #endif
diff -Naur '--exclude=.git' bluedroid-orig/stack/a2dp/a2d_sbc.c bluedroid/stack/a2dp/a2d_sbc.c
--- bluedroid-orig/stack/a2dp/a2d_sbc.c	2015-09-24 16:33:43.540227643 +0800
+++ bluedroid/stack/a2dp/a2d_sbc.c	2015-09-24 16:31:37.000000000 +0800
@@ -24,12 +24,13 @@
  ******************************************************************************/
 
 #include "bt_target.h"
-
-#if (A2D_SBC_INCLUDED == TRUE)
 #include <string.h>
 #include "a2d_api.h"
 #include "a2d_int.h"
 #include "a2d_sbc.h"
+#include "bt_utils.h"
+
+#if (A2D_SBC_INCLUDED == TRUE)
 
 /*************************************************************************************************
  * SBC descramble code
@@ -398,4 +399,57 @@
     }
 }
 
+#else /* A2D_SBC_INCLUDED == TRUE */
+
+void A2D_SbcChkFrInit(UINT8 *p_pkt)
+{
+    UNUSED(p_pkt);
+}
+
+void A2D_SbcDescramble(UINT8 *p_pkt, UINT16 len)
+{
+    UNUSED(p_pkt);
+    UNUSED(len);
+}
+
+tA2D_STATUS A2D_BldSbcInfo(UINT8 media_type, tA2D_SBC_CIE *p_ie,
+                           UINT8 *p_result)
+{
+    UNUSED(media_type);
+    UNUSED(p_ie);
+    UNUSED(p_result);
+    return A2D_FAIL;
+}
+
+tA2D_STATUS A2D_ParsSbcInfo(tA2D_SBC_CIE *p_ie, UINT8 *p_info,
+                            BOOLEAN for_caps)
+{
+    UNUSED(p_ie);
+    UNUSED(p_info);
+    UNUSED(for_caps);
+    return A2D_FAIL;
+}
+
+void A2D_BldSbcMplHdr(UINT8 *p_dst, BOOLEAN frag, BOOLEAN start,
+                      BOOLEAN last, UINT8 num)
+{
+    UNUSED(p_dst);
+    UNUSED(frag);
+    UNUSED(start);
+    UNUSED(last);
+    UNUSED(num);
+}
+
+void A2D_ParsSbcMplHdr(UINT8 *p_src, BOOLEAN *p_frag,
+                       BOOLEAN *p_start, BOOLEAN *p_last,
+                       UINT8 *p_num)
+{
+    UNUSED(p_src);
+    UNUSED(p_frag);
+    UNUSED(p_start);
+    UNUSED(p_last);
+    UNUSED(p_num);
+}
+
+
 #endif /* A2D_SBC_INCLUDED == TRUE */
diff -Naur '--exclude=.git' bluedroid-orig/stack/avct/avct_api.c bluedroid/stack/avct/avct_api.c
--- bluedroid-orig/stack/avct/avct_api.c	2015-09-24 16:33:43.540227643 +0800
+++ bluedroid/stack/avct/avct_api.c	2015-09-24 16:31:37.000000000 +0800
@@ -25,6 +25,7 @@
 #include <string.h>
 #include "data_types.h"
 #include "bt_target.h"
+#include "bt_utils.h"
 #include "gki.h"
 #include "l2c_api.h"
 #include "l2cdefs.h"
@@ -53,6 +54,8 @@
 *******************************************************************************/
 void AVCT_Register(UINT16 mtu, UINT16 mtu_br, UINT8 sec_mask)
 {
+    UNUSED(mtu_br);
+
     AVCT_TRACE_API0("AVCT_Register");
 
     /* register PSM with L2CAP */
@@ -262,7 +265,7 @@
     if (role == AVCT_INT)
     {
         /* the link control block must exist before this function is called as INT. */
-        if (p_ccb->p_lcb == NULL)
+        if ((p_ccb->p_lcb == NULL) || (p_ccb->p_lcb->allocated == 0))
         {
             result = AVCT_NOT_OPEN;
         }
@@ -292,6 +295,8 @@
 
     return result;
 #else
+    UNUSED(handle);
+    UNUSED(role);
     return AVCT_NO_RESOURCES;
 #endif
 }
@@ -329,6 +334,7 @@
     }
     return result;
 #else
+    UNUSED(handle);
     return AVCT_NO_RESOURCES;
 #endif
 }
@@ -353,6 +359,8 @@
     {
         peer_mtu = p_ccb->p_bcb->peer_mtu;
     }
+#else
+    UNUSED(handle);
 #endif
     return peer_mtu;
 }
@@ -453,7 +461,13 @@
             else
             {
                 p_ccb->p_bcb = avct_bcb_by_lcb(p_ccb->p_lcb);
-                avct_bcb_event(p_ccb->p_bcb, AVCT_LCB_UL_MSG_EVT, (tAVCT_LCB_EVT *) &ul_msg);
+                if (p_ccb->p_bcb)
+                    avct_bcb_event(p_ccb->p_bcb, AVCT_LCB_UL_MSG_EVT, (tAVCT_LCB_EVT *) &ul_msg);
+                else
+                {
+                    result = AVCT_BAD_HANDLE;
+                    GKI_freebuf(p_msg);
+                }
             }
         }
         /* send msg event to lcb */
diff -Naur '--exclude=.git' bluedroid-orig/stack/avct/avct_l2c.c bluedroid/stack/avct/avct_l2c.c
--- bluedroid-orig/stack/avct/avct_l2c.c	2015-09-24 16:33:43.540227643 +0800
+++ bluedroid/stack/avct/avct_l2c.c	2015-09-24 16:31:37.000000000 +0800
@@ -25,6 +25,7 @@
 #include <string.h>
 #include "data_types.h"
 #include "bt_target.h"
+#include "bt_utils.h"
 #include "avct_api.h"
 #include "avct_int.h"
 #include "l2c_api.h"
@@ -155,6 +156,7 @@
     tAVCT_LCB       *p_lcb;
     UINT16          result = L2CAP_CONN_OK;
     tL2CAP_CFG_INFO cfg;
+    UNUSED(psm);
 
     /* do we already have a channel for this peer? */
     if ((p_lcb = avct_lcb_by_bd(bd_addr)) == NULL)
@@ -483,13 +485,13 @@
                 L2CA_DisconnectReq(lcid);
             }
         }
-   }
-   else
-   {
-       AVCT_TRACE_ERROR0("### BCB NULL");
-       L2CA_DisconnectReq(lcid);
-   }
-   AVCT_TRACE_DEBUG1("ch_state cfc: %d ", p_bcb->ch_state);
+        AVCT_TRACE_DEBUG1("ch_state cfc: %d ", p_bcb->ch_state);
+    }
+    else
+    {
+        AVCT_TRACE_ERROR0("### BCB NULL");
+        L2CA_DisconnectReq(lcid);
+    }
 }
 #endif
 
diff -Naur '--exclude=.git' bluedroid-orig/stack/avct/avct_lcb_act.c bluedroid/stack/avct/avct_lcb_act.c
--- bluedroid-orig/stack/avct/avct_lcb_act.c	2015-09-24 16:33:43.540227643 +0800
+++ bluedroid/stack/avct/avct_lcb_act.c	2015-09-24 16:31:37.000000000 +0800
@@ -30,6 +30,8 @@
 #include "gki.h"
 #include "btm_api.h"
 
+#define UNUSED(x) (void)(x)
+
 /* packet header length lookup table */
 const UINT8 avct_lcb_pkt_type_len[] = {
     AVCT_HDR_LEN_SINGLE,
@@ -243,6 +245,7 @@
 void avct_lcb_chnl_open(tAVCT_LCB *p_lcb, tAVCT_LCB_EVT *p_data)
 {
     UINT16 result = AVCT_RESULT_FAIL;
+    UNUSED(p_data);
 
     BTM_SetOutService(p_lcb->peer_addr, BTM_SEC_SERVICE_AVCTP, 0);
     /* call l2cap connect req */
@@ -310,6 +313,8 @@
 *******************************************************************************/
 void avct_lcb_unbind_disc(tAVCT_LCB *p_lcb, tAVCT_LCB_EVT *p_data)
 {
+    UNUSED(p_lcb);
+
     avct_ccb_dealloc(p_data->p_ccb, AVCT_DISCONNECT_CFM_EVT, 0, NULL);
 }
 
@@ -430,7 +435,7 @@
     if (bind == FALSE)
     {
         AVCT_TRACE_ERROR0 ("### open_ind error");
-        avct_lcb_event(p_bcb, AVCT_LCB_INT_CLOSE_EVT, p_data);
+        avct_bcb_event(p_bcb, AVCT_LCB_INT_CLOSE_EVT, p_data);
     }
 }
 #endif
@@ -495,6 +500,7 @@
 {
     tAVCT_CCB           *p_ccb = &avct_cb.ccb[0];
     int                 i;
+    UNUSED(p_data);
 
     for (i = 0; i < AVCT_NUM_CONN; i++, p_ccb++)
     {
@@ -537,7 +543,7 @@
         if (p_ccb->allocated && (p_ccb->p_bcb == p_bcb))
         {
             //set avct_cb.bcb to 0
-            memset(p_ccb->p_bcb, NULL ,sizeof(tAVCT_BCB));
+            memset(p_ccb->p_bcb, 0 ,sizeof(tAVCT_BCB));
             p_ccb->p_bcb == NULL;
             AVCT_TRACE_DEBUG0("**close_ind");
         }
@@ -713,6 +719,7 @@
 *******************************************************************************/
 void avct_lcb_chnl_disc(tAVCT_LCB *p_lcb, tAVCT_LCB_EVT *p_data)
 {
+    UNUSED(p_data);
     AVCT_TRACE_DEBUG0("avct_lcb_chnl_disc");
     L2CA_DisconnectReq(p_lcb->ch_lcid);
 }
@@ -749,6 +756,8 @@
 *******************************************************************************/
 void avct_lcb_bind_fail(tAVCT_LCB *p_lcb, tAVCT_LCB_EVT *p_data)
 {
+    UNUSED(p_lcb);
+
     avct_ccb_dealloc(p_data->p_ccb, AVCT_CONNECT_CFM_EVT, AVCT_RESULT_FAIL, NULL);
 }
 
@@ -864,6 +873,8 @@
 *******************************************************************************/
 void avct_lcb_discard_msg(tAVCT_LCB *p_lcb, tAVCT_LCB_EVT *p_data)
 {
+    UNUSED(p_lcb);
+
     AVCT_TRACE_WARNING0("Dropping msg");
 
     GKI_freebuf(p_data->ul_msg.p_buf);
@@ -1078,6 +1089,8 @@
 *******************************************************************************/
 void avct_lcb_free_msg_ind(tAVCT_LCB *p_lcb, tAVCT_LCB_EVT *p_data)
 {
+    UNUSED(p_lcb);
+
     if (p_data)
         GKI_freebuf(p_data->p_buf);
     return;
diff -Naur '--exclude=.git' bluedroid-orig/stack/avct/avct_lcb.c bluedroid/stack/avct/avct_lcb.c
--- bluedroid-orig/stack/avct/avct_lcb.c	2015-09-24 16:33:43.540227643 +0800
+++ bluedroid/stack/avct/avct_lcb.c	2015-09-24 16:31:37.000000000 +0800
@@ -26,6 +26,7 @@
 #include <string.h>
 #include "data_types.h"
 #include "bt_target.h"
+#include "bt_utils.h"
 #include "avct_api.h"
 #include "avct_int.h"
 #include "gki.h"
@@ -233,7 +234,7 @@
     /* execute action functions */
     for (i = 0; i < AVCT_LCB_ACTIONS; i++)
     {
-        if ((action = state_table[event][i]) != AVCT_LCB_IGNORE)
+        if ((action = state_table[event][i]) < AVCT_LCB_IGNORE)
         {
             (*avct_lcb_action[action])(p_lcb, p_data);
         }
@@ -276,7 +277,7 @@
     /* execute action functions */
     for (i = 0; i < AVCT_LCB_ACTIONS; i++)
     {
-        if ((action = state_table[event][i]) != AVCT_LCB_IGNORE)
+        if ((action = state_table[event][i]) < AVCT_LCB_IGNORE)
         {
             (*avct_bcb_action[action])(p_bcb, p_data);
         }
@@ -422,6 +423,7 @@
     tAVCT_CCB   *p_ccb = &avct_cb.ccb[0];
     BOOLEAN     found = FALSE;
     int         i;
+    UNUSED(p_data);
 
     AVCT_TRACE_DEBUG1("avct_lcb_dealloc %d", p_lcb->allocated);
 
diff -Naur '--exclude=.git' bluedroid-orig/stack/avdt/avdt_ad.c bluedroid/stack/avdt/avdt_ad.c
--- bluedroid-orig/stack/avdt/avdt_ad.c	2015-09-24 16:33:43.544227643 +0800
+++ bluedroid/stack/avdt/avdt_ad.c	2015-09-24 16:31:37.000000000 +0800
@@ -25,6 +25,7 @@
 #include <string.h>
 #include "data_types.h"
 #include "bt_target.h"
+#include "bt_utils.h"
 #include "avdt_api.h"
 #include "avdtc_api.h"
 #include "avdt_int.h"
@@ -322,6 +323,7 @@
     tAVDT_CCB   *p_ccb;
     tAVDT_SCB   *p_scb;
     tAVDT_SCB_TC_CLOSE  close;
+    UNUSED(reason);
 
     close.old_tc_state = p_tbl->state;
     /* clear avdt_ad_tc_tbl entry */
diff -Naur '--exclude=.git' bluedroid-orig/stack/avdt/avdt_api.c bluedroid/stack/avdt/avdt_api.c
--- bluedroid-orig/stack/avdt/avdt_api.c	2015-09-24 16:33:43.544227643 +0800
+++ bluedroid/stack/avdt/avdt_api.c	2015-09-24 16:31:37.000000000 +0800
@@ -43,6 +43,9 @@
 tAVDT_CB avdt_cb;
 #endif
 
+#if (A2DP_KERNEL_DIRECT == TRUE)
+tAVDT_SYNC_INFO avdt_sync;
+#endif
 
 /*******************************************************************************
 **
@@ -176,6 +179,123 @@
 
 /*******************************************************************************
 **
+** Function         AVDT_UpdateServiceBusyState
+**
+** Description      This function is used to set the service busy state
+**                  during outgoing connection to properly handle the
+**                  connections in upper layers.
+**
+**
+** Returns          void
+**
+*******************************************************************************/
+void AVDT_UpdateServiceBusyState(BOOLEAN state)
+{
+    AVDT_TRACE_DEBUG1("AVDT_UpdateServiceBusyState: %d", state);
+    avdt_cb.conn_in_progress = state;
+}
+
+/*******************************************************************************
+**
+** Function         AVDT_GetServiceBusyState
+**
+** Description      This function is used to get the service busy state
+**
+**
+** Returns          outgoing connection in progress or not
+**
+*******************************************************************************/
+BOOLEAN AVDT_GetServiceBusyState(void)
+{
+    AVDT_TRACE_DEBUG1("AVDT_GetServiceBusyState: %d", avdt_cb.conn_in_progress);
+    return avdt_cb.conn_in_progress;
+}
+
+/*******************************************************************************
+**
+** Function         AVDT_SINK_Activate
+**
+** Description      Activate SEP of A2DP Sink. In Use parameter is adjusted.
+**                  In Use will be made false in case of activation. A2DP SRC
+**                  will receive in_use as false and can open A2DP Sink
+**                  connection
+**
+** Returns          void.
+**
+*******************************************************************************/
+void AVDT_SINK_Activate()
+{
+    tAVDT_SCB           *p_scb = &avdt_cb.scb[0];
+    int                 i;
+    AVDT_TRACE_DEBUG0("AVDT_SINK_Activate");
+    /* for all allocated scbs */
+    for (i = 0; i < AVDT_NUM_SEPS; i++, p_scb++)
+    {
+        if ((p_scb->allocated) && (p_scb->cs.tsep == AVDT_TSEP_SNK))
+        {
+            AVDT_TRACE_DEBUG0("AVDT_SINK_Activate found scb");
+            /* update in_use */
+            p_scb->in_use = FALSE;
+            break;
+        }
+    }
+}
+
+/*******************************************************************************
+**
+** Function         AVDT_SINK_Deactivate
+**
+** Description      Deactivate SEP of A2DP Sink. In Use parameter is adjusted.
+**                  In Use will be made TRUE in case of activation. A2DP SRC
+**                  will receive in_use as true and will not open A2DP Sink
+**                  connection
+**
+** Returns          void.
+**
+*******************************************************************************/
+void AVDT_SINK_Deactivate()
+{
+    tAVDT_SCB           *p_scb = &avdt_cb.scb[0];
+    int                 i;
+    AVDT_TRACE_DEBUG0("AVDT_SINK_Deactivate");
+    /* for all allocated scbs */
+    for (i = 0; i < AVDT_NUM_SEPS; i++, p_scb++)
+    {
+        if ((p_scb->allocated) && (p_scb->cs.tsep == AVDT_TSEP_SNK))
+        {
+            AVDT_TRACE_DEBUG0("AVDT_SINK_Deactivate, found scb");
+            /* update in_use */
+            p_scb->in_use = TRUE;
+            break;
+        }
+    }
+}
+
+UINT16 AVDT_AbortReq(UINT8 handle)
+{
+    tAVDT_SCB       *p_scb = NULL;
+    UINT16          result = AVDT_SUCCESS;
+    tAVDT_SCB_EVT   evt;
+
+    AVDT_TRACE_ERROR0("AVDT_AbortReq");
+
+    /* map handle to scb */
+    if ((p_scb = avdt_scb_by_hdl(handle)) == NULL)
+    {
+        result = AVDT_BAD_HANDLE;
+        AVDT_TRACE_ERROR0("Improper SCB, can not abort the stream");
+    }
+    else
+    /* send event to scb */
+    {
+        avdt_scb_event(p_scb, AVDT_SCB_API_ABORT_REQ_EVT, &evt);
+    }
+
+    return result;
+}
+
+/*******************************************************************************
+**
 ** Function         AVDT_CreateStream
 **
 ** Description      Create a stream endpoint.  After a stream endpoint is
@@ -1422,4 +1542,53 @@
 
     return (avdt_cb.trace_level);
 }
+#if (A2DP_KERNEL_DIRECT == TRUE)
+/*****************************************************************************
+**  Function:   btlite_send_avdt_remove_req
+**
+**
+*****************************************************************************/
+void btlite_send_avdt_remove_req(tBTM_BTLITE_CMPL *p_cb)
+{
+    APPL_TRACE_DEBUG0("btlite_send_avdt_remvoe_req");
+    BTM_SendBTLiteReq(BT_EVT_BTU_IPC_AVDT_EVT,AVDT_REMOVE_TO_LITE_REQ,(void *)&avdt_sync,p_cb);
+}
+/*****************************************************************************
+**  Function:   btlite_send_avdt_sync_req
+**
+**
+*****************************************************************************/
+void btlite_send_avdt_sync_req(tBTM_BTLITE_CMPL *p_cb)
+{
+    APPL_TRACE_DEBUG0("btlite_send_avdt_sync_req");
+    BTM_SendBTLiteReq(BT_EVT_BTU_IPC_AVDT_EVT,AVDT_SYNC_TO_LITE_REQ,(void *)&avdt_sync,p_cb);
+}
+/*****************************************************************************
+**  Function:   fill_avdt_sync_req
+**
+**
+*****************************************************************************/
+void fill_avdt_sync_req (UINT16 lcid,UINT16 handle,BD_ADDR remote_addr,UINT16 peer_mtu)
+{
+    tAVDT_SCB  *p_scb = avdt_scb_by_hdl(handle);
+    int xx, num_stream = 1;
+    if (p_scb == NULL)
+    {
+        APPL_TRACE_ERROR0("No SCB found for given handle");
+        return;
+    }
+    avdt_sync.op_code = AVDT_SYNC_TO_LITE_REQ;
+    for(xx = 0; xx < num_stream; xx++)
+    {
+        avdt_sync.scb_info[xx].handle = handle;
+        avdt_sync.scb_info[xx].local_cid = lcid;
+        bdcpy(&avdt_sync.scb_info[xx].peer_addr,&remote_addr);
+        avdt_sync.scb_info[xx].peer_mtu = peer_mtu;
+        avdt_sync.scb_info[xx].media_seq= p_scb->media_seq;
+        avdt_sync.scb_info[xx].mux_tsid_media = p_scb->curr_cfg.mux_tcid_media;
+        avdt_sync.scb_info[xx].cp.id = AVDT_SYNC_CP_ID_NONE; //CP not supported
+        avdt_sync.scb_info[xx].cp.scms_hdr = 0x00;
+    }
+}
 
+#endif
diff -Naur '--exclude=.git' bluedroid-orig/stack/avdt/avdt_ccb_act.c bluedroid/stack/avdt/avdt_ccb_act.c
--- bluedroid-orig/stack/avdt/avdt_ccb_act.c	2015-09-24 16:33:43.544227643 +0800
+++ bluedroid/stack/avdt/avdt_ccb_act.c	2015-09-24 16:31:37.000000000 +0800
@@ -26,6 +26,7 @@
 #include <string.h>
 #include "data_types.h"
 #include "bt_target.h"
+#include "bt_utils.h"
 #include "avdt_api.h"
 #include "avdtc_api.h"
 #include "avdt_int.h"
@@ -86,6 +87,8 @@
 *******************************************************************************/
 void avdt_ccb_chan_open(tAVDT_CCB *p_ccb, tAVDT_CCB_EVT *p_data)
 {
+    UNUSED(p_data);
+
     BTM_SetOutService(p_ccb->peer_addr, BTM_SEC_SERVICE_AVDTP, AVDT_CHAN_SIG);
     avdt_ad_open_req(AVDT_CHAN_SIG, p_ccb, NULL, AVDT_INT);
 }
@@ -103,6 +106,8 @@
 *******************************************************************************/
 void avdt_ccb_chan_close(tAVDT_CCB *p_ccb, tAVDT_CCB_EVT *p_data)
 {
+    UNUSED(p_data);
+
     /* close the transport channel used by this CCB */
     avdt_ad_close_req(AVDT_CHAN_SIG, p_ccb, NULL);
 }
@@ -122,6 +127,7 @@
 {
     int         i;
     tAVDT_SCB   *p_scb = &avdt_cb.scb[0];
+    UNUSED(p_data);
 
     /* see if there are any active scbs associated with this ccb */
     for (i = 0; i < AVDT_NUM_SEPS; i++, p_scb++)
@@ -666,6 +672,7 @@
     int             i;
     tAVDT_SCB       *p_scb = &avdt_cb.scb[0];
     UINT8           err_code = AVDT_ERR_CONNECT;
+    UNUSED(p_data);
 
     /* clear the ccb */
     avdt_ccb_clear_ccb(p_ccb);
@@ -754,6 +761,8 @@
 *******************************************************************************/
 void avdt_ccb_free_cmd(tAVDT_CCB *p_ccb, tAVDT_CCB_EVT *p_data)
 {
+    UNUSED(p_data);
+
     if (p_ccb->p_curr_cmd != NULL)
     {
         GKI_freebuf(p_ccb->p_curr_cmd);
@@ -838,6 +847,7 @@
 void avdt_ccb_snd_cmd(tAVDT_CCB *p_ccb, tAVDT_CCB_EVT *p_data)
 {
     BT_HDR  *p_msg;
+    UNUSED(p_data);
 
     /* do we have commands to send?  send next command;  make sure we're clear;
     ** not congested, not sending fragment, not waiting for response
@@ -870,6 +880,7 @@
 void avdt_ccb_snd_msg(tAVDT_CCB *p_ccb, tAVDT_CCB_EVT *p_data)
 {
     BT_HDR      *p_msg;
+    UNUSED(p_data);
 
     /* if not congested */
     if (!p_ccb->cong)
@@ -911,6 +922,8 @@
 *******************************************************************************/
 void avdt_ccb_set_reconn(tAVDT_CCB *p_ccb, tAVDT_CCB_EVT *p_data)
 {
+    UNUSED(p_data);
+
     p_ccb->reconn = TRUE;
 }
 
@@ -926,6 +939,8 @@
 *******************************************************************************/
 void avdt_ccb_clr_reconn(tAVDT_CCB *p_ccb, tAVDT_CCB_EVT *p_data)
 {
+    UNUSED(p_data);
+
     p_ccb->reconn = FALSE;
 }
 
@@ -944,6 +959,7 @@
 void avdt_ccb_chk_reconn(tAVDT_CCB *p_ccb, tAVDT_CCB_EVT *p_data)
 {
     UINT8   err_code = AVDT_ERR_CONNECT;
+    UNUSED(p_data);
 
     if (p_ccb->reconn)
     {
@@ -977,6 +993,8 @@
 *******************************************************************************/
 void avdt_ccb_chk_timer(tAVDT_CCB *p_ccb, tAVDT_CCB_EVT *p_data)
 {
+    UNUSED(p_data);
+
     if (p_ccb->timer_entry.event == BTU_TTYPE_AVDT_CCB_IDLE)
     {
         btu_stop_timer(&p_ccb->timer_entry);
@@ -1036,6 +1054,8 @@
 *******************************************************************************/
 void avdt_ccb_do_disconn(tAVDT_CCB *p_ccb, tAVDT_CCB_EVT *p_data)
 {
+    UNUSED(p_data);
+
     /* clear any pending commands */
     avdt_ccb_clear_cmds(p_ccb, NULL);
 
@@ -1058,6 +1078,7 @@
     tAVDT_CTRL_CBACK    *p_cback;
     BD_ADDR             bd_addr;
     tAVDT_CTRL          avdt_ctrl;
+    UNUSED(p_data);
 
     /* clear any pending commands */
     avdt_ccb_clear_cmds(p_ccb, NULL);
diff -Naur '--exclude=.git' bluedroid-orig/stack/avdt/avdt_ccb.c bluedroid/stack/avdt/avdt_ccb.c
--- bluedroid-orig/stack/avdt/avdt_ccb.c	2015-09-24 16:33:43.544227643 +0800
+++ bluedroid/stack/avdt/avdt_ccb.c	2015-09-24 16:31:37.000000000 +0800
@@ -26,6 +26,7 @@
 #include <string.h>
 #include "data_types.h"
 #include "bt_target.h"
+#include "bt_utils.h"
 #include "avdt_api.h"
 #include "avdtc_api.h"
 #include "avdt_int.h"
@@ -309,9 +310,10 @@
     state_table = avdt_ccb_st_tbl[p_ccb->state];
 
     /* set next state */
-    if (p_ccb->state != state_table[event][AVDT_CCB_NEXT_STATE])
+    if (p_ccb->state != state_table[event][AVDT_CCB_NEXT_STATE]) {
         BTTRC_AVDT_CCB_STATE(state_table[event][AVDT_CCB_NEXT_STATE]);
-    p_ccb->state = state_table[event][AVDT_CCB_NEXT_STATE];
+        p_ccb->state = state_table[event][AVDT_CCB_NEXT_STATE];
+    }
 
     /* execute action functions */
     for (i = 0; i < AVDT_CCB_ACTIONS; i++)
@@ -414,6 +416,8 @@
 *******************************************************************************/
 void avdt_ccb_dealloc(tAVDT_CCB *p_ccb, tAVDT_CCB_EVT *p_data)
 {
+    UNUSED(p_data);
+
     AVDT_TRACE_DEBUG1("avdt_ccb_dealloc %d", avdt_ccb_to_idx(p_ccb));
     btu_stop_timer(&p_ccb->timer_entry);
     memset(p_ccb, 0, sizeof(tAVDT_CCB));
diff -Naur '--exclude=.git' bluedroid-orig/stack/avdt/avdt_int.h bluedroid/stack/avdt/avdt_int.h
--- bluedroid-orig/stack/avdt/avdt_int.h	2015-09-24 16:33:43.544227643 +0800
+++ bluedroid/stack/avdt/avdt_int.h	2015-09-24 16:31:37.000000000 +0800
@@ -549,6 +549,7 @@
     tAVDT_SCB_ACTION    *p_scb_act;             /* pointer to SCB action functions */
     tAVDT_CTRL_CBACK    *p_conn_cback;          /* connection callback function */
     UINT8               trace_level;            /* trace level */
+    BOOLEAN             conn_in_progress;       /* outgoing connection in progress */
 } tAVDT_CB;
 
 
diff -Naur '--exclude=.git' bluedroid-orig/stack/avdt/avdt_l2c.c bluedroid/stack/avdt/avdt_l2c.c
--- bluedroid-orig/stack/avdt/avdt_l2c.c	2015-09-24 16:33:43.544227643 +0800
+++ bluedroid/stack/avdt/avdt_l2c.c	2015-09-24 16:31:37.000000000 +0800
@@ -25,6 +25,7 @@
 #include <string.h>
 #include "data_types.h"
 #include "bt_target.h"
+#include "bt_utils.h"
 #include "avdt_api.h"
 #include "avdtc_api.h"
 #include "avdt_int.h"
@@ -74,6 +75,7 @@
     tAVDT_CCB       *p_ccb = NULL;
     tL2CAP_CFG_INFO cfg;
     tAVDT_TC_TBL    *p_tbl;
+    UNUSED(p_ref_data);
 
     AVDT_TRACE_DEBUG1("avdt_sec_check_complete_term res: %d", res);
     if (!bd_addr)
@@ -130,6 +132,7 @@
     tAVDT_CCB       *p_ccb = NULL;
     tL2CAP_CFG_INFO cfg;
     tAVDT_TC_TBL    *p_tbl;
+    UNUSED(p_ref_data);
 
     AVDT_TRACE_DEBUG1("avdt_sec_check_complete_orig res: %d", res);
     if (bd_addr)
@@ -174,9 +177,19 @@
     UINT16          result;
     tL2CAP_CFG_INFO cfg;
     tBTM_STATUS rc;
+    UNUSED(psm);
 
+    /* Check if outgoing connection is in progress
+     * if yes, reject incoming connection at L2CAP
+     * level itself.
+     */
+    if(avdt_cb.conn_in_progress == TRUE)
+    {
+        AVDT_TRACE_WARNING0("connect_ind: outgoing conn in progress: Reject incoming conn");
+        result = L2CAP_CONN_NO_RESOURCES;
+    }
     /* do we already have a control channel for this peer? */
-    if ((p_ccb = avdt_ccb_by_bd(bd_addr)) == NULL)
+    else if ((p_ccb = avdt_ccb_by_bd(bd_addr)) == NULL)
     {
         /* no, allocate ccb */
         if ((p_ccb = avdt_ccb_alloc(bd_addr)) == NULL)
diff -Naur '--exclude=.git' bluedroid-orig/stack/avdt/avdt_msg.c bluedroid/stack/avdt/avdt_msg.c
--- bluedroid-orig/stack/avdt/avdt_msg.c	2015-09-24 16:33:43.544227643 +0800
+++ bluedroid/stack/avdt/avdt_msg.c	2015-09-24 16:31:37.000000000 +0800
@@ -29,6 +29,7 @@
 #include <string.h>
 #include "data_types.h"
 #include "bt_target.h"
+#include "bt_utils.h"
 #include "avdt_api.h"
 #include "avdtc_api.h"
 #include "avdt_int.h"
@@ -373,6 +374,8 @@
 *******************************************************************************/
 static void avdt_msg_bld_none(UINT8 **p, tAVDT_MSG *p_msg)
 {
+    UNUSED(p);
+    UNUSED(p_msg);
     return;
 }
 
@@ -688,8 +691,12 @@
                 /* verify length */
                 AVDT_TRACE_WARNING2("psc_mask=0x%x elem_len=%d", p_cfg->psc_mask, elem_len);
                 if( ((0 == (p_cfg->psc_mask & (AVDT_PSC_RECOV|AVDT_PSC_REPORT))) && (elem_len != 3))
-                    || ((p_cfg->psc_mask & AVDT_PSC_RECOV) && (elem_len != 7))
-                    || ((p_cfg->psc_mask & AVDT_PSC_REPORT) && (elem_len != 5)) )
+                    || (((p_cfg->psc_mask & AVDT_PSC_REPORT) && !(p_cfg->psc_mask & AVDT_PSC_RECOV))
+                    && (elem_len != 5))
+                    || ((!(p_cfg->psc_mask & AVDT_PSC_REPORT) && (p_cfg->psc_mask & AVDT_PSC_RECOV))
+                    && (elem_len != 5))
+                    || (((p_cfg->psc_mask & AVDT_PSC_REPORT) && (p_cfg->psc_mask & AVDT_PSC_RECOV))
+                    && (elem_len != 7)) )
                 {
                     err = AVDT_ERR_MUX_FMT;
                     break;
@@ -771,6 +778,9 @@
 *******************************************************************************/
 static UINT8 avdt_msg_prs_none(tAVDT_MSG *p_msg, UINT8 *p, UINT16 len)
 {
+    UNUSED(p_msg);
+    UNUSED(p);
+    UNUSED(len);
     return 0;
 }
 
@@ -1299,10 +1309,7 @@
                 }
                 else if (sig != AVDT_SIG_DELAY_RPT)
                 {
-                    if ((sig == AVDT_SIG_START))
-                        btu_start_timer(&p_ccb->timer_entry, BTU_TTYPE_AVDT_CCB_RET, avdt_cb.rcb.sig_tout);
-                    else
-                        btu_start_timer(&p_ccb->timer_entry, BTU_TTYPE_AVDT_CCB_RET, avdt_cb.rcb.ret_tout);
+                    btu_start_timer(&p_ccb->timer_entry, BTU_TTYPE_AVDT_CCB_RET, avdt_cb.rcb.ret_tout);
                 }
             }
         }
@@ -1660,10 +1667,8 @@
     p_buf->len = (UINT16) (p - p_start);
 
     /* stash sig, label, and message type in buf */
-    p_buf->event = sig_id;
-    AVDT_BLD_LAYERSPEC(p_buf->layer_specific, AVDT_MSG_TYPE_GRJ, p_params->hdr.label);
-    //p_buf->event = 0;
-    //AVDT_BLD_LAYERSPEC(p_buf->layer_specific, 0, p_params->hdr.label);
+    p_buf->event = 0;
+    AVDT_BLD_LAYERSPEC(p_buf->layer_specific, 0, p_params->hdr.label);
     AVDT_TRACE_DEBUG0("avdt_msg_send_grej");
 
     /* queue message and trigger ccb to send it */
@@ -1712,7 +1717,7 @@
     /* parse the message header */
     AVDT_MSG_PRS_HDR(p, label, pkt_type, msg_type);
 
-    /* AVDT_TRACE_DEBUG1("msg_type=%d", msg_type); */
+    AVDT_TRACE_DEBUG2("msg_type=%d, sig=%d", msg_type, sig);
     /* set up label and ccb_idx in message hdr */
     msg.hdr.label = label;
     msg.hdr.ccb_idx = avdt_ccb_to_idx(p_ccb);
diff -Naur '--exclude=.git' bluedroid-orig/stack/avdt/avdt_scb_act.c bluedroid/stack/avdt/avdt_scb_act.c
--- bluedroid-orig/stack/avdt/avdt_scb_act.c	2015-09-24 16:33:43.544227643 +0800
+++ bluedroid/stack/avdt/avdt_scb_act.c	2015-09-24 16:31:37.000000000 +0800
@@ -26,6 +26,7 @@
 #include <string.h>
 #include "data_types.h"
 #include "bt_target.h"
+#include "bt_utils.h"
 #include "avdt_api.h"
 #include "avdtc_api.h"
 #include "avdt_int.h"
@@ -103,6 +104,8 @@
 *******************************************************************************/
 void avdt_scb_hdl_abort_rsp(tAVDT_SCB *p_scb, tAVDT_SCB_EVT *p_data)
 {
+    UNUSED(p_scb);
+    UNUSED(p_data);
     return;
 }
 
@@ -167,6 +170,8 @@
 *******************************************************************************/
 void avdt_scb_hdl_getconfig_rsp(tAVDT_SCB *p_scb, tAVDT_SCB_EVT *p_data)
 {
+    UNUSED(p_scb);
+    UNUSED(p_data);
     return;
 }
 
@@ -215,6 +220,8 @@
 *******************************************************************************/
 void avdt_scb_hdl_open_rsp(tAVDT_SCB *p_scb, tAVDT_SCB_EVT *p_data)
 {
+    UNUSED(p_data);
+
     /* initiate opening of trans channels for this SEID */
     p_scb->role = AVDT_OPEN_INT;
     avdt_ad_open_req(AVDT_CHAN_MEDIA, p_scb->p_ccb, p_scb, AVDT_INT);
@@ -669,6 +676,8 @@
 *******************************************************************************/
 void avdt_scb_drop_pkt(tAVDT_SCB *p_scb, tAVDT_SCB_EVT *p_data)
 {
+    UNUSED(p_scb);
+
     GKI_freebuf(p_data->p_pkt);
     AVDT_TRACE_ERROR0(" avdt_scb_drop_pkt Dropped incoming media packet");
 }
@@ -875,6 +884,7 @@
 void avdt_scb_hdl_setconfig_rsp(tAVDT_SCB *p_scb, tAVDT_SCB_EVT *p_data)
 {
     tAVDT_EVT_HDR   single;
+    UNUSED(p_data);
 
     if (p_scb->p_ccb != NULL)
     {
@@ -899,6 +909,8 @@
 *******************************************************************************/
 void avdt_scb_hdl_start_cmd(tAVDT_SCB *p_scb, tAVDT_SCB_EVT *p_data)
 {
+    UNUSED(p_data);
+
     (*p_scb->cs.p_ctrl_cback)(avdt_scb_to_hdl(p_scb),
                               p_scb->p_ccb ? p_scb->p_ccb->peer_addr : NULL,
                               AVDT_START_IND_EVT,
@@ -935,6 +947,8 @@
 *******************************************************************************/
 void avdt_scb_hdl_suspend_cmd(tAVDT_SCB *p_scb, tAVDT_SCB_EVT *p_data)
 {
+    UNUSED(p_data);
+
     (*p_scb->cs.p_ctrl_cback)(avdt_scb_to_hdl(p_scb),
                               p_scb->p_ccb ? p_scb->p_ccb->peer_addr : NULL,
                               AVDT_SUSPEND_IND_EVT,
@@ -1221,7 +1235,7 @@
 
         p_data->apiwrite.p_buf->len += AVDT_MEDIA_HDR_SIZE;
         p_data->apiwrite.p_buf->offset -= AVDT_MEDIA_HDR_SIZE;
-
+        p_scb->media_seq++;
         p = (UINT8 *)(p_data->apiwrite.p_buf + 1) + p_data->apiwrite.p_buf->offset;
 
         UINT8_TO_BE_STREAM(p, AVDT_MEDIA_OCTET1);
@@ -1231,8 +1245,6 @@
         UINT32_TO_BE_STREAM(p, ssrc);
     }
 
-    p_scb->media_seq++;
-
     /* store it */
     p_scb->p_pkt = p_data->apiwrite.p_buf;
 }
@@ -1345,6 +1357,7 @@
 void avdt_scb_snd_abort_req(tAVDT_SCB *p_scb, tAVDT_SCB_EVT *p_data)
 {
     tAVDT_EVT_HDR   hdr;
+    UNUSED(p_data);
 
     if (p_scb->p_ccb != NULL)
     {
@@ -1367,6 +1380,8 @@
 *******************************************************************************/
 void avdt_scb_snd_abort_rsp(tAVDT_SCB *p_scb, tAVDT_SCB_EVT *p_data)
 {
+    UNUSED(p_scb);
+
     avdt_msg_send_rsp(avdt_ccb_by_idx(p_data->msg.hdr.ccb_idx), AVDT_SIG_ABORT,
                       &p_data->msg);
 }
@@ -1383,6 +1398,7 @@
 void avdt_scb_snd_close_req(tAVDT_SCB *p_scb, tAVDT_SCB_EVT *p_data)
 {
     tAVDT_EVT_HDR   hdr;
+    UNUSED(p_data);
 
     p_scb->role = AVDT_CLOSE_INT;
 
@@ -1453,6 +1469,7 @@
 void avdt_scb_snd_getconfig_req(tAVDT_SCB *p_scb, tAVDT_SCB_EVT *p_data)
 {
     tAVDT_EVT_HDR   hdr;
+    UNUSED(p_data);
 
     hdr.seid = p_scb->peer_seid;
 
@@ -1485,6 +1502,7 @@
 void avdt_scb_snd_open_req(tAVDT_SCB *p_scb, tAVDT_SCB_EVT *p_data)
 {
     tAVDT_EVT_HDR   hdr;
+    UNUSED(p_data);
 
     hdr.seid = p_scb->peer_seid;
 
@@ -1697,6 +1715,8 @@
 *******************************************************************************/
 void avdt_scb_snd_tc_close(tAVDT_SCB *p_scb, tAVDT_SCB_EVT *p_data)
 {
+    UNUSED(p_data);
+
 #if AVDT_REPORTING == TRUE
     if(p_scb->curr_cfg.psc_mask & AVDT_PSC_REPORT)
         avdt_ad_close_req(AVDT_CHAN_REPORT, p_scb->p_ccb, p_scb);
@@ -1717,6 +1737,7 @@
 void avdt_scb_cb_err(tAVDT_SCB *p_scb, tAVDT_SCB_EVT *p_data)
 {
     tAVDT_CTRL          avdt_ctrl;
+    UNUSED(p_data);
 
     /* set error code and parameter */
     avdt_ctrl.hdr.err_code = AVDT_ERR_BAD_STATE;
@@ -1756,6 +1777,8 @@
 *******************************************************************************/
 void avdt_scb_rej_state(tAVDT_SCB *p_scb, tAVDT_SCB_EVT *p_data)
 {
+    UNUSED(p_scb);
+
     p_data->msg.hdr.err_code = AVDT_ERR_BAD_STATE;
     p_data->msg.hdr.err_param = 0;
     avdt_msg_send_rej(avdt_ccb_by_idx(p_data->msg.hdr.ccb_idx),
@@ -1774,6 +1797,8 @@
 *******************************************************************************/
 void avdt_scb_rej_in_use(tAVDT_SCB *p_scb, tAVDT_SCB_EVT *p_data)
 {
+    UNUSED(p_scb);
+
     p_data->msg.hdr.err_code = AVDT_ERR_IN_USE;
     p_data->msg.hdr.err_param = 0;
     avdt_msg_send_rej(avdt_ccb_by_idx(p_data->msg.hdr.ccb_idx),
@@ -1792,6 +1817,8 @@
 *******************************************************************************/
 void avdt_scb_rej_not_in_use(tAVDT_SCB *p_scb, tAVDT_SCB_EVT *p_data)
 {
+    UNUSED(p_scb);
+
     p_data->msg.hdr.err_code = AVDT_ERR_NOT_IN_USE;
     p_data->msg.hdr.err_param = 0;
     avdt_msg_send_rej(avdt_ccb_by_idx(p_data->msg.hdr.ccb_idx),
@@ -1809,6 +1836,8 @@
 *******************************************************************************/
 void avdt_scb_set_remove(tAVDT_SCB *p_scb, tAVDT_SCB_EVT *p_data)
 {
+    UNUSED(p_data);
+
     p_scb->remove = TRUE;
 }
 
@@ -1867,6 +1896,7 @@
 #if AVDT_MULTIPLEXING == TRUE
     BT_HDR          *p_frag;
 #endif
+    UNUSED(p_data);
 
     /* set error code and parameter */
     avdt_ctrl.hdr.err_code = AVDT_ERR_BAD_STATE;
@@ -1931,6 +1961,7 @@
     UINT8   res = AVDT_AD_SUCCESS;
     tAVDT_SCB_EVT data;
 #endif
+    UNUSED(p_data);
 
     avdt_ctrl.hdr.err_code = 0;
 
@@ -2004,6 +2035,8 @@
 *******************************************************************************/
 void avdt_scb_tc_timer(tAVDT_SCB *p_scb, tAVDT_SCB_EVT *p_data)
 {
+    UNUSED(p_data);
+
     btu_start_timer(&p_scb->timer_entry, BTU_TTYPE_AVDT_SCB_TC, AVDT_SCB_TC_DISC_TOUT);
 }
 
@@ -2018,6 +2051,7 @@
 *******************************************************************************/
 void avdt_scb_clr_vars(tAVDT_SCB *p_scb, tAVDT_SCB_EVT *p_data)
 {
+    UNUSED(p_data);
     p_scb->in_use = FALSE;
     p_scb->p_ccb = NULL;
     p_scb->peer_seid = 0;
diff -Naur '--exclude=.git' bluedroid-orig/stack/avdt/avdt_scb.c bluedroid/stack/avdt/avdt_scb.c
--- bluedroid-orig/stack/avdt/avdt_scb.c	2015-09-24 16:33:43.544227643 +0800
+++ bluedroid/stack/avdt/avdt_scb.c	2015-09-24 16:31:37.000000000 +0800
@@ -26,6 +26,7 @@
 #include <string.h>
 #include "data_types.h"
 #include "bt_target.h"
+#include "bt_utils.h"
 #include "avdt_api.h"
 #include "avdtc_api.h"
 #include "avdt_int.h"
@@ -539,10 +540,10 @@
     state_table = avdt_scb_st_tbl[p_scb->state];
 
     /* set next state */
-    if (p_scb->state != state_table[event][AVDT_SCB_NEXT_STATE])
+    if (p_scb->state != state_table[event][AVDT_SCB_NEXT_STATE]) {
         BTTRC_AVDT_SCB_STATE(state_table[event][AVDT_SCB_NEXT_STATE]);
-    p_scb->state = state_table[event][AVDT_SCB_NEXT_STATE];
-
+        p_scb->state = state_table[event][AVDT_SCB_NEXT_STATE];
+    }
 
     /* execute action functions */
     for (i = 0; i < AVDT_SCB_ACTIONS; i++)
@@ -647,6 +648,7 @@
 #if AVDT_MULTIPLEXING == TRUE
     void *p_buf;
 #endif
+    UNUSED(p_data);
 
     AVDT_TRACE_DEBUG1("avdt_scb_dealloc hdl=%d", avdt_scb_to_hdl(p_scb));
     btu_stop_timer(&p_scb->timer_entry);
@@ -745,7 +747,7 @@
     }
 
     /* verify every scb */
-    for (i = 0; i < num_seid; i++)
+    for (i = 0; ((i < num_seid) && (i < AVDT_NUM_SEPS)); i++)
     {
         if ((p_scb = avdt_scb_by_hdl(p_seid[i])) == NULL)
         {
@@ -764,7 +766,7 @@
         }
     }
 
-    if (i != num_seid)
+    if ((i != num_seid) && (i < AVDT_NUM_SEPS))
     {
         ret = p_seid[i];
     }
diff -Naur '--exclude=.git' bluedroid-orig/stack/avrc/avrc_api.c bluedroid/stack/avrc/avrc_api.c
--- bluedroid-orig/stack/avrc/avrc_api.c	2015-09-24 16:33:43.544227643 +0800
+++ bluedroid/stack/avrc/avrc_api.c	2015-09-24 16:31:37.000000000 +0800
@@ -351,6 +351,7 @@
     BT_HDR      *p_pkt = *pp_pkt;
     UINT8       *p_data;
     BOOLEAN     drop = FALSE;
+    BOOLEAN     buf_overflow = FALSE;
     BT_HDR      *p_rsp = NULL;
     BT_HDR      *p_cmd = NULL;
     BOOLEAN     req_continue = FALSE;
@@ -442,6 +443,7 @@
                     AVRC_TRACE_WARNING0("Fragmented message too big! - report the partial message");
                     p_pkt->len = buf_len - p_rcb->p_rmsg->offset;
                     pkt_type = AVRC_PKT_END;
+                    buf_overflow = TRUE;
                 }
 
                 /* copy contents of p_pkt to p_rx_msg */
@@ -505,6 +507,20 @@
                 AVRC_MsgReq (handle, (UINT8)(label), AVRC_CMD_CTRL, p_cmd);
             }
         }
+        /*
+         * Drop it if we are out of buffer
+         */
+        else if (cr == AVCT_RSP && req_continue == FALSE  && buf_overflow == TRUE)
+        {
+            avrc_cmd.pdu    = AVRC_PDU_ABORT_CONTINUATION_RSP;
+            avrc_cmd.status = AVRC_STS_NO_ERROR;
+            avrc_cmd.target_pdu = p_rcb->rasm_pdu;
+            if (AVRC_BldCommand ((tAVRC_COMMAND *)&avrc_cmd, &p_cmd) == AVRC_STS_NO_ERROR)
+            {
+                drop = 4;
+                AVRC_MsgReq (handle, (UINT8)(label), AVRC_CMD_CTRL, p_cmd);
+            }
+        }
     }
 
     return drop;
@@ -529,7 +545,7 @@
     UINT8       *p_data;
     UINT8       *browse_length;
     UINT8       *p_begin;
-    BOOLEAN     drop = FALSE;
+    UINT8       drop = 0;
     BOOLEAN     free = TRUE;
     BT_HDR      *p_rsp = NULL;
     UINT8       *p_rsp_data;
@@ -577,7 +593,6 @@
             msg.hdr.subunit_type    = (p_data[1] & AVRC_SUBTYPE_MASK) >> AVRC_SUBTYPE_SHIFT;
             msg.hdr.subunit_id      = p_data[1] & AVRC_SUBID_MASK;
             opcode                  = p_data[2];
-            AVRC_TRACE_ERROR1("opcode %x",opcode);
         }
 
 
@@ -781,7 +796,7 @@
         opcode = p_data[0];
         AVRC_TRACE_DEBUG2("opcode:%x, length:%x",opcode, p_pkt->len);
         /*Do sanity Check here*/
-        if (cr == AVCT_CMD)
+        if ((avrc_cb.ccb[handle].control & AVRC_CT_TARGET) && (cr == AVCT_CMD))
         {
             opcode  =  AVRC_OP_BROWSE;
             msg.browse.browse_len = p_pkt->len;
@@ -792,9 +807,10 @@
         }
         else
         {
-            AVRC_TRACE_ERROR0("### expect AVCT_CMD");
-            GKI_freebuf(p_pkt);
+            AVRC_TRACE_ERROR0("Drop invalid Avrcp Browse message");
         }
+        /*Free the packet as the same already got copied in BTA*/
+        GKI_freebuf(p_pkt);
     }
 
 }
@@ -1034,7 +1050,7 @@
             AVRC_TRACE_DEBUG1 ("p_pkt->len(%d) > AVRC_MAX_CTRL_DATA_LEN", p_pkt->len );
             p_pkt_new = (BT_HDR *)GKI_getbuf((UINT16)(AVRC_PACKET_LEN + AVCT_MSG_OFFSET
                 + BT_HDR_SIZE));
-            if (p_pkt_new)
+            if ((p_pkt_new) && (p_start != NULL))
             {
                 p_fcb->frag_enabled = TRUE;
                 p_fcb->p_fmsg       = p_pkt;
diff -Naur '--exclude=.git' bluedroid-orig/stack/avrc/avrc_bld_ct.c bluedroid/stack/avrc/avrc_bld_ct.c
--- bluedroid-orig/stack/avrc/avrc_bld_ct.c	2015-09-24 16:33:43.544227643 +0800
+++ bluedroid/stack/avrc/avrc_bld_ct.c	2015-09-24 16:31:37.000000000 +0800
@@ -1,5 +1,6 @@
 /******************************************************************************
  *
+ *  Copyright (c) 2015, The Linux Foundation. All rights reserved.
  *  Copyright (C) 2006-2013 Broadcom Corporation
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
@@ -88,27 +89,214 @@
 
 /*******************************************************************************
 **
-** Function         avrc_bld_vol_change_notfn
+** Function         avrc_bld_register_notifn
 **
-** Description      This function builds the register notification for volume change.
+** Description      This function builds the register notification.
 **
 ** Returns          AVRC_STS_NO_ERROR, if the command is built successfully
 **                  Otherwise, the error code.
 **
 *******************************************************************************/
-static tAVRC_STS avrc_bld_vol_change_notfn(BT_HDR * p_pkt)
+static tAVRC_STS avrc_bld_register_notifn(BT_HDR * p_pkt, UINT8 event_id, UINT32 event_param)
 {
     UINT8   *p_data, *p_start;
 
-    AVRC_TRACE_API0("avrc_bld_vol_change");
+    AVRC_TRACE_API0("avrc_bld_register_notifn");
     /* get the existing length, if any, and also the num attributes */
     // Set the notify value
     p_start = (UINT8 *)(p_pkt + 1) + p_pkt->offset;
     p_data = p_start + 2; /* pdu + rsvd */
     /* add fixed length 5 -*/
     UINT16_TO_BE_STREAM(p_data, 5);
-    UINT8_TO_BE_STREAM(p_data,AVRC_EVT_VOLUME_CHANGE);
-    UINT32_TO_BE_STREAM(p_data, 0);
+    UINT8_TO_BE_STREAM(p_data,event_id);
+    UINT32_TO_BE_STREAM(p_data, event_param);
+    p_pkt->len = (p_data - p_start);
+    return AVRC_STS_NO_ERROR;
+}
+/*******************************************************************************
+**
+** Function         avrc_bld_get_capability_cmd
+**
+** Description      This function builds the get capability command.
+**
+** Returns          AVRC_STS_NO_ERROR, if the command is built successfully
+**                  Otherwise, the error code.
+**
+*******************************************************************************/
+static tAVRC_STS avrc_bld_get_capability_cmd(BT_HDR * p_pkt, UINT8 cap_id)
+{
+    UINT8   *p_data, *p_start;
+
+    AVRC_TRACE_API0("avrc_bld_get_capability_cmd");
+    p_start = (UINT8 *)(p_pkt + 1) + p_pkt->offset;
+    p_data = p_start + 2; /* pdu + rsvd */
+    /* add fixed length 1 -*/
+    UINT16_TO_BE_STREAM(p_data, 1);
+    UINT8_TO_BE_STREAM(p_data,cap_id);
+    p_pkt->len = (p_data - p_start);
+    return AVRC_STS_NO_ERROR;
+}
+/*******************************************************************************
+**
+** Function         avrc_bld_list_player_app_attr_cmd
+**
+** Description      This function builds the list player app attrib command.
+**
+** Returns          AVRC_STS_NO_ERROR, if the command is built successfully
+**                  Otherwise, the error code.
+**
+*******************************************************************************/
+static tAVRC_STS avrc_bld_list_player_app_attr_cmd(BT_HDR * p_pkt)
+{
+    UINT8   *p_data, *p_start;
+
+    AVRC_TRACE_API0("avrc_bld_list_player_app_attr_cmd");
+    p_start = (UINT8 *)(p_pkt + 1) + p_pkt->offset;
+    p_data = p_start + 2; /* pdu + rsvd */
+    /* add fixed length 1 -*/
+    UINT16_TO_BE_STREAM(p_data, 0);
+    p_pkt->len = (p_data - p_start);
+    return AVRC_STS_NO_ERROR;
+}
+/*******************************************************************************
+**
+** Function         avrc_bld_list_player_app_values_cmd
+**
+** Description      This function builds the list player app values command.
+**
+** Returns          AVRC_STS_NO_ERROR, if the command is built successfully
+**                  Otherwise, the error code.
+**
+*******************************************************************************/
+static tAVRC_STS avrc_bld_list_player_app_values_cmd(BT_HDR * p_pkt, UINT8 attrib_id)
+{
+    UINT8   *p_data, *p_start;
+
+    AVRC_TRACE_API0("avrc_bld_list_player_app_values_cmd");
+    p_start = (UINT8 *)(p_pkt + 1) + p_pkt->offset;
+    p_data = p_start + 2; /* pdu + rsvd */
+    /* add fixed length 1 -*/
+    UINT16_TO_BE_STREAM(p_data, 1);
+    UINT8_TO_BE_STREAM(p_data,attrib_id);
+    p_pkt->len = (p_data - p_start);
+    return AVRC_STS_NO_ERROR;
+}
+/*******************************************************************************
+**
+** Function         avrc_bld_get_current_player_app_values_cmd
+**
+** Description      This function builds the get current player app setting values command.
+**
+** Returns          AVRC_STS_NO_ERROR, if the command is built successfully
+**                  Otherwise, the error code.
+**
+*******************************************************************************/
+static tAVRC_STS avrc_bld_get_current_player_app_values_cmd(BT_HDR * p_pkt, UINT8 num_attrib_id, UINT8* attrib_ids)
+{
+    UINT8   *p_data, *p_start;
+    UINT8 param_len = 0, count = 0;
+
+    AVRC_TRACE_API0("avrc_bld_get_current_player_app_values_cmd");
+    p_start = (UINT8 *)(p_pkt + 1) + p_pkt->offset;
+    p_data = p_start + 2; /* pdu + rsvd */
+    param_len = num_attrib_id + 1; // 1 additional to hold num attributes feild
+    /* add length -*/
+    UINT16_TO_BE_STREAM(p_data, param_len);
+    UINT8_TO_BE_STREAM(p_data,num_attrib_id);
+    for(count = 0; count < num_attrib_id; count ++)
+    {
+        UINT8_TO_BE_STREAM(p_data,attrib_ids[count]);
+    }
+    p_pkt->len = (p_data - p_start);
+    return AVRC_STS_NO_ERROR;
+}
+/*******************************************************************************
+**
+** Function         avrc_bld_set_current_player_app_values_cmd
+**
+** Description      This function builds the set current player app setting values command.
+**
+** Returns          AVRC_STS_NO_ERROR, if the command is built successfully
+**                  Otherwise, the error code.
+**
+*******************************************************************************/
+static tAVRC_STS avrc_bld_set_current_player_app_values_cmd(BT_HDR * p_pkt, UINT8 num_attrib_id, tAVRC_APP_SETTING* p_val)
+{
+    UINT8   *p_data, *p_start;
+    UINT8 param_len = 0, count = 0;
+
+    AVRC_TRACE_API0("avrc_bld_set_current_player_app_values_cmd");
+    p_start = (UINT8 *)(p_pkt + 1) + p_pkt->offset;
+    p_data = p_start + 2; /* pdu + rsvd */
+    /* we have to store attrib- value pair
+     * 1 additional to store num elements
+     */
+    param_len = (2*num_attrib_id) + 1;
+    /* add length */
+    UINT16_TO_BE_STREAM(p_data, param_len);
+    UINT8_TO_BE_STREAM(p_data,num_attrib_id);
+    for(count = 0; count < num_attrib_id; count ++)
+    {
+        UINT8_TO_BE_STREAM(p_data,p_val[count].attr_id);
+        UINT8_TO_BE_STREAM(p_data,p_val[count].attr_val);
+    }
+    p_pkt->len = (p_data - p_start);
+    return AVRC_STS_NO_ERROR;
+}
+/*******************************************************************************
+**
+** Function         avrc_bld_get_element_attr_cmd
+**
+** Description      This function builds the get element attribute command.
+**
+** Returns          AVRC_STS_NO_ERROR, if the command is built successfully
+**                  Otherwise, the error code.
+**
+*******************************************************************************/
+static tAVRC_STS avrc_bld_get_element_attr_cmd(BT_HDR * p_pkt, UINT8 num_attrib, UINT32* attrib_ids)
+{
+    UINT8   *p_data, *p_start;
+    UINT8 param_len = 0, count = 0;
+
+    AVRC_TRACE_API0("avrc_bld_get_element_attr_cmd");
+    p_start = (UINT8 *)(p_pkt + 1) + p_pkt->offset;
+    p_data = p_start + 2; /* pdu + rsvd */
+    /* we have to store attrib- value pair
+     * 1 additional to store num elements
+     */
+    param_len = (4*num_attrib) + 9;
+    /* add length */
+    UINT16_TO_BE_STREAM(p_data, param_len);
+    /* 8 bytes of identifier as 0 (playing)*/
+    UINT32_TO_BE_STREAM(p_data,0);
+    UINT32_TO_BE_STREAM(p_data,0);
+    UINT8_TO_BE_STREAM(p_data,num_attrib);
+    for(count = 0; count < num_attrib; count ++)
+    {
+        UINT32_TO_BE_STREAM(p_data,attrib_ids[count]);
+    }
+    p_pkt->len = (p_data - p_start);
+    return AVRC_STS_NO_ERROR;
+}
+/*******************************************************************************
+**
+** Function         avrc_bld_get_play_status_cmd
+**
+** Description      This function builds the get play status command.
+**
+** Returns          AVRC_STS_NO_ERROR, if the command is built successfully
+**                  Otherwise, the error code.
+**
+*******************************************************************************/
+static tAVRC_STS avrc_bld_get_play_status_cmd(BT_HDR * p_pkt)
+{
+    UINT8   *p_data, *p_start;
+
+    AVRC_TRACE_API0("avrc_bld_list_player_app_attr_cmd");
+    p_start = (UINT8 *)(p_pkt + 1) + p_pkt->offset;
+    p_data = p_start + 2; /* pdu + rsvd */
+    /* add fixed length 1 -*/
+    UINT16_TO_BE_STREAM(p_data, 0);
     p_pkt->len = (p_data - p_start);
     return AVRC_STS_NO_ERROR;
 }
@@ -228,14 +416,35 @@
         status = avrc_bld_set_abs_volume_cmd(&p_cmd->volume, p_pkt);
         break;
 #endif
-
-    case AVRC_PDU_REGISTER_NOTIFICATION:      /* 0x31 */
 #if (AVRC_ADV_CTRL_INCLUDED == TRUE)
-        if(AVRC_EVT_VOLUME_CHANGE==p_cmd->reg_notif.event_id)
-           status=avrc_bld_vol_change_notfn(p_pkt);
-#endif
+    case AVRC_PDU_REGISTER_NOTIFICATION:      /* 0x31 */
+        status=avrc_bld_register_notifn(p_pkt,p_cmd->reg_notif.event_id,p_cmd->reg_notif.param);
         break;
-
+    case AVRC_PDU_GET_CAPABILITIES:
+        status = avrc_bld_get_capability_cmd(p_pkt, p_cmd->get_caps.capability_id);
+        break;
+    case AVRC_PDU_LIST_PLAYER_APP_ATTR:
+        status = avrc_bld_list_player_app_attr_cmd(p_pkt);
+        break;
+    case AVRC_PDU_LIST_PLAYER_APP_VALUES:
+        status = avrc_bld_list_player_app_values_cmd(p_pkt,p_cmd->list_app_values.attr_id);
+        break;
+    case AVRC_PDU_GET_CUR_PLAYER_APP_VALUE:
+        status = avrc_bld_get_current_player_app_values_cmd(p_pkt,
+             p_cmd->get_cur_app_val.num_attr,p_cmd->get_cur_app_val.attrs);
+        break;
+    case AVRC_PDU_SET_PLAYER_APP_VALUE:
+        status = avrc_bld_set_current_player_app_values_cmd(p_pkt,
+                     p_cmd->set_app_val.num_val,p_cmd->set_app_val.p_vals);
+        break;
+    case AVRC_PDU_GET_ELEMENT_ATTR:
+        status = avrc_bld_get_element_attr_cmd(p_pkt,
+              p_cmd->get_elem_attrs.num_attr,p_cmd->get_elem_attrs.attrs);
+        break;
+    case AVRC_PDU_GET_PLAY_STATUS:
+        status = avrc_bld_get_play_status_cmd(p_pkt);
+        break;
+#endif
     }
 
     if (alloc && (status != AVRC_STS_NO_ERROR) )
diff -Naur '--exclude=.git' bluedroid-orig/stack/avrc/avrc_bld_tg.c bluedroid/stack/avrc/avrc_bld_tg.c
--- bluedroid-orig/stack/avrc/avrc_bld_tg.c	2015-09-24 16:33:43.544227643 +0800
+++ bluedroid/stack/avrc/avrc_bld_tg.c	2015-09-24 16:31:37.000000000 +0800
@@ -21,6 +21,7 @@
 #include "avrc_api.h"
 #include "avrc_defs.h"
 #include "avrc_int.h"
+#include "bt_utils.h"
 
 /*****************************************************************************
 **  Global data
@@ -279,6 +280,9 @@
 *******************************************************************************/
 static tAVRC_STS avrc_bld_set_app_setting_value_rsp (tAVRC_RSP *p_rsp, BT_HDR *p_pkt)
 {
+    UNUSED(p_rsp);
+    UNUSED(p_pkt);
+
     /* nothing to be added. */
     AVRC_TRACE_API0("avrc_bld_set_app_setting_value_rsp");
     return AVRC_STS_NO_ERROR;
@@ -404,6 +408,9 @@
 *******************************************************************************/
 static tAVRC_STS avrc_bld_inform_charset_rsp (tAVRC_RSP *p_rsp, BT_HDR *p_pkt)
 {
+    UNUSED(p_rsp);
+    UNUSED(p_pkt);
+
     /* nothing to be added. */
     AVRC_TRACE_API0("avrc_bld_inform_charset_rsp");
     return AVRC_STS_NO_ERROR;
@@ -422,6 +429,9 @@
 *******************************************************************************/
 static tAVRC_STS avrc_bld_inform_battery_status_rsp (tAVRC_RSP *p_rsp, BT_HDR *p_pkt)
 {
+    UNUSED(p_rsp);
+    UNUSED(p_pkt);
+
     /* nothing to be added. */
     AVRC_TRACE_API0("avrc_bld_inform_battery_status_rsp");
     return AVRC_STS_NO_ERROR;
@@ -519,7 +529,6 @@
 
     return AVRC_STS_NO_ERROR;
 }
-
 /*******************************************************************************
 **
 ** Function         avrc_bld_notify_rsp
@@ -538,7 +547,7 @@
     UINT8   xx;
     tAVRC_STS status = AVRC_STS_NO_ERROR;
 
-    AVRC_TRACE_API0("avrc_bld_notify_rsp");
+    AVRC_TRACE_API1("avrc_bld_notify_rsp event_id %d",p_rsp->event_id);
 
     p_start = (UINT8 *)(p_pkt + 1) + p_pkt->offset;
     p_data = p_len = p_start + 2; /* pdu + rsvd */
@@ -642,6 +651,10 @@
         len = EVT_ADDR_PLAYER_CHANGE_RSP_LENGTH;
         break;
 
+    case AVRC_EVT_VOLUME_CHANGE:
+        len = 2;
+        UINT8_TO_BE_STREAM(p_data, (AVRC_MAX_VOLUME & p_rsp->param.volume));
+        break;
     default:
         status = AVRC_STS_BAD_PARAM;
         AVRC_TRACE_ERROR0("unknown event_id");
@@ -666,6 +679,9 @@
 *******************************************************************************/
 static tAVRC_STS avrc_bld_next_rsp (tAVRC_RSP *p_rsp, BT_HDR *p_pkt)
 {
+    UNUSED(p_rsp);
+    UNUSED(p_pkt);
+
     /* nothing to be added. */
     AVRC_TRACE_API0("avrc_bld_next_rsp");
     return AVRC_STS_NO_ERROR;
@@ -697,6 +713,31 @@
     return status;
 }
 
+/*****************************************************************************
+**
+** Function      avrc_bld_set_absolute_volume_rsp
+**
+** Description   This function builds the set absolute volume response
+**
+** Returns       AVRC_STS_NO_ERROR, if the response is build successfully
+**               Otherwise, the error code.
+**
+******************************************************************************/
+static tAVRC_STS avrc_bld_set_absolute_volume_rsp(UINT8 abs_vol, BT_HDR *p_pkt)
+{
+    UINT8   *p_data, *p_start;
+    tAVRC_STS status = AVRC_STS_NO_ERROR;
+
+    AVRC_TRACE_API0(" avrc_bld_play_item_rsp");
+    p_start = (UINT8 *)(p_pkt + 1) + p_pkt->offset;
+    /* To calculate length */
+    p_data = p_start + 2;
+    /* add fixed lenth status(1) */
+    UINT16_TO_BE_STREAM(p_data, 1);
+    UINT8_TO_BE_STREAM(p_data, abs_vol);
+    p_pkt->len = (p_data - p_start);
+    return status;
+}
 /*******************************************************************************
 **
 ** Function         avrc_bld_group_navigation_rsp
@@ -737,10 +778,10 @@
 ******************************************************************************/
 static tAVRC_STS  avrc_bld_folder_item_values_rsp(tAVRC_GET_ITEMS_RSP *p_rsp, BT_HDR *p_pkt )
 {
-    UINT8 *p_data, *p_start, *p_length;
+    UINT8 *p_data, *p_start, *p_length, *p_media_element_len;
     UINT8 *item_length;
-    UINT16 itemlength;
-    UINT16 length = 0, item_numb = 0, i;
+    UINT16 itemlength, param_length;
+    UINT16 length = 0, item_numb = 0, i, xx, media_attr_count;
 
     AVRC_TRACE_DEBUG1(" avrc_bld_folder_item_values_rsp offset :x%x", p_pkt->offset);
     p_start       = (UINT8 *)(p_pkt + 1) + p_pkt->offset;
@@ -771,122 +812,78 @@
     /*Number of Items OCT 6 and 7*/
     item_numb = p_rsp->item_count;
     UINT16_TO_BE_STREAM(p_data, p_rsp->item_count);
-
-    switch(p_rsp->p_item_list->item_type)
+    param_length = 0;
+    for (i = 0; i < item_numb; i++)
     {
-        case AVRC_ITEM_PLAYER:
-            for (i =0 ; i < item_numb ; ++i)
-            {
-                /* Item Type OCT 8 */
-                *p_data++    = p_rsp->p_item_list[i].item_type; /* AVRC_ITEM_PLAYER, AVRC_ITEM_FOLDER, or AVRC_ITEM_MEDIA */
-                /*Store item_length location and update it*/
-                item_length  = p_data ;
-                p_data       = p_data + 2 ;
-                /* Player ID OCT 11 and 12*/
-                UINT16_TO_BE_STREAM(p_data ,p_rsp->p_item_list[i].u.player.player_id) ;
-                /*Major Player type , OCT 13*/
-                *p_data++    = p_rsp->p_item_list[i].u.player.major_type;
-                /*Player SUB type OCT 14 to 17*/
-                UINT32_TO_BE_STREAM(p_data ,p_rsp->p_item_list[i].u.player.sub_type );
-                /*Play Status OCT 18*/
-                *p_data++   = p_rsp->p_item_list[i].u.player.play_status ;
-                /*Feature BIT MASK OCT 19 to OCT 34*/
-                ARRAY_TO_BE_STREAM(p_data,p_rsp->p_item_list[i].u.player.features ,AVRC_FEATURE_MASK_SIZE);
-                /*Charset ID OCT 35 and 36*/
-                UINT16_TO_BE_STREAM(p_data ,p_rsp->p_item_list[i].u.player.name.charset_id);
-                /*Displayable name lenght OCT 37 and 38*/
-                UINT16_TO_BE_STREAM(p_data ,p_rsp->p_item_list[i].u.player.name.str_len);
-                /*Displayable Name OCT 39 + str lenght*/
-                ARRAY_TO_BE_STREAM(p_data,p_rsp->p_item_list[i].u.player.name.p_str ,\
-                                   p_rsp->p_item_list[i].u.player.name.str_len );
-                itemlength = (UINT16)(p_data - item_length);
-                itemlength = itemlength - 2;
-                AVRC_TRACE_DEBUG1("itemlength = %d",itemlength);
-                length     += itemlength + 3; //Add 2 OCTETS of param_length + 1 Media type
-                UINT16_TO_BE_STREAM(item_length ,itemlength );
-            }
-            break;
-        case AVRC_ITEM_FOLDER:
-            /*Not Supported */
-            AVRC_TRACE_ERROR0("### AVRC_ITEM_RESPONSE Not supported");
-            break;
-        case AVRC_ITEM_MEDIA:
-            /* Not Supported */
-            AVRC_TRACE_ERROR0("### AVRC_ITEM_Media Not supported");
-            break;
-        default :
-            AVRC_TRACE_ERROR0("### Response not valid type");
-            break;
+        itemlength = 0;
+        switch(p_rsp->p_item_list[i].item_type)
+        {
+            case AVRC_ITEM_PLAYER:
+                UINT8_TO_BE_STREAM(p_data, p_rsp->p_item_list[i].item_type);
+                itemlength = 28 + p_rsp->p_item_list[i].u.player.name.str_len;
+                UINT16_TO_BE_STREAM(p_data, itemlength);
+                UINT16_TO_BE_STREAM(p_data, p_rsp->p_item_list[i].u.player.player_id);
+                UINT8_TO_BE_STREAM(p_data, p_rsp->p_item_list[i].u.player.major_type);
+                UINT32_TO_BE_STREAM(p_data, p_rsp->p_item_list[i].u.player.sub_type);
+                UINT8_TO_BE_STREAM(p_data, p_rsp->p_item_list[i].u.player.play_status);
+                ARRAY_TO_BE_STREAM(p_data, p_rsp->p_item_list[i].u.player.features,\
+                                                                AVRC_FEATURE_MASK_SIZE);
+                UINT16_TO_BE_STREAM(p_data, p_rsp->p_item_list[i].u.player.name.charset_id);
+                UINT16_TO_BE_STREAM(p_data, p_rsp->p_item_list[i].u.player.name.str_len);
+                ARRAY_TO_BE_STREAM(p_data, p_rsp->p_item_list[i].u.player.name.p_str,\
+                                   p_rsp->p_item_list[i].u.player.name.str_len);
+                break;
+            case AVRC_ITEM_FOLDER:
+                UINT8_TO_BE_STREAM(p_data, p_rsp->p_item_list[i].item_type);
+                itemlength = 14 + p_rsp->p_item_list[i].u.folder.name.str_len;
+                UINT16_TO_BE_STREAM(p_data, itemlength);
+                ARRAY_TO_BE_STREAM(p_data, p_rsp->p_item_list[i].u.folder.uid ,AVRC_UID_SIZE);
+                UINT8_TO_BE_STREAM(p_data, p_rsp->p_item_list[i].u.folder.type);
+                UINT8_TO_BE_STREAM(p_data, p_rsp->p_item_list[i].u.folder.playable);
+                UINT16_TO_BE_STREAM(p_data, p_rsp->p_item_list[i].u.folder.name.charset_id);
+                UINT16_TO_BE_STREAM(p_data, p_rsp->p_item_list[i].u.folder.name.str_len);
+                ARRAY_TO_BE_STREAM(p_data, p_rsp->p_item_list[i].u.folder.name.p_str,\
+                                   p_rsp->p_item_list[i].u.folder.name.str_len);
+                break;
+            case AVRC_ITEM_MEDIA:
+                UINT8_TO_BE_STREAM(p_data, p_rsp->p_item_list[i].item_type);
+                p_media_element_len = p_data;
+                itemlength = 13 + p_rsp->p_item_list[i].u.media.name.str_len;
+                p_data = p_data + 2; /* for length */
+                ARRAY_TO_BE_STREAM(p_data, p_rsp->p_item_list[i].u.media.uid ,AVRC_UID_SIZE);
+                UINT8_TO_BE_STREAM(p_data, p_rsp->p_item_list[i].u.media.type);
+                UINT16_TO_BE_STREAM(p_data, p_rsp->p_item_list[i].u.media.name.charset_id);
+                UINT16_TO_BE_STREAM(p_data, p_rsp->p_item_list[i].u.media.name.str_len);
+                ARRAY_TO_BE_STREAM(p_data, p_rsp->p_item_list[i].u.media.name.p_str,\
+                                                   p_rsp->p_item_list[i].u.media.name.str_len);
+                UINT8_TO_BE_STREAM(p_data, p_rsp->p_item_list[i].u.media.attr_count);
+                media_attr_count = p_rsp->p_item_list[i].u.media.attr_count;
+                itemlength += 1; /* for attribute count  */
+                for (xx = 0; xx < media_attr_count; xx++)
+                {
+                    itemlength += 8 +  p_rsp->p_item_list[i].u.media.p_attr_list[xx].name.str_len;
+                    UINT32_TO_BE_STREAM(p_data,\
+                        p_rsp->p_item_list[i].u.media.p_attr_list[xx].attr_id);
+                    UINT16_TO_BE_STREAM(p_data,\
+                        p_rsp->p_item_list[i].u.media.p_attr_list[xx].name.charset_id);
+                    UINT16_TO_BE_STREAM(p_data,\
+                        p_rsp->p_item_list[i].u.media.p_attr_list[xx].name.str_len);
+                    ARRAY_TO_BE_STREAM(p_data,\
+                        p_rsp->p_item_list[i].u.media.p_attr_list[xx].name.p_str,\
+                        p_rsp->p_item_list[i].u.media.p_attr_list[xx].name.str_len);
+                }
+                UINT16_TO_BE_STREAM(p_media_element_len, itemlength);
+                break;
+        }
+        param_length += itemlength + 3; /* 3 to accommodate item_len and item_type */
     }
-    //Update the item length item
-    length    = length + 5; //Add explicit 5, 2 num items+ 2UID Counter + 1 status counter
-    UINT16_TO_BE_STREAM(p_length ,length );
-    p_pkt->len  = length + 3; //2 bytes of length + PDU
-    AVRC_TRACE_DEBUG1("length = %d",length);
-    return p_rsp->status ;
+    param_length = param_length + 5; //Add explicit 5, 2 num items+ 2UID Counter + 1 status counter
+    UINT16_TO_BE_STREAM(p_length, param_length);
+    p_pkt->len  = p_data - p_start;
+    return AVRC_STS_NO_ERROR;
 }
 
-/**************************************************************************************
-**
-** Function                  avrcp_bld_setfolder_rsp
-**
-** Description
-**
-** Returns
-**
-************************************************************************************/
-static tAVRC_STS avrcp_bld_setfolder_rsp (tAVRC_SET_BR_PLAYER_RSP *p_rsp, BT_HDR *p_pkt )
-{
-    UINT8 *p_data, *p_start, *p_length , *p_debug;
-    UINT8 *item_length;
-    UINT16 itemlength;
-    UINT16 length=0 , item_numb=0 ,i;
 
-    AVRC_TRACE_DEBUG1("avrcp_bld_setfolder_rsp offset :x%x", p_pkt->offset);
-    p_start       = (UINT8 *)(p_pkt + 1) + p_pkt->offset;
-    p_debug       = p_start;
-    p_data        = p_start ; //1st byte is PDU and rsp does not have any OPCODE
-    *p_data++      =  p_rsp->pdu;
-    /* Refer Media Play list AVRCP 1.5 22.19 (Response for Set Folder Items)
-     * Mark a pointer to be filled once length is calculated at last
-    */
-    p_length       =  p_data;
-    /* increment to adjust length*/
-    p_data         = p_data + 2 ;
-
-    /* Status , TODO check for proper status else return error */
-    *p_data++     = p_rsp->status;
-
-    /* UID Counter OCT 4 and 5 */
-    UINT16_TO_BE_STREAM(p_data ,p_rsp->uid_counter);
-
-    /* Number of items OCT 6 to 9 */
-    UINT32_TO_BE_STREAM(p_data ,p_rsp->num_items);
-    /* Charset ID OCT 10 and 11 */
-    UINT32_TO_BE_STREAM(p_data ,p_rsp->charset_id);
-    /* Folder depth OCT 12 */
-    *p_data++    = p_rsp->folder_depth;
-    /* Charset ID */
-    UINT32_TO_BE_STREAM(p_data ,p_rsp->charset_id);
-
-    switch (p_rsp->folder_depth)
-    {
-        case 2:
-            UINT16_TO_BE_STREAM(p_data, p_rsp->p_folders[0].str_len);
-            ARRAY_TO_BE_STREAM(p_data,p_rsp->p_folders[0].p_str ,p_rsp->p_folders[0].str_len);
-            UINT16_TO_BE_STREAM(p_data, p_rsp->p_folders[1].str_len);
-            ARRAY_TO_BE_STREAM(p_data,p_rsp->p_folders[1].p_str ,p_rsp->p_folders[1].str_len);
-            break;
-
-        default:
-            break;
-    }
-    itemlength = (UINT16)(p_data - p_start ) - 2;
-    UINT16_TO_BE_STREAM(p_length, itemlength);
-    p_pkt->len  = itemlength;
-    AVRC_TRACE_DEBUG1("length = %d",itemlength);
-    return p_rsp->status ;
-}
 
 /*******************************************************************************
 **
@@ -1030,6 +1027,7 @@
     tAVRC_STS status = AVRC_STS_BAD_PARAM;
     BT_HDR *p_pkt;
     BOOLEAN alloc = FALSE;
+    UNUSED(handle);
 
     if (!p_rsp || !pp_pkt)
     {
@@ -1122,6 +1120,10 @@
     case AVRC_PDU_SET_ADDRESSED_PLAYER: /*PDU 0x60*/
         status = avrc_bld_set_address_player_rsp(&p_rsp->addr_player, p_pkt);
         break;
+
+    case AVRC_PDU_SET_ABSOLUTE_VOLUME:
+        status = avrc_bld_set_absolute_volume_rsp(p_rsp->volume.volume, p_pkt);
+        break;
     }
 
     if (alloc && (status != AVRC_STS_NO_ERROR) )
@@ -1216,10 +1218,6 @@
             status = avrc_bld_folder_item_values_rsp(&p_rsp->get_items, p_pkt);
             break;
 
-        case AVRC_PDU_SET_BROWSED_PLAYER:
-            status = avrcp_bld_setfolder_rsp(&p_rsp->br_player, p_pkt);
-            break;
-
         default :
             break;
     }
diff -Naur '--exclude=.git' bluedroid-orig/stack/avrc/avrc_int.h bluedroid/stack/avrc/avrc_int.h
--- bluedroid-orig/stack/avrc/avrc_int.h	2015-09-24 16:33:43.544227643 +0800
+++ bluedroid/stack/avrc/avrc_int.h	2015-09-24 16:31:37.000000000 +0800
@@ -42,6 +42,7 @@
 
 /* Number of protocol elements in protocol element list. */
 #define AVRC_NUM_PROTO_ELEMS     2
+#define AVRC_NUM_ADDL_PROTO_ELEMS     1
 
 #ifndef AVRC_MIN_CMD_LEN
 #define AVRC_MIN_CMD_LEN    20
diff -Naur '--exclude=.git' bluedroid-orig/stack/avrc/avrc_pars_ct.c bluedroid/stack/avrc/avrc_pars_ct.c
--- bluedroid-orig/stack/avrc/avrc_pars_ct.c	2015-09-24 16:33:43.544227643 +0800
+++ bluedroid/stack/avrc/avrc_pars_ct.c	2015-09-24 16:31:37.000000000 +0800
@@ -1,5 +1,6 @@
 /******************************************************************************
  *
+ *  Copyright (c) 2015, The Linux Foundation. All rights reserved.
  *  Copyright (C) 2006-2013 Broadcom Corporation
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
@@ -21,6 +22,7 @@
 #include "avrc_api.h"
 #include "avrc_defs.h"
 #include "avrc_int.h"
+#include "bt_utils.h"
 
 /*****************************************************************************
 **  Global data
@@ -39,7 +41,7 @@
 **                  Otherwise, the error code defined by AVRCP 1.4
 **
 *******************************************************************************/
-static tAVRC_STS avrc_pars_vendor_rsp(tAVRC_MSG_VENDOR *p_msg, tAVRC_RESPONSE *p_result, UINT8 *p_buf, UINT16 buf_len)
+static tAVRC_STS avrc_pars_vendor_rsp(tAVRC_MSG_VENDOR *p_msg, tAVRC_RESPONSE *p_result)
 {
     tAVRC_STS  status = AVRC_STS_NO_ERROR;
     UINT8   *p = p_msg->p_vendor_data;
@@ -102,6 +104,189 @@
 
     return status;
 }
+#if (AVRC_ADV_CTRL_INCLUDED == TRUE)
+/*******************************************************************************
+**
+** Function         avrc_ctrl_pars_vendor_rsp
+**
+** Description      This function parses the vendor specific commands defined by
+**                  Bluetooth SIG
+**
+** Returns          AVRC_STS_NO_ERROR, if the message in p_data is parsed successfully.
+**                  Otherwise, the error code defined by AVRCP 1.4
+**
+*******************************************************************************/
+static tAVRC_STS avrc_ctrl_pars_vendor_rsp(tAVRC_MSG_VENDOR *p_msg, tAVRC_RESPONSE *p_result, UINT8* p_buf, UINT16* buf_len)
+{
+    tAVRC_STS  status = AVRC_STS_NO_ERROR;
+    UINT8   *p = p_msg->p_vendor_data;
+    UINT16  len;
+    UINT8   xx, yy;
+    UINT8 eventid=0;
+
+    BE_STREAM_TO_UINT8 (p_result->pdu, p);
+    p++; /* skip the reserved/packe_type byte */
+    BE_STREAM_TO_UINT16 (len, p);
+    AVRC_TRACE_DEBUG3("avrc_ctrl_pars_vendor_rsp() ctype:0x%x pdu:0x%x, len:%d",
+                                         p_msg->hdr.ctype, p_result->pdu, len);
+    if (p_msg->hdr.ctype == AVRC_RSP_REJ)
+    {
+        p_result->rsp.status = *p;
+        return p_result->rsp.status;
+    }
+
+    switch (p_result->pdu)
+    {
+    /* case AVRC_PDU_REQUEST_CONTINUATION_RSP: 0x40 */
+    /* case AVRC_PDU_ABORT_CONTINUATION_RSP:   0x41 */
+
+     case AVRC_PDU_REGISTER_NOTIFICATION:    /* 0x31 */
+        if (len <= 0)
+        {
+            buf_len = 0;
+            break;
+        }
+        memcpy(p_buf,p,len);
+        *buf_len = len;
+        break;
+
+    case AVRC_PDU_GET_CAPABILITIES:
+        if (len == 0)
+        {
+            p_result->get_caps.count = 0;
+            p_result->get_caps.capability_id = 0;
+            break;
+        }
+        BE_STREAM_TO_UINT8(p_result->get_caps.capability_id,p);
+        BE_STREAM_TO_UINT8(p_result->get_caps.count,p);
+        AVRC_TRACE_DEBUG2("AVRC_PDU_GET_CAPABILITIES cap id =%d, cap_count = %d "
+                                     ,p_result->get_caps.capability_id,p_result->get_caps.count);
+        if (p_result->get_caps.capability_id == AVRC_CAP_COMPANY_ID)
+        {
+            for(xx =0; ((xx<=p_result->get_caps.count) && (xx <=AVRC_CAP_MAX_NUM_COMP_ID)); xx++)
+            {
+                BE_STREAM_TO_UINT24(p_result->get_caps.param.company_id[xx],p);
+            }
+        }
+        else if (p_result->get_caps.capability_id == AVRC_CAP_EVENTS_SUPPORTED)
+        {
+            for(xx =0; ((xx<=p_result->get_caps.count) && (xx <=AVRC_CAP_MAX_NUM_EVT_ID)); xx++)
+            {
+                BE_STREAM_TO_UINT8(p_result->get_caps.param.event_id[xx],p);
+            }
+        }
+        break;
+    case AVRC_PDU_LIST_PLAYER_APP_ATTR:
+        if (len <= 0)
+        {
+            p_result->list_app_attr.num_attr = 0;
+            break;
+        }
+        BE_STREAM_TO_UINT8(p_result->list_app_attr.num_attr,p);
+        AVRC_TRACE_DEBUG1("AVRC_PDU_LIST_PLAYER_APP_ATTR count = %d ",
+                                           p_result->list_app_attr.num_attr);
+        for(xx = 0; xx < p_result->list_app_attr.num_attr;xx++)
+        {
+            BE_STREAM_TO_UINT8(p_result->list_app_attr.attrs[xx],p);
+        }
+        break;
+    case AVRC_PDU_LIST_PLAYER_APP_VALUES:
+        if (len <= 0)
+        {
+            p_result->list_app_values.num_val = 0;
+            break;
+        }
+        BE_STREAM_TO_UINT8(p_result->list_app_values.num_val,p);
+        AVRC_TRACE_DEBUG1("AVRC_PDU_LIST_PLAYER_APP_ATTR count = %d ",
+                                          p_result->list_app_attr.num_attr);
+        for(xx = 0; xx < p_result->list_app_values.num_val; xx++)
+        {
+            BE_STREAM_TO_UINT8(p_result->list_app_values.vals[xx],p);
+        }
+        break;
+    case AVRC_PDU_GET_CUR_PLAYER_APP_VALUE:
+    {
+        if (len <= 0)
+        {
+            p_result->get_cur_app_val.num_val = 0;
+            break;
+        }
+        BE_STREAM_TO_UINT8(p_result->get_cur_app_val.num_val,p);
+        tAVRC_APP_SETTING *app_sett =
+            (tAVRC_APP_SETTING*)GKI_getbuf(p_result->get_cur_app_val.num_val*sizeof(tAVRC_APP_SETTING));
+        AVRC_TRACE_DEBUG1("AVRC_PDU_GET_CUR_PLAYER_APP_VALUE count = %d "
+                                     ,p_result->get_cur_app_val.num_val);
+        for (xx = 0; xx < p_result->get_cur_app_val.num_val; xx++)
+        {
+            BE_STREAM_TO_UINT8(app_sett[xx].attr_id,p);
+            BE_STREAM_TO_UINT8(app_sett[xx].attr_val,p);
+        }
+        p_result->get_cur_app_val.p_vals = app_sett;
+    }
+        break;
+    case AVRC_PDU_SET_PLAYER_APP_VALUE:
+        /* nothing comes as part of this rsp */
+        break;
+    case AVRC_PDU_GET_ELEMENT_ATTR:
+        if (len <= 0)
+        {
+            p_result->get_elem_attrs.num_attr = 0;
+            break;
+        }
+        BE_STREAM_TO_UINT8(p_result->get_elem_attrs.num_attr,p);
+        memcpy(p_buf,p,len-1); // 1 byte of len already read.
+        *buf_len = len-1;
+        break;
+    case AVRC_PDU_GET_PLAY_STATUS:
+        if (len <= 0)
+        {
+            buf_len = 0;
+            break;
+        }
+        memcpy(p_buf,p,len);
+        *buf_len = len;
+        break;
+
+    default:
+        status = AVRC_STS_BAD_CMD;
+        break;
+    }
+
+    return status;
+}
+#endif /* (AVRC_ADV_CTRL_INCLUDED == TRUE) */
+/*******************************************************************************
+**
+** Function         AVRC_Ctrl_ParsResponse
+**
+** Description      This function is a parse response for AVRCP Controller.
+**
+** Returns          AVRC_STS_NO_ERROR, if the message in p_data is parsed successfully.
+**                  Otherwise, the error code defined by AVRCP 1.4
+**
+*******************************************************************************/
+tAVRC_STS AVRC_Ctrl_ParsResponse (tAVRC_MSG *p_msg, tAVRC_RESPONSE *p_result, UINT8 *p_buf, UINT16* buf_len)
+{
+    tAVRC_STS  status = AVRC_STS_INTERNAL_ERR;
+    UINT16  id;
+
+    if (p_msg && p_result)
+    {
+        switch (p_msg->hdr.opcode)
+        {
+        case AVRC_OP_VENDOR:     /*  0x00    Vendor-dependent commands */
+            status = avrc_ctrl_pars_vendor_rsp(&p_msg->vendor, p_result, p_buf,buf_len);
+            break;
+
+        default:
+            AVRC_TRACE_ERROR1("AVRC_Ctrl_ParsResponse() unknown opcode:0x%x", p_msg->hdr.opcode);
+            break;
+        }
+        p_result->rsp.opcode = p_msg->hdr.opcode;
+        p_result->rsp.status = status;
+    }
+    return status;
+}
 
 /*******************************************************************************
 **
@@ -117,13 +302,15 @@
 {
     tAVRC_STS  status = AVRC_STS_INTERNAL_ERR;
     UINT16  id;
+    UNUSED(p_buf);
+    UNUSED(buf_len);
 
     if (p_msg && p_result)
     {
         switch (p_msg->hdr.opcode)
         {
         case AVRC_OP_VENDOR:     /*  0x00    Vendor-dependent commands */
-            status = avrc_pars_vendor_rsp(&p_msg->vendor, p_result, p_buf, buf_len);
+            status = avrc_pars_vendor_rsp(&p_msg->vendor, p_result);
             break;
 
         case AVRC_OP_PASS_THRU:  /*  0x7C    panel subunit opcode */
@@ -143,6 +330,4 @@
     }
     return status;
 }
-
-
 #endif /* (AVRC_METADATA_INCLUDED == TRUE) */
diff -Naur '--exclude=.git' bluedroid-orig/stack/avrc/avrc_pars_tg.c bluedroid/stack/avrc/avrc_pars_tg.c
--- bluedroid-orig/stack/avrc/avrc_pars_tg.c	2015-09-24 16:33:43.544227643 +0800
+++ bluedroid/stack/avrc/avrc_pars_tg.c	2015-09-24 16:31:37.000000000 +0800
@@ -1,5 +1,6 @@
 /******************************************************************************
  *
+ *  Copyright (c) 2015, The Linux Foundation. All rights reserved.
  *  Copyright (C) 2003-2013 Broadcom Corporation
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
@@ -27,6 +28,67 @@
 *****************************************************************************/
 #if (AVRC_METADATA_INCLUDED == TRUE)
 
+#if (AVRC_CTLR_INCLUDED == TRUE)
+/*******************************************************************************
+**
+** Function         avrc_ctrl_pars_vendor_cmd
+**
+** Description      This function parses the vendor specific commands defined by
+**                  Bluetooth SIG for AVRCP Conroller.
+**
+** Returns          AVRC_STS_NO_ERROR, if the message in p_data is parsed successfully.
+**                  Otherwise, the error code defined by AVRCP 1.4
+**
+*******************************************************************************/
+static tAVRC_STS avrc_ctrl_pars_vendor_cmd(tAVRC_MSG_VENDOR *p_msg, tAVRC_COMMAND *p_result,
+                                      UINT8 *p_buf, UINT16 buf_len)
+{
+    tAVRC_STS  status = AVRC_STS_NO_ERROR;
+    UINT8   *p = p_msg->p_vendor_data;
+    UINT16  len;
+
+    p_result->pdu = *p++;
+    AVRC_TRACE_DEBUG1("avrc_ctrl_pars_vendor_cmd() pdu:0x%x", p_result->pdu);
+    if (!AVRC_IsValidAvcType (p_result->pdu, p_msg->hdr.ctype))
+    {
+        AVRC_TRACE_DEBUG0("avrc_ctrl_pars_vendor_cmd() detects wrong AV/C type!");
+        status = AVRC_STS_BAD_CMD;
+    }
+
+    p++; /* skip the reserved byte */
+    BE_STREAM_TO_UINT16 (len, p);
+    if ((len+4) != (p_msg->vendor_len))
+    {
+        status = AVRC_STS_INTERNAL_ERR;
+    }
+
+    if (status != AVRC_STS_NO_ERROR)
+        return status;
+
+    switch (p_result->pdu)
+    {
+    case AVRC_PDU_SET_ABSOLUTE_VOLUME:
+    {
+        if(len!=1)
+            status = AVRC_STS_INTERNAL_ERR;
+        else
+        {
+            BE_STREAM_TO_UINT8 (p_result->volume.volume, p);
+            p_result->volume.volume = AVRC_MAX_VOLUME & p_result->volume.volume;
+        }
+        break;
+    }
+    case AVRC_PDU_REGISTER_NOTIFICATION:    /* 0x31 */
+        BE_STREAM_TO_UINT8 (p_result->reg_notif.event_id, p);
+        BE_STREAM_TO_UINT32 (p_result->reg_notif.param, p);
+        break;
+    default:
+        status = AVRC_STS_BAD_CMD;
+        break;
+    }
+    return status;
+}
+#endif
 /*******************************************************************************
 **
 ** Function         avrc_pars_vendor_cmd
@@ -51,14 +113,6 @@
     tAVRC_APP_SETTING       *p_app_set;
     UINT16  size_needed;
 
-    /* NULL check for p_vendor_data */
-    if (p == NULL)
-    {
-        status = AVRC_STS_INTERNAL_ERR;
-        AVRC_TRACE_ERROR0("avrc_pars_vendor_cmd() detects NULL vendor data!");
-        return status;
-    }
-
     p_result->pdu = *p++;
     AVRC_TRACE_DEBUG1("avrc_pars_vendor_cmd() pdu:0x%x", p_result->pdu);
     if (!AVRC_IsValidAvcType (p_result->pdu, p_msg->hdr.ctype))
@@ -251,9 +305,7 @@
 
     case AVRC_PDU_REGISTER_NOTIFICATION:    /* 0x31 */
         if (len != 5)
-        {
             status = AVRC_STS_INTERNAL_ERR;
-        }
         else
         {
             BE_STREAM_TO_UINT8 (p_result->reg_notif.event_id, p);
@@ -273,10 +325,13 @@
     case AVRC_PDU_SET_ADDRESSED_PLAYER:
         if (len != 2)
         {
-           status = AVRC_STS_INTERNAL_ERR;
-           return status ;
+           status = AVRC_STS_NOT_FOUND;
+           AVRC_TRACE_ERROR0("AVRC_PDU_SET_ADDRESSED_PLAYER: bad len");
+        }
+        else
+        {
+            BE_STREAM_TO_UINT16 (p_result->addr_player.player_id, p);
         }
-        BE_STREAM_TO_UINT16 (p_result->addr_player.player_id, p);
         break;
 
     default:
@@ -286,7 +341,43 @@
 
     return status;
 }
+#if (AVRC_CTLR_INCLUDED == TRUE)
+/*******************************************************************************
+**
+** Function         AVRC_Ctrl_ParsCommand
+**
+** Description      This function is used to parse cmds received for CTRL
+**                  Currently it is for SetAbsVolume and Volume Change Notification..
+**
+** Returns          AVRC_STS_NO_ERROR, if the message in p_data is parsed successfully.
+**                  Otherwise, the error code defined by AVRCP 1.4
+**
+*******************************************************************************/
+tAVRC_STS AVRC_Ctrl_ParsCommand (tAVRC_MSG *p_msg, tAVRC_COMMAND *p_result, UINT8 *p_buf, UINT16 buf_len)
+{
+    tAVRC_STS  status = AVRC_STS_INTERNAL_ERR;
+    UINT16  id;
 
+    if (p_msg && p_result)
+    {
+        switch (p_msg->hdr.opcode)
+        {
+        case AVRC_OP_VENDOR:     /*  0x00    Vendor-dependent commands */
+            status = avrc_ctrl_pars_vendor_cmd(&p_msg->vendor, p_result, p_buf, buf_len);
+            break;
+
+        default:
+            AVRC_TRACE_ERROR1("AVRC_ParsCommand() unknown opcode:0x%x", p_msg->hdr.opcode);
+            break;
+        }
+        p_result->cmd.opcode = p_msg->hdr.opcode;
+        p_result->cmd.status = status;
+    }
+    BTIF_TRACE_IMP2("AVRC_Ctrl_ParsCommand() return status:0x%x",
+            __FUNCTION__, status);
+    return status;
+}
+#endif
 /*******************************************************************************
 **
 ** Function         AVRC_ParsCommand
diff -Naur '--exclude=.git' bluedroid-orig/stack/avrc/avrc_sdp.c bluedroid/stack/avrc/avrc_sdp.c
--- bluedroid-orig/stack/avrc/avrc_sdp.c	2015-09-24 16:33:43.544227643 +0800
+++ bluedroid/stack/avrc/avrc_sdp.c	2015-09-24 16:31:37.000000000 +0800
@@ -226,7 +226,8 @@
 **
 ******************************************************************************/
 UINT16 AVRC_AddRecord(UINT16 service_uuid, char *p_service_name,
-                char *p_provider_name, UINT16 categories, UINT32 sdp_handle)
+                char *p_provider_name, UINT16 categories, UINT32 sdp_handle,
+                BOOLEAN browse_supported)
 {
     UINT16      browse_list[1];
     BOOLEAN     result = TRUE;
@@ -265,12 +266,21 @@
 
     /* add profile descriptor list   */
 #if SDP_AVRCP_1_5 == TRUE
+    if (browse_supported)
+    {
+        /* additional protocol list to include browsing channel */
+        result &= SDP_AddAdditionProtoLists( sdp_handle, AVRC_NUM_ADDL_PROTO_ELEMS,
+                                        (tSDP_PROTO_LIST_ELEM *)avrc_add_proto_list);
+    }
+
     result &= SDP_AddProfileDescriptorList(sdp_handle, UUID_SERVCLASS_AV_REMOTE_CONTROL, AVRC_REV_1_5);
 #else
 #if SDP_AVRCP_1_4 == TRUE
-    /* additional protocol list to include browsing channel */
-    result &= SDP_AddAdditionProtoLists( sdp_handle, 1, (tSDP_PROTO_LIST_ELEM *)avrc_add_proto_list);
-
+    if (browse_supported)
+    {
+        /* additional protocol list to include browsing channel */
+        result &= SDP_AddAdditionProtoLists( sdp_handle, 1, (tSDP_PROTO_LIST_ELEM *)avrc_add_proto_list);
+    }
     result &= SDP_AddProfileDescriptorList(sdp_handle, UUID_SERVCLASS_AV_REMOTE_CONTROL, AVRC_REV_1_5);
 #else
 #if AVRC_METADATA_INCLUDED == TRUE
diff -Naur '--exclude=.git' bluedroid-orig/stack/avrc/avrc_utils.c bluedroid/stack/avrc/avrc_utils.c
--- bluedroid-orig/stack/avrc/avrc_utils.c	2015-09-24 16:33:43.544227643 +0800
+++ bluedroid/stack/avrc/avrc_utils.c	2015-09-24 16:31:37.000000000 +0800
@@ -60,6 +60,7 @@
         case AVRC_PDU_REQUEST_CONTINUATION_RSP:    /* 0x40 */
         case AVRC_PDU_ABORT_CONTINUATION_RSP:      /* 0x41 */
         case AVRC_PDU_SET_ADDRESSED_PLAYER:
+        case AVRC_PDU_SET_ABSOLUTE_VOLUME:
              if (avc_type == AVRC_CMD_CTRL)
                 result=TRUE;
              break;
@@ -115,8 +116,7 @@
          break;
     }
 
-    if (attrib >= AVRC_PLAYER_SETTING_LOW_MENU_EXT &&
-       attrib <= AVRC_PLAYER_SETTING_HIGH_MENU_EXT)
+    if (attrib >= AVRC_PLAYER_SETTING_LOW_MENU_EXT)
        result = TRUE;
 
     if (!result)
@@ -141,7 +141,7 @@
     BOOLEAN result=FALSE;
 
     if ( (attr >= AVRC_PLAYER_SETTING_EQUALIZER && attr <= AVRC_PLAYER_SETTING_SCAN) ||
-         (attr >= AVRC_PLAYER_SETTING_LOW_MENU_EXT && attr <= AVRC_PLAYER_SETTING_HIGH_MENU_EXT) )
+         (attr >= AVRC_PLAYER_SETTING_LOW_MENU_EXT) )
     {
        result = TRUE;
     }
diff -Naur '--exclude=.git' bluedroid-orig/stack/btm/btm_ble_gap.c bluedroid/stack/btm/btm_ble_gap.c
--- bluedroid-orig/stack/btm/btm_ble_gap.c	2015-09-24 16:33:43.544227643 +0800
+++ bluedroid/stack/btm/btm_ble_gap.c	2015-09-24 16:31:37.000000000 +0800
@@ -718,6 +718,8 @@
     if (p_cb->connectable_mode & BTM_BLE_CONNECTABLE)
         p_cb->evt_type = btm_set_conn_mode_adv_init_addr(p_cb, p_addr_ptr, &init_addr_type, &own_addr_type);
 
+    p_cb->evt_type = 0x3; //BTM_BLE_CONNECT_LO_DUTY_DIR_EVT
+
     /* update adv params */
     btsnd_hcic_ble_write_adv_params (p_cb->adv_interval_min,
                                      p_cb->adv_interval_max,
@@ -730,6 +732,8 @@
 
     if (adv_mode == BTM_BLE_ADV_ENABLE)
         btm_ble_start_adv();
+    else
+        BTM_TRACE_ERROR1 ("%s: BLE ADV IS DISABLED", __FUNCTION__);
 
     return status;
 }
@@ -987,6 +991,32 @@
     p_inqvar_data->adv_data_input.manu.p_val=p_buff;
 }
 
+#ifndef PLATFORM_ANDROID
+void BTM_SetFlag(UINT8 flag)
+{
+    tBTM_BLE_INQ_CB *p_inqvar_data = &btm_cb.ble_ctr_cb.inq_var;
+    p_inqvar_data->adv_data_input.flag=flag;
+}
+void BTM_SetAppearance(UINT16 appearance)
+{
+    tBTM_BLE_INQ_CB *p_inqvar_data = &btm_cb.ble_ctr_cb.inq_var;
+    p_inqvar_data->adv_data_input.appearance=appearance;
+}
+void BTM_SetRange(UINT16 hi, UINT16 low)
+{
+    tBTM_BLE_INQ_CB *p_inqvar_data = &btm_cb.ble_ctr_cb.inq_var;
+    p_inqvar_data->adv_data_input.int_range.hi=hi;
+    p_inqvar_data->adv_data_input.int_range.low=low;
+}
+void BTM_write_adv(tBTM_BLE_AD_MASK data_mask, tBTM_BLE_ADV_DATA *p_data)
+{
+    tBTM_BLE_INQ_CB *p_inqvar_data = &btm_cb.ble_ctr_cb.inq_var;
+    p_data = &(p_inqvar_data->adv_data_input);
+    BTM_BleWriteAdvData(data_mask,p_data);
+}
+#endif
+
+
 /*******************************************************************************
 **
 ** Function         BTM_SetServiceData
@@ -1460,10 +1490,11 @@
         if (p_cb->discoverable_mode == BTM_BLE_NON_DISCOVERABLE)
         {
             p_cb->br_edr_supported_flag = 0;
+#if 0
             BTM_TRACE_EVENT0 ("always disable adv in non-discoverable non-connectable mode with no scan rsp");
             if(!p_cb->scan_rsp)
                 new_mode = BTM_BLE_ADV_DISABLE;
-
+#endif
         }
     }
     else /* connectable */
@@ -2435,8 +2466,17 @@
     {
         BTM_TRACE_DEBUG1("btm_ble_write_adv_enable_complete successfully set to enable/disable: %d", p_cb->adv_mode);
     }
-    BTM_TRACE_DEBUG1("btm_ble_write_adv_enable_complete Flag value is:%d",*p_cb->adv_data.p_flags );
-    (*p_cback)(p_cb->evt_type, p_cb->adv_mode, (*p_cb->adv_data.p_flags & BTM_BLE_LIMIT_DISC_FLAG )); //evt_type is adv type, adv_mode is enable/disable
+
+    //BTM_TRACE_DEBUG1("btm_ble_write_adv_enable_complete Flag value is:%d",*p_cb->adv_data.p_flags );
+
+    if (p_cback == NULL) {
+        BTM_TRACE_DEBUG1("%s: BLE ADV ENABLE CB NULL!!!", __FUNCTION__);
+        return;
+    }
+    else {
+        BTM_TRACE_DEBUG1("%s: BLE ADV ENABLE CB IS PRESENT", __FUNCTION__);
+        (*p_cback)(p_cb->evt_type, p_cb->adv_mode, (*p_cb->adv_data.p_flags & BTM_BLE_LIMIT_DISC_FLAG )); //evt_type is adv type, adv_mode is enable/disable
+    }
 }
 
 void btm_ble_set_visibility(UINT16 conn_mode, UINT16 disc_mode, tBTM_BLE_ADV_ENABLE_CBACK *p_cb)
diff -Naur '--exclude=.git' bluedroid-orig/stack/btm/btm_devctl.c bluedroid/stack/btm/btm_devctl.c
--- bluedroid-orig/stack/btm/btm_devctl.c	2015-09-24 16:33:43.548227643 +0800
+++ bluedroid/stack/btm/btm_devctl.c	2015-09-24 16:31:37.000000000 +0800
@@ -108,6 +108,7 @@
 #define BTM_SCO_HOST_BUF_SIZE       0xff
 #endif
 
+BOOLEAN disable_interlaced_scan = FALSE;
 /********************************************************************************/
 /*              L O C A L    F U N C T I O N     P R O T O T Y P E S            */
 /********************************************************************************/
@@ -139,6 +140,7 @@
 *******************************************************************************/
 void btm_dev_init (void)
 {
+    int xx;
 #if 0  /* cleared in btm_init; put back in if called from anywhere else! */
     memset (&btm_cb.devcb, 0, sizeof (tBTM_DEVCB));
 #endif
@@ -152,6 +154,9 @@
     btm_cb.devcb.rln_timer.param    = (TIMER_PARAM_TYPE)TT_DEV_RLN;
     btm_cb.devcb.rlinkp_timer.param = (TIMER_PARAM_TYPE)TT_DEV_RLNKP;
 
+    for(xx = 0; xx < BTM_MAX_CLB_TIMERS; xx++)
+        btm_cb.devcb.clb_cmd_timers[xx].param = (TIMER_PARAM_TYPE)TT_DEV_CLB_PARAM(xx);
+
     btm_cb.btm_acl_pkt_types_supported = BTM_ACL_PKT_TYPES_MASK_DH1 + BTM_ACL_PKT_TYPES_MASK_DM1 +
                                          BTM_ACL_PKT_TYPES_MASK_DH3 + BTM_ACL_PKT_TYPES_MASK_DM3 +
                                          BTM_ACL_PKT_TYPES_MASK_DH5 + BTM_ACL_PKT_TYPES_MASK_DM5;
@@ -620,6 +625,8 @@
 *******************************************************************************/
 void btm_dev_timeout (TIMER_LIST_ENT  *p_tle)
 {
+    tBTM_CLB_CMD_CMPL clb_cmd_cmpl;
+
     TIMER_PARAM_TYPE timer_type = (TIMER_PARAM_TYPE)p_tle->param;
 
     if ((timer_type & TT_DEV_RESET_MASK) == TT_DEV_RESET)
@@ -636,6 +643,16 @@
         if (p_cb)
             (*p_cb)((void *) NULL);
     }
+    else if ((timer_type & TT_DEV_RESET_MASK) == TT_DEV_CLB)
+    {
+        tBTM_CMPL_CB *p_cb = btm_cb.devcb.clb_cb_info.p_cmd_cmpl_cb;
+
+        clb_cmd_cmpl.command_type = TT_DEV_CLB_TYPE(timer_type);
+        clb_cmd_cmpl.timeout      = TRUE;
+
+        if(p_cb)
+            (*p_cb)(&clb_cmd_cmpl);
+    }
 }
 
 /*******************************************************************************
@@ -1123,8 +1140,16 @@
         else
             l2cu_set_non_flushable_pbf(FALSE);
 #endif
-        BTM_SetPageScanType (BTM_DEFAULT_SCAN_TYPE);
-        BTM_SetInquiryScanType (BTM_DEFAULT_SCAN_TYPE);
+        if(disable_interlaced_scan)
+        {
+            BTM_SetPageScanType (BTM_SCAN_TYPE_STANDARD);
+            BTM_SetInquiryScanType (BTM_SCAN_TYPE_STANDARD);
+        }
+        else
+        {
+            BTM_SetPageScanType (BTM_DEFAULT_SCAN_TYPE);
+            BTM_SetInquiryScanType (BTM_DEFAULT_SCAN_TYPE);
+        }
 
         break;
 
@@ -1988,6 +2013,103 @@
         return (BTM_NO_RESOURCES);
 
 }
+#if (A2DP_KERNEL_DIRECT == TRUE)
+void btm_btlite_rsp_hdl(tBTM_BTLITE_RSP *p, tBTM_BTLITE_CMPL_CB *p_cb)
+{
+    tBTM_BTLITE_CMPL  btlite_cplt_params;
+    btlite_cplt_params.event = p->event;
+    btlite_cplt_params.opcode = p->opcode;
+    btlite_cplt_params.param_len  = p->param_len;
+    btlite_cplt_params.p_param_buf = p->p_param_buf;
+    (*p_cb)(&btlite_cplt_params);
+}
+
+//void BTM_SendBTLiteReq(UINT8 cmd_type,void *p_info,tBTM_VSC_CMPL_CB *p_cb)
+void BTM_SendBTLiteReq(UINT16 event, UINT8 cmd_type,void *p_info,tBTM_BTLITE_CMPL *p_cb)
+{
+   BTM_TRACE_DEBUG2("BTM_sendBTLiteReq evt = %x cmd_type = %d",event,cmd_type);
+   void *p_buf;
+   if (event == BT_EVT_BTU_IPC_BTM_EVT)
+   {
+       if (cmd_type == BTA_AV_SYNC_TO_LITE_REQ)
+       {
+           if ((p_buf = (tBTA_AV_SYNC_INFO_REQ *)GKI_getbuf((UINT16)sizeof(BT_HDR) + sizeof(tBTA_AV_SYNC_INFO_REQ) +
+                                                            HCI_DATA_PREAMBLE_SIZE)) != NULL )
+           {
+               btsnd_btlite_req_cmd(p_buf, cmd_type, event, p_info, (void *)p_cb);
+           }
+       }
+       else if (cmd_type == BTA_AV_STR_START_TO_LITE_REQ)
+       {
+           if ((p_buf = (tBTA_AV_SYNC_INFO_REQ *)GKI_getbuf((UINT16)sizeof(BT_HDR)+sizeof(tBTA_AV_SCB_REQ) +
+                                                            HCI_DATA_PREAMBLE_SIZE)) != NULL )
+           {
+               btsnd_btlite_req_cmd(p_buf, cmd_type, event, p_info, (void *)p_cb);
+           }
+       }
+       else
+       {
+           if (cmd_type == BTA_AV_STR_STOP_TO_LITE_REQ || cmd_type == BTA_AV_STR_SUSPEND_TO_LITE_REQ)
+           {
+               if ((p_buf = (tBTA_AV_SCB_STOP_REQ *) GKI_getbuf((UINT16)sizeof(BT_HDR) + sizeof(tBTA_AV_SCB_STOP_REQ) +
+                                                                HCI_DATA_PREAMBLE_SIZE)) != NULL)
+               {
+                    btsnd_btlite_req_cmd(p_buf, cmd_type, event, p_info, (void *)p_cb);
+               }
+           }
+           else if(cmd_type == BTA_AV_STR_CLEANUP_TO_LITE_REQ)
+           {
+               if ((p_buf = (tBTA_AV_SCB_CLEANUP_REQ *) GKI_getbuf((UINT16)sizeof(BT_HDR) + sizeof(tBTA_AV_SCB_CLEANUP_REQ) +
+                                                                  HCI_DATA_PREAMBLE_SIZE)) != NULL)
+               {
+                   btsnd_btlite_req_cmd(p_buf, cmd_type, event, p_info, (void *)p_cb);
+               }
+           }
+           else
+               BTM_TRACE_DEBUG1("BTM_sendBTLiteReq UNKNOWN cmd_type = %d",cmd_type);
+       }
+   }
+   else if(event == BT_EVT_BTU_IPC_L2C_EVT)
+   {
+       if (cmd_type == L2C_SYNC_TO_LITE_REQ)
+       {
+           if ((p_buf = (tL2C_SYNC_TO_LITE_REQ *) GKI_getbuf((UINT16)sizeof(BT_HDR) + sizeof(tL2C_SYNC_TO_LITE_REQ) +
+                                                             HCI_DATA_PREAMBLE_SIZE)) != NULL)
+           {
+               btsnd_btlite_req_cmd(p_buf, cmd_type, event, p_info, (void *)p_cb);
+           }
+       }
+       else if(cmd_type == L2C_REMOVE_TO_LITE_REQ)
+       {
+           if ((p_buf = (tL2C_REMOVE_TO_LITE_REQ *) GKI_getbuf((UINT16)sizeof(BT_HDR) + sizeof(tL2C_REMOVE_TO_LITE_REQ) +
+                                                              HCI_DATA_PREAMBLE_SIZE)) != NULL)
+           {
+               btsnd_btlite_req_cmd(p_buf, cmd_type, event, p_info, (void *)p_cb);
+           }
+       }
+   }
+   else if(event == BT_EVT_BTU_IPC_AVDT_EVT)
+   {
+       if (cmd_type == AVDT_SYNC_TO_LITE_REQ || cmd_type == AVDT_REMOVE_TO_LITE_REQ)
+       {
+           if ((p_buf = (tAVDT_SYNC_INFO *) GKI_getbuf((UINT16)sizeof(BT_HDR) + sizeof(tAVDT_SYNC_INFO) +
+                                                       HCI_DATA_PREAMBLE_SIZE)) != NULL)
+           {
+               btsnd_btlite_req_cmd(p_buf, cmd_type, event,p_info,(void *)p_cb);
+           }
+       }
+       else if(cmd_type == AVDT_SYNC_CP_TO_LITE_REQ)
+       {
+           if ((p_buf = (tAVDT_SYNC_INFO *) GKI_getbuf((UINT16)sizeof(BT_HDR) + AVDT_CP_REQ_DATA_SIZE +
+                                                       HCI_DATA_PREAMBLE_SIZE)) != NULL)
+           {
+               btsnd_btlite_req_cmd(p_buf, cmd_type,event, p_info,(void *)p_cb);
+           }
+       }
+   }
+}
+
+#endif //A2DP_KERNEL_DIRECT
 
 #if HCI_RAW_CMD_INCLUDED == TRUE
 /*******************************************************************************
@@ -2148,13 +2270,15 @@
 {
     UINT8 i;
 
-    BTM_TRACE_DEBUG0 ("BTM Event: Vendor Specific event from controller");
+    BTM_TRACE_ERROR1("btm_vendor_specific_evt: Vendor Specific event from controller of len: %d", evt_len);
 
     for (i=0; i<BTM_MAX_VSE_CALLBACKS; i++)
     {
         if (btm_cb.devcb.p_vend_spec_cb[i])
             (*btm_cb.devcb.p_vend_spec_cb[i])(evt_len, p);
     }
+    BTM_TRACE_ERROR0("btm_vendor_specific_evt: Calling save_bt_firmware_version_cback() to save the Version Info");
+    save_bt_firmware_version_cback(p, evt_len);
 }
 
 
@@ -2579,4 +2703,388 @@
         (*p_cb)(status);
 }
 
+/*******************************************************************************
+**
+** Function         BTM_RegisterCLB
+**
+** Description      Register CLB callbacks.
+**
+** Returns          BTM_SUCCESS if successful, otherwise an error
+**
+**
+*******************************************************************************/
+tBTM_STATUS BTM_RegisterCLB(tBTM_CLB_CB_INFO *p_clb_cb_info)
+{
+    if (btm_cb.devcb.clb_cb_info.p_cmd_cmpl_cb)
+        return (BTM_BUSY);
+
+    btm_cb.devcb.clb_cb_info = *p_clb_cb_info;
+
+    return (BTM_SUCCESS);
+}
+
+/*******************************************************************************
+**
+** Function         BTM_DeregisterCLB
+**
+** Description      De-Register CLB callbacks.
+**
+** Returns          BTM_SUCCESS if successful, otherwise an error
+**
+**
+*******************************************************************************/
+tBTM_STATUS BTM_DeregisterCLB(void)
+{
+    memset(&btm_cb.devcb.clb_cb_info, 0, sizeof(tBTM_CLB_CB_INFO));
+
+    return (BTM_SUCCESS);
+}
+
+/*******************************************************************************
+**
+** Function         BTM_SetCLB
+**
+** Description      Enable/Disable Connectionless Slave Broadcasts
+**
+** Returns          BTM_SUCCESS if successful, otherwise an error
+**
+**
+*******************************************************************************/
+tBTM_STATUS BTM_SetCLB(UINT8 enable, UINT8 lt_addr, UINT8 lpo_allowed, 
+                                   UINT16 packet_type, UINT16 interval_min, 
+                                   UINT16 interval_max, UINT16 supervision_timeout) 
+{
+    if (btm_cb.devcb.clb_cmd_timers[BTM_SET_CLB_CMPL].in_use)
+        return (BTM_BUSY);
+
+    if (btsnd_hcic_set_clb(enable, lt_addr, lpo_allowed, packet_type, interval_min, interval_max, supervision_timeout))
+    {
+        btu_start_timer (&btm_cb.devcb.clb_cmd_timers[BTM_SET_CLB_CMPL], BTU_TTYPE_BTM_DEV_CTL, BTM_DEV_REPLY_TIMEOUT);
+
+        return (BTM_CMD_STARTED);
+    }
+    else
+        return (BTM_NO_RESOURCES);
+}
+
+void btm_set_clb_complete(UINT8 *p)
+{
+    tBTM_CMPL_CB *p_cb = btm_cb.devcb.clb_cb_info.p_cmd_cmpl_cb;
+    tBTM_CLB_CMD_CMPL results;
+
+    btu_stop_timer(&btm_cb.devcb.clb_cmd_timers[BTM_SET_CLB_CMPL]);
+
+    if(p_cb)
+    {
+        results.command_type = BTM_SET_CLB_CMPL;
+        results.timeout      = FALSE;
 
+        STREAM_TO_UINT8(results.data.set_clb.status, p);
+        STREAM_TO_UINT8(results.data.set_clb.lt_addr, p);
+        STREAM_TO_UINT16(results.data.set_clb.interval, p);
+
+        (*p_cb)(&results);
+    }
+}
+
+/*******************************************************************************
+**
+** Function         BTM_StartSyncTrain
+**
+** Description      Start the Synchronization Train
+**
+** Returns          BTM_SUCCESS if successful, otherwise an error
+**
+**
+*******************************************************************************/
+tBTM_STATUS BTM_StartSyncTrain(void)
+{
+    if (btm_cb.devcb.clb_cmd_timers[BTM_START_SYNC_TRAIN_CMPL].in_use)
+        return (BTM_BUSY);
+
+    if (btsnd_hcic_start_sync_train())
+    {
+        btu_start_timer (&btm_cb.devcb.clb_cmd_timers[BTM_START_SYNC_TRAIN_CMPL], BTU_TTYPE_BTM_DEV_CTL, BTM_DEV_REPLY_TIMEOUT);
+
+        return (BTM_CMD_STARTED);
+    }
+    else
+        return (BTM_NO_RESOURCES);
+}
+
+void btm_start_sync_train_complete(UINT8 *p)
+{
+    tBTM_CMPL_CB      *p_cb    = btm_cb.devcb.clb_cb_info.p_cmd_cmpl_cb;
+    tBTM_CLB_CMD_CMPL  results;
+
+    btu_stop_timer(&btm_cb.devcb.clb_cmd_timers[BTM_START_SYNC_TRAIN_CMPL]);
+
+    if(p_cb)
+    {
+        results.command_type = BTM_START_SYNC_TRAIN_CMPL;
+        results.timeout      = FALSE;
+        
+        STREAM_TO_UINT8(results.data.status, p);
+
+        (*p_cb)(&results);
+    }
+}
+
+void btm_sync_train_complete(UINT8 *p)
+{
+    UINT8                    status;
+    tBTM_SYNC_TRAIN_CMPL_CB *p_cb   = btm_cb.devcb.clb_cb_info.p_sync_train_cmpl_cb;
+
+    if(p_cb)
+    {
+        STREAM_TO_UINT8(status, p);
+        
+        (*p_cb)(status);
+    }
+}
+
+/*******************************************************************************
+**
+** Function         BTM_SetReservedLTADDR
+**
+** Description      Set a reserved LT_ADDR
+**
+** Returns          BTM_SUCCESS if successful, otherwise an error
+**
+**
+*******************************************************************************/
+tBTM_STATUS BTM_SetReservedLTADDR(UINT8 lt_addr)
+{
+    BTM_TRACE_API1("%s: Enter", __FUNCTION__);
+    if (btm_cb.devcb.clb_cmd_timers[BTM_SET_RESERVED_LT_ADDR_CMPL].in_use)
+        return (BTM_BUSY);
+
+    if (btsnd_hcic_set_reserved_lt_addr(lt_addr))
+    {
+        btu_start_timer (&btm_cb.devcb.clb_cmd_timers[BTM_SET_RESERVED_LT_ADDR_CMPL], BTU_TTYPE_BTM_DEV_CTL, BTM_DEV_REPLY_TIMEOUT);
+
+        return (BTM_CMD_STARTED);
+    }
+    else
+        return (BTM_NO_RESOURCES);
+    BTM_TRACE_API1("%s: Exit", __FUNCTION__);
+}
+
+/*******************************************************************************
+**
+** Function         BTM_DeleteReservedLTADDR
+**
+** Description      Delete a reserved LT_ADDR
+**
+** Returns          BTM_SUCCESS if successful, otherwise an error
+**
+**
+*******************************************************************************/
+tBTM_STATUS BTM_DeleteReservedLTADDR(UINT8 lt_addr)
+{
+    if (btm_cb.devcb.clb_cmd_timers[BTM_SET_RESERVED_LT_ADDR_CMPL].in_use)
+        return (BTM_BUSY);
+
+    if (btsnd_hcic_delete_reserved_lt_addr(lt_addr))
+    {
+        btu_start_timer (&btm_cb.devcb.clb_cmd_timers[BTM_SET_RESERVED_LT_ADDR_CMPL], BTU_TTYPE_BTM_DEV_CTL, BTM_DEV_REPLY_TIMEOUT);
+
+        return (BTM_CMD_STARTED);
+    }
+    else
+        return (BTM_NO_RESOURCES);
+}
+
+void btm_set_reserved_lt_addr_complete(UINT8 *p)
+{
+    BTM_TRACE_API1("%s: Enter", __FUNCTION__);
+    tBTM_CMPL_CB      *p_cb    = btm_cb.devcb.clb_cb_info.p_cmd_cmpl_cb;
+    tBTM_CLB_CMD_CMPL  results;
+
+    btu_stop_timer(&btm_cb.devcb.clb_cmd_timers[BTM_SET_RESERVED_LT_ADDR_CMPL]);
+
+    BTM_TRACE_API0("M1");
+    if(p_cb)
+    {
+    BTM_TRACE_API0("M2");
+        results.command_type = BTM_SET_RESERVED_LT_ADDR_CMPL;
+        results.timeout      = FALSE;
+
+    BTM_TRACE_API0("M3");
+        STREAM_TO_UINT8(results.data.set_reserved.status, p);
+        STREAM_TO_UINT8(results.data.set_reserved.lt_addr, p);
+
+    BTM_TRACE_API0("M4");
+        (*p_cb)(&results);
+    }
+    else
+    BTM_TRACE_API0("M5");
+    BTM_TRACE_API1("%s: Exit", __FUNCTION__);
+}
+
+/*******************************************************************************
+**
+** Function         BTM_SetCLBData
+**
+** Description      Set the Connectionless Slave Broadcast data
+**
+** Returns          BTM_SUCCESS if successful, otherwise an error
+**
+**
+*******************************************************************************/
+tBTM_STATUS BTM_SetCLBData(UINT8 lt_addr, UINT8 fragment, UINT8 data_len, UINT8 *data)
+{
+    if (btm_cb.devcb.clb_cmd_timers[BTM_SET_CLB_DATA_CMPL].in_use)
+        return (BTM_BUSY);
+
+    if (btsnd_hcic_set_clb_data(lt_addr, fragment, data_len, data))
+    {
+        btu_start_timer (&btm_cb.devcb.clb_cmd_timers[BTM_SET_CLB_DATA_CMPL], BTU_TTYPE_BTM_DEV_CTL, BTM_DEV_REPLY_TIMEOUT);
+
+        return (BTM_CMD_STARTED);
+    }
+    else
+        return (BTM_NO_RESOURCES);
+}
+
+void btm_set_clb_data_complete(UINT8 *p)
+{
+    tBTM_CMPL_CB      *p_cb    = btm_cb.devcb.clb_cb_info.p_cmd_cmpl_cb;
+    tBTM_CLB_CMD_CMPL  results;
+
+    btu_stop_timer(&btm_cb.devcb.clb_cmd_timers[BTM_SET_CLB_DATA_CMPL]);
+
+    if(p_cb)
+    {
+        results.command_type = BTM_SET_CLB_DATA_CMPL;
+        results.timeout      = FALSE;
+
+        STREAM_TO_UINT8(results.data.set_clb_data.status, p);
+        STREAM_TO_UINT8(results.data.set_clb_data.lt_addr, p);
+
+        (*p_cb)(&results);
+    }
+}
+
+/*******************************************************************************
+**
+** Function         BTM_WriteSyncTrainParams
+**
+** Description      Write the Synchronization Train Parameters
+**
+** Returns          BTM_SUCCESS if successful, otherwise an error
+**
+**
+*******************************************************************************/
+tBTM_STATUS BTM_WriteSyncTrainParams(UINT16 interval_min, UINT16 interval_max, UINT32 timeout, UINT8 service_data)
+{
+    if (btm_cb.devcb.clb_cmd_timers[BTM_WRITE_SYNC_TRAIN_PARAM_CMPL].in_use)
+        return (BTM_BUSY);
+
+    if (btsnd_hcic_write_sync_train_params(interval_min, interval_max, timeout, service_data))
+    {
+        btu_start_timer (&btm_cb.devcb.clb_cmd_timers[BTM_WRITE_SYNC_TRAIN_PARAM_CMPL], BTU_TTYPE_BTM_DEV_CTL, BTM_DEV_REPLY_TIMEOUT);
+
+        return (BTM_CMD_STARTED);
+    }
+    else
+        return (BTM_NO_RESOURCES);
+}
+
+void btm_write_sync_train_params_complete(UINT8 *p)
+{
+    tBTM_CMPL_CB      *p_cb    = btm_cb.devcb.clb_cb_info.p_cmd_cmpl_cb;
+    tBTM_CLB_CMD_CMPL  results;
+
+    btu_stop_timer(&btm_cb.devcb.clb_cmd_timers[BTM_WRITE_SYNC_TRAIN_PARAM_CMPL]);
+
+    if(p_cb)
+    {
+        results.command_type = BTM_WRITE_SYNC_TRAIN_PARAM_CMPL;
+        results.timeout      = FALSE;
+
+        STREAM_TO_UINT8(results.data.write_param.status, p);
+        STREAM_TO_UINT16(results.data.write_param.interval, p);
+
+        (*p_cb)(&results);
+    }
+}
+
+/*******************************************************************************
+**
+** Function         BTM_SetTrigClkCapture
+**
+** Description      Start/Stop Triggered Clock Capture
+**
+** Returns          BTM_SUCCESS if successful, otherwise an error
+**                  If ENABLED, capture events will be sent to the
+**                  p_trg_clk_cap_cb.
+**
+**
+*******************************************************************************/
+tBTM_STATUS BTM_SetTrigClkCapture(UINT16 handle, UINT8 enable,
+                                    UINT8 which_clock, UINT8 lpo_allowed,
+                                    UINT8 num_clock_cap_to_filter)
+{
+    if (btm_cb.devcb.clb_cmd_timers[BTM_SET_TRG_CLK_CAP_CMPL].in_use)
+        return (BTM_BUSY);
+
+    if (btsnd_hcic_set_trig_clk_capture(handle, enable, which_clock, lpo_allowed, num_clock_cap_to_filter))
+    {
+        btu_start_timer (&btm_cb.devcb.clb_cmd_timers[BTM_SET_TRG_CLK_CAP_CMPL], BTU_TTYPE_BTM_DEV_CTL, BTM_DEV_REPLY_TIMEOUT);
+
+        return (BTM_CMD_STARTED);
+    }
+    else
+        return (BTM_NO_RESOURCES);
+}
+
+void btm_set_trg_clk_capture_complete(UINT8 *p)
+{
+    tBTM_CMPL_CB      *p_cb    = btm_cb.devcb.clb_cb_info.p_cmd_cmpl_cb;
+    tBTM_CLB_CMD_CMPL  results;
+
+    btu_stop_timer(&btm_cb.devcb.clb_cmd_timers[BTM_SET_TRG_CLK_CAP_CMPL]);
+
+    if(p_cb)
+    {
+        results.command_type = BTM_SET_TRG_CLK_CAP_CMPL;
+        results.timeout      = FALSE;
+
+        STREAM_TO_UINT8(results.data.status, p);
+
+        (*p_cb)(&results);
+    }
+}
+
+void btm_trg_clk_capture(UINT8 *p)
+{
+    tBTM_TRG_CLK_CAP_CB *p_cb    = btm_cb.devcb.clb_cb_info.p_trg_clk_cap_cb;
+    tBTM_TRG_CLK_CAP     results;
+
+    if(p_cb)
+    {
+        STREAM_TO_UINT16(results.handle, p);
+        STREAM_TO_UINT8(results.which_clock, p);
+        STREAM_TO_UINT32(results.clock, p);
+        STREAM_TO_UINT16(results.offset, p);
+
+        (*p_cb)(&results);
+    }
+}
+
+void btm_slv_page_rsp_to(void)
+{
+    tBTM_SLV_PAGE_RSP_TO_CB *p_cb = btm_cb.devcb.clb_cb_info.p_slv_page_rsp_to_cb;
+
+    if(p_cb)
+        (*p_cb)();
+}
+
+void btm_clb_channel_map_change(UINT8 *p)
+{
+    tBTM_CLB_CHANNEL_CHANGE_CB *p_cb = btm_cb.devcb.clb_cb_info.p_clb_channel_change_cb;
+
+    if(p_cb)
+        (*p_cb) ();
+}
diff -Naur '--exclude=.git' bluedroid-orig/stack/btm/btm_inq.c bluedroid/stack/btm/btm_inq.c
--- bluedroid-orig/stack/btm/btm_inq.c	2015-09-24 16:33:43.548227643 +0800
+++ bluedroid/stack/btm/btm_inq.c	2015-09-24 16:31:37.000000000 +0800
@@ -2648,7 +2648,7 @@
         }
         else
         {
-            cmd_ok = FALSE
+            cmd_ok = FALSE;
         }
 
         if (cmd_ok)
@@ -2816,7 +2816,7 @@
 #if (BLE_INCLUDED == TRUE)
                 if (BTM_UseLeLink(remote_bda))
                 {
-                    if (btm_ble_read_remote_name(remote_bda, p_cur, p_cb) != BTM_CMD_STARTED)
+	                if (btm_ble_read_remote_name(remote_bda, p_cur, p_cb) != BTM_CMD_STARTED)
                         p_cur->remote_name_state = BTM_INQ_RMT_NAME_FAILED;
                     else
                         return;
diff -Naur '--exclude=.git' bluedroid-orig/stack/btm/btm_int.h bluedroid/stack/btm/btm_int.h
--- bluedroid-orig/stack/btm/btm_int.h	2015-09-24 16:33:43.548227643 +0800
+++ bluedroid/stack/btm/btm_int.h	2015-09-24 16:31:37.000000000 +0800
@@ -137,6 +137,10 @@
 #define TT_DEV_RESET     1
 #define TT_DEV_RLN       2
 #define TT_DEV_RLNKP     4              /* Read Link Policy Settings */
+#define TT_DEV_CLB       8
+
+#define TT_DEV_CLB_PARAM(_x) ((_x << 8) | TT_DEV_CLB)
+#define TT_DEV_CLB_TYPE(_x)  ((_x >> 8) & 0xFF)
 
 /* Define the Device Management control structure
 */
@@ -233,6 +237,13 @@
     UINT8               lmp_features_host_may_support;  /* The flags of LMP features host may support via BR/EDR ctrlr + BTM_RE_READ_1ST_PAGE */
     UINT8               supported_cmds[HCI_NUM_SUPP_COMMANDS_BYTES]; /* Supported Commands bit field */
 
+    tBTM_CLB_CB_INFO    clb_cb_info;
+    tBTM_CMPL_CB        *read_clk_cmpl;
+
+#define BTM_MAX_CLB_TIMERS 6
+    TIMER_LIST_ENT      clb_cmd_timers[BTM_MAX_CLB_TIMERS];
+
+
 } tBTM_DEVCB;
 
 
@@ -292,7 +303,6 @@
 
 #define BTM_EXT_RMT_NAME_TIMEOUT    40
 
-
     TIMER_LIST_ENT  rmt_name_timer_ent;
 
     UINT16           discoverable_mode;
@@ -1072,6 +1082,17 @@
 extern  void btm_reset_ctrlr_complete (void);
 extern void btm_write_simple_paring_mode_complete (UINT8 *p);
 extern void btm_write_le_host_supported_complete (UINT8 *p);
+extern void btm_set_clb_complete(UINT8 *p);
+extern void btm_start_sync_train_complete(UINT8 *p);
+extern void btm_sync_train_complete(UINT8 *p);
+extern void btm_set_reserved_lt_addr_complete(UINT8 *p);
+extern void btm_set_clb_data_complete(UINT8 *p);
+extern void btm_write_sync_train_params_complete(UINT8 *p);
+extern void btm_set_trg_clk_capture_complete(UINT8 *p);
+extern void btm_trg_clk_capture(UINT8 *p);
+extern void btm_slv_page_rsp_to(void);
+extern void btm_clb_channel_map_change(UINT8 *p);
+extern void btm_read_clk_cmpl(UINT8 *p);
 
 #if (BLE_INCLUDED == TRUE)
 extern void btm_read_ble_buf_size_complete (UINT8 *p, UINT16 evt_len);
@@ -1097,7 +1118,9 @@
 extern void btm_delete_stored_link_key_complete (UINT8 *p);
 extern void btm_return_link_keys_evt (tBTM_RETURN_LINK_KEYS_EVT *result);
 extern void btm_report_device_status (tBTM_DEV_STATUS status);
-
+#if (A2DP_KERNEL_DIRECT == TRUE)
+extern void btm_btlite_rsp_hdl(tBTM_BTLITE_RSP *p,tBTM_BTLITE_CMPL_CB *p_cb);
+#endif
 
 /* Internal functions provided by btm_dev.c
 **********************************************
diff -Naur '--exclude=.git' bluedroid-orig/stack/btm/btm_sec.c bluedroid/stack/btm/btm_sec.c
--- bluedroid-orig/stack/btm/btm_sec.c	2015-09-24 16:33:43.548227643 +0800
+++ bluedroid/stack/btm/btm_sec.c	2015-09-24 16:31:37.000000000 +0800
@@ -101,6 +101,26 @@
 /*  BTM_IO_CAP_IN       2   KeyboardOnly */
 /*  BTM_IO_CAP_NONE     3   NoInputNoOutput */
 
+static const UINT8 white_addr_prefix[][3] = {
+    {0x24, 0x4B, 0x03}  // Samsung J Sound Bar
+};
+static BOOLEAN dev_whitelisted_for_inAuthorize(BD_ADDR peer_dev)
+{
+    int i;
+    int list_size = sizeof(white_addr_prefix)/sizeof(white_addr_prefix[0]);
+    for (i = 0; i < list_size; i++) {
+         if (white_addr_prefix[i][0] == peer_dev[0] &&
+             white_addr_prefix[i][1] == peer_dev[1] &&
+             white_addr_prefix[i][2] == peer_dev[2]) {
+             BTIF_TRACE_DEBUG3("whitelist authorize incoming connect %02x:%02x:%02x",
+                                 peer_dev[0], peer_dev[1], peer_dev[2]);
+             return TRUE;
+         }
+    }
+    return FALSE;
+}
+
+
 /*******************************************************************************
 **
 ** Function         BTM_SecRegister
@@ -2755,6 +2775,8 @@
         btsnd_hcic_set_event_mask(LOCAL_BR_EDR_CONTROLLER_ID,
                                   (UINT8 *)HCI_LISBON_EVENT_MASK_EXT);
 #endif
+        //XXX
+        btsnd_hcic_set_event_mask_page_2(LOCAL_BR_EDR_CONTROLLER_ID, (UINT8 *)HCI_PAGE_2_EVENT_MASK); 
         /* set the default IO capabilities */
         btm_cb.devcb.loc_io_caps = BTM_LOCAL_IO_CAPS;
         /* add mx service to use no security */
@@ -5166,7 +5188,17 @@
             return(btm_sec_start_authorization (p_dev_rec));
         }
     }
-
+    else if(p_dev_rec->p_cur_service && !(p_dev_rec->sec_flags & BTM_SEC_AUTHORIZED)
+            //&& (!p_dev_rec->is_originator && dev_whitelisted_for_inAuthorize(p_dev_rec->bd_addr))
+            && (!p_dev_rec->is_originator)
+            && (p_dev_rec->p_cur_service->service_id == BTM_SEC_SERVICE_AVDTP))
+    {
+        if (p_dev_rec->p_cur_service->service_id < BTM_SEC_MAX_SERVICES)
+        {
+            BTM_TRACE_EVENT0 ("Security Manager: Start authorization");
+            return(btm_sec_start_authorization (p_dev_rec));
+        }
+    }
     /* All required  security procedures already established */
     p_dev_rec->security_required &= ~(BTM_SEC_OUT_AUTHORIZE | BTM_SEC_IN_AUTHORIZE |
                                       BTM_SEC_OUT_AUTHENTICATE | BTM_SEC_IN_AUTHENTICATE |
diff -Naur '--exclude=.git' bluedroid-orig/stack/btu/btu_hcif.c bluedroid/stack/btu/btu_hcif.c
--- bluedroid-orig/stack/btu/btu_hcif.c	2015-09-24 16:33:43.548227643 +0800
+++ bluedroid/stack/btu/btu_hcif.c	2015-09-24 16:31:37.000000000 +0800
@@ -57,6 +57,8 @@
 //Counter to track number of HCI command timeout
 static int num_hci_cmds_timed_out;
 
+extern BOOLEAN enable_test_mode;
+
 /********************************************************************************/
 /*              L O C A L    F U N C T I O N     P R O T O T Y P E S            */
 /********************************************************************************/
@@ -137,6 +139,10 @@
 static void btu_ble_proc_ltk_req (UINT8 *p, UINT16 evt_len);
 static void btu_hcif_encyption_key_refresh_cmpl_evt (UINT8 *p, UINT16 evt_len);
     #endif
+
+static void btu_hcif_sync_train_complete_evt (UINT8 *p, UINT16 evt_len);
+static void btu_hcif_trig_clk_capture_evt (UINT8 *p, UINT16 evt_len);
+static void btu_hcif_slv_page_resp_to_evt (UINT8 *p, UINT16 evt_len);
 /*******************************************************************************
 **
 ** Function         btu_hcif_store_cmd
@@ -166,8 +172,10 @@
     STREAM_TO_UINT16 (opcode, p);
 
     /* don't do anything for certain commands */
-    if ((opcode == HCI_RESET) || (opcode == HCI_HOST_NUM_PACKETS_DONE))
+    if ((opcode == HCI_RESET) || (opcode == HCI_HOST_NUM_PACKETS_DONE) ||
+        (opcode == HCI_GRP_VENDOR_SPECIFIC) || (opcode == HCI_VSC_DETACH_PATCH))
     {
+        ALOGE("%s: Not adding opcode : 0x%4x to the  'cmd_compl_q'", __func__, opcode);
         return;
     }
 
@@ -226,6 +234,7 @@
 *******************************************************************************/
 void btu_hcif_process_event (UINT8 controller_id, BT_HDR *p_msg)
 {
+    tHCI_CMD_CB * p_hci_cmd_cb = &(btu_cb.hci_cmd_cb[controller_id]);
     UINT8   *p = (UINT8 *)(p_msg + 1) + p_msg->offset;
     UINT8   hci_evt_code, hci_evt_len;
 #if BLE_INCLUDED == TRUE
@@ -234,6 +243,8 @@
     STREAM_TO_UINT8  (hci_evt_code, p);
     STREAM_TO_UINT8  (hci_evt_len, p);
 
+    ALOGE("%s: Recvd. HCI EVENT CODE: 0x%x", __func__, hci_evt_code);
+
     switch (hci_evt_code)
     {
         case HCI_INQUIRY_COMP_EVT:
@@ -424,8 +435,32 @@
             }
             break;
 #endif /* BLE_INCLUDED */
+        case HCI_SYNC_TRAIN_COMP_EVT:
+            btu_hcif_sync_train_complete_evt(p, hci_evt_len);
+            break;
+        case HCI_TRIG_CLK_CAPTURE_EVT:
+            btu_hcif_trig_clk_capture_evt(p, hci_evt_len);
+            break;
+        case HCI_SLAVE_PAGE_RESP_TIMEOUT_EVT:
+            btu_hcif_slv_page_resp_to_evt(p, hci_evt_len);
+            break;
+        case HCI_CLB_CHANNEL_CHANGE_EVT:
+            btm_clb_channel_map_change(p);
+            break;
         case HCI_VENDOR_SPECIFIC_EVT:
                 btm_vendor_specific_evt (p, hci_evt_len);
+                if(TRUE == enable_test_mode)
+                {
+                   /*
+                    * Start the timer for 15secs: On its expiry trigger the BT FW Download.
+                    * Borrowing the timer type from AMP for initiating the firmware
+                    * upgrade process.
+                    */
+                   ALOGE("%s: Starting the BT FW Upgrade timer for 15secs", __func__);
+                   btu_start_timer (&(p_hci_cmd_cb->fw_upgrade_trigger_timer),
+                       (UINT16)(BTU_TTYPE_BTU_AMP1_CMD_CMPL), 15);
+                }
+
             break;
     }
 #if HCI_RAW_CMD_INCLUDED == TRUE
@@ -1147,8 +1182,30 @@
         case HCI_BLE_TEST_END:
             btm_ble_test_command_complete(p);
             break;
+        case HCI_VSC_DETACH_PATCH:
+            ALOGE("%s: Controller probably got re-enumerated. Read patch version", __func__);
+            btif_read_version_internal();
+            break;
 #endif /* (BLE_INCLUDED == TRUE) */
 
+        case HCI_SET_CLB:
+            btm_set_clb_complete(p);
+            break;
+        case HCI_SET_RESERVED_LT_ADDR:
+        case HCI_DELETE_RESERVED_LT_ADDR:
+        BT_TRACE_1 (TRACE_LAYER_HCI, TRACE_TYPE_DEBUG,
+                    "LT addr command complete %d", opcode);
+            btm_set_reserved_lt_addr_complete(p);
+            break;
+        case HCI_WRITE_CLB_DATA:
+            btm_set_clb_data_complete(p);
+            break;
+        case HCI_WRITE_SYNC_TRAIN_PARAM:
+            btm_write_sync_train_params_complete(p);
+            break;
+        case HCI_SET_TRIG_CLK_CAPTURE:
+            btm_set_trg_clk_capture_complete(p);
+            break;
         default:
             if ((opcode & HCI_GRP_VENDOR_SPECIFIC) == HCI_GRP_VENDOR_SPECIFIC)
                 btm_vsc_complete (p, opcode, evt_len, (tBTM_CMPL_CB *)p_cplt_cback);
@@ -1180,6 +1237,7 @@
 #endif
 
     STREAM_TO_UINT16 (cc_opcode, p);
+    ALOGE("%s: Recvd. CC for opcode: 0x%x", __func__, cc_opcode);
 
     evt_len -= 3;
 
@@ -1402,6 +1460,10 @@
                 break;
 #endif
 */
+                    case HCI_START_SYNC_TRAIN:
+                        if (p_cmd != NULL)
+                            btm_start_sync_train_complete(p_cmd);
+                        break;
                     default:
                         if ((opcode & HCI_GRP_VENDOR_SPECIFIC) == HCI_GRP_VENDOR_SPECIFIC)
                             btm_vsc_complete (&status, opcode, 1, (tBTM_CMPL_CB *)p_vsc_status_cback);
@@ -1413,6 +1475,11 @@
             {
                 if ((opcode & HCI_GRP_VENDOR_SPECIFIC) == HCI_GRP_VENDOR_SPECIFIC)
                     btm_vsc_complete (&status, opcode, 1, (tBTM_CMPL_CB *)p_vsc_status_cback);
+                else if(opcode == HCI_START_SYNC_TRAIN)
+                {
+                    if(p_cmd != NULL)
+                        btm_start_sync_train_complete(p_cmd);
+                }
             }
 #if BTM_PWR_MGR_INCLUDED == TRUE
     }
@@ -1689,22 +1756,35 @@
 *******************************************************************************/
 static void btu_hcif_hardware_error_evt (UINT8 *p, UINT16 evt_len)
 {
-    BT_TRACE_1 (TRACE_LAYER_HCI, TRACE_TYPE_ERROR, "Ctlr H/w error event - code:0x%x", *p);
+    tHCI_CMD_CB *p_hci_cmd_cb = &(btu_cb.hci_cmd_cb[0]);
 
-    /* If anyone wants device status notifications, give him one. */
-    btm_report_device_status (BTM_DEV_STATUS_DOWN);
+    BT_TRACE_1 (TRACE_LAYER_HCI, TRACE_TYPE_ERROR, "Ctlr H/w error event - code:0x%x", *p);
 
-    /* Reset the controller */
-    if (BTM_IsDeviceUp())
-        BTM_DeviceReset (NULL);
     if(*p == 0x0f)
-     {
+    {
+       /* If anyone wants device status notifications, give him one. */
+       btm_report_device_status (BTM_DEV_STATUS_DOWN);
+
+       /* Reset the controller */
+       if (BTM_IsDeviceUp()) {
+           ALOGE("%s: Resetting the device", __func__);
+           BTM_DeviceReset (NULL);
+       }
        BT_TRACE_0 (TRACE_LAYER_HCI, TRACE_TYPE_ERROR, "Ctlr H/w error event - code:Tigger SSR");
        bte_ssr_cleanup();
        usleep(20000); /* 20 milliseconds */
         /* Killing the process to force a restart as part of fault tolerance */
        kill(getpid(), SIGKILL);
-     }
+    }
+    /* 0xff - used for indicating HCI down status */
+    else if (*p == 0xff)
+    {
+       /* Stop the CMD COMPLETE TIMER as HCI is already down */
+       btu_stop_timer (&(p_hci_cmd_cb->cmd_cmpl_timer));
+
+       /* Notify BTIF_TASK that the driver got unloaded*/
+       GKI_send_event(BTIF_TASK, BT_EVT_HCI_DISCONNECT);
+    }
 }
 
 
@@ -2313,3 +2393,17 @@
 ***********************************************/
 #endif /* BLE_INCLUDED */
 
+static void btu_hcif_sync_train_complete_evt (UINT8 *p, UINT16 evt_len)
+{
+    btm_sync_train_complete(p);
+}
+
+static void btu_hcif_trig_clk_capture_evt (UINT8 *p, UINT16 evt_len)
+{
+    btm_trg_clk_capture(p);
+}
+
+static void btu_hcif_slv_page_resp_to_evt (UINT8 *p, UINT16 evt_len)
+{
+    btm_slv_page_rsp_to();
+}
diff -Naur '--exclude=.git' bluedroid-orig/stack/btu/btu_task.c bluedroid/stack/btu/btu_task.c
--- bluedroid-orig/stack/btu/btu_task.c	2015-09-24 16:33:43.548227643 +0800
+++ bluedroid/stack/btu/btu_task.c	2015-09-24 16:31:37.000000000 +0800
@@ -233,6 +233,7 @@
             while ((p_msg = (BT_HDR *) GKI_read_mbox (BTU_HCI_RCV_MBOX)) != NULL)
             {
                 /* Determine the input message type. */
+                BT_TRACE_1(TRACE_LAYER_BTU, TRACE_TYPE_API, "btu_task event %x",p_msg->event);
                 switch (p_msg->event & BT_EVT_MASK)
                 {
                     case BT_EVT_TO_BTU_HCI_ACL:
@@ -343,9 +344,16 @@
                         GKI_freebuf (p_msg);
                         break;
 #endif
-
+#if (A2DP_KERNEL_DIRECT == TRUE)
+                    case BT_EVT_BTU_IPC_EVT:
+                        //call btlite_rsp
+                        APPL_TRACE_ERROR0("BT_EVT_BTU_IPC_EVT");
+                        btu_btlite_rsp_event(p_msg);
+                        break;
+#endif
                     default:
                         i = 0;
+                        APPL_TRACE_ERROR0("BTU_TASK DEFAULT!!!");
                         mask = (UINT16) (p_msg->event & BT_EVT_MASK);
                         handled = FALSE;
 
@@ -462,6 +470,15 @@
                         btu_hcif_cmd_timeout((UINT8)(p_tle->event - BTU_TTYPE_BTU_CMD_CMPL));
                         break;
 
+                    case BTU_TTYPE_BTU_AMP1_CMD_CMPL:
+                        if (btif_hw_chip_firmware_update() != 0) {
+                            tHCI_CMD_CB * p_hci_cmd_cb = &(btu_cb.hci_cmd_cb[0]);
+                            btu_start_timer (&(p_hci_cmd_cb->fw_upgrade_trigger_timer),
+                                (UINT16)(BTU_TTYPE_BTU_AMP1_CMD_CMPL),
+                                15); /* start short timer, if timer is set to 1 then it could expire before HCISU checks. */
+                        }
+                        break;
+
 #if (defined(HID_HOST_INCLUDED) && HID_HOST_INCLUDED == TRUE)
                     case BTU_TTYPE_HID_HOST_REPAGE_TO :
                         hidh_proc_repage_timeout(p_tle);
diff -Naur '--exclude=.git' bluedroid-orig/stack/CMakeLists.txt bluedroid/stack/CMakeLists.txt
--- bluedroid-orig/stack/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/stack/CMakeLists.txt	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,173 @@
+CMAKE_MINIMUM_REQUIRED(VERSION 2.6)
+PROJECT(bt-brcm_stack C)
+
+SET(SRCS
+./a2dp/a2d_api.c
+./a2dp/a2d_sbc.c
+./avrc/avrc_api.c
+./avrc/avrc_sdp.c
+./avrc/avrc_opt.c
+./avrc/avrc_bld_tg.c
+./avrc/avrc_bld_ct.c
+./avrc/avrc_pars_tg.c
+./avrc/avrc_pars_ct.c
+./avrc/avrc_utils.c
+./hid/hidh_api.c
+./hid/hidh_conn.c
+./hid/hidd_api.c
+./hid/hidd_conn.c
+./bnep/bnep_main.c
+./bnep/bnep_utils.c
+./bnep/bnep_api.c
+./hcic/hciblecmds.c
+./hcic/hcicmds.c
+./btm/btm_ble.c
+./btm/btm_sec.c
+./btm/btm_inq.c
+./btm/btm_ble_addr.c
+./btm/btm_ble_bgconn.c
+./btm/btm_main.c
+./btm/btm_dev.c
+./btm/btm_ble_gap.c
+./btm/btm_acl.c
+./btm/btm_sco.c
+./btm/btm_pm.c
+./btm/btm_devctl.c
+./rfcomm/rfc_utils.c
+./rfcomm/port_rfc.c
+./rfcomm/rfc_l2cap_if.c
+./rfcomm/rfc_mx_fsm.c
+./rfcomm/port_utils.c
+./rfcomm/rfc_port_fsm.c
+./rfcomm/rfc_port_if.c
+./rfcomm/port_api.c
+./rfcomm/rfc_ts_frames.c
+./mcap/mca_dact.c
+./mcap/mca_dsm.c
+./mcap/mca_l2c.c
+./mcap/mca_main.c
+./mcap/mca_csm.c
+./mcap/mca_cact.c
+./mcap/mca_api.c
+./gatt/gatt_sr.c
+./gatt/gatt_cl.c
+./gatt/gatt_api.c
+./gatt/gatt_auth.c
+./gatt/gatt_utils.c
+./gatt/gatt_main.c
+./gatt/att_protocol.c
+./gatt/gatt_attr.c
+./gatt/gatt_db.c
+./avct/avct_api.c
+./avct/avct_l2c.c
+./avct/avct_lcb.c
+./avct/avct_ccb.c
+./avct/avct_lcb_act.c
+./smp/smp_main.c
+./smp/smp_l2c.c
+./smp/smp_cmac.c
+./smp/smp_utils.c
+./smp/smp_act.c
+./smp/smp_keys.c
+./smp/smp_api.c
+./smp/aes.c
+./avdt/avdt_ccb.c
+./avdt/avdt_scb_act.c
+./avdt/avdt_msg.c
+./avdt/avdt_ccb_act.c
+./avdt/avdt_api.c
+./avdt/avdt_scb.c
+./avdt/avdt_ad.c
+./avdt/avdt_l2c.c
+./sdp/sdp_server.c
+./sdp/sdp_main.c
+./sdp/sdp_db.c
+./sdp/sdp_utils.c
+./sdp/sdp_api.c
+./sdp/sdp_discovery.c
+./pan/pan_main.c
+./srvc/srvc_battery.c
+./srvc/srvc_battery_int.h
+./srvc/srvc_dis.c
+./srvc/srvc_dis_int.h
+./srvc/srvc_eng.c
+./srvc/srvc_eng_int.h
+./pan/pan_api.c
+./pan/pan_utils.c
+./btu/btu_hcif.c
+./btu/btu_init.c
+./btu/btu_task.c
+./l2cap/l2c_fcr.c
+./l2cap/l2c_ucd.c
+./l2cap/l2c_main.c
+./l2cap/l2c_api.c
+./l2cap/l2c_utils.c
+./l2cap/l2c_csm.c
+./l2cap/l2c_link.c
+./l2cap/l2c_ble.c
+./gap/gap_api.c
+./gap/gap_ble.c
+./gap/gap_conn.c
+./gap/gap_utils.c
+./qcom/qcom_etc.c
+)
+
+SET(PREFIX ${CMAKE_INSTALL_PREFIX})
+SET(EXEC_PREFIX "\${prefix}")
+SET(LIBDIR "\${prefix}/lib")
+SET(INCLUDEDIR "\${prefix}/include")
+SET(VERSION_MAJOR 1)
+SET(VERSION ${VERSION_MAJOR}.0.0)
+
+
+set(LOCAL_C_INCLUDES
+	./include 
+	./avct 
+	./btm 
+	./avrc 
+	./l2cap 
+	./avdt 
+	./gatt 
+	./gap 
+	./pan 
+	./bnep 
+	./hid 
+	./sdp 
+	./smp 
+	./srvc
+	../include 
+	../gki/common 
+	../gki/ulinux 
+	../udrv/include 
+	../rpc/include 
+	../hcis 
+	../ctrlr/include 
+	../bta/include 
+	../bta/sys 
+	../brcm/include 
+	../utils/include 
+	../../../../system/core/include
+	$(bdroid_C_INCLUDES))
+include_directories(${LOCAL_C_INCLUDES})
+
+FOREACH(flag ${packages_CFLAGS})
+	SET(EXTRA_CFLAGS "${EXTRA_CFLAGS} ${flag}")
+ENDFOREACH(flag)
+
+#SET(EXTRA_CFLAGS "${EXTRA_CFLAGS} -fvisibility=hidden -Wall")
+SET(EXTRA_CFLAGS "${EXTRA_CFLAGS} -g ")
+
+SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${EXTRA_CFLAGS} -fPIC")
+
+FIND_PROGRAM(UNAME NAMES uname)
+EXEC_PROGRAM("${UNAME}" ARGS "-m" OUTPUT_VARIABLE "ARCH")
+IF("${ARCH}" STREQUAL "arm")
+	ADD_DEFINITIONS("-DTARGET")
+	MESSAGE("add -DTARGET")
+ENDIF("${ARCH}" STREQUAL "arm")
+
+ADD_LIBRARY(${PROJECT_NAME} STATIC ${SRCS})
+SET_TARGET_PROPERTIES(${PROJECT_NAME} PROPERTIES SOVERSION ${VERSION_MAJOR})
+SET_TARGET_PROPERTIES(${PROJECT_NAME} PROPERTIES VERSION ${VERSION})
+TARGET_LINK_LIBRARIES(${PROJECT_NAME} ${packages_LDFLAGS})
+INSTALL(TARGETS ${PROJECT_NAME} DESTINATION lib)
diff -Naur '--exclude=.git' bluedroid-orig/stack/hcic/hcicmds.c bluedroid/stack/hcic/hcicmds.c
--- bluedroid-orig/stack/hcic/hcicmds.c	2015-09-24 16:33:43.548227643 +0800
+++ bluedroid/stack/hcic/hcicmds.c	2015-09-24 16:31:37.000000000 +0800
@@ -3344,7 +3344,302 @@
 
     btu_hcif_send_cmd (LOCAL_BR_EDR_CONTROLLER_ID,  p);
 }
-
+#if (A2DP_KERNEL_DIRECT == TRUE)
+void dump_btlite_cmd(void *buf,UINT8 cmd)
+{
+    BT_HDR *p = (BT_HDR *)buf;
+    UINT8 *pp = (UINT8 *)(p + 1);
+    APPL_TRACE_DEBUG1("[BTLite]total length = %d",p->len);
+
+    APPL_TRACE_DEBUG1("[BTLite]length = %d",(UINT16)(*pp) | ((UINT16)(*(pp+1))<<8));
+    pp+=2;
+    APPL_TRACE_DEBUG1("[BTLite]event = %d",(UINT16)(*pp) | ((UINT16)(*(pp+1))<<8));
+    pp+=2;
+    APPL_TRACE_DEBUG1("[BTLite]cmd_type = %d",*pp);
+    pp++;
+    if(cmd == 0)
+    {
+       APPL_TRACE_DEBUG1("[BTLite]avdt handle = %d",*pp);
+       pp++;
+       APPL_TRACE_DEBUG1("[BTLite]chnl = %x",*pp);
+       pp++;
+       APPL_TRACE_DEBUG1("[BTLite]codec_type = %d",*pp);
+       pp++;
+       APPL_TRACE_DEBUG1("[BTLite]cong = %d",*pp);
+       pp++;
+       APPL_TRACE_DEBUG1("[BTLite]hdi = %d",*pp);
+       pp++;
+       APPL_TRACE_DEBUG1("[BTLite]hndl = %d",*pp);
+       pp++;
+       APPL_TRACE_DEBUG1("[BTLite]l2c_buf = %d",*pp);
+       pp++;
+       APPL_TRACE_DEBUG1("[BTLite]l2c_cid = %x",(UINT16)(*pp) | ((UINT16)(*(pp+1))<<8));
+       pp+=2;
+       APPL_TRACE_DEBUG6("[BTLite]peer BD_ADDR %x:%x:%x:%x:%x:%x",
+                       *pp,*(pp+1),*(pp+2),*(pp+3),*(pp+4),*(pp+5));
+       pp+=7;
+       APPL_TRACE_DEBUG1("[BTLite]curr_mtu = %d",(UINT16)(*pp) | ((UINT16)(*(pp+1))<<8));
+    }
+    else if(cmd == 2)
+    {
+       APPL_TRACE_DEBUG1("[BTLite]scb_idx = %d",*pp);
+       pp++;
+       APPL_TRACE_DEBUG1("[BTLite]audio_open_cnt = %x",*pp);
+       pp++;
+       APPL_TRACE_DEBUG1("[BTLite]bitrate = %x",(UINT16)(*pp) | ((UINT16)(*(pp+1))<<8));
+       pp+=2;
+       APPL_TRACE_DEBUG1("[BTLite]bitrate busy = %x",(UINT16)(*pp) | ((UINT16)(*(pp+1))<<8));
+       pp+=2;
+       APPL_TRACE_DEBUG1("[BTLite]bitrate swampd = %x",(UINT16)(*pp) | ((UINT16)(*(pp+1))<<8));
+       pp+=2;
+       APPL_TRACE_DEBUG1("[BTLite]busy_level = %d",*pp);
+       pp++;
+       APPL_TRACE_DEBUG6("[BTLite]codec info  = %d %d %d %d %d %d",
+                          *pp,*(pp+1),*(pp+2),*(pp+3),*(pp+4),*(pp+5));
+       pp+=6;
+       APPL_TRACE_DEBUG4("[BTLite]codec info  = %d %d %d %d ",*pp,*(pp+1), *(pp+2), *(pp+3));
+       pp+=4;
+       APPL_TRACE_DEBUG1("[BTLite]codec_type = %d",*pp);
+       pp++;
+       APPL_TRACE_DEBUG1("[BTLite]start_stop_flag = %d",*pp);
+       pp++;
+       APPL_TRACE_DEBUG1("[BTLite]streaming_type= %d",*pp);
+       pp++;
+
+    }
+    else if(cmd == 4 || cmd == 8)
+    {
+       APPL_TRACE_DEBUG1("[BTLite]scb_idx = %d",*pp);
+       pp++;
+       APPL_TRACE_DEBUG1("[BTLite]audio_open_cnt = %x",*pp);
+       pp++;
+    }
+    else if(cmd == 6)
+    {
+       APPL_TRACE_DEBUG1("[BTLite]scb_idx = %d",*pp);
+       pp++;
+       APPL_TRACE_DEBUG1("[BTLite]audio_open_cnt = %x",*pp);
+       pp++;
+       APPL_TRACE_DEBUG1("[BTLite]curr_mtu = %d",(UINT16)(*pp) | ((UINT16)(*(pp+1))<<8));
+    }
+}
+static void store_btlite_cmd_cb(UINT8 cmd_type,void *p_rsp_cback)
+{
+    tHCI_CMD_CB *btlite_cb = &btu_cb.btlite_cmd_cb;
+    BT_HDR *p = GKI_getbuf(sizeof(BT_HDR) + sizeof(void *));
+    APPL_TRACE_DEBUG0("store_btlite_cmd_cb");
+    UINT8 *pp = p;
+    pp = (UINT8 *)(p + 1);
+    *((void **)pp) = p_rsp_cback;
+    p->event = cmd_type;
+    GKI_enqueue(&(btlite_cb->cmd_cmpl_q),p);
+}
+void btsnd_btlite_req_cmd(void *p_buf,UINT8 cmd_type,UINT16 evt,void *p_info,void *p_cb)
+{
+    BT_HDR *p  = (BT_HDR *)p_buf;
+    UINT8 *pp  = (UINT8 *)(p + 1);
+    UINT16 tx_len;
+    BOOLEAN store_cmd = TRUE;
+    APPL_TRACE_DEBUG1("btsnd_btlite_req_cmd cmd_type = %d",cmd_type);
+
+    if (evt == BT_EVT_BTU_IPC_BTM_EVT)
+    {
+        if (cmd_type == BTA_AV_SYNC_TO_LITE_REQ)
+        {
+            tBTA_AV_SYNC_INFO_REQ *pp_info = (tBTA_AV_SYNC_INFO_REQ *)p_info;
+            p->len = (sizeof(tBTA_AV_SYNC_INFO_REQ) + HCI_DATA_PREAMBLE_SIZE);
+            p->offset = 0;
+            tx_len = (sizeof(tBTA_AV_SYNC_INFO_REQ) + sizeof(UINT16)); // UINT16 for IPC event
+            UINT16_TO_STREAM(pp,tx_len);
+            UINT16_TO_STREAM(pp,BT_EVT_BTU_IPC_BTM_EVT);
+            UINT8_TO_STREAM(pp,cmd_type); //IPC opcode
+            UINT8_TO_STREAM(pp,pp_info->sync_info.avdt_handle);
+            UINT8_TO_STREAM(pp,pp_info->sync_info.chnl);
+            UINT8_TO_STREAM(pp,pp_info->sync_info.codec_type);
+            UINT8_TO_STREAM(pp,pp_info->sync_info.cong);
+            UINT8_TO_STREAM(pp,pp_info->sync_info.hdi);
+            UINT8_TO_STREAM(pp,pp_info->sync_info.hndl);
+            UINT8_TO_STREAM(pp,pp_info->sync_info.l2c_bufs);
+            UINT16_TO_STREAM(pp,pp_info->sync_info.l2c_cid);
+            ARRAY_TO_STREAM(pp,pp_info->sync_info.peer_addr,sizeof(BD_ADDR));
+            UINT8_TO_STREAM(pp,pp_info->multi_av_supported);
+            UINT16_TO_STREAM(pp,pp_info->curr_mtu);
+        }
+        else if(cmd_type == BTA_AV_STR_START_TO_LITE_REQ)
+        {
+            tBTA_AV_SCB_REQ *pp_info = (tBTA_AV_SCB_REQ *)p_info;
+            p->len = (sizeof(tBTA_AV_SCB_REQ) + HCI_DATA_PREAMBLE_SIZE);
+            p->offset = 0;
+            tx_len = (sizeof(tBTA_AV_SCB_REQ) + sizeof(UINT16)); // UINT16 for IPC event
+            UINT16_TO_STREAM(pp,tx_len);
+            UINT16_TO_STREAM(pp,BT_EVT_BTU_IPC_BTM_EVT);
+            UINT8_TO_STREAM(pp,cmd_type); //IPC opcode
+            UINT8_TO_STREAM(pp,pp_info->scb_idx);
+            UINT8_TO_STREAM(pp,pp_info->audio_open_cnt);
+            UINT16_TO_STREAM(pp,pp_info->p_codec_cfg.bit_rate);
+            UINT16_TO_STREAM(pp,pp_info->p_codec_cfg.bit_rate_busy);
+            UINT16_TO_STREAM(pp,pp_info->p_codec_cfg.bit_rate_swampd);
+            UINT8_TO_STREAM(pp,pp_info->p_codec_cfg.busy_level);
+            ARRAY_TO_STREAM(pp,pp_info->p_codec_cfg.codec_info,AVDT_CODEC_SIZE);
+            UINT8_TO_STREAM(pp,pp_info->p_codec_cfg.codec_type);
+            UINT8_TO_STREAM(pp,pp_info->start_stop_flag);
+            UINT8_TO_STREAM(pp,pp_info->streaming_type);
+        }
+        else
+        {
+            if (cmd_type == BTA_AV_STR_SUSPEND_TO_LITE_REQ || cmd_type == BTA_AV_STR_STOP_TO_LITE_REQ)
+            {
+                tBTA_AV_SCB_STOP_REQ *pp_info = (tBTA_AV_SCB_STOP_REQ *)p_info;
+                p->len = (sizeof(tBTA_AV_SCB_STOP_REQ) + HCI_DATA_PREAMBLE_SIZE);
+                p->offset = 0;
+                tx_len = (sizeof(tBTA_AV_SCB_STOP_REQ) + sizeof(UINT16)); // UINT16 for IPC event
+                UINT16_TO_STREAM(pp,tx_len);
+                UINT16_TO_STREAM(pp,BT_EVT_BTU_IPC_BTM_EVT);
+                UINT8_TO_STREAM(pp,cmd_type);
+                UINT8_TO_STREAM(pp,pp_info->scb_idx);
+                UINT8_TO_STREAM(pp,pp_info->audio_open_cnt);
+            }
+            else if(cmd_type == BTA_AV_STR_CLEANUP_TO_LITE_REQ)
+            {
+                tBTA_AV_SCB_CLEANUP_REQ *pp_info = (tBTA_AV_SCB_CLEANUP_REQ *)p_info;
+                p->len = (sizeof(tBTA_AV_SCB_CLEANUP_REQ) + HCI_DATA_PREAMBLE_SIZE);
+                p->offset = 0;
+                tx_len = (sizeof(tBTA_AV_SCB_CLEANUP_REQ) + sizeof(UINT16)); // UINT16 for IPC event
+                UINT16_TO_STREAM(pp,tx_len);
+                UINT16_TO_STREAM(pp,BT_EVT_BTU_IPC_BTM_EVT);
+                UINT8_TO_STREAM(pp,cmd_type);
+                UINT8_TO_STREAM(pp,pp_info->scb_idx);
+                UINT8_TO_STREAM(pp,pp_info->audio_open_cnt);
+                UINT16_TO_STREAM(pp,pp_info->curr_mtu);
+            }
+        }
+    }
+    else if(evt == BT_EVT_BTU_IPC_L2C_EVT)
+    {
+        if (cmd_type == L2C_SYNC_TO_LITE_REQ)
+        {
+            tL2C_SYNC_TO_LITE_REQ *pp_info = (tL2C_SYNC_TO_LITE_REQ *)p_info;
+            int xx;
+            p->len = (sizeof(tL2C_SYNC_TO_LITE_REQ) + HCI_DATA_PREAMBLE_SIZE);
+            p->offset = 0;
+            tx_len = (sizeof(tL2C_SYNC_TO_LITE_REQ) + sizeof(UINT16));
+            UINT16_TO_STREAM(pp,tx_len);
+            UINT16_TO_STREAM(pp,BT_EVT_BTU_IPC_L2C_EVT);
+            UINT8_TO_STREAM(pp,cmd_type);
+            UINT16_TO_STREAM(pp,pp_info->light_xmit_quota);
+            UINT16_TO_STREAM(pp,pp_info->acl_data_size);
+            UINT16_TO_STREAM(pp,pp_info->non_flushable_pbf);
+            UINT8_TO_STREAM(pp,pp_info->multi_av_data_cong_start);
+            UINT8_TO_STREAM(pp,pp_info->multi_av_data_cong_end);
+            UINT8_TO_STREAM(pp,pp_info->multi_av_data_cong_discard);
+            UINT8_TO_STREAM(pp,pp_info->num_stream);
+            for(xx = 0;xx < pp_info->num_stream;xx++)
+            {
+                UINT16_TO_STREAM(pp,pp_info->stream[xx].local_cid);
+                UINT16_TO_STREAM(pp,pp_info->stream[xx].remote_cid);
+                UINT16_TO_STREAM(pp,pp_info->stream[xx].out_mtu);
+                UINT16_TO_STREAM(pp,pp_info->stream[xx].handle);
+                UINT16_TO_STREAM(pp,pp_info->stream[xx].link_xmit_quota);
+                UINT8_TO_STREAM(pp,pp_info->stream[xx].is_flushable);
+            }
+        }
+        else if(cmd_type == L2C_REMOVE_TO_LITE_REQ)
+        {
+            tL2C_SYNC_TO_LITE_REQ *pp_info = (tL2C_SYNC_TO_LITE_REQ *)p_info;
+            int xx;
+            p->len = (sizeof(tL2C_REMOVE_TO_LITE_REQ) + HCI_DATA_PREAMBLE_SIZE);
+            p->offset = 0;
+            tx_len = (sizeof(tL2C_REMOVE_TO_LITE_REQ) + sizeof(UINT16));
+            UINT16_TO_STREAM(pp,tx_len);
+            UINT16_TO_STREAM(pp,BT_EVT_BTU_IPC_L2C_EVT);
+            UINT8_TO_STREAM(pp,cmd_type);
+            UINT16_TO_STREAM(pp,pp_info->light_xmit_quota);
+            UINT8_TO_STREAM(pp,pp_info->num_stream);
+            for(xx = 0;xx < pp_info->num_stream;xx++)
+            {
+                UINT16_TO_STREAM(pp,pp_info->stream[xx].local_cid);
+            }
+        }
+    }
+    else if(evt == BT_EVT_BTU_IPC_AVDT_EVT)
+    {
+        if (cmd_type == AVDT_SYNC_TO_LITE_REQ || cmd_type == AVDT_REMOVE_TO_LITE_REQ)
+        {
+            tAVDT_SYNC_INFO *pp_info = (tAVDT_SYNC_INFO *)p_info;
+            int xx;
+            p->len = (sizeof(tAVDT_SYNC_INFO) + HCI_DATA_PREAMBLE_SIZE);
+            p->offset = 0;
+            tx_len = (sizeof(tAVDT_SYNC_INFO) + sizeof(UINT16)); //Event length
+            UINT16_TO_STREAM(pp,tx_len);
+            UINT16_TO_STREAM(pp,BT_EVT_BTU_IPC_AVDT_EVT);
+            //UINT8_TO_STREAM(pp,pp_info->op_code);
+            UINT8_TO_STREAM(pp,cmd_type);
+            UINT8_TO_STREAM(pp,pp_info->status);
+            for(xx = 0; xx < NUM_STREAM; xx++)
+            {
+                UINT8_TO_STREAM(pp,pp_info->scb_info[xx].handle);
+                ARRAY_TO_STREAM(pp,pp_info->scb_info[xx].peer_addr,BD_ADDR_LEN);
+                UINT16_TO_STREAM(pp,pp_info->scb_info[xx].local_cid);
+                UINT16_TO_STREAM(pp,pp_info->scb_info[xx].peer_mtu);
+                UINT8_TO_STREAM(pp,pp_info->scb_info[xx].mux_tsid_media);
+                UINT16_TO_STREAM(pp,pp_info->scb_info[xx].media_seq);
+            }
+//            store_cmd = FALSE;
+        }
+        else if(cmd_type == AVDT_SYNC_CP_TO_LITE_REQ)
+        {
+            tAVDT_SYNC_INFO *pp_info = (tAVDT_SYNC_INFO *)p_info;
+            int xx;
+            p->len = (sizeof(AVDT_CP_REQ_DATA_SIZE) + HCI_DATA_PREAMBLE_SIZE);
+            p->offset = 0;
+            tx_len = (sizeof(AVDT_CP_REQ_DATA_SIZE) + sizeof(UINT16)); //Event length
+            UINT16_TO_STREAM(pp,tx_len);
+            UINT16_TO_STREAM(pp,BT_EVT_BTU_IPC_AVDT_EVT);
+            UINT8_TO_STREAM(pp,pp_info->op_code);
+            UINT8_TO_STREAM(pp,pp_info->status);
+            for(xx = 0; xx < NUM_STREAM; xx++)
+            {
+                UINT8_TO_STREAM(pp,pp_info->scb_info[xx].handle);
+                UINT16_TO_STREAM(pp,pp_info->scb_info[xx].cp.id);
+                UINT8_TO_STREAM(pp,pp_info->scb_info[xx].cp.scms_hdr);
+            }
+        }
+    }
+//    dump_btlite_cmd(p,cmd_type);
+    if (store_cmd)
+        store_btlite_cmd_cb(cmd_type, p_cb);
+    HCI_BTU_IPC_EVT_TO_LOWER(p);
+}
+void btu_btlite_rsp_event(BT_HDR * p_msg)
+{
+    APPL_TRACE_DEBUG0("btu_btlite_rsp_event");
+    BT_HDR *p = p_msg;
+    UINT8 *pp = (p + 1);
+    BT_HDR *p_cmd;
+    tBTM_BTLITE_RSP struct_btlite_rsp;
+    UINT16 dummy;
+    tHCI_CMD_CB *btlite_callback = &btu_cb.btlite_cmd_cb;
+    void *p_rsp_cback = NULL;
+    p_cmd = GKI_getfirst(&btlite_callback->cmd_cmpl_q);
+    if (p_cmd != NULL)
+    {
+        /* for future extension to check rsp against cmd, for now we are just interested in handling response */
+        GKI_remove_from_queue(&btlite_callback->cmd_cmpl_q,p_cmd);
+        p_rsp_cback = *((void **)(p_cmd + 1));
+        GKI_freebuf(p_cmd);
+  //  }
+        STREAM_TO_UINT16(struct_btlite_rsp.param_len,pp);
+        struct_btlite_rsp.param_len-= (BTUSB_LITE_IPC_HDR_EVT_SIZE + sizeof(UINT8)); //subtract 2bytes of event and 1 byte of opcode
+        //STREAM_TO_UINT16(dummy,pp); //dummy varaible to drop event;
+        STREAM_TO_UINT16(struct_btlite_rsp.event,pp); //dummy varaible to drop event;
+        STREAM_TO_UINT8(struct_btlite_rsp.opcode,pp);
+        STREAM_TO_ARRAY(struct_btlite_rsp.p_param_buf,pp,struct_btlite_rsp.param_len);
+        //btm_btlite_rsp_hdl(&struct_btlite_rsp,(tBTM_VSC_CMPL *)p_rsp_cback);
+        btm_btlite_rsp_hdl(&struct_btlite_rsp,(tBTM_BTLITE_CMPL *)p_rsp_cback);
+    }
+    GKI_freebuf(p_msg);
+}
+#endif
 void btsnd_hcic_data (BT_HDR *p_buf, UINT16 len, UINT16 handle, UINT8 boundary, UINT8 broadcast)
 {
     UINT8   *p;
@@ -3382,3 +3677,193 @@
     return (TRUE);
 }
 
+BOOLEAN btsnd_hcic_set_clb(UINT8 enable, UINT8 lt_addr, UINT8 lpo_allowed, UINT16 packet_type, UINT16 interval_min, UINT16 interval_max, UINT16 supervision_timeout)
+{
+    BT_HDR *p;
+    UINT8 *pp;
+
+    if((p = HCI_GET_CMD_BUF(HCIC_PARAM_SIZE_SET_CLB)) == NULL)
+        return (FALSE);
+
+    pp        = (UINT8 *)(p + 1);
+    p->len    = HCIC_PREAMBLE_SIZE + HCIC_PARAM_SIZE_SET_CLB;
+    p->offset = 0;
+
+    UINT16_TO_STREAM(pp, HCI_SET_CLB);
+    UINT8_TO_STREAM (pp, HCIC_PARAM_SIZE_SET_CLB);
+    UINT8_TO_STREAM (pp, enable);
+    UINT8_TO_STREAM (pp, lt_addr);
+    UINT8_TO_STREAM (pp, lpo_allowed);
+    UINT16_TO_STREAM(pp, packet_type);
+    UINT16_TO_STREAM(pp, interval_min);
+    UINT16_TO_STREAM(pp, interval_max);
+    UINT16_TO_STREAM(pp, supervision_timeout);
+
+    btu_hcif_send_cmd(LOCAL_BR_EDR_CONTROLLER_ID, p);
+
+    return(TRUE);
+}
+/* Start Synchronization Train */
+HCI_API extern BOOLEAN btsnd_hcic_start_sync_train(void)
+{
+    BT_HDR *p;
+    UINT8 *pp;
+
+    if((p = HCI_GET_CMD_BUF(HCIC_PARAM_SIZE_START_SYNC_TRAIN)) == NULL)
+        return (FALSE);
+
+    pp        = (UINT8 *)(p + 1);
+    p->len    = HCIC_PREAMBLE_SIZE + HCIC_PARAM_SIZE_START_SYNC_TRAIN;
+    p->offset = 0;
+
+    UINT16_TO_STREAM(pp, HCI_START_SYNC_TRAIN);
+    UINT8_TO_STREAM (pp, HCIC_PARAM_SIZE_START_SYNC_TRAIN);
+
+    btu_hcif_send_cmd(LOCAL_BR_EDR_CONTROLLER_ID, p);
+
+    return(TRUE);
+}
+
+/* Set Reserved LT_ADDR */
+HCI_API extern BOOLEAN btsnd_hcic_set_reserved_lt_addr(UINT8 lt_addr)
+{
+    BT_HDR *p;
+    UINT8 *pp;
+
+    if((p = HCI_GET_CMD_BUF(HCIC_PARAM_SIZE_SET_RESERVED_LT_ADDR)) == NULL)
+        return (FALSE);
+
+    pp        = (UINT8 *)(p + 1);
+    p->len    = HCIC_PREAMBLE_SIZE + HCIC_PARAM_SIZE_SET_RESERVED_LT_ADDR;
+    p->offset = 0;
+
+    UINT16_TO_STREAM(pp, HCI_SET_RESERVED_LT_ADDR);
+    UINT8_TO_STREAM (pp, HCIC_PARAM_SIZE_SET_RESERVED_LT_ADDR);
+    UINT8_TO_STREAM (pp, lt_addr);
+
+    btu_hcif_send_cmd(LOCAL_BR_EDR_CONTROLLER_ID, p);
+
+    return(TRUE);
+}
+
+/* Delete Reserved LT ADDR */
+HCI_API extern BOOLEAN btsnd_hcic_delete_reserved_lt_addr(UINT8 lt_addr)
+{
+    BT_HDR *p;
+    UINT8 *pp;
+
+    if((p = HCI_GET_CMD_BUF(HCIC_PARAM_SIZE_DELETE_RESERVED_LT_ADDR)) == NULL)
+        return (FALSE);
+
+    pp        = (UINT8 *)(p + 1);
+    p->len    = HCIC_PREAMBLE_SIZE + HCIC_PARAM_SIZE_DELETE_RESERVED_LT_ADDR;
+    p->offset = 0;
+
+    UINT16_TO_STREAM(pp, HCI_DELETE_RESERVED_LT_ADDR);
+    UINT8_TO_STREAM (pp, HCIC_PARAM_SIZE_DELETE_RESERVED_LT_ADDR);
+    UINT8_TO_STREAM (pp, lt_addr);
+
+    btu_hcif_send_cmd(LOCAL_BR_EDR_CONTROLLER_ID, p);
+
+    return(TRUE);
+}
+
+/* Set Connectionless Slave Broadcast Data */
+HCI_API extern BOOLEAN btsnd_hcic_set_clb_data(UINT8 lt_addr, UINT8 fragment, UINT8 data_len, UINT8 *data)
+{
+    BT_HDR *p;
+    UINT8 *pp;
+
+    BT_TRACE_1 (TRACE_LAYER_HCI, TRACE_TYPE_WARNING, "btsnd set cld data: %d", data_len);
+    if((p = HCI_GET_CMD_BUF(HCIC_PARAM_SIZE_SET_CLB_DATA)) == NULL)
+        return (FALSE);
+
+    pp        = (UINT8 *)(p + 1);
+    p->len    = HCIC_PREAMBLE_SIZE + 3 + data_len;
+    p->offset = 0;
+    BT_TRACE_1 (TRACE_LAYER_HCI, TRACE_TYPE_WARNING, "cmd len (p): %d", p->len);
+
+    UINT16_TO_STREAM(pp, HCI_WRITE_CLB_DATA);
+    UINT8_TO_STREAM (pp, 3 + data_len);
+    UINT8_TO_STREAM (pp, lt_addr);
+    UINT8_TO_STREAM (pp, fragment);
+    UINT8_TO_STREAM (pp, data_len);
+    ARRAY_TO_STREAM (pp, data, data_len);
+
+    BT_TRACE_1 (TRACE_LAYER_HCI, TRACE_TYPE_WARNING, "cmd len (p): %d", p->len);
+    btu_hcif_send_cmd(LOCAL_BR_EDR_CONTROLLER_ID, p);
+
+    return(TRUE);
+}
+
+/* Read Synchronization Train Parameters. */
+HCI_API extern BOOLEAN btsnd_hcic_read_sync_train_params(void)
+{
+    BT_HDR *p;
+    UINT8 *pp;
+
+    if((p = HCI_GET_CMD_BUF(HCIC_PARAM_SIZE_READ_SYNC_TRAIN_PARAMS)) == NULL)
+        return (FALSE);
+
+    pp        = (UINT8 *)(p + 1);
+    p->len    = HCIC_PREAMBLE_SIZE + HCIC_PARAM_SIZE_READ_SYNC_TRAIN_PARAMS;
+    p->offset = 0;
+
+    UINT16_TO_STREAM(pp, HCI_READ_SYNC_TRAIN_PARAM);
+    UINT8_TO_STREAM (pp, HCIC_PARAM_SIZE_READ_SYNC_TRAIN_PARAMS);
+
+    btu_hcif_send_cmd(LOCAL_BR_EDR_CONTROLLER_ID, p);
+
+    return(TRUE);
+}
+
+/* Write Synchronization Train Parameters. */
+HCI_API extern BOOLEAN btsnd_hcic_write_sync_train_params(UINT16 interval_min, UINT16 interval_max, UINT32 timeout, UINT8 service_data)
+{
+    BT_HDR *p;
+    UINT8 *pp;
+
+    if((p = HCI_GET_CMD_BUF(HCIC_PARAM_SIZE_WRITE_SYNC_TRAIN_PARAMS)) == NULL)
+        return (FALSE);
+
+    pp        = (UINT8 *)(p + 1);
+    p->len    = HCIC_PREAMBLE_SIZE + HCIC_PARAM_SIZE_WRITE_SYNC_TRAIN_PARAMS;
+    p->offset = 0;
+
+    UINT16_TO_STREAM(pp, HCI_WRITE_SYNC_TRAIN_PARAM);
+    UINT8_TO_STREAM (pp, HCIC_PARAM_SIZE_WRITE_SYNC_TRAIN_PARAMS);
+    UINT16_TO_STREAM(pp, interval_min);
+    UINT16_TO_STREAM(pp, interval_max);
+    UINT32_TO_STREAM(pp, timeout);
+    UINT8_TO_STREAM (pp, service_data);
+
+    btu_hcif_send_cmd(LOCAL_BR_EDR_CONTROLLER_ID, p);
+
+    return(TRUE);
+}
+
+/* Start Triggered Clock Capture */
+HCI_API extern BOOLEAN btsnd_hcic_set_trig_clk_capture(UINT16 handle, UINT8 enable, UINT8 which_clock, UINT8 lpo_allowed, UINT8 num_clock_cap_to_filter)
+{
+    BT_HDR *p;
+    UINT8 *pp;
+
+    if((p = HCI_GET_CMD_BUF(HCIC_PARAM_SIZE_SET_TRIG_CLK_CAPTURE)) == NULL)
+        return (FALSE);
+
+    pp        = (UINT8 *)(p + 1);
+    p->len    = HCIC_PREAMBLE_SIZE + HCIC_PARAM_SIZE_SET_TRIG_CLK_CAPTURE;
+    p->offset = 0;
+
+    UINT16_TO_STREAM(pp, HCI_SET_TRIG_CLK_CAPTURE);
+    UINT8_TO_STREAM (pp, HCIC_PARAM_SIZE_SET_TRIG_CLK_CAPTURE);
+    UINT16_TO_STREAM(pp, handle);
+    UINT8_TO_STREAM (pp, enable);
+    UINT8_TO_STREAM (pp, which_clock);
+    UINT8_TO_STREAM (pp, lpo_allowed);
+    UINT8_TO_STREAM (pp, num_clock_cap_to_filter);
+
+    btu_hcif_send_cmd(LOCAL_BR_EDR_CONTROLLER_ID, p);
+
+    return(TRUE);
+}
diff -Naur '--exclude=.git' bluedroid-orig/stack/include/avct_api.h bluedroid/stack/include/avct_api.h
--- bluedroid-orig/stack/include/avct_api.h	2015-09-24 16:33:43.548227643 +0800
+++ bluedroid/stack/include/avct_api.h	2015-09-24 16:31:37.000000000 +0800
@@ -271,6 +271,22 @@
 *******************************************************************************/
 AVCT_API extern UINT16 AVCT_MsgReq(UINT8 handle, UINT8 label, UINT8 cr, BT_HDR *p_msg);
 
+
+/*******************************************************************************
+**
+** Function         avct_get_peer_addr_by_ccb
+**
+**
+** Description      Return peer BD address on ccb index (or handle).
+**
+**
+**
+**
+** Returns          BD Address.
+**
+*******************************************************************************/
+AVCT_API extern BOOLEAN avct_get_peer_addr_by_ccb (UINT8 idx, BD_ADDR addr);
+
 #ifdef __cplusplus
 }
 #endif
diff -Naur '--exclude=.git' bluedroid-orig/stack/include/avdt_api.h bluedroid/stack/include/avdt_api.h
--- bluedroid-orig/stack/include/avdt_api.h	2015-09-24 16:33:43.552227643 +0800
+++ bluedroid/stack/include/avdt_api.h	2015-09-24 16:31:37.000000000 +0800
@@ -454,6 +454,63 @@
 *******************************************************************************/
 AVDT_API extern void AVDT_Deregister(void);
 
+
+/*******************************************************************************
+**
+** Function         AVDT_UpdateServiceBusyState
+**
+** Description      This function is used to set the service busy state
+**                  during outgoing connection to properly handle the
+**                  connections in upper layers.
+**
+**
+** Returns          void
+**
+*******************************************************************************/
+void AVDT_UpdateServiceBusyState(BOOLEAN state);
+
+/*******************************************************************************
+**
+** Function         AVDT_GetServiceBusyState
+**
+** Description      This function is used to get the service busy state
+**
+**
+** Returns          outgoing connection in progress or not
+**
+*******************************************************************************/
+BOOLEAN AVDT_GetServiceBusyState(void);
+
+/*******************************************************************************
+**
+** Function         AVDT_SINK_Activate
+**
+** Description      Activate SEP of A2DP Sink. In Use parameter is adjusted.
+**                  In Use will be made false in case of activation. A2DP SRC
+**                  will receive in_use as false and can open A2DP Sink
+**                  connection
+**
+** Returns          void
+**
+*******************************************************************************/
+AVDT_API extern void AVDT_SINK_Activate(void);
+
+/*******************************************************************************
+**
+** Function         AVDT_SINK_Deactivate
+**
+** Description      Deactivate SEP of A2DP Sink. In Use parameter is adjusted.
+**                  In Use will be made TRUE in case of activation. A2DP SRC
+**                  will receive in_use as true and will not open A2DP Sink
+**                  connection
+**
+** Returns          void.
+**
+*******************************************************************************/
+AVDT_API extern void AVDT_SINK_Deactivate(void);
+
+AVDT_API extern UINT16 AVDT_AbortReq(UINT8 handle);
+
 /*******************************************************************************
 **
 ** Function         AVDT_CreateStream
diff -Naur '--exclude=.git' bluedroid-orig/stack/include/avrc_api.h bluedroid/stack/include/avrc_api.h
--- bluedroid-orig/stack/include/avrc_api.h	2015-09-24 16:33:43.552227643 +0800
+++ bluedroid/stack/include/avrc_api.h	2015-09-24 16:31:37.000000000 +0800
@@ -201,7 +201,7 @@
 **
 ******************************************************************************/
 AVRC_API extern UINT16 AVRC_AddRecord(UINT16 service_uuid, char *p_service_name,
-                char *p_provider_name, UINT16 categories, UINT32 sdp_handle);
+                char *p_provider_name, UINT16 categories, UINT32 sdp_handle, BOOLEAN browse_supported);
 
 /******************************************************************************
 **
@@ -555,6 +555,20 @@
 
 /*******************************************************************************
 **
+** Function         AVRC_Ctrl_ParsCommand
+**
+** Description      This function is used to parse cmds received for CTRL
+**                  Currently it is for SetAbsVolume and Volume Change Notification..
+**
+** Returns          AVRC_STS_NO_ERROR, if the message in p_data is parsed successfully.
+**                  Otherwise, the error code defined by AVRCP 1.4
+**
+*******************************************************************************/
+AVRC_API extern tAVRC_STS AVRC_Ctrl_ParsCommand (tAVRC_MSG *p_msg, tAVRC_COMMAND *p_result,
+    UINT8 *p_buf, UINT16 buf_len);
+
+/*******************************************************************************
+**
 ** Function         AVRC_ParsCommand
 **
 ** Description      This function is used to parse the received command.
@@ -581,6 +595,18 @@
 
 /*******************************************************************************
 **
+** Function         AVRC_Ctrl_ParsResponse
+**
+** Description      This function is a parse response for AVRCP Controller.
+**
+** Returns          AVRC_STS_NO_ERROR, if the message in p_data is parsed successfully.
+**                  Otherwise, the error code defined by AVRCP 1.4
+**
+*******************************************************************************/
+AVRC_API extern tAVRC_STS AVRC_Ctrl_ParsResponse (tAVRC_MSG *p_msg, tAVRC_RESPONSE *p_result,
+   UINT8 *p_buf, UINT16* buf_len);
+/*******************************************************************************
+**
 ** Function         AVRC_BldCommand
 **
 ** Description      This function builds the given AVRCP command to the given
diff -Naur '--exclude=.git' bluedroid-orig/stack/include/avrc_defs.h bluedroid/stack/include/avrc_defs.h
--- bluedroid-orig/stack/include/avrc_defs.h	2015-09-24 16:33:43.552227643 +0800
+++ bluedroid/stack/include/avrc_defs.h	2015-09-24 16:31:37.000000000 +0800
@@ -840,12 +840,10 @@
 #define AVRC_IS_VALID_CAP_ID(a)           (((a == AVRC_CAP_COMPANY_ID) || (a == AVRC_CAP_EVENTS_SUPPORTED)) ? TRUE : FALSE)
 
 #define AVRC_IS_VALID_EVENT_ID(a)           (((a >= AVRC_EVT_PLAY_STATUS_CHANGE) && \
-                                              (a <= AVRC_EVT_ADDR_PLAYER_CHANGE)) ? TRUE : FALSE)
+                                              (a <= AVRC_EVT_VOLUME_CHANGE)) ? TRUE : FALSE)
 
 #define AVRC_IS_VALID_ATTRIBUTE(a)          (((((a > 0) && a <= AVRC_PLAYER_SETTING_SCAN)) || \
-                                               ((a >= AVRC_PLAYER_SETTING_LOW_MENU_EXT) && \
-                                                (a <= AVRC_PLAYER_SETTING_HIGH_MENU_EXT))) ? TRUE : FALSE)
-
+                                            (a >= AVRC_PLAYER_SETTING_LOW_MENU_EXT)) ? TRUE : FALSE)
 
 #define AVRC_IS_VALID_MEDIA_ATTRIBUTE(a)    ((a >= AVRC_MEDIA_ATTR_ID_TITLE) && \
                                              (a <= AVRC_MEDIA_ATTR_ID_PLAYING_TIME) ? TRUE : FALSE)
@@ -1098,7 +1096,7 @@
     UINT32      start_item;
     UINT32      end_item;
     UINT8       attr_count;
-    UINT32      *p_attr_list;
+    UINT32      attrs[AVRC_MAX_ELEM_ATTR_SIZE];
 } tAVRC_GET_ITEMS_CMD;
 
 /* ChangePath */
@@ -1109,7 +1107,7 @@
     UINT8       opcode;         /* Op Code (assigned by AVRC_BldCommand according to pdu) */
     UINT16      uid_counter;
     UINT8       direction;
-    tAVRC_UID   folder_uid;
+    UINT64      folder_uid;
 } tAVRC_CHG_PATH_CMD;
 
 /* GetItemAttrs */
@@ -1119,10 +1117,10 @@
     tAVRC_STS   status;
     UINT8       opcode;         /* Op Code (assigned by AVRC_BldCommand according to pdu) */
     UINT8       scope;
-    tAVRC_UID   uid;
+    UINT64      uid;
     UINT16      uid_counter;
     UINT8       attr_count;
-    UINT32      *p_attr_list;
+    UINT32      attrs[AVRC_MAX_ELEM_ATTR_SIZE];
 } tAVRC_GET_ATTRS_CMD;
 
 /* Search */
@@ -1141,7 +1139,7 @@
     tAVRC_STS   status;
     UINT8       opcode;         /* Op Code (assigned by AVRC_BldCommand according to pdu) */
     UINT8       scope;
-    tAVRC_UID   uid;
+    UINT64      uid;
     UINT16      uid_counter;
 } tAVRC_PLAY_ITEM_CMD;
 
diff -Naur '--exclude=.git' bluedroid-orig/stack/include/btm_api.h bluedroid/stack/include/btm_api.h
--- bluedroid-orig/stack/include/btm_api.h	2015-09-24 16:33:43.552227643 +0800
+++ bluedroid/stack/include/btm_api.h	2015-09-24 16:31:37.000000000 +0800
@@ -28,7 +28,7 @@
 #include "bt_target.h"
 #include "sdp_api.h"
 #include "hcidefs.h"
-
+#include "uipc_msg.h"
 #if BLE_INCLUDED == TRUE && SMP_INCLUDED == TRUE
 #include "smp_api.h"
 #endif
@@ -119,7 +119,89 @@
     UINT8   *p_param_buf;
 } tBTM_RAW_CMPL;
 
+/* Structure for btlite response */
+#if (A2DP_KERNEL_DIRECT == TRUE)
+typedef struct
+{
+    UINT16  event;
+    UINT8   opcode;
+    UINT8  param_len;
+    UINT8  *p_param_buf;
+} tBTM_BTLITE_CMPL;
+typedef struct
+{
+    UINT8 param_len;
+    UINT16 event;
+    UINT8  opcode;
+    UINT8  p_param_buf[240];
+} tBTM_BTLITE_RSP;
+#endif
 #define  BTM_VSC_CMPL_DATA_SIZE  (BTM_MAX_VENDOR_SPECIFIC_LEN + sizeof(tBTM_VSC_CMPL))
+
+/* Structure returned when a Set CLB command completes. */
+typedef struct
+{
+   UINT8 status;
+   UINT8 lt_addr;
+   UINT16 interval;
+} tBTM_SET_CLB_CMPL;
+
+/* Structure returned whan a Set Reserved LT_ADDR command completes. */
+typedef struct
+{
+   UINT8 status;
+   UINT8 lt_addr;
+} tBTM_SET_RESERVED_LT_ADDR_CMPL;
+
+/* Structure returned when a Set CLB Data command completes. */
+typedef struct
+{
+   UINT8 status;
+   UINT8 lt_addr;
+} tBTM_SET_CLB_DATA_CMPL;
+
+/* Structure returned when a Write Sync Train Parameters command completes. */
+typedef struct
+{
+   UINT8 status;
+   UINT16 interval;
+} tBTM_WRITE_SYNC_TRAIN_PARAM_CMPL;
+
+/* Structure returned when a Triggered Clock Capture event occurs. */
+typedef struct
+{
+   UINT16 handle;
+   UINT8  which_clock;
+   UINT32 clock;
+   UINT16 offset;
+} tBTM_TRG_CLK_CAP;
+
+/* Defines the type of CLB command complete events that could occur */
+#define BTM_SET_CLB_CMPL                0
+#define BTM_START_SYNC_TRAIN_CMPL       1
+#define BTM_SET_RESERVED_LT_ADDR_CMPL   2
+#define BTM_SET_CLB_DATA_CMPL           3
+#define BTM_WRITE_SYNC_TRAIN_PARAM_CMPL 4
+#define BTM_SET_TRG_CLK_CAP_CMPL        5
+
+/* Union to hold the data returned in CLB command complete events. */
+typedef union
+{
+   UINT8                            status; /* START_SYNC TRAIN, SET_TRG_CLK_CAP */
+   tBTM_SET_CLB_CMPL                set_clb;
+   tBTM_SET_RESERVED_LT_ADDR_CMPL   set_reserved;
+   tBTM_SET_CLB_DATA_CMPL           set_clb_data;
+   tBTM_WRITE_SYNC_TRAIN_PARAM_CMPL write_param;
+} tBTM_CLB_CMPL_DATA;
+
+/* Structure which is returned in the tBTM_CMPL_CB when a CLB command completes. */
+typedef struct
+{
+    UINT8              command_type;
+    BOOLEAN            timeout;
+    tBTM_CLB_CMPL_DATA data;
+} tBTM_CLB_CMD_CMPL;
+
 /**************************************************
 **  Device Control and General Callback Functions
 ***************************************************/
@@ -169,6 +251,34 @@
 */
 typedef UINT8 (tBTM_FILTER_CB) (BD_ADDR bd_addr, DEV_CLASS dc);
 
+#if (A2DP_KERNEL_DIRECT == TRUE)
+typedef void (tBTM_BTLITE_CMPL_CB) (tBTM_BTLITE_CMPL *p1);
+#endif
+
+/* Callback for apps to receive a Triggered Clock Capture event. (Set when enabling
+** clock capture).
+*/
+typedef void (tBTM_TRG_CLK_CAP_CB) (tBTM_TRG_CLK_CAP *p);
+
+/* Callback for notifying when the Synchronization Train has completed. */
+typedef void (tBTM_SYNC_TRAIN_CMPL_CB) (UINT8 status);
+
+/* Callback for Slave Page Response Timeout events. */
+typedef void (tBTM_SLV_PAGE_RSP_TO_CB) (void);
+
+/* Calback for when the CLB channel map changes */
+typedef void (tBTM_CLB_CHANNEL_CHANGE_CB) (void);
+
+/* Structure which holds the callbacks registered for CLB events. */
+typedef struct
+{
+   tBTM_CMPL_CB            *p_cmd_cmpl_cb;
+   tBTM_TRG_CLK_CAP_CB     *p_trg_clk_cap_cb;
+   tBTM_SYNC_TRAIN_CMPL_CB *p_sync_train_cmpl_cb;
+   tBTM_SLV_PAGE_RSP_TO_CB *p_slv_page_rsp_to_cb;
+   tBTM_CLB_CHANNEL_CHANGE_CB *p_clb_channel_change_cb;
+} tBTM_CLB_CB_INFO;
+
 /*****************************************************************************
 **  DEVICE DISCOVERY - Inquiry, Remote Name, Discovery, Class of Device
 *****************************************************************************/
@@ -524,6 +634,8 @@
 #define BTM_EIR_SHORTENED_LOCAL_NAME_TYPE   HCI_EIR_SHORTENED_LOCAL_NAME_TYPE   /* 0x08 */
 #define BTM_EIR_COMPLETE_LOCAL_NAME_TYPE    HCI_EIR_COMPLETE_LOCAL_NAME_TYPE    /* 0x09 */
 #define BTM_EIR_TX_POWER_LEVEL_TYPE         HCI_EIR_TX_POWER_LEVEL_TYPE         /* 0x0A */
+#define BTM_EIR_DID_INFO_TYPE               HCI_EIR_DID_INFO_TYPE               /* 0x10  */
+#define BTM_EIR_3D_INFO_TYPE                HCI_EIR_3D_INFO_TYPE                /* 0x3D */
 #define BTM_EIR_MANUFACTURER_SPECIFIC_TYPE  HCI_EIR_MANUFACTURER_SPECIFIC_TYPE  /* 0xFF */
 
 /* the following EIR tags are defined to OOB, not regular EIR data */
@@ -1267,9 +1379,10 @@
 #define BTM_SEC_SERVICE_HIDD_SEC_CTRL   51
 #define BTM_SEC_SERVICE_HIDD_NOSEC_CTRL 52
 #define BTM_SEC_SERVICE_HIDD_INTR       53
+#define BTM_SEC_SERVICE_3D_SYNC         54
 
 /* Update these as services are added */
-#define BTM_SEC_SERVICE_FIRST_EMPTY     54
+#define BTM_SEC_SERVICE_FIRST_EMPTY     55
 
 #ifndef BTM_SEC_MAX_SERVICES
 /* accomadate client profiles also */
@@ -2447,6 +2560,123 @@
     BTM_API extern tBTM_STATUS BTM_EnableTestMode(void);
 
 
+/*******************************************************************************
+**
+** Function         BTM_RegisterCLB
+**
+** Description      Register CLB callbacks.
+**
+** Returns          BTM_SUCCESS if successful, otherwise an error
+**
+**
+*******************************************************************************/
+    BTM_API extern tBTM_STATUS BTM_RegisterCLB(tBTM_CLB_CB_INFO *p_clb_cb_info);
+
+/*******************************************************************************
+**
+** Function         BTM_DeregisterCLB
+**
+** Description      De-Register CLB callbacks.
+**
+** Returns          BTM_SUCCESS if successful, otherwise an error
+**
+**
+*******************************************************************************/
+    BTM_API extern tBTM_STATUS BTM_DeregisterCLB(void);
+
+/*******************************************************************************
+**
+** Function         BTM_SetCLB
+**
+** Description      Enable/Disable Connectionless Slave Broadcasts
+**
+** Returns          BTM_SUCCESS if successful, otherwise an error
+**
+**
+*******************************************************************************/
+    BTM_API extern tBTM_STATUS BTM_SetCLB(UINT8 enable, UINT8 lt_addr, UINT8 lpo_allowed, 
+                                         UINT16 packet_type, UINT16 interval_min, 
+                                         UINT16 interval_max, UINT16 supervision_timeout); 
+
+/*******************************************************************************
+**
+** Function         BTM_StartSyncTrain
+**
+** Description      Start the Synchronization Train
+**
+** Returns          BTM_SUCCESS if successful, otherwise an error
+**
+**
+*******************************************************************************/
+    BTM_API extern tBTM_STATUS BTM_StartSyncTrain(void);
+
+/*******************************************************************************
+**
+** Function         BTM_SetReservedLTADDR
+**
+** Description      Set a reserved LT_ADDR
+**
+** Returns          BTM_SUCCESS if successful, otherwise an error
+**
+**
+*******************************************************************************/
+    BTM_API extern tBTM_STATUS BTM_SetReservedLTADDR(UINT8 lt_addr);
+
+/*******************************************************************************
+**
+** Function         BTM_DeleteReservedLTADDR
+**
+** Description      Delete a reserved LT_ADDR
+**
+** Returns          BTM_SUCCESS if successful, otherwise an error
+**
+**
+*******************************************************************************/
+    BTM_API extern tBTM_STATUS BTM_DeleteReservedLTADDR(UINT8 lt_addr);
+
+/*******************************************************************************
+**
+** Function         BTM_SetCLBData
+**
+** Description      Set the Connectionless Slave Broadcast data
+**
+** Returns          BTM_SUCCESS if successful, otherwise an error
+**
+**
+*******************************************************************************/
+    BTM_API extern tBTM_STATUS BTM_SetCLBData(UINT8 lt_addr, UINT8 fragment, UINT8 data_len, UINT8 *data);
+
+/*******************************************************************************
+**
+** Function         BTM_WriteSyncTrainParams
+**
+** Description      Write the Synchronization Train Parameters
+**
+** Returns          BTM_SUCCESS if successful, otherwise an error
+**
+**
+*******************************************************************************/
+    BTM_API extern tBTM_STATUS BTM_WriteSyncTrainParams(UINT16 interval_min, UINT16 interval_max, 
+                                                       UINT32 timeout, UINT8 service_data);
+
+/*******************************************************************************
+**
+** Function         BTM_SetTrigClkCapture
+**
+** Description      Start/Stop Triggered Clock Capture
+**
+** Returns          BTM_SUCCESS if successful, otherwise an error
+**                  If ENABLED, capture events will be sent to the
+**                  p_trg_clk_cap_cb.
+**
+**
+*******************************************************************************/
+    BTM_API extern tBTM_STATUS BTM_SetTrigClkCapture(UINT16 handle, UINT8 enable,
+                                                      UINT8 which_clock, UINT8 lpo_allowed,
+                                                      UINT8 num_clock_cap_to_filter);
+
+
+    BTM_API extern tBTM_STATUS BTM_ReadClock(tBTM_CMPL_CB *p_cb);
 /*****************************************************************************
 **  DEVICE DISCOVERY FUNCTIONS - Inquiry, Remote Name, Discovery, Class of Device
 *****************************************************************************/
@@ -4754,6 +4984,21 @@
 *******************************************************************************/
 BTM_API extern void BTM_PCM2Setup_Write (BOOLEAN clk_master, tBTM_VSC_CMPL_CB *p_arc_cb);
 
+#if (A2DP_KERNEL_DIRECT == TRUE)
+/*******************************************************************************
+**
+** Function         BTM_SendBTLiteReq
+**
+** Description      Send BTLITE command.
+**
+** Returns          void
+**
+*******************************************************************************/
+//BTM_API extern void BTM_SendBTLiteReq(tBTA_AV_DUAL_STACK_EVT cmd,void *p_info, tBTM_VSC_CMPL_CB *cb);
+BTM_API extern void BTM_SendBTLiteReq(UINT16 event,tBTA_AV_DUAL_STACK_EVT cmd,void *p_info, tBTM_BTLITE_CMPL *cb);
+
+#endif
+
 #ifdef __cplusplus
 }
 #endif
diff -Naur '--exclude=.git' bluedroid-orig/stack/include/btm_ble_api.h bluedroid/stack/include/btm_ble_api.h
--- bluedroid-orig/stack/include/btm_ble_api.h	2015-09-24 16:33:43.552227643 +0800
+++ bluedroid/stack/include/btm_ble_api.h	2015-09-24 16:31:37.000000000 +0800
@@ -1021,6 +1021,13 @@
 *******************************************************************************/
 BTM_API extern BOOLEAN BTM_UseLeLink (BD_ADDR bd_addr);
 
+#ifndef PLATFORM_ANDROID
+BTM_API extern void BTM_SetFlag(UINT8 flag);
+BTM_API extern void BTM_SetAppearance(UINT16 appearance);
+BTM_API extern void BTM_SetRange(UINT16 hi, UINT16 low);
+BTM_API extern void BTM_write_adv(tBTM_BLE_AD_MASK data_mask, tBTM_BLE_ADV_DATA *p_data);
+#endif
+
 #ifdef __cplusplus
 }
 #endif
diff -Naur '--exclude=.git' bluedroid-orig/stack/include/bt_types.h bluedroid/stack/include/bt_types.h
--- bluedroid-orig/stack/include/bt_types.h	2015-09-24 16:33:43.552227643 +0800
+++ bluedroid/stack/include/bt_types.h	2015-09-24 16:31:37.000000000 +0800
@@ -192,6 +192,7 @@
 
 #define BT_EVT_TRIGGER_STACK_INIT   EVENT_MASK(APPL_EVT_0)
 #define BT_EVT_HARDWARE_INIT_FAIL   EVENT_MASK(APPL_EVT_1)
+#define BT_EVT_HCI_DISCONNECT       EVENT_MASK(APPL_EVT_2)
 
 #define BT_EVT_PRELOAD_CMPL         EVENT_MASK(APPL_EVT_6)
 
@@ -442,6 +443,8 @@
 #define BT_EIR_OOB_COD_TYPE                 0x0D
 #define BT_EIR_OOB_SSP_HASH_C_TYPE          0x0E
 #define BT_EIR_OOB_SSP_RAND_R_TYPE          0x0F
+#define BT_EIR_DID_INFO_TYPE                0x10
+#define BT_EIR_3D_INFO_TYPE                 0x3D
 #define BT_EIR_MANUFACTURER_SPECIFIC_TYPE   0xFF
 
 #define BT_OOB_COD_SIZE            3
diff -Naur '--exclude=.git' bluedroid-orig/stack/include/btu.h bluedroid/stack/include/btu.h
--- bluedroid-orig/stack/include/btu.h	2015-09-24 16:33:43.552227643 +0800
+++ bluedroid/stack/include/btu.h	2015-09-24 16:31:37.000000000 +0800
@@ -217,6 +217,7 @@
 #if (defined(BTU_CMD_CMPL_TOUT_DOUBLE_CHECK) && BTU_CMD_CMPL_TOUT_DOUBLE_CHECK == TRUE)
     BOOLEAN          checked_hcisu;
 #endif
+    TIMER_LIST_ENT   fw_upgrade_trigger_timer;        /* FW Upgrade trigger timer */
 } tHCI_CMD_CB;
 
 /* Define structure holding BTU variables
@@ -240,7 +241,9 @@
     UINT16    hcit_ble_acl_pkt_size;            /* Max BLE ACL packet size across HCI transport  */
                                             /* (this is data size plus 4 bytes overhead) */
 #endif
-
+#if (A2DP_KERNEL_DIRECT == TRUE)
+    tHCI_CMD_CB btlite_cmd_cb;
+#endif
     BOOLEAN     reset_complete;             /* TRUE after first ack from device received */
     UINT8       trace_level;                /* Trace level for HCI layer */
 
@@ -299,7 +302,9 @@
 BTU_API extern void  btu_hcif_send_cmd (UINT8 controller_id, BT_HDR *p_msg);
 BTU_API extern void  btu_hcif_send_host_rdy_for_data(void);
 BTU_API extern void  btu_hcif_cmd_timeout (UINT8 controller_id);
-
+#if (A2DP_KERNEL_DIRECT == TRUE)
+BTU_API extern void btu_btlite_rsp_event(BT_HDR *p_msg);
+#endif
 /* Functions provided by btu_core.c
 ************************************
 */
diff -Naur '--exclude=.git' bluedroid-orig/stack/include/hcidefs.h bluedroid/stack/include/hcidefs.h
--- bluedroid-orig/stack/include/hcidefs.h	2015-09-24 16:33:43.552227643 +0800
+++ bluedroid/stack/include/hcidefs.h	2015-09-24 16:31:37.000000000 +0800
@@ -231,11 +231,11 @@
 #define HCI_SET_MWS_PATTERN_CONFIGURATION       (0x0073 | HCI_GRP_HOST_CONT_BASEBAND_CMDS)
 
 /* ConnectionLess Broadcast */
-#define HCI_SET_RESERVED_LT_ADDR                (0x0077 | HCI_GRP_HOST_CONT_BASEBAND_CMDS)
-#define HCI_DELETE_RESERVED_LT_ADDR             (0x0078 | HCI_GRP_HOST_CONT_BASEBAND_CMDS)
-#define HCI_WRITE_CLB_DATA                      (0x0079 | HCI_GRP_HOST_CONT_BASEBAND_CMDS)
-#define HCI_WRITE_SYNC_TRAIN_PARAM              (0x007A | HCI_GRP_HOST_CONT_BASEBAND_CMDS)
-#define HCI_READ_SYNC_TRAIN_PARAM               (0x007B | HCI_GRP_HOST_CONT_BASEBAND_CMDS)
+#define HCI_SET_RESERVED_LT_ADDR                (0x0074 | HCI_GRP_HOST_CONT_BASEBAND_CMDS)
+#define HCI_DELETE_RESERVED_LT_ADDR             (0x0075 | HCI_GRP_HOST_CONT_BASEBAND_CMDS)
+#define HCI_WRITE_CLB_DATA                      (0x0076 | HCI_GRP_HOST_CONT_BASEBAND_CMDS)
+#define HCI_READ_SYNC_TRAIN_PARAM               (0x0077 | HCI_GRP_HOST_CONT_BASEBAND_CMDS)
+#define HCI_WRITE_SYNC_TRAIN_PARAM              (0x0078 | HCI_GRP_HOST_CONT_BASEBAND_CMDS)
 
 #define HCI_CONT_BASEBAND_CMDS_FIRST    HCI_SET_EVENT_MASK
 #define HCI_CONT_BASEBAND_CMDS_LAST     HCI_READ_SYNC_TRAIN_PARAM
@@ -269,6 +269,7 @@
 #define HCI_READ_LOCAL_AMP_INFO         (0x0009 | HCI_GRP_STATUS_PARAMS)
 #define HCI_READ_LOCAL_AMP_ASSOC        (0x000A | HCI_GRP_STATUS_PARAMS)
 #define HCI_WRITE_REMOTE_AMP_ASSOC      (0x000B | HCI_GRP_STATUS_PARAMS)
+#define HCI_SET_TRIG_CLK_CAPTURE        (0x000D | HCI_GRP_STATUS_PARAMS)
 
 #define HCI_STATUS_PARAMS_CMDS_FIRST    HCI_READ_FAILED_CONTACT_COUNT
 #define HCI_STATUS_PARAMS_CMDS_LAST     HCI_WRITE_REMOTE_AMP_ASSOC
@@ -344,6 +345,21 @@
 #define HCI_LE_SCAN_SL_STATE      0x00000400
 #define HCI_LE_INIT_MA_STATE      0x00000800
 
+/* Vendor specific commands for Headless Mode */
+#define HCI_VSC_HEADLESS_DEV_ADD_DEL_PARAM_SIZE    6
+
+#define HCI_VSC_HEADLESS_DEV_GET_LIST             (0x0036 | HCI_GRP_VENDOR_SPECIFIC)
+#define HCI_VSC_HEADLESS_DEV_ADD         (0x0037 | HCI_GRP_VENDOR_SPECIFIC)
+#define HCI_VSC_HEADLESS_DEV_DEL      (0x0039 | HCI_GRP_VENDOR_SPECIFIC)
+#define HCI_VSC_HEADLESS_ENABLE           (0x003B | HCI_GRP_VENDOR_SPECIFIC)
+
+#define HCI_VSC_DETACH_PATCH                       (0x0073 | HCI_GRP_VENDOR_SPECIFIC)
+#define HCI_VSC_HEADLESS_SET_SCAN_MODE             (0x0134 | HCI_GRP_VENDOR_SPECIFIC)
+#define HCI_VSC_HEADLESS_SET_LE_ADV_DATA             (0x0172 | HCI_GRP_VENDOR_SPECIFIC)
+#define HCI_VSC_ENABLE_WAKE_UP_TEST             (0x017A | HCI_GRP_VENDOR_SPECIFIC)
+#define HCI_VSC_ADD_AV_DEVICE_TO_HEADLESS             (0x017B | HCI_GRP_VENDOR_SPECIFIC)
+#define HCI_VSC_READ_LAST_MEMORY                       (0x0038 | HCI_GRP_VENDOR_SPECIFIC)
+
 /*
 **  Definitions for HCI Events
 */
@@ -411,6 +427,7 @@
 #define HCI_NUM_COMPL_DATA_BLOCKS_EVT       0x48
 #define HCI_SHORT_RANGE_MODE_COMPLETE_EVT   0x4C
 #define HCI_AMP_STATUS_CHANGE_EVT           0x4D
+#define HCI_TRIG_CLK_CAPTURE_EVT            0x4E
 
 /* ULP HCI Event */
 #define HCI_BLE_EVENT                   0x03E
@@ -813,6 +830,8 @@
 #define HCI_EIR_OOB_COD_TYPE                 BT_EIR_OOB_COD_TYPE
 #define HCI_EIR_OOB_SSP_HASH_C_TYPE          BT_EIR_OOB_SSP_HASH_C_TYPE
 #define HCI_EIR_OOB_SSP_RAND_R_TYPE          BT_EIR_OOB_SSP_RAND_R_TYPE
+#define HCI_EIR_DID_INFO_TYPE                BT_EIR_DID_INFO_TYPE
+#define HCI_EIR_3D_INFO_TYPE                 BT_EIR_3D_INFO_TYPE
 
 /* Definitions for Write Simple Pairing Mode */
 #define HCI_SP_MODE_UNDEFINED           0x00
@@ -1028,12 +1047,19 @@
 #define HCI_CLB_DISABLE                 0x00
 #define HCI_CLB_ENABLE                  0x01
 
+#define HCI_CLB_LPO_DISALLOWED          0x00
+#define HCI_CLB_LPO_ALLOWED             0x01
+
 /* ConnectionLess Broadcast Data fragment */
 #define HCI_CLB_FRAGMENT_CONT           0x00
 #define HCI_CLB_FRAGMENT_START          0x01
 #define HCI_CLB_FRAGMENT_END            0x02
 #define HCI_CLB_FRAGMENT_SINGLE         0x03
 
+/* Triggered Clock Capture */
+#define HCI_WHICH_CLOCK_LOCAL           0x00
+#define HCI_WHICH_CLOCK_PICO            0x01
+
 /* AMP Controller Status codes
 */
 #define HCI_AMP_CTRLR_PHYSICALLY_DOWN   0
diff -Naur '--exclude=.git' bluedroid-orig/stack/include/hcimsgs.h bluedroid/stack/include/hcimsgs.h
--- bluedroid-orig/stack/include/hcimsgs.h	2015-09-24 16:33:43.552227643 +0800
+++ bluedroid/stack/include/hcimsgs.h	2015-09-24 16:31:37.000000000 +0800
@@ -23,6 +23,9 @@
 #include "hcidefs.h"
 #include "bt_types.h"
 
+#if (A2DP_KERNEL_DIRECT == TRUE)
+#include "uipc_msg.h"
+#endif
 
 #ifdef __cplusplus
 extern "C" {
@@ -929,7 +932,73 @@
                                                 void *buffer, UINT16 opcode,
                                                 UINT8 len, UINT8 *p_data,
                                                 void *p_cmd_cplt_cback);
+#if (A2DP_KERNEL_DIRECT == TRUE)
+HCI_API extern void btsnd_btlite_req_cmd (void *p_cmd, UINT8 cmd_type, UINT16 evt,
+                                          void *p_info, void *p_cmd_cplt_cback);
+#endif
+
+/* Set Connectionless Slave Broadcast */
+HCI_API extern BOOLEAN btsnd_hcic_set_clb(UINT8 enable, UINT8 lt_addr, UINT8 lpo_allowed, 
+                                         UINT16 packet_type, UINT16 interval_mim, 
+                                         UINT16 interval_max, UINT16 supervision_timeout); 
+
+#define HCIC_PARAM_SIZE_SET_CLB 11
+
+#define HCI_SET_CLB_DISABLE 0
+#define HCI_SET_CLB_ENABLE  1
+
+#define HCI_SET_CLB_LPO_DISALLOWED 0
+#define HCI_SET_CLB_LPO_ALLOWED    1
+
+/* Start Synchronization Train */
+HCI_API extern BOOLEAN btsnd_hcic_start_sync_train(void);
+
+#define HCIC_PARAM_SIZE_START_SYNC_TRAIN 0
+
+/* Set Reserved LT_ADDR */
+HCI_API extern BOOLEAN btsnd_hcic_set_reserved_lt_addr(UINT8 lt_addr);
+
+#define HCIC_PARAM_SIZE_SET_RESERVED_LT_ADDR 1
+
+/* Delete Reserved LT ADDR */
+HCI_API extern BOOLEAN btsnd_hcic_delete_reserved_lt_addr(UINT8 lt_addr);
+
+#define HCIC_PARAM_SIZE_DELETE_RESERVED_LT_ADDR 1
+
+/* Set Connectionless Slave Broadcast Data */
+HCI_API extern BOOLEAN btsnd_hcic_set_clb_data(UINT8 lt_addr, UINT8 fragment, UINT8 data_len, UINT8 *data);
+
+//No max data length is defined, so in theory we could have up to 256 bytes of data
+#define HCIC_PARAM_SIZE_SET_CLB_DATA 259
+
+#define HCI_SET_CLB_DATA_FRAGMENT_CONTINUE 0
+#define HCI_SET_CLB_DATA_FRAGMENT_STARTING 1
+#define HCI_SET_CLB_DATA_FRAGMENT_ENDING   2
+#define HCI_SET_CLB_DATA_NO_FRAGMENTATION  3
+
+/* Read Synchronization Train Parameters. */
+HCI_API extern BOOLEAN btsnd_hcic_read_sync_train_params(void);
+
+#define HCIC_PARAM_SIZE_READ_SYNC_TRAIN_PARAMS 0
+
+/* Write Synchronization Train Parameters. */
+HCI_API extern BOOLEAN btsnd_hcic_write_sync_train_params(UINT16 interval_mim, UINT16 interval_max, UINT32 timeout, UINT8 service_data);
+
+#define HCIC_PARAM_SIZE_WRITE_SYNC_TRAIN_PARAMS 9
+
+/* Start Triggered Clock Capture */
+HCI_API extern BOOLEAN btsnd_hcic_set_trig_clk_capture(UINT16 handle, UINT8 enable, UINT8 which_clock, UINT8 lpo_allowed, UINT8 num_clock_cap_to_filter);
+
+#define HCIC_PARAM_SIZE_SET_TRIG_CLK_CAPTURE 6
+
+#define HCI_SET_TRG_CLK_CAPTURE_DISABLE 0
+#define HCI_SET_TRG_CLK_CAPTURE_ENABLE  1
+
+#define HCI_SET_TRG_CLK_CAPTURE_CLOCK_LOCAL 0
+#define HCI_SET_TRG_CLK_CAPTURE_CLOCK_PICO  1
 
+#define HCI_SET_TRG_CLK_CAPTURE_LPO_DISALLOWED 0
+#define HCI_SET_TRG_CLK_CAPTURE_LPO_ALLOWED    1
 
 /*********************************************************************************
 **                                                                              **
diff -Naur '--exclude=.git' bluedroid-orig/stack/include/sdpdefs.h bluedroid/stack/include/sdpdefs.h
--- bluedroid-orig/stack/include/sdpdefs.h	2015-09-24 16:33:43.552227643 +0800
+++ bluedroid/stack/include/sdpdefs.h	2015-09-24 16:31:37.000000000 +0800
@@ -253,6 +253,8 @@
 #define UUID_SERVCLASS_MAP_PROFILE              0X1134  /* MAP profile UUID */
 #define UUID_SERVCLASS_MESSAGE_ACCESS           0X1132  /* Message Access Service UUID */
 #define UUID_SERVCLASS_MESSAGE_NOTIFICATION     0X1133  /* Message Notification Service UUID */
+#define UUID_SERVCLASS_3D_DISPLAY               0X1137
+#define UUID_SERVCLASS_3D_SYNC                  0X1139
 
 #define UUID_SERVCLASS_GAP_SERVER               0x1800
 #define UUID_SERVCLASS_GATT_SERVER              0x1801
diff -Naur '--exclude=.git' bluedroid-orig/stack/include/uipc_msg.h bluedroid/stack/include/uipc_msg.h
--- bluedroid-orig/stack/include/uipc_msg.h	2015-09-24 16:33:43.552227643 +0800
+++ bluedroid/stack/include/uipc_msg.h	2015-09-24 16:31:37.000000000 +0800
@@ -231,10 +231,19 @@
 #define AVDT_REMOVE_TO_LITE_RESP     7
 #define AVDT_SYNC_TO_BTC_LITE_REQ    8
 #define AVDT_SYNC_TO_BTC_LITE_RESP   9
+#define AVDT_SYNC_CP_TO_LITE_REQ     0x0C
+#define AVDT_SYNC_CP_TO_LITE_RESP    0x0D
 
 /* status */
 #define AVDT_SYNC_SUCCESS            0
 #define AVDT_SYNC_FAILURE            1
+#define AVDT_SYNC_CP_ID_NONE        0x0000
+
+typedef struct
+{
+    UINT16  id;
+    UINT8   scms_hdr;
+} tAVDT_SYNC_CP;
 
 typedef struct
 {
@@ -263,6 +272,7 @@
     UINT16  peer_mtu;       /* L2CAP mtu of the peer device */
     UINT8   mux_tsid_media; /* TSID for media transport session */
     UINT16  media_seq;      /* media packet sequence number */
+    tAVDT_SYNC_CP cp;       /* Content Protection Info */
 } tAVDT_SCB_SYNC_INFO;
 
 typedef struct t_avdt_sync_info
@@ -282,6 +292,8 @@
     tAVDT_SYNC_TO_BTC_LITE_RESP btc_sync_resp;
 } tAVDT_SYNC_MSG;
 
+#define NUM_STREAM 1
+#define AVDT_CP_REQ_DATA_SIZE (sizeof(UINT8) + sizeof(UINT8)+ sizeof(UINT8)+ sizeof(tAVDT_SYNC_CP))
 /********************************
 
     BTA AV Sync Message
@@ -790,7 +802,7 @@
 } tAUDIO_SCALE_CONFIG_REQ;
 
 typedef UINT8 tBTA_AV_DUAL_STACK_EVT;
-
+#define BTUSB_LITE_IPC_HDR_EVT_SIZE (sizeof(UINT16))
 typedef struct
 {
     UINT8               avdt_handle;    /* AVDTP handle */
@@ -808,8 +820,8 @@
 {
     tBTA_AV_DUAL_STACK_EVT  event;
     tBTA_AV_SYNC_INFO       sync_info;
-    UINT16                  curr_mtu;                 /* common mtu shared by all active streams */
     UINT8                   multi_av_supported;       /* Whether multi-av is supported */
+    UINT16                  curr_mtu;                 /* common mtu shared by all active streams */
 }tBTA_AV_SYNC_INFO_REQ; /* SYNC_TO_LITE_REQ */
 
 /* Dual stack stream events */
@@ -838,6 +850,7 @@
     UINT8                           audio_open_cnt;
     tBTA_AV_AUDIO_CODEC_SYNC_INFO   p_codec_cfg;
     UINT8                           start_stop_flag;
+    UINT8                           streaming_type;  /* 0 for SBC; 1 for CLB */
 }tBTA_AV_SCB_REQ;
 
 typedef struct
@@ -848,6 +861,13 @@
     UINT16                          curr_mtu;           /* common mtu shared by all active streams */
 }tBTA_AV_SCB_CLEANUP_REQ;
 
+typedef struct
+{
+    tBTA_AV_DUAL_STACK_EVT          event;
+    UINT8                           scb_idx;
+    UINT8                           audio_open_cnt;
+}tBTA_AV_SCB_STOP_REQ;
+
 /* Add request/response structures if needed ...
 typedef struct
 {
diff -Naur '--exclude=.git' bluedroid-orig/stack/l2cap/l2c_api.c bluedroid/stack/l2cap/l2c_api.c
--- bluedroid-orig/stack/l2cap/l2c_api.c	2015-09-24 16:33:43.552227643 +0800
+++ bluedroid/stack/l2cap/l2c_api.c	2015-09-24 16:31:37.000000000 +0800
@@ -35,6 +35,10 @@
 #include "btu.h"
 #include "btm_api.h"
 
+
+#if (A2DP_KERNEL_DIRECT == TRUE)
+static tL2C_SYNC_TO_LITE_REQ L2C_sync;
+#endif
 /*******************************************************************************
 **
 ** Function         L2CA_Register
@@ -1815,4 +1819,55 @@
 
     return (num_left);
 }
+#if (A2DP_KERNEL_DIRECT == TRUE)
+void btlite_send_l2c_remove_req(tBTM_BTLITE_CMPL *p_cb)
+{
+    APPL_TRACE_DEBUG0("btlite_send_l2c_remove_req");
+    BTM_SendBTLiteReq(BT_EVT_BTU_IPC_L2C_EVT,L2C_REMOVE_TO_LITE_REQ,(void *)&L2C_sync,p_cb);
+}
+void btlite_send_l2c_sync_req(tBTM_BTLITE_CMPL *p_cb)
+{
+    APPL_TRACE_DEBUG0("btlite_send_l2c_sync_req");
+    BTM_SendBTLiteReq(BT_EVT_BTU_IPC_L2C_EVT,L2C_SYNC_TO_LITE_REQ,(void *)&L2C_sync,p_cb);
+}
+void fill_l2c_sync_req(UINT16 cid,BD_ADDR bd_add,UINT16 peer_mtu)
+{
+    tL2C_LCB *p_lcb = l2cu_find_lcb_by_bd_addr(bd_add);
+    tL2C_CCB *p_ccb;
+    UINT8 xx;
+    if (p_lcb == NULL)
+    {
+        APPL_TRACE_ERROR0("Cannot find LCB for BD ADDR");
+        return 0;
+    }
+    p_ccb = l2cu_find_ccb_by_cid(p_lcb,cid);
+    L2C_sync.light_xmit_quota = p_lcb->link_xmit_quota;
+    L2C_sync.acl_data_size    = btu_cb.hcit_acl_data_size;
+#if L2CAP_NON_FLUSHABLE_PB_INCLUDED == TRUE
+    L2C_sync.non_flushable_pbf = l2cb.non_flushable_pbf;
+#endif
+#if (MULTI_AV_SUPPORT == TRUE)
+    L2C_sync.multi_av_data_cong_start = 0;
+    L2C_sync.multi_av_data_cong_end   = 1;
+    L2C_sync.multi_av_data_cong_discard = 0;
+#endif
+    L2C_sync.num_stream = 1;
+    if (p_ccb == NULL)
+    {
+        APPL_TRACE_ERROR0("Cannot find CCB for cid");
+		return 0;
+    }
+    for (xx = 0; xx < L2C_sync.num_stream;xx++)
+    {
+         L2C_sync.stream[xx].local_cid = p_ccb->local_cid;
+         L2C_sync.stream[xx].is_flushable = p_ccb->is_flushable;
+         L2C_sync.stream[xx].remote_cid = p_ccb->remote_cid;
+         //L2C_sync.stream[xx].link_xmit_quota = p_lcb->link_xmit_quota;
+         L2C_sync.stream[xx].link_xmit_quota = L2CAP_HIGH_PRI_MIN_XMIT_QUOTA_A;
+         //L2C_sync.stream[xx].out_mtu = p_ccb->peer_cfg.mtu;
+         L2C_sync.stream[xx].out_mtu = peer_mtu;
+         L2C_sync.stream[xx].handle = p_lcb->handle;
+    }
+}
+#endif
 
diff -Naur '--exclude=.git' bluedroid-orig/stack/qcom/qcom_etc.c bluedroid/stack/qcom/qcom_etc.c
--- bluedroid-orig/stack/qcom/qcom_etc.c	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/stack/qcom/qcom_etc.c	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,31 @@
+#include <stdio.h>
+#include <cutils/properties.h>
+#include <cutils/sched_policy.h>
+
+void strlcpy(char *a,char *b,size_t n){
+    strncpy(a,b,n);
+}
+
+int property_set(const char *key, const char *value){
+    return 0;
+}
+
+int property_get(const char *key, char *value, const char *default_value){
+    int len;
+    if(default_value)
+    {
+       len = strlen(default_value);
+	if(len >= PROPERTY_VALUE_MAX)
+	{
+		len = PROPERTY_VALUE_MAX -1 ;
+	}
+    	memcpy(value, default_value, len);
+	value[len]='\0';
+    }
+	
+    return 0;
+}
+
+extern int set_sched_policy(int tid, SchedPolicy policy){
+    return 0;
+}
diff -Naur '--exclude=.git' bluedroid-orig/test/bluedroidtest/bdt.pc.in bluedroid/test/bluedroidtest/bdt.pc.in
--- bluedroid-orig/test/bluedroidtest/bdt.pc.in	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/test/bluedroidtest/bdt.pc.in	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,11 @@
+prefix=@PREFIX@
+exec_prefix=@EXEC_PREFIX@
+libdir=@LIB_INSTALL_DIR@
+includedir=@INCLUDEDIR@
+
+Name: bdt
+Description: Bluetooth test application
+Version: @VERSION@
+Requires: dlog
+Libs: -L${libdir} 
+Cflags: -I${includedir}
diff -Naur '--exclude=.git' bluedroid-orig/test/bluedroidtest/bluedroidtest.c bluedroid/test/bluedroidtest/bluedroidtest.c
--- bluedroid-orig/test/bluedroidtest/bluedroidtest.c	2015-09-24 16:33:43.552227643 +0800
+++ bluedroid/test/bluedroidtest/bluedroidtest.c	2015-09-24 16:31:37.000000000 +0800
@@ -33,6 +33,7 @@
 #include <unistd.h>
 #include <ctype.h>
 #include <fcntl.h>
+#include <signal.h>
 #include <sys/prctl.h>
 #include <sys/capability.h>
 
@@ -93,6 +94,7 @@
 /************************************************************************************
 **  Externs
 ************************************************************************************/
+int hw_reset = 0;
 
 /************************************************************************************
 **  Functions
@@ -347,6 +349,55 @@
     }
 }
 
+int GetBdAddr(char *p, bt_bdaddr_t *pbd_addr)
+{
+    char Arr[13] = {0};
+    char *pszAddr = NULL;
+    uint8_t k1 = 0;
+    uint8_t k2 = 0;
+    char i;
+    char *t = NULL;
+
+    skip_blanks(&p);
+
+    printf("Input=%s\n", p);
+
+    if(12 > strlen(p))
+    {
+        printf("\nInvalid Bd Address. Format[112233445566]\n");
+        return 0;
+    }
+    memcpy(Arr, p, 12);
+
+    for(i=0; i<12; i++)
+    {
+        Arr[i] = tolower(Arr[i]);
+    }
+    pszAddr = Arr;
+
+    for(i=0; i<6; i++)
+    {
+        k1 = (uint8_t) ( (*pszAddr >= 'a') ? ( 10 + (uint8_t)( *pszAddr - 'a' )) : (*pszAddr - '0') );
+        pszAddr++;
+        k2 = (uint8_t) ( (*pszAddr >= 'a') ? ( 10 + (uint8_t)( *pszAddr - 'a' )) : (*pszAddr - '0') );
+        pszAddr++;
+
+        if ( (k1>15)||(k2>15) )
+        {
+            return 0;
+        }
+        pbd_addr->address[i] = (k1<<4 | k2);
+    }
+    return 1;
+}
+
+void do_pairing(char *p)
+{
+    bt_bdaddr_t bd_addr = {{0}};
+    if(GetBdAddr(p, &bd_addr) == 0) return;
+}
+
+	
 #define is_cmd(str) ((strlen(str) == strlen(cmd)) && strncmp((const char *)&cmd, str, strlen(str)) == 0)
 #define if_cmd(str)  if (is_cmd(str))
 
@@ -474,6 +525,11 @@
     bdt_log("DUT MODE RECV : NOT IMPLEMENTED");
 }
 
+static void hci_event_recv(uint8_t opcode, uint8_t *buf, uint8_t len)
+{
+    bdt_log("%s: RECVD. EVENT MODE : 0x%x", __func__, opcode);
+}
+
 static void le_test_mode(bt_status_t status, uint16_t packet_count)
 {
     bdt_log("LE TEST MODE END status:%s number_of_packets:%d", dump_bt_status(status), packet_count);
@@ -492,6 +548,62 @@
     }
 }
 
+#if 1 //2015.07.13 shyi
+void headless_mode_changed_cb(bt_status_t status)
+{
+    bdt_log("headless_mode_changed_cb, status : %d", status);
+}
+
+void add_av_headless_wakeup_cb(bt_status_t status)
+{
+    bdt_log("add_av_headless_wakeup_cb, status : %d", status);
+}
+
+#ifdef X86_TEST_INTERFACE
+void read_firmware_version_cb(uint8_t *p)
+{
+    int i;
+    btif_fw_version_t *version = (btif_fw_version_t *)p;
+    bdt_log("read_firmware_version_cb: 0x%x", version->patch_version);
+
+}
+#endif
+
+void hw_failure_cb(bt_hw_fail_t error)
+{
+    bdt_log("hw_failure_cb: Recvd. HW INIT FAILURE INDICATION : %d!!!", error);
+    bdt_log("hw_failure_cb: Unloading the Bluedroid Lib...");
+    HAL_unload();
+    bdt_log("hw_failure_cb: Loading the Bluedroid Lib...");
+    HAL_load();
+    bt_enabled = 0;
+    hw_reset = 1;
+}
+
+static bt_callbacks_t bt_callbacks = {
+    sizeof(bt_callbacks_t),
+    adapter_state_changed,
+    NULL, /*adapter_properties_cb */
+    NULL, /* remote_device_properties_cb */
+    device_found_cb, /* device_found_cb */
+    NULL , /* discovery_state_changed_cb */
+    NULL, /* pin_request_cb  */
+    NULL, /* ssp_request_cb  */
+    NULL, /*bond_state_changed_cb */
+    NULL, /* acl_state_changed_cb */
+    NULL, /* thread_evt_cb */
+    dut_mode_recv, /*dut_mode_recv_cb */
+    le_test_mode, /* le_test_mode_cb */
+    hci_event_recv, /* hci_event_recv_cb */
+    NULL, /*authorize_request_cb */
+    headless_mode_changed_cb, /* headless_mode_changed_cb */
+    add_av_headless_wakeup_cb, /* add_av_headless_wakeup_cb */
+    hw_failure_cb /* hw_failure_cb */,
+#ifdef X86_TEST_INTERFACE
+    read_firmware_version_cb /* read_firmware_version_cb */
+#endif
+};
+#else
 static bt_callbacks_t bt_callbacks = {
     sizeof(bt_callbacks_t),
     adapter_state_changed,
@@ -512,6 +624,7 @@
     NULL
 #endif
 };
+#endif
 
 void bdt_init(void)
 {
@@ -520,6 +633,77 @@
     check_return_status(status);
 }
 
+#define MAX_PARAM_LEN 6
+
+
+#ifdef X86_TEST_INTERFACE
+
+void bdt_hw_chip_firmware_update(char *p)
+{
+    bdt_log(" UPDATING BT FIRMWARE...");
+
+    status = sBtInterface->hw_chip_firmware_update();
+    check_return_status(status);
+}
+#endif
+
+void bdt_read_version(char *p)
+{
+    btif_fw_version_t version;
+    status = sBtInterface->read_version(&version);
+
+    check_return_status(status);
+}
+ 
+#ifdef X86_TEST_INTERFACE
+void bdt_hci_send_cmd(char *p)
+{
+    uint16_t opcode;
+    uint8_t param_len = 0;
+
+    bdt_log("SEND BT RAW HCI CMD");
+
+    /* Extract the command opcode */
+    opcode =(uint16_t) get_hex(&p, 0);
+    if (!opcode) {
+        bdt_log("Invalid opcode!!!");
+        return;
+    }
+
+    /* Extract the command params if any */
+    param_len = (uint8_t) get_int(&p, 0);
+    if (param_len)
+        bdt_log("%s: No. of Cmd-params: %d", __func__, param_len);
+    else
+        goto send_cmd;
+
+    /* Extract the command params if any */
+    if (param_len > MAX_PARAM_LEN) {
+        bdt_log("%s: Max. supported parameter length is %d", __func__, MAX_PARAM_LEN);
+        return;
+    }
+
+    /* Allocate memory for the command params */
+    if (param_len)
+    {
+        uint8_t cmd_param[param_len];
+        int i;
+
+        for (i = 0; i < param_len; i++) {
+            cmd_param[i] = (uint8_t) get_hex(&p, 0);
+            bdt_log("%s: cmd_params[%d]: 0x%x", __func__, i, cmd_param[i]);
+       }
+
+        bdt_log("%s: Sending CMD: 0x%x of param_len: %d", __func__, opcode, param_len);
+        status = sBtInterface->hci_cmd_send(opcode, cmd_param, param_len);
+    } else {
+send_cmd:
+        bdt_log("%s: Sending CMD: 0x%x ", __func__, opcode);
+        status = sBtInterface->hci_cmd_send(opcode, NULL, param_len);
+    }
+}
+#endif
+
 void bdt_enable(void)
 {
     bdt_log("ENABLE BT");
@@ -620,6 +804,92 @@
     sBtInterface->cleanup();
 }
 
+void bdt_search(void)
+{
+   if (!bt_enabled) {
+        bdt_log("Bluetooth must be enabled for search to work.");
+        return;
+    }
+    else {
+        printf("Starting discovery\n");
+        sBtInterface->start_discovery();
+        sleep(30);
+        printf("Cancelling discovery\n");
+        sBtInterface->cancel_discovery();
+    }
+    return;
+}
+
+#if 1 //2015.07.13 shyi
+void bdt_add_headless_mode_wakeup_device(char *p)
+{
+    bt_bdaddr_t bd_addr = {{0}};
+    if(GetBdAddr(p, &bd_addr) == 0)
+        return;
+
+   if (!bt_enabled) {
+        bdt_log("Bluetooth must be enabled for add headless mode wakeup device to work.");
+        return;
+    }
+    else {
+        bdt_log("add headless mode wakeup device");
+        status = sBtInterface->add_headless_mode_wakeup_device(&bd_addr);
+    }
+    check_return_status(status);
+    return;
+}
+
+void bdt_add_av_dev_to_headless_mode(char *p)
+{
+    bt_bdaddr_t bd_addr = {{0}};
+    if(GetBdAddr(p, &bd_addr) == 0)
+        return;
+
+   if (!bt_enabled) {
+        bdt_log("Bluetooth must be enabled for add headless mode wakeup device to work.");
+        return;
+    }
+    else {
+        bdt_log("add headless mode wakeup device");
+        status = sBtInterface->add_av_dev_to_headless_mode(&bd_addr);
+    }
+    check_return_status(status);
+    return;
+}
+
+void bdt_delete_headless_mode_wakeup_device(char *p)
+{
+    bt_bdaddr_t bd_addr = {{0}};
+    if(GetBdAddr(p, &bd_addr) == 0)
+        return;
+
+   if (!bt_enabled) {
+        bdt_log("Bluetooth must be enabled for delete headless mode wakeup device to work.");
+        return;
+    }
+    else {
+        bdt_log("delete headless mode wakeup device");
+        status = sBtInterface->delete_headless_mode_wakeup_device(&bd_addr);
+    }
+    check_return_status(status);
+    return;
+}
+
+void bdt_enter_headless_mode(void)
+{
+   if (!bt_enabled) {
+        bdt_log("Bluetooth must be enabled for enter headless mode to work.");
+        return;
+    }
+    else {
+        bdt_log("enter headless mode");
+        status = sBtInterface->enter_headless_mode();
+    }
+    check_return_status(status);
+    return;
+}
+#endif
+	
 /*******************************************************************************
  ** Console commands
  *******************************************************************************/
@@ -662,6 +932,26 @@
     bdt_enable();
 }
 
+void do_read_version(char *p)
+{
+    bdt_read_version(p);
+}
+
+#ifdef X86_TEST_INTERFACE
+void do_hw_chip_firmware_update(char *p)
+{
+    bdt_hw_chip_firmware_update(p);
+}
+#endif
+
+
+#ifdef X86_TEST_INTERFACE
+void do_hci_send_cmd(char *p)
+{
+    bdt_hci_send_cmd(p);
+}
+#endif
+
 void do_disable(char *p)
 {
     bdt_disable();
@@ -681,6 +971,33 @@
     bdt_cleanup();
 }
 
+void do_search(char *p)
+{
+	bdt_search();
+}
+
+#if 1 //2015.07.13 shyi
+void do_add_headless_mode_wakeup_device(char *p)
+{
+	bdt_add_headless_mode_wakeup_device(p);
+}
+
+void do_add_av_dev_to_headless_mode(char *p)
+{
+	bdt_add_av_dev_to_headless_mode(p);
+}
+
+void do_delete_headless_mode_wakeup_device(char *p)
+{
+	bdt_delete_headless_mode_wakeup_device(p);
+}
+
+void do_enter_headless_mode(char *p)
+{
+	bdt_enter_headless_mode();
+}
+#endif
+
 /*******************************************************************
  *
  *  CONSOLE COMMAND TABLE
@@ -707,7 +1024,22 @@
     { "le_test_mode", do_le_test_mode, ":: LE Test Mode - RxTest - 1 <rx_freq>, \n\t \
                       TxTest - 2 <tx_freq> <test_data_len> <payload_pattern>, \n\t \
                       End Test - 3 <no_args>", 0 },
+    { "search", do_search, ":: searches for remote bluetooth devices", 0 },
     /* add here */
+#ifdef X86_TEST_INTERFACE
+    { "hci_send_cmd", do_hci_send_cmd, "::Sends HCI RAW CMD", 0 },
+#endif
+#if 1 //2015.07.13 shyi
+    { "add_headless_mode_wakeup_device", do_add_headless_mode_wakeup_device, ":: add headless mode wakeup device, need bd_addr", 0 },
+    { "add_av_dev_to_headless_mode", do_add_av_dev_to_headless_mode, ":: add av dev to headless mode, need bd_addr", 0 },
+    { "delete_headless_mode_wakeup_device", do_delete_headless_mode_wakeup_device, ":: delete headless mode wakeup device, need bd_addr", 0 },
+    { "enter_headless_mode", do_enter_headless_mode, ":: enter headless mode", 0 },
+#endif
+
+    { "read_version", do_read_version, ": : Read the BT Firmware Version", 0 },
+#ifdef X86_TEST_INTERFACE
+    { "update_bt_fw", do_hw_chip_firmware_update, ": : Update new BT Firmware", 0},
+#endif
 
     /* last entry */
     {NULL, NULL, "", 0},
@@ -741,6 +1073,8 @@
         i++;
     }
     bdt_log("%s : unknown command\n", p_saved);
+    if (hw_reset)
+        bdt_init();
     do_help(NULL);
 }
 
diff -Naur '--exclude=.git' bluedroid-orig/test/bluedroidtest/CMakeLists.txt bluedroid/test/bluedroidtest/CMakeLists.txt
--- bluedroid-orig/test/bluedroidtest/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/test/bluedroidtest/CMakeLists.txt	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,55 @@
+CMAKE_MINIMUM_REQUIRED(VERSION 2.6)
+PROJECT(bdt C)
+
+SET(SRCS
+./bluedroidtest.c
+)
+
+SET(PREFIX ${CMAKE_INSTALL_PREFIX})
+SET(EXEC_PREFIX "\${prefix}")
+SET(LIBDIR "\${prefix}/bin")
+SET(INCLUDEDIR "\${prefix}/include")
+SET(VERSION_MAJOR 1)
+SET(VERSION ${VERSION_MAJOR}.0.0)
+
+
+set(LOCAL_C_INCLUDES
+	. 
+	..
+	../..
+	../../../../../hardware/libhardware/include
+	../../../../../system/core/include)
+include_directories(${LOCAL_C_INCLUDES})
+
+LINK_DIRECTORIES(../../../../../hardware/libhardware)
+
+FOREACH(flag ${packages_CFLAGS})
+	SET(EXTRA_CFLAGS "${EXTRA_CFLAGS} ${flag}")
+ENDFOREACH(flag)
+
+#SET(EXTRA_CFLAGS "${EXTRA_CFLAGS} -fvisibility=hidden -Wall")
+SET(EXTRA_CFLAGS "${EXTRA_CFLAGS} -g ")
+
+SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${EXTRA_CFLAGS}")
+
+FIND_PROGRAM(UNAME NAMES uname)
+EXEC_PROGRAM("${UNAME}" ARGS "-m" OUTPUT_VARIABLE "ARCH")
+IF("${ARCH}" STREQUAL "arm")
+	ADD_DEFINITIONS("-DTARGET")
+	MESSAGE("add -DTARGET")
+ENDIF("${ARCH}" STREQUAL "arm")
+
+ADD_EXECUTABLE(${PROJECT_NAME} ${SRCS})
+SET_TARGET_PROPERTIES(${PROJECT_NAME} PROPERTIES SOVERSION ${VERSION_MAJOR})
+SET_TARGET_PROPERTIES(${PROJECT_NAME} PROPERTIES VERSION ${VERSION})
+#TARGET_LINK_LIBRARIES(${PROJECT_NAME} ${service_pkgs_LDFLAGS} ${packages_LDFLAGS} ${CMAKE_DL_LIBS})
+#TARGET_LINK_LIBRARIES(${PROJECT_NAME} -ldlog)
+#TARGET_LINK_LIBRARIES(${PROJECT_NAME} -lpthread)
+#TARGET_LINK_LIBRARIES(${PROJECT_NAME} -ldl)
+TARGET_LINK_LIBRARIES(${PROJECT_NAME} -lhardware)
+
+
+CONFIGURE_FILE(${CMAKE_CURRENT_SOURCE_DIR}/${PROJECT_NAME}.pc.in ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}.pc @ONLY)
+INSTALL(FILES ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}.pc DESTINATION bin/pkgconfig)
+INSTALL(TARGETS ${PROJECT_NAME} DESTINATION bin)
+
diff -Naur '--exclude=.git' bluedroid-orig/test/l2test_ertm/l2test_ertm.c bluedroid/test/l2test_ertm/l2test_ertm.c
--- bluedroid-orig/test/l2test_ertm/l2test_ertm.c	2015-09-24 16:33:43.556227643 +0800
+++ bluedroid/test/l2test_ertm/l2test_ertm.c	2015-09-24 16:31:37.000000000 +0800
@@ -610,9 +610,11 @@
 
 btl2cap_interface_t* get_l2cap_interface(void)
 {
+#ifdef PLATFORM_ANDROID
     if ((sBtInterface)&&(sBtInterface->get_testapp_interface)) {
         return sBtInterface->get_testapp_interface(TEST_APP_L2CAP);
     }
+#endif
     return NULL;
 }
 
diff -Naur '--exclude=.git' bluedroid-orig/test/sdptest/sdptool.c bluedroid/test/sdptest/sdptool.c
--- bluedroid-orig/test/sdptest/sdptool.c	2015-09-24 16:33:43.556227643 +0800
+++ bluedroid/test/sdptest/sdptool.c	2015-09-24 16:31:37.000000000 +0800
@@ -488,11 +488,13 @@
 
 btsdp_interface_t* get_sdp_interface(void)
 {
+#if PLATFORM_ANDROID
     printf("Get SDP interface");
     if (sBtInterface) {
         printf("\nGet SDP interface\n");
         return sBtInterface->get_testapp_interface(TEST_APP_SDP);
     }
+#endif
     return NULL;
 }
 
diff -Naur '--exclude=.git' bluedroid-orig/udrv/ulinux/uipc.c bluedroid/udrv/ulinux/uipc.c
--- bluedroid-orig/udrv/ulinux/uipc.c	2015-09-24 16:33:43.556227643 +0800
+++ bluedroid/udrv/ulinux/uipc.c	2015-09-24 16:31:37.000000000 +0800
@@ -247,7 +247,13 @@
 static int uipc_main_init(void)
 {
     int i;
+#ifndef X86_BUILD	
     const pthread_mutexattr_t attr = PTHREAD_MUTEX_RECURSIVE;
+#else
+    pthread_mutexattr_t attr;
+    pthread_mutexattr_init(&attr);
+    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
+#endif
     pthread_mutex_init(&uipc_main.mutex, &attr);
 
     BTIF_TRACE_EVENT0("### uipc_main_init ###");
diff -Naur '--exclude=.git' bluedroid-orig/utils/CMakeLists.txt bluedroid/utils/CMakeLists.txt
--- bluedroid-orig/utils/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
+++ bluedroid/utils/CMakeLists.txt	2015-09-24 16:31:37.000000000 +0800
@@ -0,0 +1,44 @@
+CMAKE_MINIMUM_REQUIRED(VERSION 2.6)
+PROJECT(bt-utils C)
+
+SET(SRCS
+./src/bt_utils.c
+)
+
+SET(PREFIX ${CMAKE_INSTALL_PREFIX})
+SET(EXEC_PREFIX "\${prefix}")
+SET(LIBDIR "\${prefix}/lib")
+SET(INCLUDEDIR "\${prefix}/include")
+SET(VERSION_MAJOR 1)
+SET(VERSION ${VERSION_MAJOR}.0.0)
+
+
+set(LOCAL_C_INCLUDES
+	./include 
+	../gki/ulinux 
+	../ulinux/
+	../../../../system/core/include
+	${bdroid_C_INCLUDES})
+include_directories(${LOCAL_C_INCLUDES})
+
+FOREACH(flag ${packages_CFLAGS})
+	SET(EXTRA_CFLAGS "${EXTRA_CFLAGS} ${flag}")
+ENDFOREACH(flag)
+
+#SET(EXTRA_CFLAGS "${EXTRA_CFLAGS} -fvisibility=hidden -Wall")
+SET(EXTRA_CFLAGS "${EXTRA_CFLAGS} -g ")
+
+SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${EXTRA_CFLAGS} -fPIC")
+
+FIND_PROGRAM(UNAME NAMES uname)
+EXEC_PROGRAM("${UNAME}" ARGS "-m" OUTPUT_VARIABLE "ARCH")
+IF("${ARCH}" STREQUAL "arm")
+	ADD_DEFINITIONS("-DTARGET")
+	MESSAGE("add -DTARGET")
+ENDIF("${ARCH}" STREQUAL "arm")
+
+ADD_LIBRARY(${PROJECT_NAME} STATIC ${SRCS})
+SET_TARGET_PROPERTIES(${PROJECT_NAME} PROPERTIES SOVERSION ${VERSION_MAJOR})
+SET_TARGET_PROPERTIES(${PROJECT_NAME} PROPERTIES VERSION ${VERSION})
+TARGET_LINK_LIBRARIES(${PROJECT_NAME} ${packages_LDFLAGS})
+INSTALL(TARGETS ${PROJECT_NAME} DESTINATION lib)
diff -Naur '--exclude=.git' bluedroid-orig/utils/include/bt_utils.h bluedroid/utils/include/bt_utils.h
--- bluedroid-orig/utils/include/bt_utils.h	2015-09-24 16:33:43.556227643 +0800
+++ bluedroid/utils/include/bt_utils.h	2015-09-24 16:31:37.000000000 +0800
@@ -39,5 +39,5 @@
 void bt_utils_init();
 void bt_utils_cleanup();
 void raise_priority_a2dp(tHIGH_PRIORITY_TASK high_task);
-
+#define UNUSED(x) (void)(x)
 #endif /* BT_UTILS_H */
