From abc199cd62c7158fe9526bd35720e5d5b6f26322 Mon Sep 17 00:00:00 2001
From: Bhasker Neti <bneti@codeaurora.org>
Date: Sun, 30 Mar 2014 15:28:58 +0530
Subject: [PATCH 01/25] Bluetooth: x86-Rome driver support

Add USB client driver support for Rome USB chip.

Change-Id: I781dcdc913291ab0695ced1b34fde2710049586e
Signed-off-by: Bhasker Neti <bneti@codeaurora.org>
---
 drivers/bluetooth/ath3k.c         |  154 +++++++++++++++++++++++++++++++++----
 drivers/bluetooth/btusb.c         |   12 ++-
 include/net/bluetooth/bluetooth.h |    5 ++
 3 files changed, 154 insertions(+), 17 deletions(-)

diff --git a/drivers/bluetooth/ath3k.c b/drivers/bluetooth/ath3k.c
index 11f467c..3524824 100644
--- a/drivers/bluetooth/ath3k.c
+++ b/drivers/bluetooth/ath3k.c
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2008-2009 Atheros Communications Inc.
+ * Copyright (c) 2014 The Linux Foundation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -32,6 +33,19 @@
 #define VERSION "1.0"
 #define ATH3K_FIRMWARE	"ath3k-1.fw"
 
+#define ROME2_1_USB_RAMPATCH_FILE	"ar3k/rampatch_2.1.tlv"
+#define ROME2_1_USB_NVM_FILE		"ar3k/nvm_tlv_usb_2.1.bin"
+
+#define ROME1_1_USB_RAMPATCH_FILE	"ar3k/rampatch_1.1.img"
+#define ROME1_1_USB_NVM_FILE		"ar3k/nvm_tlv_usb_1.1.bin"
+
+#define ROME2_1_USB_RAMPATCH_HEADER	sizeof(struct rome2_1_version)
+#define ROME1_1_USB_RAMPATCH_HEADER	sizeof(struct rome1_1_version)
+#define ROME1_1_USB_NVM_HEADER		0x04
+#define ROME2_1_USB_NVM_HEADER		0x04
+#define ROME2_1_USB_CHIP_VERSION		0x200
+#define ROME1_1_USB_CHIP_VERSION		0x101
+
 #define ATH3K_DNLOAD				0x01
 #define ATH3K_GETSTATE				0x05
 #define ATH3K_SET_NORMAL_MODE			0x07
@@ -57,6 +71,34 @@ struct ath3k_version {
 	unsigned char	reserved[0x07];
 };
 
+struct __packed rome1_1_version {
+	u8	type;
+	u8	length[3];
+	u8	sign_ver;
+	u8	sign_algo;
+	u8	resv1[2];
+	u16	product_id;
+	u16	build_ver;
+	u16	patch_ver;
+	u8	resv2[2];
+	u32	entry_addr;
+};
+struct __packed rome2_1_version {
+	u8	type;
+	u8	length[3];
+	u32	total_len;
+	u32	patch_len;
+	u8	sign_ver;
+	u8	sign_algo;
+	u8	resv1[2];
+	u16	product_id;
+	u16	build_ver;
+	u16	patch_ver;
+	u8	resv2[2];
+	u32	entry_addr;
+};
+
+
 static struct usb_device_id ath3k_table[] = {
 	/* Atheros AR3011 */
 	{ USB_DEVICE(0x0CF3, 0x3000) },
@@ -213,8 +255,27 @@ static int ath3k_get_version(struct usb_device *udev,
 			USB_CTRL_SET_TIMEOUT);
 }
 
+int get_rome_version(struct usb_device *udev)
+{
+	struct ath3k_version fw_version;
+	int ret = 0;
+
+	ret = ath3k_get_version(udev, &fw_version);
+	if (ret < 0) {
+		BT_ERR("Failed to get Rome Firmware version");
+		return ret;
+	}
+	if ((fw_version.rom_version == ROME2_1_USB_CHIP_VERSION) ||
+		(fw_version.rom_version == ROME1_1_USB_CHIP_VERSION))
+		ret = fw_version.rom_version;
+	else
+		ret = 0;
+	return ret;
+}
+EXPORT_SYMBOL(get_rome_version);
+
 static int ath3k_load_fwfile(struct usb_device *udev,
-		const struct firmware *firmware)
+		const struct firmware *firmware, int header_h)
 {
 	u8 *send_buf;
 	int err, pipe, len, size, count, sent = 0;
@@ -228,7 +289,7 @@ static int ath3k_load_fwfile(struct usb_device *udev,
 		return -ENOMEM;
 	}
 
-	size = min_t(uint, count, FW_HDR_SIZE);
+	size = min_t(uint, count, header_h);
 	memcpy(send_buf, firmware->data, size);
 
 	pipe = usb_sndctrlpipe(udev, 0);
@@ -304,6 +365,8 @@ static int ath3k_load_patch(struct usb_device *udev)
 	char filename[ATH3K_NAME_LEN] = {0};
 	const struct firmware *firmware;
 	struct ath3k_version fw_version, pt_version;
+	struct rome2_1_version *rome2_1_version;
+	struct rome1_1_version *rome1_1_version;
 	int ret;
 
 	ret = ath3k_get_state(udev, &fw_state);
@@ -322,20 +385,45 @@ static int ath3k_load_patch(struct usb_device *udev)
 		BT_ERR("Can't get version to change to load ram patch err");
 		return ret;
 	}
-
-	snprintf(filename, ATH3K_NAME_LEN, "ar3k/AthrBT_0x%08x.dfu",
+	if (fw_version.rom_version == ROME1_1_USB_CHIP_VERSION) {
+		BT_DBG("Chip Detected as ROME1.1");
+		snprintf(filename, ATH3K_NAME_LEN, ROME1_1_USB_RAMPATCH_FILE);
+	} else if (fw_version.rom_version == ROME2_1_USB_CHIP_VERSION) {
+		BT_DBG("Chip Detected as ROME2.1");
+		snprintf(filename, ATH3K_NAME_LEN, ROME2_1_USB_RAMPATCH_FILE);
+	} else {
+		BT_DBG("Chip Detected as Ath3k");
+		snprintf(filename, ATH3K_NAME_LEN, "ar3k/AthrBT_0x%08x.dfu",
 		fw_version.rom_version);
-
+	}
 	ret = request_firmware(&firmware, filename, &udev->dev);
 	if (ret < 0) {
 		BT_ERR("Patch file not found %s", filename);
 		return ret;
 	}
 
-	pt_version.rom_version = *(int *)(firmware->data + firmware->size - 8);
-	pt_version.build_version = *(int *)
+	if (fw_version.rom_version == ROME2_1_USB_CHIP_VERSION) {
+		rome2_1_version = (struct rome2_1_version *) firmware->data;
+		pt_version.rom_version = rome2_1_version->build_ver;
+		pt_version.build_version = rome2_1_version->patch_ver;
+		BT_DBG("pt_ver.rom2.1_ver : 0x%x", pt_version.rom_version);
+		BT_DBG("pt_ver.build2.1_ver: 0x%x", pt_version.build_version);
+		BT_DBG("fw_ver.rom2.1_ver: 0x%x", fw_version.rom_version);
+		BT_DBG("fw_ver.build2.1_ver: 0x%x", fw_version.build_version);
+	} else if (fw_version.rom_version == ROME1_1_USB_CHIP_VERSION) {
+		rome1_1_version = (struct rome1_1_version *) firmware->data;
+		pt_version.build_version = rome1_1_version->build_ver;
+		pt_version.rom_version = rome1_1_version->patch_ver;
+		BT_DBG("pt_ver.rom1.1_ver : 0x%x", pt_version.rom_version);
+		BT_DBG("pt_ver.build1.1_ver: 0x%x", pt_version.build_version);
+		BT_DBG("fw_ver.rom1.1_ver: 0x%x", fw_version.rom_version);
+		BT_DBG("fw_ver.build1.1_ver: 0x%x", fw_version.build_version);
+	} else {
+		pt_version.rom_version = *(int *)(firmware->data +
+						firmware->size - 8);
+		pt_version.build_version = *(int *)
 		(firmware->data + firmware->size - 4);
-
+	}
 	if ((pt_version.rom_version != fw_version.rom_version) ||
 		(pt_version.build_version <= fw_version.build_version)) {
 		BT_ERR("Patch file version did not match with firmware");
@@ -343,7 +431,15 @@ static int ath3k_load_patch(struct usb_device *udev)
 		return -EINVAL;
 	}
 
-	ret = ath3k_load_fwfile(udev, firmware);
+	if (fw_version.rom_version == ROME2_1_USB_CHIP_VERSION)
+		ret = ath3k_load_fwfile(udev, firmware,
+						ROME2_1_USB_RAMPATCH_HEADER);
+	else if (fw_version.rom_version == ROME1_1_USB_CHIP_VERSION)
+		ret = ath3k_load_fwfile(udev, firmware,
+						 ROME1_1_USB_RAMPATCH_HEADER);
+	else
+		ret = ath3k_load_fwfile(udev, firmware, FW_HDR_SIZE);
+
 	release_firmware(firmware);
 
 	return ret;
@@ -385,8 +481,13 @@ static int ath3k_load_syscfg(struct usb_device *udev)
 		break;
 	}
 
-	snprintf(filename, ATH3K_NAME_LEN, "ar3k/ramps_0x%08x_%d%s",
-		fw_version.rom_version, clk_value, ".dfu");
+	if (fw_version.rom_version == ROME2_1_USB_CHIP_VERSION)
+		snprintf(filename, ATH3K_NAME_LEN, ROME2_1_USB_NVM_FILE);
+	else if (fw_version.rom_version == ROME1_1_USB_CHIP_VERSION)
+		snprintf(filename, ATH3K_NAME_LEN, ROME1_1_USB_NVM_FILE);
+	else
+		snprintf(filename, ATH3K_NAME_LEN, "ar3k/ramps_0x%08x_%d%s",
+			fw_version.rom_version, clk_value, ".dfu");
 
 	ret = request_firmware(&firmware, filename, &udev->dev);
 	if (ret < 0) {
@@ -394,12 +495,36 @@ static int ath3k_load_syscfg(struct usb_device *udev)
 		return ret;
 	}
 
-	ret = ath3k_load_fwfile(udev, firmware);
+	if (fw_version.rom_version == ROME2_1_USB_CHIP_VERSION)
+		ret = ath3k_load_fwfile(udev, firmware, ROME2_1_USB_NVM_HEADER);
+	else if (fw_version.rom_version == ROME1_1_USB_CHIP_VERSION)
+		ret = ath3k_load_fwfile(udev, firmware, ROME1_1_USB_NVM_HEADER);
+	else
+		ret = ath3k_load_fwfile(udev, firmware, FW_HDR_SIZE);
 	release_firmware(firmware);
 
 	return ret;
 }
 
+
+int rome_download(struct usb_device *udev)
+{
+	int ret;
+
+	ret = ath3k_load_patch(udev);
+	if (ret < 0) {
+		BT_ERR("Loading patch file failed");
+		return ret;
+	}
+	ret = ath3k_load_syscfg(udev);
+	if (ret < 0) {
+		BT_ERR("Loading sysconfig file failed");
+		return ret;
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL(rome_download);
 static int ath3k_probe(struct usb_interface *intf,
 			const struct usb_device_id *id)
 {
@@ -411,7 +536,10 @@ static int ath3k_probe(struct usb_interface *intf,
 
 	if (intf->cur_altsetting->desc.bInterfaceNumber != 0)
 		return -ENODEV;
-
+	if (get_rome_version(udev)) {
+		BT_INFO("Rome detected, fw dnld will be triggered from btusb");
+		return -ENODEV;
+	}
 	/* match device ID in ath3k blacklist table */
 	if (!id->driver_info) {
 		const struct usb_device_id *match;
diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c
index 7a7e5f8..610d168 100644
--- a/drivers/bluetooth/btusb.c
+++ b/drivers/bluetooth/btusb.c
@@ -4,7 +4,6 @@
  *
  *  Copyright (C) 2005-2008  Marcel Holtmann <marcel@holtmann.org>
  *
- *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
@@ -1323,7 +1322,7 @@ static int btusb_probe(struct usb_interface *intf,
 	struct usb_endpoint_descriptor *ep_desc;
 	struct btusb_data *data;
 	struct hci_dev *hdev;
-	int i, err;
+	int i, version, err;
 
 	BT_DBG("intf %p id %p", intf, id);
 
@@ -1353,12 +1352,17 @@ static int btusb_probe(struct usb_interface *intf,
 	if (id->driver_info & BTUSB_ATH3012) {
 		struct usb_device *udev = interface_to_usbdev(intf);
 
+		version = get_rome_version(udev);
+		BT_INFO("Rome Version: 0x%x",  version);
 		/* Old firmware would otherwise let ath3k driver load
 		 * patch and sysconfig files */
-		if (le16_to_cpu(udev->descriptor.bcdDevice) <= 0x0001)
+		if (version)
+			rome_download(udev);
+		else if (le16_to_cpu(udev->descriptor.bcdDevice) <= 0x0001) {
+			BT_INFO("FW for ar3k is yet to be downloaded");
 			return -ENODEV;
+		}
 	}
-
 	data = devm_kzalloc(&intf->dev, sizeof(*data), GFP_KERNEL);
 	if (!data)
 		return -ENOMEM;
diff --git a/include/net/bluetooth/bluetooth.h b/include/net/bluetooth/bluetooth.h
index 10eb9b3..5ad8266 100644
--- a/include/net/bluetooth/bluetooth.h
+++ b/include/net/bluetooth/bluetooth.h
@@ -1,6 +1,7 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
    Copyright (C) 2000-2001 Qualcomm Incorporated
+   Copyright (C) 2014 The Linux Foundation. All rights reserved.
 
    Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
 
@@ -28,6 +29,7 @@
 #include <linux/poll.h>
 #include <net/sock.h>
 #include <linux/seq_file.h>
+#include <linux/usb.h>
 
 #ifndef AF_BLUETOOTH
 #define AF_BLUETOOTH	31
@@ -344,4 +346,7 @@ void sco_exit(void);
 
 void bt_sock_reclassify_lock(struct sock *sk, int proto);
 
+int get_rome_version(struct usb_device *udev);
+int rome_download(struct usb_device *udev);
+
 #endif /* __BLUETOOTH_H */
-- 
1.7.9.5


From 4497c029255017497be3666794f6259716b56e8e Mon Sep 17 00:00:00 2001
From: Bhasker Neti <bneti@codeaurora.org>
Date: Tue, 13 May 2014 19:09:41 +0530
Subject: [PATCH 02/25] Bluetooth: Enable auto suspend in bt usb client driver

This allows BT firmware/host to go low power when there
is no tx/rx activity.

Change-Id: I03da27e40f194bfaba5969c859ba447b242a51c2
Signed-off-by: Bhasker Neti <bneti@codeaurora.org>
---
 drivers/bluetooth/btusb.c |    1 +
 1 file changed, 1 insertion(+)

diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c
index 610d168..8024ac9 100644
--- a/drivers/bluetooth/btusb.c
+++ b/drivers/bluetooth/btusb.c
@@ -1482,6 +1482,7 @@ static int btusb_probe(struct usb_interface *intf,
 	}
 
 	usb_set_intfdata(intf, data);
+	usb_enable_autosuspend(data->udev);
 
 	return 0;
 }
-- 
1.7.9.5


From 54f4d13e6ff48a6cbbbe49c27b9af373f658e625 Mon Sep 17 00:00:00 2001
From: Nitin Srivastava <nitinsr@codeaurora.org>
Date: Wed, 25 Jun 2014 10:48:42 +0530
Subject: [PATCH 03/25] bluetooth: Fix SCO connection synchronization.

Configure the alternate setting of interface '1' to
'2' once the BT USB driver gets the SCO connection complete
event from HCI Layer. Similarly, configure the alt. setting
to '0' on SCO disconnection complete event.

Change-Id: Ia1384451bedda52749599516e9ff4ec3b1f409c7
Signed-off-by: Nitin Srivastava <nitinsr@codeaurora.org>
---
 drivers/bluetooth/btusb.c   |   10 ++++++----
 include/net/bluetooth/hci.h |    1 +
 net/bluetooth/hci_event.c   |    3 +++
 3 files changed, 10 insertions(+), 4 deletions(-)

diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c
index 8024ac9..4d31349 100644
--- a/drivers/bluetooth/btusb.c
+++ b/drivers/bluetooth/btusb.c
@@ -35,7 +35,8 @@ static bool ignore_sniffer;
 static bool disable_scofix;
 static bool force_scofix;
 
-static bool reset = 1;
+static int sco_conn;
+static int reset = 1;
 
 static struct usb_driver btusb_driver;
 
@@ -820,8 +821,9 @@ static void btusb_notify(struct hci_dev *hdev, unsigned int evt)
 
 	BT_DBG("%s evt %d", hdev->name, evt);
 
-	if (hdev->conn_hash.sco_num != data->sco_num) {
-		data->sco_num = hdev->conn_hash.sco_num;
+	if ((evt == HCI_NOTIFY_SCO_COMPLETE) || (evt == HCI_NOTIFY_CONN_DEL)) {
+		BT_DBG("SCO conn state changed: evt %d", evt);
+		sco_conn = (evt == HCI_NOTIFY_SCO_COMPLETE) ? 1 : 0;
 		schedule_work(&data->work);
 	}
 }
@@ -876,7 +878,7 @@ static void btusb_work(struct work_struct *work)
 	int new_alts;
 	int err;
 
-	if (hdev->conn_hash.sco_num > 0) {
+	if (sco_conn) {
 		if (!test_bit(BTUSB_DID_ISO_RESUME, &data->flags)) {
 			err = usb_autopm_get_interface(data->isoc ? data->isoc : data->intf);
 			if (err < 0) {
diff --git a/include/net/bluetooth/hci.h b/include/net/bluetooth/hci.h
index e0512aa..fff67ae 100644
--- a/include/net/bluetooth/hci.h
+++ b/include/net/bluetooth/hci.h
@@ -47,6 +47,7 @@
 #define HCI_NOTIFY_CONN_ADD		1
 #define HCI_NOTIFY_CONN_DEL		2
 #define HCI_NOTIFY_VOICE_SETTING	3
+#define HCI_NOTIFY_SCO_COMPLETE		4
 
 /* HCI bus types */
 #define HCI_VIRTUAL	0
diff --git a/net/bluetooth/hci_event.c b/net/bluetooth/hci_event.c
index b93cd2e..f97baf4 100644
--- a/net/bluetooth/hci_event.c
+++ b/net/bluetooth/hci_event.c
@@ -2961,6 +2961,9 @@ static void hci_sync_conn_complete_evt(struct hci_dev *hdev,
 		conn->state  = BT_CONNECTED;
 
 		hci_conn_add_sysfs(conn);
+		BT_DBG("SCO conn complete");
+		if (hdev->notify)
+			hdev->notify(hdev, HCI_NOTIFY_SCO_COMPLETE);
 		break;
 
 	case 0x11:	/* Unsupported Feature or Parameter Value */
-- 
1.7.9.5


From 4db8ee8b6394aa77a50e861b1ebd8d93be6ab931 Mon Sep 17 00:00:00 2001
From: Anantha Krishnan <ananthk@codeaurora.org>
Date: Tue, 1 Jul 2014 18:51:11 +0530
Subject: [PATCH 04/25] bluetooth: Check FW status before downloading the
 firmware

As part of firmware download process, query the firmware for
the RamPatch and NVM download status. Download the firmware
only if the Firmware says they are not done.

CRs-Fixed: 667416
Change-Id: I842b527991c2e973a747c84a87a4e2bdbe7434b2
Signed-off-by: Anantha Krishnan <ananthk@codeaurora.org>
---
 drivers/bluetooth/ath3k.c |   24 +++++++++++++++++++-----
 1 file changed, 19 insertions(+), 5 deletions(-)

diff --git a/drivers/bluetooth/ath3k.c b/drivers/bluetooth/ath3k.c
index 3524824..b870544 100644
--- a/drivers/bluetooth/ath3k.c
+++ b/drivers/bluetooth/ath3k.c
@@ -55,8 +55,10 @@
 #define ATH3K_MODE_MASK				0x3F
 #define ATH3K_NORMAL_MODE			0x0E
 
-#define ATH3K_PATCH_UPDATE			0x80
-#define ATH3K_SYSCFG_UPDATE			0x40
+#define ATH3K_PATCH_UPDATE			0xA0
+#define ATH3K_SYSCFG_UPDATE			0x60
+#define ATH3K_PATCH_SYSCFG_UPDATE		(ATH3K_PATCH_UPDATE | \
+							ATH3K_SYSCFG_UPDATE)
 
 #define ATH3K_XTAL_FREQ_26M			0x00
 #define ATH3K_XTAL_FREQ_40M			0x01
@@ -375,10 +377,14 @@ static int ath3k_load_patch(struct usb_device *udev)
 		return ret;
 	}
 
-	if (fw_state & ATH3K_PATCH_UPDATE) {
-		BT_DBG("Patch was already downloaded");
+	if ((fw_state == ATH3K_PATCH_UPDATE) ||
+		(fw_state == ATH3K_PATCH_SYSCFG_UPDATE)) {
+		BT_INFO("%s: Patch already downloaded(fw_state: %d)", __func__,
+			fw_state);
 		return 0;
-	}
+	} else
+		BT_DBG("%s: Downloading RamPatch(fw_state: %d)", __func__,
+			fw_state);
 
 	ret = ath3k_get_version(udev, &fw_version);
 	if (ret < 0) {
@@ -459,6 +465,14 @@ static int ath3k_load_syscfg(struct usb_device *udev)
 		return -EBUSY;
 	}
 
+	if ((fw_state == ATH3K_SYSCFG_UPDATE) ||
+		(fw_state == ATH3K_PATCH_SYSCFG_UPDATE)) {
+		BT_INFO("%s: NVM already downloaded(fw_state: %d)", __func__,
+			fw_state);
+		return 0;
+	} else
+		BT_DBG("%s: Downloading NVM(fw_state: %d)", __func__, fw_state);
+
 	ret = ath3k_get_version(udev, &fw_version);
 	if (ret < 0) {
 		BT_ERR("Can't get version to change to load ram patch err");
-- 
1.7.9.5


From 5c80ca7de3d3726e1a615bb7e0a2a8d129bfcb1e Mon Sep 17 00:00:00 2001
From: Anantha Krishnan <ananthk@codeaurora.org>
Date: Mon, 7 Jul 2014 16:46:34 +0530
Subject: [PATCH 05/25] bluetooth: Rename BT Firmware files

Rename the bluetooth firmware files to be in sync with the
firmware release.

Change-Id: I5dd0623829e40921fc00d73f69d7cebc0f80ddc4
Signed-off-by: Anantha Krishnan <ananthk@codeaurora.org>
---
 drivers/bluetooth/ath3k.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/drivers/bluetooth/ath3k.c b/drivers/bluetooth/ath3k.c
index b870544..8ea8614 100644
--- a/drivers/bluetooth/ath3k.c
+++ b/drivers/bluetooth/ath3k.c
@@ -33,7 +33,7 @@
 #define VERSION "1.0"
 #define ATH3K_FIRMWARE	"ath3k-1.fw"
 
-#define ROME2_1_USB_RAMPATCH_FILE	"ar3k/rampatch_2.1.tlv"
+#define ROME2_1_USB_RAMPATCH_FILE	"ar3k/rampatch_tlv_usb_2.1.tlv"
 #define ROME2_1_USB_NVM_FILE		"ar3k/nvm_tlv_usb_2.1.bin"
 
 #define ROME1_1_USB_RAMPATCH_FILE	"ar3k/rampatch_1.1.img"
-- 
1.7.9.5


From 224cfe664a4bf72b420da10b7cde4f90875395ae Mon Sep 17 00:00:00 2001
From: Anantha Krishnan <ananthk@codeaurora.org>
Date: Thu, 10 Jul 2014 17:11:50 +0530
Subject: [PATCH 06/25] bluetooth: Send HCI RESET during BT OFF

While turning BT OFF HCI RESET is not being sent and hence
controller is not in proper state when user does BT OFF
from GUI.

Change-Id: I3375215597cb6c6c45d756596c1abdc60ca643d5
CRs-Fixed: 676608
Signed-off-by: Anantha Krishnan <ananthk@codeaurora.org>
---
 net/bluetooth/hci_core.c |    3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/net/bluetooth/hci_core.c b/net/bluetooth/hci_core.c
index ace5e55..5578897 100644
--- a/net/bluetooth/hci_core.c
+++ b/net/bluetooth/hci_core.c
@@ -1242,8 +1242,7 @@ static int hci_dev_do_close(struct hci_dev *hdev)
 	/* Reset device */
 	skb_queue_purge(&hdev->cmd_q);
 	atomic_set(&hdev->cmd_cnt, 1);
-	if (!test_bit(HCI_RAW, &hdev->flags) &&
-	    test_bit(HCI_QUIRK_RESET_ON_CLOSE, &hdev->quirks)) {
+	if (!test_bit(HCI_RAW, &hdev->flags)) {
 		set_bit(HCI_INIT, &hdev->flags);
 		__hci_req_sync(hdev, hci_reset_req, 0, HCI_CMD_TIMEOUT);
 		clear_bit(HCI_INIT, &hdev->flags);
-- 
1.7.9.5


From eb626457f7b3624fcff5ca42e13971ed9432ba3d Mon Sep 17 00:00:00 2001
From: Mike Feldman <mfeldman@quicinc.com>
Date: Wed, 3 Mar 2010 00:41:14 -0600
Subject: [PATCH 07/25] Bluetooth: add Qualcomm In-Band Sleep support to
 hci_uart

Add new HCIUART protocol HCIUART_IBS which enables the Bluetooth
device to enter a low power state when possible.  It also tells
the msm_serial_hs UART driver that it may go to a low-power state
even though the port is open.

CRs-Fixed: 713897

Change-Id: I18207f076c9fb39c04275a8db2625a2d31bb0ae2
Signed-off-by: Mike Feldman <mfeldman@quicinc.com>
Git-commit: 81fda6eb1b506a36bcdbbe77a59b6fe82c997568
[ananthk@codeaurora.org: Resolved merge conflicts]
Signed-off-by: Anantha Krishnan <ananthk@codeaurora.org>
---
 drivers/bluetooth/Kconfig     |   11 +
 drivers/bluetooth/Makefile    |    1 +
 drivers/bluetooth/hci_ibs.c   |  820 +++++++++++++++++++++++++++++++++++++++++
 drivers/bluetooth/hci_ldisc.c |    8 +-
 drivers/bluetooth/hci_uart.h  |    8 +-
 5 files changed, 846 insertions(+), 2 deletions(-)
 create mode 100644 drivers/bluetooth/hci_ibs.c

diff --git a/drivers/bluetooth/Kconfig b/drivers/bluetooth/Kconfig
index 11a6104..011a9e3 100644
--- a/drivers/bluetooth/Kconfig
+++ b/drivers/bluetooth/Kconfig
@@ -94,6 +94,17 @@ config BT_HCIUART_3WIRE
 
 	  Say Y here to compile support for Three-wire UART protocol.
 
+config BT_HCIUART_IBS
+	bool "HCI_IBS protocol support"
+	depends on BT_HCIUART
+	default n
+	help
+	  HCI_IBS (HCI In-Band Sleep) is a serial protocol for communication
+	  between Bluetooth device and host. This protocol is required for
+	  UART clock control for some Qualcomm Bluetooth devices.
+
+	  Say Y here to compile support for HCI_IBS protocol.
+
 config BT_HCIBCM203X
 	tristate "HCI BCM203x USB driver"
 	depends on USB
diff --git a/drivers/bluetooth/Makefile b/drivers/bluetooth/Makefile
index 4afae20..d8fdc3a 100644
--- a/drivers/bluetooth/Makefile
+++ b/drivers/bluetooth/Makefile
@@ -28,4 +28,5 @@ hci_uart-$(CONFIG_BT_HCIUART_BCSP)	+= hci_bcsp.o
 hci_uart-$(CPTCFG_BT_HCIUART_LL)	+= hci_ll.o
 hci_uart-$(CPTCFG_BT_HCIUART_ATH3K)	+= hci_ath.o
 hci_uart-$(CPTCFG_BT_HCIUART_3WIRE)	+= hci_h5.o
+hci_uart-$(CPTCFG_BT_HCIUART_IBS)	+= hci_ibs.o
 hci_uart-objs				:= $(hci_uart-y)
diff --git a/drivers/bluetooth/hci_ibs.c b/drivers/bluetooth/hci_ibs.c
new file mode 100644
index 0000000..1f26cef
--- /dev/null
+++ b/drivers/bluetooth/hci_ibs.c
@@ -0,0 +1,820 @@
+/*
+ *  Qualcomm's Bluetooth Software In-Band Sleep UART protocol
+ *
+ *  HCI_IBS (HCI In-Band Sleep) is Qualcomm's power management
+ *  protocol extension to H4.
+ *
+ *  Copyright (C) 2007 Texas Instruments, Inc.
+ *  Copyright (c) 2010, Code Aurora Forum. All rights reserved.
+ *
+ *  Acknowledgements:
+ *  This file is based on hci_ll.c, which was...
+ *  Written by Ohad Ben-Cohen <ohad@bencohen.org>
+ *  which was in turn based on hci_h4.c, which was written
+ *  by Maxim Krasnyansky and Marcel Holtmann.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2
+ *  as published by the Free Software Foundation
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/interrupt.h>
+#include <linux/ptrace.h>
+#include <linux/poll.h>
+
+#include <linux/slab.h>
+#include <linux/tty.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/signal.h>
+#include <linux/ioctl.h>
+#include <linux/timer.h>
+#include <linux/skbuff.h>
+#include <linux/serial_core.h>
+
+#ifdef CONFIG_SERIAL_MSM_HS
+#include <mach/msm_serial_hs.h>
+#endif
+
+#include <net/bluetooth/bluetooth.h>
+#include <net/bluetooth/hci_core.h>
+
+#include "hci_uart.h"
+
+/* HCI_IBS protocol messages */
+#define HCI_IBS_SLEEP_IND	0xFE
+#define HCI_IBS_WAKE_IND	0xFD
+#define HCI_IBS_WAKE_ACK	0xFC
+
+/* HCI_IBS receiver States */
+#define HCI_IBS_W4_PACKET_TYPE	0
+#define HCI_IBS_W4_EVENT_HDR	1
+#define HCI_IBS_W4_ACL_HDR	2
+#define HCI_IBS_W4_SCO_HDR	3
+#define HCI_IBS_W4_DATA		4
+
+/* HCI_IBS transmit side sleep protocol states */
+enum tx_ibs_states_e {
+	HCI_IBS_TX_ASLEEP,
+	HCI_IBS_TX_WAKING,
+	HCI_IBS_TX_AWAKE,
+};
+
+/* HCI_IBS receive side sleep protocol states */
+enum rx_states_e {
+	HCI_IBS_RX_ASLEEP,
+	HCI_IBS_RX_AWAKE,
+};
+
+/* HCI_IBS transmit and receive side clock state vote */
+enum hci_ibs_clock_state_vote_e {
+	HCI_IBS_VOTE_STATS_UPDATE,
+	HCI_IBS_TX_VOTE_CLOCK_ON,
+	HCI_IBS_TX_VOTE_CLOCK_OFF,
+	HCI_IBS_RX_VOTE_CLOCK_ON,
+	HCI_IBS_RX_VOTE_CLOCK_OFF,
+};
+
+static unsigned long wake_retrans = 1;
+static unsigned long tx_idle_delay = (HZ * 2);
+
+struct hci_ibs_cmd {
+	u8 cmd;
+} __attribute__((packed));
+
+struct ibs_struct {
+	unsigned long rx_state;
+	unsigned long rx_count;
+	struct sk_buff *rx_skb;
+	struct sk_buff_head txq;
+	struct sk_buff_head tx_wait_q;	/* HCI_IBS wait queue	*/
+	spinlock_t hci_ibs_lock;	/* HCI_IBS state lock	*/
+	unsigned long tx_ibs_state;	/* HCI_IBS transmit side power state */
+	unsigned long rx_ibs_state;	/* HCI_IBS receive side power state */
+	unsigned long tx_vote;		/* clock must be on for TX */
+	unsigned long rx_vote;		/* clock must be on for RX */
+	struct	timer_list tx_idle_timer;
+	struct	timer_list wake_retrans_timer;
+	/* debug */
+	unsigned long ibs_sent_wacks;
+	unsigned long ibs_sent_slps;
+	unsigned long ibs_sent_wakes;
+	unsigned long ibs_recv_wacks;
+	unsigned long ibs_recv_slps;
+	unsigned long ibs_recv_wakes;
+	unsigned long vote_last_jif;
+	unsigned long vote_on_ticks;
+	unsigned long vote_off_ticks;
+	unsigned long tx_votes_on;
+	unsigned long rx_votes_on;
+	unsigned long tx_votes_off;
+	unsigned long rx_votes_off;
+	unsigned long votes_on;
+	unsigned long votes_off;
+};
+
+#ifdef CONFIG_SERIAL_MSM_HS
+static void __ibs_msm_serial_clock_on(struct tty_struct *tty)
+{
+	struct uart_state *state = tty->driver_data;
+	struct uart_port *port = state->port;
+
+	msm_hs_request_clock_on(port);
+}
+
+static void __ibs_msm_serial_clock_request_off(struct tty_struct *tty)
+{
+	struct uart_state *state = tty->driver_data;
+	struct uart_port *port = state->port;
+
+	msm_hs_request_clock_off(port);
+}
+#else
+static inline void __ibs_msm_serial_clock_on(struct tty_struct *tty) {}
+static inline void __ibs_msm_serial_clock_request_off(struct tty_struct *tty) {}
+#endif
+
+/* clock_vote needs to be called with the ibs lock held */
+static void ibs_msm_serial_clock_vote(unsigned long vote, struct hci_uart *hu)
+{
+	struct ibs_struct *ibs = hu->priv;
+
+	unsigned long old_vote = (ibs->tx_vote | ibs->rx_vote);
+	unsigned long new_vote;
+
+	switch (vote) {
+	default: /* error */
+		BT_ERR("voting irregularity");
+		return;
+	case HCI_IBS_VOTE_STATS_UPDATE:
+		if (old_vote)
+			ibs->vote_off_ticks += (jiffies - ibs->vote_last_jif);
+		else
+			ibs->vote_on_ticks += (jiffies - ibs->vote_last_jif);
+		return;
+	case HCI_IBS_TX_VOTE_CLOCK_ON:
+		ibs->tx_vote = 1;
+		ibs->tx_votes_on++;
+		new_vote = 1;
+		break;
+	case HCI_IBS_RX_VOTE_CLOCK_ON:
+		ibs->rx_vote = 1;
+		ibs->rx_votes_on++;
+		new_vote = 1;
+		break;
+	case HCI_IBS_TX_VOTE_CLOCK_OFF:
+		ibs->tx_vote = 0;
+		ibs->tx_votes_off++;
+		new_vote = ibs->rx_vote | ibs->tx_vote;
+		break;
+	case HCI_IBS_RX_VOTE_CLOCK_OFF:
+		ibs->rx_vote = 0;
+		ibs->rx_votes_off++;
+		new_vote = ibs->rx_vote | ibs->tx_vote;
+		break;
+	}
+	if (new_vote != old_vote) {
+		if (new_vote)
+			__ibs_msm_serial_clock_on(hu->tty);
+		else
+			__ibs_msm_serial_clock_request_off(hu->tty);
+
+		BT_DBG("HCIUART_IBS: vote msm_serial_hs clock %lu(%lu)",
+			new_vote, vote);
+		/* debug */
+		if (new_vote) {
+			ibs->votes_on++;
+			ibs->vote_off_ticks += (jiffies - ibs->vote_last_jif);
+		} else {
+			ibs->votes_off++;
+			ibs->vote_on_ticks += (jiffies - ibs->vote_last_jif);
+		}
+		ibs->vote_last_jif = jiffies;
+	}
+}
+
+/*
+ * Builds and sends an HCI_IBS command packet.
+ * These are very simple packets with only 1 cmd byte
+ */
+static int send_hci_ibs_cmd(u8 cmd, struct hci_uart *hu)
+{
+	int err = 0;
+	struct sk_buff *skb = NULL;
+	struct ibs_struct *ibs = hu->priv;
+	struct hci_ibs_cmd *hci_ibs_packet;
+
+	BT_DBG("hu %p cmd 0x%x", hu, cmd);
+
+	/* allocate packet */
+	skb = bt_skb_alloc(1, GFP_ATOMIC);
+	if (!skb) {
+		BT_ERR("cannot allocate memory for HCI_IBS packet");
+		err = -ENOMEM;
+		goto out;
+	}
+
+	/* prepare packet */
+	hci_ibs_packet = (struct hci_ibs_cmd *) skb_put(skb, 1);
+	hci_ibs_packet->cmd = cmd;
+	skb->dev = (void *) hu->hdev;
+
+	/* send packet */
+	skb_queue_tail(&ibs->txq, skb);
+out:
+	return err;
+}
+
+static void hci_ibs_tx_idle_timeout(unsigned long arg)
+{
+	struct hci_uart *hu = (struct hci_uart *) arg;
+	struct ibs_struct *ibs = hu->priv;
+	unsigned long flags;
+	unsigned long vote_tx_sleep = 0;
+
+	BT_DBG("hu %p idle timeout in %lu state", hu, ibs->tx_ibs_state);
+
+	spin_lock_irqsave_nested(&ibs->hci_ibs_lock,
+					flags, SINGLE_DEPTH_NESTING);
+
+	switch (ibs->tx_ibs_state) {
+	default:
+	case HCI_IBS_TX_ASLEEP:
+	case HCI_IBS_TX_WAKING:
+		BT_ERR("spurrious timeout in tx state %ld", ibs->tx_ibs_state);
+		goto out;
+	case HCI_IBS_TX_AWAKE: /* TX_IDLE, go to SLEEP */
+		if (send_hci_ibs_cmd(HCI_IBS_SLEEP_IND, hu) < 0) {
+			BT_ERR("cannot send SLEEP to device");
+			goto out;
+		}
+		ibs->tx_ibs_state = HCI_IBS_TX_ASLEEP;
+		ibs->ibs_sent_slps++; /* debug */
+		vote_tx_sleep = 1;
+		break;
+	}
+
+	spin_unlock_irqrestore(&ibs->hci_ibs_lock, flags);
+
+	hci_uart_tx_wakeup(hu);  /* run HCI tx handling unlocked */
+
+	if (!vote_tx_sleep)
+		return;
+	/* now that message queued to tty driver, vote for tty clocks off */
+	/* It is up to the tty driver to pend the clocks off until tx done. */
+
+	spin_lock_irqsave_nested(&ibs->hci_ibs_lock,
+					flags, SINGLE_DEPTH_NESTING);
+	ibs_msm_serial_clock_vote(HCI_IBS_TX_VOTE_CLOCK_OFF, hu);
+out:
+	spin_unlock_irqrestore(&ibs->hci_ibs_lock, flags);
+}
+
+static void hci_ibs_wake_retrans_timeout(unsigned long arg)
+{
+	struct hci_uart *hu = (struct hci_uart *) arg;
+	struct ibs_struct *ibs = hu->priv;
+	unsigned long flags;
+	unsigned long retransmit = 0;
+
+	BT_DBG("hu %p wake retransmit timeout in %lu state",
+		hu, ibs->tx_ibs_state);
+
+	spin_lock_irqsave_nested(&ibs->hci_ibs_lock,
+					flags, SINGLE_DEPTH_NESTING);
+
+	switch (ibs->tx_ibs_state) {
+	default:
+	case HCI_IBS_TX_ASLEEP:
+	case HCI_IBS_TX_AWAKE:
+		BT_ERR("spurrious timeout tx state %ld", ibs->tx_ibs_state);
+		goto out;
+	case HCI_IBS_TX_WAKING: /* No WAKE_ACK, retransmit WAKE */
+		retransmit = 1;
+		if (send_hci_ibs_cmd(HCI_IBS_WAKE_IND, hu) < 0) {
+			BT_ERR("cannot acknowledge device wake up");
+			goto out;
+		}
+		ibs->ibs_sent_wakes++; /* debug */
+		mod_timer(&ibs->wake_retrans_timer, jiffies + wake_retrans);
+		break;
+	}
+out:
+	spin_unlock_irqrestore(&ibs->hci_ibs_lock, flags);
+	if (retransmit)
+		hci_uart_tx_wakeup(hu);
+}
+
+/* Initialize protocol */
+static int ibs_open(struct hci_uart *hu)
+{
+	struct ibs_struct *ibs;
+
+	BT_DBG("hu %p", hu);
+
+	ibs = kzalloc(sizeof(*ibs), GFP_ATOMIC);
+	if (!ibs)
+		return -ENOMEM;
+
+	skb_queue_head_init(&ibs->txq);
+	skb_queue_head_init(&ibs->tx_wait_q);
+	spin_lock_init(&ibs->hci_ibs_lock);
+
+	/* Assume we start with both sides asleep -- extra wakes OK */
+	ibs->tx_ibs_state = HCI_IBS_TX_ASLEEP;
+	ibs->rx_ibs_state = HCI_IBS_RX_ASLEEP;
+	/* clocks actually on, but we start votes off */
+	ibs->tx_vote = 0;
+	ibs->rx_vote = 0;
+
+	/* debug */
+	ibs->ibs_sent_wacks = 0;
+	ibs->ibs_sent_slps = 0;
+	ibs->ibs_sent_wakes = 0;
+	ibs->ibs_recv_wacks = 0;
+	ibs->ibs_recv_slps = 0;
+	ibs->ibs_recv_wakes = 0;
+	ibs->vote_last_jif = jiffies;
+	ibs->vote_on_ticks = 0;
+	ibs->vote_off_ticks = 0;
+	ibs->votes_on = 0;
+	ibs->votes_off = 0;
+	ibs->tx_votes_on = 0;
+	ibs->tx_votes_off = 0;
+	ibs->rx_votes_on = 0;
+	ibs->rx_votes_off = 0;
+
+	hu->priv = ibs;
+
+	init_timer(&ibs->wake_retrans_timer);
+	ibs->wake_retrans_timer.function = hci_ibs_wake_retrans_timeout;
+	ibs->wake_retrans_timer.data     = (u_long) hu;
+
+	init_timer(&ibs->tx_idle_timer);
+	ibs->tx_idle_timer.function = hci_ibs_tx_idle_timeout;
+	ibs->tx_idle_timer.data     = (u_long) hu;
+
+	BT_INFO("HCI_IBS open, tx_idle_delay=%lu, wake_retrans=%lu",
+		tx_idle_delay, wake_retrans);
+
+	return 0;
+}
+
+void ibs_log_local_stats(struct ibs_struct *ibs)
+{
+	BT_INFO("HCI_IBS stats: tx_idle_delay=%lu, wake_retrans=%lu",
+		tx_idle_delay, wake_retrans);
+
+	BT_INFO("HCI_IBS stats: tx_ibs_state=%lu, rx_ibs_state=%lu",
+		ibs->tx_ibs_state, ibs->rx_ibs_state);
+	BT_INFO("HCI_IBS stats: sent: sleep=%lu, wake=%lu, wake_ack=%lu",
+		ibs->ibs_sent_slps, ibs->ibs_sent_wakes, ibs->ibs_sent_wacks);
+	BT_INFO("HCI_IBS stats: recv: sleep=%lu, wake=%lu, wake_ack=%lu",
+		ibs->ibs_recv_slps, ibs->ibs_recv_wakes, ibs->ibs_recv_wacks);
+
+	BT_INFO("HCI_IBS stats: queues: txq=%s, txwaitq=%s",
+		skb_queue_empty(&(ibs->txq)) ? "empty" : "full",
+		skb_queue_empty(&(ibs->tx_wait_q)) ? "empty" : "full");
+
+	BT_INFO("HCI_IBS stats: vote state: tx=%lu, rx=%lu",
+		ibs->tx_vote, ibs->rx_vote);
+	BT_INFO("HCI_IBS stats: tx votes cast: on=%lu, off=%lu",
+		ibs->tx_votes_on, ibs->tx_votes_off);
+	BT_INFO("HCI_IBS stats: rx votes cast: on=%lu, off=%lu",
+		ibs->rx_votes_on, ibs->rx_votes_off);
+	BT_INFO("HCI_IBS stats: msm_clock votes cast: on=%lu, off=%lu",
+		ibs->votes_on, ibs->votes_off);
+	BT_INFO("HCI_IBS stats: vote ticks: on=%lu, off=%lu",
+		ibs->vote_on_ticks, ibs->vote_off_ticks);
+}
+
+/* Flush protocol data */
+static int ibs_flush(struct hci_uart *hu)
+{
+	struct ibs_struct *ibs = hu->priv;
+
+	BT_DBG("hu %p", hu);
+
+	skb_queue_purge(&ibs->tx_wait_q);
+	skb_queue_purge(&ibs->txq);
+
+	return 0;
+}
+
+/* Close protocol */
+static int ibs_close(struct hci_uart *hu)
+{
+	struct ibs_struct *ibs = hu->priv;
+
+	BT_DBG("hu %p", hu);
+
+	ibs_msm_serial_clock_vote(HCI_IBS_VOTE_STATS_UPDATE, hu);
+	ibs_log_local_stats(ibs);
+
+	skb_queue_purge(&ibs->tx_wait_q);
+	skb_queue_purge(&ibs->txq);
+	del_timer(&ibs->tx_idle_timer);
+	del_timer(&ibs->wake_retrans_timer);
+
+	kfree_skb(ibs->rx_skb);
+
+	hu->priv = NULL;
+
+	kfree(ibs);
+
+	return 0;
+}
+
+/*
+ * Called upon a wake-up-indication from the device
+ */
+static void ibs_device_want_to_wakeup(struct hci_uart *hu)
+{
+	unsigned long flags;
+	struct ibs_struct *ibs = hu->priv;
+
+	BT_DBG("hu %p", hu);
+
+	/* lock hci_ibs state */
+	spin_lock_irqsave(&ibs->hci_ibs_lock, flags);
+
+	/* debug */
+	ibs->ibs_recv_wakes++;
+
+	switch (ibs->rx_ibs_state) {
+	case HCI_IBS_RX_ASLEEP:
+		/* Make sure clock is on - we may have turned clock off since
+		 * receiving the wake up indicator
+		 */
+		ibs_msm_serial_clock_vote(HCI_IBS_RX_VOTE_CLOCK_ON, hu);
+		ibs->rx_ibs_state = HCI_IBS_RX_AWAKE;
+		/* deliberate fall-through */
+	case HCI_IBS_RX_AWAKE:
+		/* Always acknowledge device wake up,
+		 * sending IBS message doesn't count as TX ON.
+		 */
+		if (send_hci_ibs_cmd(HCI_IBS_WAKE_ACK, hu) < 0) {
+			BT_ERR("cannot acknowledge device wake up");
+			goto out;
+		}
+		ibs->ibs_sent_wacks++; /* debug */
+		break;
+	default:
+		/* any other state is illegal */
+		BT_ERR("received HCI_IBS_WAKE_IND in rx state %ld",
+			ibs->rx_ibs_state);
+		break;
+	}
+
+out:
+	spin_unlock_irqrestore(&ibs->hci_ibs_lock, flags);
+
+	/* actually send the packets */
+	hci_uart_tx_wakeup(hu);
+}
+
+/*
+ * Called upon a sleep-indication from the device
+ */
+static void ibs_device_want_to_sleep(struct hci_uart *hu)
+{
+	unsigned long flags;
+	struct ibs_struct *ibs = hu->priv;
+
+	BT_DBG("hu %p", hu);
+
+	/* lock hci_ibs state */
+	spin_lock_irqsave(&ibs->hci_ibs_lock, flags);
+
+	/* debug */
+	ibs->ibs_recv_slps++;
+
+	switch (ibs->rx_ibs_state) {
+	case HCI_IBS_RX_AWAKE:
+		/* update state */
+		ibs->rx_ibs_state = HCI_IBS_RX_ASLEEP;
+		ibs_msm_serial_clock_vote(HCI_IBS_RX_VOTE_CLOCK_OFF, hu);
+		break;
+	case HCI_IBS_RX_ASLEEP:
+		/* deliberate fall-through */
+	default:
+		/* any other state is illegal */
+		BT_ERR("received HCI_IBS_SLEEP_IND in rx state %ld",
+			ibs->rx_ibs_state);
+		break;
+	}
+
+	spin_unlock_irqrestore(&ibs->hci_ibs_lock, flags);
+}
+
+/*
+ * Called upon wake-up-acknowledgement from the device
+ */
+static void ibs_device_woke_up(struct hci_uart *hu)
+{
+	unsigned long flags;
+	struct ibs_struct *ibs = hu->priv;
+	struct sk_buff *skb = NULL;
+
+	BT_DBG("hu %p", hu);
+
+	/* lock hci_ibs state */
+	spin_lock_irqsave(&ibs->hci_ibs_lock, flags);
+
+	/* debug */
+	ibs->ibs_recv_wacks++;
+
+	switch (ibs->tx_ibs_state) {
+	case HCI_IBS_TX_ASLEEP:
+		/* This could be spurrious rx wake on the BT chip.
+		 * Send it another SLEEP othwise it will stay awake. */
+	default:
+		BT_ERR("received HCI_IBS_WAKE_ACK in tx state %ld",
+			ibs->tx_ibs_state);
+		break;
+	case HCI_IBS_TX_AWAKE:
+		/* expect one if we send 2 WAKEs */
+		BT_DBG("received HCI_IBS_WAKE_ACK in tx state %ld",
+			ibs->tx_ibs_state);
+		break;
+	case HCI_IBS_TX_WAKING:
+		/* send pending packets */
+		while ((skb = skb_dequeue(&ibs->tx_wait_q)))
+			skb_queue_tail(&ibs->txq, skb);
+		/* switch timers and change state to HCI_IBS_TX_AWAKE */
+		del_timer(&ibs->wake_retrans_timer);
+		mod_timer(&ibs->tx_idle_timer, jiffies + tx_idle_delay);
+		ibs->tx_ibs_state = HCI_IBS_TX_AWAKE;
+	}
+
+	spin_unlock_irqrestore(&ibs->hci_ibs_lock, flags);
+
+	/* actually send the packets */
+	hci_uart_tx_wakeup(hu);
+}
+
+/* Enqueue frame for transmittion (padding, crc, etc) */
+/* may be called from two simultaneous tasklets */
+static int ibs_enqueue(struct hci_uart *hu, struct sk_buff *skb)
+{
+	unsigned long flags = 0;
+	struct ibs_struct *ibs = hu->priv;
+
+	BT_DBG("hu %p skb %p", hu, skb);
+
+	/* Prepend skb with frame type */
+	memcpy(skb_push(skb, 1), &bt_cb(skb)->pkt_type, 1);
+
+	/* lock hci_ibs state */
+	spin_lock_irqsave(&ibs->hci_ibs_lock, flags);
+
+	/* act according to current state */
+	switch (ibs->tx_ibs_state) {
+	case HCI_IBS_TX_AWAKE:
+		BT_DBG("device awake, sending normally");
+		skb_queue_tail(&ibs->txq, skb);
+		mod_timer(&ibs->tx_idle_timer, jiffies + tx_idle_delay);
+		break;
+
+	case HCI_IBS_TX_ASLEEP:
+		BT_DBG("device asleep, waking up and queueing packet");
+		ibs_msm_serial_clock_vote(HCI_IBS_TX_VOTE_CLOCK_ON, hu);
+		/* save packet for later */
+		skb_queue_tail(&ibs->tx_wait_q, skb);
+		/* awake device */
+		if (send_hci_ibs_cmd(HCI_IBS_WAKE_IND, hu) < 0) {
+			BT_ERR("cannot send WAKE to device");
+			break;
+		}
+		ibs->ibs_sent_wakes++; /* debug */
+
+		/* start retransmit timer */
+		mod_timer(&ibs->wake_retrans_timer, jiffies + wake_retrans);
+
+		ibs->tx_ibs_state = HCI_IBS_TX_WAKING;
+		break;
+
+	case HCI_IBS_TX_WAKING:
+		BT_DBG("device waking up, queueing packet");
+		/* transient state; just keep packet for later */
+		skb_queue_tail(&ibs->tx_wait_q, skb);
+		break;
+
+	default:
+		BT_ERR("illegal tx state: %ld (losing packet)",
+			ibs->tx_ibs_state);
+		kfree_skb(skb);
+		break;
+	}
+
+	spin_unlock_irqrestore(&ibs->hci_ibs_lock, flags);
+
+	return 0;
+}
+
+static inline int ibs_check_data_len(struct ibs_struct *ibs, int len)
+{
+	register int room = skb_tailroom(ibs->rx_skb);
+
+	BT_DBG("len %d room %d", len, room);
+
+	if (!len) {
+		hci_recv_frame(ibs->rx_skb);
+	} else if (len > room) {
+		BT_ERR("Data length is too large");
+		kfree_skb(ibs->rx_skb);
+	} else {
+		ibs->rx_state = HCI_IBS_W4_DATA;
+		ibs->rx_count = len;
+		return len;
+	}
+
+	ibs->rx_state = HCI_IBS_W4_PACKET_TYPE;
+	ibs->rx_skb   = NULL;
+	ibs->rx_count = 0;
+
+	return 0;
+}
+
+/* Recv data */
+static int ibs_recv(struct hci_uart *hu, void *data, int count)
+{
+	struct ibs_struct *ibs = hu->priv;
+	register char *ptr;
+	struct hci_event_hdr *eh;
+	struct hci_acl_hdr   *ah;
+	struct hci_sco_hdr   *sh;
+	register int len, type, dlen;
+
+	BT_DBG("hu %p count %d rx_state %ld rx_count %ld",
+			hu, count, ibs->rx_state, ibs->rx_count);
+
+	ptr = data;
+	while (count) {
+		if (ibs->rx_count) {
+			len = min_t(unsigned int, ibs->rx_count, count);
+			memcpy(skb_put(ibs->rx_skb, len), ptr, len);
+			ibs->rx_count -= len; count -= len; ptr += len;
+
+			if (ibs->rx_count)
+				continue;
+
+			switch (ibs->rx_state) {
+			case HCI_IBS_W4_DATA:
+				BT_DBG("Complete data");
+				hci_recv_frame(ibs->rx_skb);
+
+				ibs->rx_state = HCI_IBS_W4_PACKET_TYPE;
+				ibs->rx_skb = NULL;
+				continue;
+
+			case HCI_IBS_W4_EVENT_HDR:
+				eh = (struct hci_event_hdr *) ibs->rx_skb->data;
+
+				BT_DBG("Event header: evt 0x%2.2x plen %d",
+					eh->evt, eh->plen);
+
+				ibs_check_data_len(ibs, eh->plen);
+				continue;
+
+			case HCI_IBS_W4_ACL_HDR:
+				ah = (struct hci_acl_hdr *) ibs->rx_skb->data;
+				dlen = __le16_to_cpu(ah->dlen);
+
+				BT_DBG("ACL header: dlen %d", dlen);
+
+				ibs_check_data_len(ibs, dlen);
+				continue;
+
+			case HCI_IBS_W4_SCO_HDR:
+				sh = (struct hci_sco_hdr *) ibs->rx_skb->data;
+
+				BT_DBG("SCO header: dlen %d", sh->dlen);
+
+				ibs_check_data_len(ibs, sh->dlen);
+				continue;
+			}
+		}
+
+		/* HCI_IBS_W4_PACKET_TYPE */
+		switch (*ptr) {
+		case HCI_EVENT_PKT:
+			BT_DBG("Event packet");
+			ibs->rx_state = HCI_IBS_W4_EVENT_HDR;
+			ibs->rx_count = HCI_EVENT_HDR_SIZE;
+			type = HCI_EVENT_PKT;
+			break;
+
+		case HCI_ACLDATA_PKT:
+			BT_DBG("ACL packet");
+			ibs->rx_state = HCI_IBS_W4_ACL_HDR;
+			ibs->rx_count = HCI_ACL_HDR_SIZE;
+			type = HCI_ACLDATA_PKT;
+			break;
+
+		case HCI_SCODATA_PKT:
+			BT_DBG("SCO packet");
+			ibs->rx_state = HCI_IBS_W4_SCO_HDR;
+			ibs->rx_count = HCI_SCO_HDR_SIZE;
+			type = HCI_SCODATA_PKT;
+			break;
+
+		/* HCI_IBS signals */
+		case HCI_IBS_SLEEP_IND:
+			BT_DBG("HCI_IBS_SLEEP_IND packet");
+			ibs_device_want_to_sleep(hu);
+			ptr++; count--;
+			continue;
+
+		case HCI_IBS_WAKE_IND:
+			BT_DBG("HCI_IBS_WAKE_IND packet");
+			ibs_device_want_to_wakeup(hu);
+			ptr++; count--;
+			continue;
+
+		case HCI_IBS_WAKE_ACK:
+			BT_DBG("HCI_IBS_WAKE_ACK packet");
+			ibs_device_woke_up(hu);
+			ptr++; count--;
+			continue;
+
+		default:
+			BT_ERR("Unknown HCI packet type %2.2x", (__u8)*ptr);
+			hu->hdev->stat.err_rx++;
+			ptr++; count--;
+			continue;
+		};
+
+		ptr++; count--;
+
+		/* Allocate packet */
+		ibs->rx_skb = bt_skb_alloc(HCI_MAX_FRAME_SIZE, GFP_ATOMIC);
+		if (!ibs->rx_skb) {
+			BT_ERR("Can't allocate mem for new packet");
+			ibs->rx_state = HCI_IBS_W4_PACKET_TYPE;
+			ibs->rx_count = 0;
+			return 0;
+		}
+
+		ibs->rx_skb->dev = (void *) hu->hdev;
+		bt_cb(ibs->rx_skb)->pkt_type = type;
+	}
+
+	return count;
+}
+
+static struct sk_buff *ibs_dequeue(struct hci_uart *hu)
+{
+	struct ibs_struct *ibs = hu->priv;
+	return skb_dequeue(&ibs->txq);
+}
+
+static struct hci_uart_proto ibs_p = {
+	.id		= HCI_UART_IBS,
+	.open		= ibs_open,
+	.close		= ibs_close,
+	.recv		= ibs_recv,
+	.enqueue	= ibs_enqueue,
+	.dequeue	= ibs_dequeue,
+	.flush		= ibs_flush,
+};
+
+int ibs_init(void)
+{
+	int err = hci_uart_register_proto(&ibs_p);
+
+	if (!err)
+		BT_INFO("HCI_IBS protocol initialized");
+	else
+		BT_ERR("HCI_IBS protocol registration failed");
+
+	return err;
+}
+
+int ibs_deinit(void)
+{
+	return hci_uart_unregister_proto(&ibs_p);
+}
+
+module_param(wake_retrans, ulong, 0644);
+MODULE_PARM_DESC(wake_retrans, "Delay (1/HZ) to retransmit WAKE_IND");
+
+module_param(tx_idle_delay, ulong, 0644);
+MODULE_PARM_DESC(tx_idle_delay, "Delay (1/HZ) since last tx for SLEEP_IND");
diff --git a/drivers/bluetooth/hci_ldisc.c b/drivers/bluetooth/hci_ldisc.c
index bc68a44..836b1cd 100644
--- a/drivers/bluetooth/hci_ldisc.c
+++ b/drivers/bluetooth/hci_ldisc.c
@@ -2,9 +2,9 @@
  *
  *  Bluetooth HCI UART driver
  *
- *  Copyright (C) 2000-2001  Qualcomm Incorporated
  *  Copyright (C) 2002-2003  Maxim Krasnyansky <maxk@qualcomm.com>
  *  Copyright (C) 2004-2005  Marcel Holtmann <marcel@holtmann.org>
+ *  Copyright (c) 2000-2001, 2010, Code Aurora Forum. All rights reserved.
  *
  *
  *  This program is free software; you can redistribute it and/or modify
@@ -597,6 +597,9 @@ static int __init hci_uart_init(void)
 #ifdef CONFIG_BT_HCIUART_3WIRE
 	h5_init();
 #endif
+#ifdef CPTCFG_BT_HCIUART_IBS
+	ibs_init();
+#endif
 
 	return 0;
 }
@@ -620,6 +623,9 @@ static void __exit hci_uart_exit(void)
 #ifdef CONFIG_BT_HCIUART_3WIRE
 	h5_deinit();
 #endif
+#ifdef CPTCFG_BT_HCIUART_IBS
+	ibs_deinit();
+#endif
 
 	/* Release tty registration of line discipline */
 	if ((err = tty_unregister_ldisc(N_HCI)))
diff --git a/drivers/bluetooth/hci_uart.h b/drivers/bluetooth/hci_uart.h
index fffa61f..f5a9c90 100644
--- a/drivers/bluetooth/hci_uart.h
+++ b/drivers/bluetooth/hci_uart.h
@@ -2,9 +2,9 @@
  *
  *  Bluetooth HCI UART driver
  *
- *  Copyright (C) 2000-2001  Qualcomm Incorporated
  *  Copyright (C) 2002-2003  Maxim Krasnyansky <maxk@qualcomm.com>
  *  Copyright (C) 2004-2005  Marcel Holtmann <marcel@holtmann.org>
+ *  Copyright (c) 2000-2001, 2010, Code Aurora Forum. All rights reserved.
  *
  *
  *  This program is free software; you can redistribute it and/or modify
@@ -43,6 +43,7 @@
 #define HCI_UART_H4DS	3
 #define HCI_UART_LL	4
 #define HCI_UART_ATH3K	5
+#define HCI_UART_IBS	6
 
 #define HCI_UART_RAW_DEVICE	0
 #define HCI_UART_RESET_ON_INIT	1
@@ -114,3 +115,8 @@ int ath_deinit(void);
 int h5_init(void);
 int h5_deinit(void);
 #endif
+
+#ifdef CPTCFG_BT_HCIUART_IBS
+int ibs_init(void);
+int ibs_deinit(void);
+#endif
-- 
1.7.9.5


From 6efb4d4e1f1b8d77a836e14e01d8f1dda7fa2393 Mon Sep 17 00:00:00 2001
From: Ram Mohan Korukonda <rkorukon@codeaurora.org>
Date: Sun, 19 Aug 2012 13:44:57 +0530
Subject: [PATCH 08/25] bluetooth: hci_ibs: Vote on/off UART clocks in non
 atomic context.

As per the latest clock design, we should not vote for the clocks
in the atomic context.

CRs-fixed: 377905
Change-Id: I70f269d40f007326de7a6279bfd11c4e576d251b
Signed-off-by: Ram Mohan Korukonda <rkorukon@codeaurora.org>
Signed-off-by: Anantha Krishnan <ananthk@codeaurora.org>
---
 drivers/bluetooth/hci_ibs.c |  137 ++++++++++++++++++++++++++++++++++---------
 1 file changed, 110 insertions(+), 27 deletions(-)

diff --git a/drivers/bluetooth/hci_ibs.c b/drivers/bluetooth/hci_ibs.c
index 1f26cef..47e6ccc 100644
--- a/drivers/bluetooth/hci_ibs.c
+++ b/drivers/bluetooth/hci_ibs.c
@@ -112,6 +112,13 @@ struct ibs_struct {
 	unsigned long rx_vote;		/* clock must be on for RX */
 	struct	timer_list tx_idle_timer;
 	struct	timer_list wake_retrans_timer;
+	struct	workqueue_struct *workqueue;
+	struct	work_struct ws_awake_rx;
+	struct	work_struct ws_awake_device;
+	struct	work_struct ws_rx_vote_off;
+	struct	work_struct ws_tx_vote_off;
+	void *ibs_hu; /* keeps the hci_uart pointer for reference */
+
 	/* debug */
 	unsigned long ibs_sent_wacks;
 	unsigned long ibs_sent_slps;
@@ -242,12 +249,90 @@ out:
 	return err;
 }
 
+static void ibs_wq_awake_device(struct work_struct *work)
+{
+	struct ibs_struct *ibs = container_of(work, struct ibs_struct,
+					ws_awake_device);
+	struct hci_uart *hu = (struct hci_uart *)ibs->ibs_hu;
+
+	BT_DBG(" %p ", hu);
+
+	/* Vote for serial clock */
+	ibs_msm_serial_clock_vote(HCI_IBS_TX_VOTE_CLOCK_ON, hu);
+
+	spin_lock(&ibs->hci_ibs_lock);
+
+	/* send wake indication to device */
+	if (send_hci_ibs_cmd(HCI_IBS_WAKE_IND, hu) < 0)
+		BT_ERR("cannot send WAKE to device");
+
+	ibs->ibs_sent_wakes++; /* debug */
+
+	/* start retransmit timer */
+	mod_timer(&ibs->wake_retrans_timer, jiffies + wake_retrans);
+
+	spin_unlock(&ibs->hci_ibs_lock);
+}
+
+static void ibs_wq_awake_rx(struct work_struct *work)
+{
+	struct ibs_struct *ibs = container_of(work, struct ibs_struct,
+					ws_awake_rx);
+	struct hci_uart *hu = (struct hci_uart *)ibs->ibs_hu;
+
+	BT_DBG(" %p ", hu);
+
+	ibs_msm_serial_clock_vote(HCI_IBS_RX_VOTE_CLOCK_ON, hu);
+
+	spin_lock(&ibs->hci_ibs_lock);
+	ibs->rx_ibs_state = HCI_IBS_RX_AWAKE;
+	/* Always acknowledge device wake up,
+	 * sending IBS message doesn't count as TX ON
+	 */
+	if (send_hci_ibs_cmd(HCI_IBS_WAKE_ACK, hu) < 0)
+		BT_ERR("cannot acknowledge device wake up");
+
+	ibs->ibs_sent_wacks++; /* debug */
+
+	spin_unlock(&ibs->hci_ibs_lock);
+	/* actually send the packets */
+	hci_uart_tx_wakeup(hu);
+
+}
+
+static void ibs_wq_serial_rx_clock_vote_off(struct work_struct *work)
+{
+	struct ibs_struct *ibs = container_of(work, struct ibs_struct,
+					ws_rx_vote_off);
+	struct hci_uart *hu = (struct hci_uart *)ibs->ibs_hu;
+
+	BT_DBG(" %p ", hu);
+
+	ibs_msm_serial_clock_vote(HCI_IBS_RX_VOTE_CLOCK_OFF, hu);
+
+}
+
+static void ibs_wq_serial_tx_clock_vote_off(struct work_struct *work)
+{
+	struct ibs_struct *ibs = container_of(work, struct ibs_struct,
+					ws_tx_vote_off);
+	struct hci_uart *hu = (struct hci_uart *)ibs->ibs_hu;
+
+	BT_DBG(" %p ", hu);
+
+	hci_uart_tx_wakeup(hu);  /* run HCI tx handling unlocked */
+
+	/* now that message queued to tty driver, vote for tty clocks off */
+	/* It is up to the tty driver to pend the clocks off until tx done. */
+	ibs_msm_serial_clock_vote(HCI_IBS_TX_VOTE_CLOCK_OFF, hu);
+
+}
+
 static void hci_ibs_tx_idle_timeout(unsigned long arg)
 {
 	struct hci_uart *hu = (struct hci_uart *) arg;
 	struct ibs_struct *ibs = hu->priv;
 	unsigned long flags;
-	unsigned long vote_tx_sleep = 0;
 
 	BT_DBG("hu %p idle timeout in %lu state", hu, ibs->tx_ibs_state);
 
@@ -267,22 +352,11 @@ static void hci_ibs_tx_idle_timeout(unsigned long arg)
 		}
 		ibs->tx_ibs_state = HCI_IBS_TX_ASLEEP;
 		ibs->ibs_sent_slps++; /* debug */
-		vote_tx_sleep = 1;
 		break;
 	}
 
-	spin_unlock_irqrestore(&ibs->hci_ibs_lock, flags);
-
-	hci_uart_tx_wakeup(hu);  /* run HCI tx handling unlocked */
-
-	if (!vote_tx_sleep)
-		return;
-	/* now that message queued to tty driver, vote for tty clocks off */
-	/* It is up to the tty driver to pend the clocks off until tx done. */
+	queue_work(ibs->workqueue, &ibs->ws_tx_vote_off);
 
-	spin_lock_irqsave_nested(&ibs->hci_ibs_lock,
-					flags, SINGLE_DEPTH_NESTING);
-	ibs_msm_serial_clock_vote(HCI_IBS_TX_VOTE_CLOCK_OFF, hu);
 out:
 	spin_unlock_irqrestore(&ibs->hci_ibs_lock, flags);
 }
@@ -336,6 +410,19 @@ static int ibs_open(struct hci_uart *hu)
 	skb_queue_head_init(&ibs->txq);
 	skb_queue_head_init(&ibs->tx_wait_q);
 	spin_lock_init(&ibs->hci_ibs_lock);
+	ibs->workqueue = create_singlethread_workqueue("ibs_wq");
+	if (!ibs->workqueue) {
+		BT_ERR("IBS Workqueue not initialized properly");
+		kfree(ibs);
+		return -ENOMEM;
+	}
+
+	INIT_WORK(&ibs->ws_awake_rx, ibs_wq_awake_rx);
+	INIT_WORK(&ibs->ws_awake_device, ibs_wq_awake_device);
+	INIT_WORK(&ibs->ws_rx_vote_off, ibs_wq_serial_rx_clock_vote_off);
+	INIT_WORK(&ibs->ws_tx_vote_off, ibs_wq_serial_tx_clock_vote_off);
+
+	ibs->ibs_hu = (void *)hu;
 
 	/* Assume we start with both sides asleep -- extra wakes OK */
 	ibs->tx_ibs_state = HCI_IBS_TX_ASLEEP;
@@ -432,6 +519,8 @@ static int ibs_close(struct hci_uart *hu)
 	skb_queue_purge(&ibs->txq);
 	del_timer(&ibs->tx_idle_timer);
 	del_timer(&ibs->wake_retrans_timer);
+	destroy_workqueue(ibs->workqueue);
+	ibs->ibs_hu = NULL;
 
 	kfree_skb(ibs->rx_skb);
 
@@ -463,9 +552,10 @@ static void ibs_device_want_to_wakeup(struct hci_uart *hu)
 		/* Make sure clock is on - we may have turned clock off since
 		 * receiving the wake up indicator
 		 */
-		ibs_msm_serial_clock_vote(HCI_IBS_RX_VOTE_CLOCK_ON, hu);
-		ibs->rx_ibs_state = HCI_IBS_RX_AWAKE;
-		/* deliberate fall-through */
+		/* awake rx clock */
+		queue_work(ibs->workqueue, &ibs->ws_awake_rx);
+		spin_unlock_irqrestore(&ibs->hci_ibs_lock, flags);
+		return;
 	case HCI_IBS_RX_AWAKE:
 		/* Always acknowledge device wake up,
 		 * sending IBS message doesn't count as TX ON.
@@ -510,7 +600,8 @@ static void ibs_device_want_to_sleep(struct hci_uart *hu)
 	case HCI_IBS_RX_AWAKE:
 		/* update state */
 		ibs->rx_ibs_state = HCI_IBS_RX_ASLEEP;
-		ibs_msm_serial_clock_vote(HCI_IBS_RX_VOTE_CLOCK_OFF, hu);
+		/* vote off rx clock under workqueue */
+		queue_work(ibs->workqueue, &ibs->ws_rx_vote_off);
 		break;
 	case HCI_IBS_RX_ASLEEP:
 		/* deliberate fall-through */
@@ -595,20 +686,12 @@ static int ibs_enqueue(struct hci_uart *hu, struct sk_buff *skb)
 
 	case HCI_IBS_TX_ASLEEP:
 		BT_DBG("device asleep, waking up and queueing packet");
-		ibs_msm_serial_clock_vote(HCI_IBS_TX_VOTE_CLOCK_ON, hu);
 		/* save packet for later */
 		skb_queue_tail(&ibs->tx_wait_q, skb);
-		/* awake device */
-		if (send_hci_ibs_cmd(HCI_IBS_WAKE_IND, hu) < 0) {
-			BT_ERR("cannot send WAKE to device");
-			break;
-		}
-		ibs->ibs_sent_wakes++; /* debug */
-
-		/* start retransmit timer */
-		mod_timer(&ibs->wake_retrans_timer, jiffies + wake_retrans);
 
 		ibs->tx_ibs_state = HCI_IBS_TX_WAKING;
+		/* schedule a work queue to wake up device */
+		queue_work(ibs->workqueue, &ibs->ws_awake_device);
 		break;
 
 	case HCI_IBS_TX_WAKING:
-- 
1.7.9.5


From 17a71e25512f443fc72ae94b37ac2e74ed6c9c34 Mon Sep 17 00:00:00 2001
From: Ananth Krishanan <ananthk@codeaurora.org>
Date: Fri, 8 Aug 2014 19:11:56 +0530
Subject: [PATCH 09/25] bluetooth: use corect struct member and number of
 protocols

The original file is picked from 2.6.29b but struct definition of
uart_state has changed from then to 3.10. use correct definition.
Use correct definition of max number of protocols.

Change-Id: Id24efdd6e69640cb8f2374363e30e4dc44cc507a
CRs-Fixed: 706864
Signed-off-by: Anantha Krishnan <ananthk@codeaurora.org>
---
 drivers/bluetooth/hci_ibs.c  |    8 ++++----
 drivers/bluetooth/hci_uart.h |    9 ++++++++-
 2 files changed, 12 insertions(+), 5 deletions(-)

diff --git a/drivers/bluetooth/hci_ibs.c b/drivers/bluetooth/hci_ibs.c
index 47e6ccc..06e797d 100644
--- a/drivers/bluetooth/hci_ibs.c
+++ b/drivers/bluetooth/hci_ibs.c
@@ -5,7 +5,7 @@
  *  protocol extension to H4.
  *
  *  Copyright (C) 2007 Texas Instruments, Inc.
- *  Copyright (c) 2010, Code Aurora Forum. All rights reserved.
+ *  Copyright (c) 2010, 2012, 2014, The Linux Foundation. All rights reserved.
  *
  *  Acknowledgements:
  *  This file is based on hci_ll.c, which was...
@@ -50,7 +50,7 @@
 #include <linux/serial_core.h>
 
 #ifdef CONFIG_SERIAL_MSM_HS
-#include <mach/msm_serial_hs.h>
+#include <linux/platform_data/msm_serial_hs.h>
 #endif
 
 #include <net/bluetooth/bluetooth.h>
@@ -141,7 +141,7 @@ struct ibs_struct {
 static void __ibs_msm_serial_clock_on(struct tty_struct *tty)
 {
 	struct uart_state *state = tty->driver_data;
-	struct uart_port *port = state->port;
+	struct uart_port *port = state->uart_port;
 
 	msm_hs_request_clock_on(port);
 }
@@ -149,7 +149,7 @@ static void __ibs_msm_serial_clock_on(struct tty_struct *tty)
 static void __ibs_msm_serial_clock_request_off(struct tty_struct *tty)
 {
 	struct uart_state *state = tty->driver_data;
-	struct uart_port *port = state->port;
+	struct uart_port *port = state->uart_port;
 
 	msm_hs_request_clock_off(port);
 }
diff --git a/drivers/bluetooth/hci_uart.h b/drivers/bluetooth/hci_uart.h
index f5a9c90..da5eaa3 100644
--- a/drivers/bluetooth/hci_uart.h
+++ b/drivers/bluetooth/hci_uart.h
@@ -35,7 +35,7 @@
 #define HCIUARTGETFLAGS		_IOR('U', 204, int)
 
 /* UART protocols */
-#define HCI_UART_MAX_PROTO	6
+#define HCI_UART_MAX_PROTO	7
 
 #define HCI_UART_H4	0
 #define HCI_UART_BCSP	1
@@ -50,6 +50,8 @@
 #define HCI_UART_CREATE_AMP	2
 #define HCI_UART_INIT_PENDING	3
 
+#include <linux/interrupt.h>
+
 struct hci_uart;
 
 struct hci_uart_proto {
-- 
1.7.9.5


From 44757066c28c6a35e12815b7011a994b6169b048 Mon Sep 17 00:00:00 2001
From: Anantha Krishnan <ananthk@codeaurora.org>
Date: Mon, 18 Aug 2014 08:24:00 +0530
Subject: [PATCH 10/25] bluetooth: hci_ibs: disable irqs when spinlock is
 acquired

Deadlock is observed while performing bluetooth stress and
stability tests. Since same lock is getting acquired from both irq
and non-irq context, irqs should be disable while acquiring
the spinlock always. Otherwise there is chance of deadlock
observing while performing stability tests

Change-Id: I6921e7ed70362e1cbdc3f90543e0c906bab8f385
Signed-off-by: Anantha Krishnan <ananthk@codeaurora.org>
---
 drivers/bluetooth/hci_ibs.c |   13 +++++++++----
 1 file changed, 9 insertions(+), 4 deletions(-)

diff --git a/drivers/bluetooth/hci_ibs.c b/drivers/bluetooth/hci_ibs.c
index 06e797d..42a67ab 100644
--- a/drivers/bluetooth/hci_ibs.c
+++ b/drivers/bluetooth/hci_ibs.c
@@ -254,13 +254,14 @@ static void ibs_wq_awake_device(struct work_struct *work)
 	struct ibs_struct *ibs = container_of(work, struct ibs_struct,
 					ws_awake_device);
 	struct hci_uart *hu = (struct hci_uart *)ibs->ibs_hu;
+	unsigned long flags;
 
 	BT_DBG(" %p ", hu);
 
 	/* Vote for serial clock */
 	ibs_msm_serial_clock_vote(HCI_IBS_TX_VOTE_CLOCK_ON, hu);
 
-	spin_lock(&ibs->hci_ibs_lock);
+	spin_lock_irqsave(&ibs->hci_ibs_lock, flags);
 
 	/* send wake indication to device */
 	if (send_hci_ibs_cmd(HCI_IBS_WAKE_IND, hu) < 0)
@@ -271,7 +272,8 @@ static void ibs_wq_awake_device(struct work_struct *work)
 	/* start retransmit timer */
 	mod_timer(&ibs->wake_retrans_timer, jiffies + wake_retrans);
 
-	spin_unlock(&ibs->hci_ibs_lock);
+	spin_unlock_irqrestore(&ibs->hci_ibs_lock, flags);
+
 }
 
 static void ibs_wq_awake_rx(struct work_struct *work)
@@ -279,12 +281,14 @@ static void ibs_wq_awake_rx(struct work_struct *work)
 	struct ibs_struct *ibs = container_of(work, struct ibs_struct,
 					ws_awake_rx);
 	struct hci_uart *hu = (struct hci_uart *)ibs->ibs_hu;
+	unsigned long flags;
 
 	BT_DBG(" %p ", hu);
 
 	ibs_msm_serial_clock_vote(HCI_IBS_RX_VOTE_CLOCK_ON, hu);
 
-	spin_lock(&ibs->hci_ibs_lock);
+	spin_lock_irqsave(&ibs->hci_ibs_lock, flags);
+
 	ibs->rx_ibs_state = HCI_IBS_RX_AWAKE;
 	/* Always acknowledge device wake up,
 	 * sending IBS message doesn't count as TX ON
@@ -294,7 +298,8 @@ static void ibs_wq_awake_rx(struct work_struct *work)
 
 	ibs->ibs_sent_wacks++; /* debug */
 
-	spin_unlock(&ibs->hci_ibs_lock);
+	spin_unlock_irqrestore(&ibs->hci_ibs_lock, flags);
+
 	/* actually send the packets */
 	hci_uart_tx_wakeup(hu);
 
-- 
1.7.9.5


From 19b5bd11d62103a9efd6394266cc0ec4fd73f669 Mon Sep 17 00:00:00 2001
From: Anantha Krishnan <ananthk@codeaurora.org>
Date: Tue, 26 Aug 2014 04:03:53 +0530
Subject: [PATCH 11/25] bluetooth : Configure the Tx idle timeout to 1sec

when there is no activity on the host tx for 1 sec
indicate the controller to enter into sleep.
1sec is the optimal value we need to satisfy the power
and performance requirements.

Change-Id: I9c2a2973a7fbb1a49460e06117c264aa4e0e44e4
Signed-off-by: Anantha Krishnan <ananthk@codeaurora.org>
---
 drivers/bluetooth/hci_ibs.c |   11 ++++++++---
 1 file changed, 8 insertions(+), 3 deletions(-)

diff --git a/drivers/bluetooth/hci_ibs.c b/drivers/bluetooth/hci_ibs.c
index 42a67ab..55d1b95 100644
--- a/drivers/bluetooth/hci_ibs.c
+++ b/drivers/bluetooth/hci_ibs.c
@@ -63,6 +63,9 @@
 #define HCI_IBS_WAKE_IND	0xFD
 #define HCI_IBS_WAKE_ACK	0xFC
 
+/* TX idle time out value */
+#define TX_IDLE_TO		1000
+
 /* HCI_IBS receiver States */
 #define HCI_IBS_W4_PACKET_TYPE	0
 #define HCI_IBS_W4_EVENT_HDR	1
@@ -270,7 +273,7 @@ static void ibs_wq_awake_device(struct work_struct *work)
 	ibs->ibs_sent_wakes++; /* debug */
 
 	/* start retransmit timer */
-	mod_timer(&ibs->wake_retrans_timer, jiffies + wake_retrans);
+	mod_timer(&ibs->wake_retrans_timer, jiffies + msecs_to_jiffies(10));
 
 	spin_unlock_irqrestore(&ibs->hci_ibs_lock, flags);
 
@@ -656,7 +659,8 @@ static void ibs_device_woke_up(struct hci_uart *hu)
 			skb_queue_tail(&ibs->txq, skb);
 		/* switch timers and change state to HCI_IBS_TX_AWAKE */
 		del_timer(&ibs->wake_retrans_timer);
-		mod_timer(&ibs->tx_idle_timer, jiffies + tx_idle_delay);
+		mod_timer(&ibs->tx_idle_timer, jiffies +
+			msecs_to_jiffies(TX_IDLE_TO));
 		ibs->tx_ibs_state = HCI_IBS_TX_AWAKE;
 	}
 
@@ -686,7 +690,8 @@ static int ibs_enqueue(struct hci_uart *hu, struct sk_buff *skb)
 	case HCI_IBS_TX_AWAKE:
 		BT_DBG("device awake, sending normally");
 		skb_queue_tail(&ibs->txq, skb);
-		mod_timer(&ibs->tx_idle_timer, jiffies + tx_idle_delay);
+		mod_timer(&ibs->tx_idle_timer, jiffies +
+			msecs_to_jiffies(TX_IDLE_TO));
 		break;
 
 	case HCI_IBS_TX_ASLEEP:
-- 
1.7.9.5


From 919514a0f79002b2d8e5a60006ca67004c75d70c Mon Sep 17 00:00:00 2001
From: Anantha Krishnan <ananthk@codeaurora.org>
Date: Thu, 4 Sep 2014 15:58:44 +0530
Subject: [PATCH 12/25] bluetooth: Type cast the received data before parsing

On x86 platforms we observe that the data received from socket
buffer needs to be type casted to unsigned char in order to
parse the bluetooth sleep packets sent by the bluetooth
controller to APPS processor

Change-Id: If398a3b1ccf7972555fa1a53e6c117874e7b1301
Signed-off-by: Anantha Krishnan <ananthk@codeaurora.org>
---
 drivers/bluetooth/hci_ibs.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/drivers/bluetooth/hci_ibs.c b/drivers/bluetooth/hci_ibs.c
index 55d1b95..0d73218 100644
--- a/drivers/bluetooth/hci_ibs.c
+++ b/drivers/bluetooth/hci_ibs.c
@@ -807,7 +807,7 @@ static int ibs_recv(struct hci_uart *hu, void *data, int count)
 		}
 
 		/* HCI_IBS_W4_PACKET_TYPE */
-		switch (*ptr) {
+		switch ((unsigned char) *ptr) {
 		case HCI_EVENT_PKT:
 			BT_DBG("Event packet");
 			ibs->rx_state = HCI_IBS_W4_EVENT_HDR;
-- 
1.7.9.5


From 821c14ba86e4bef384ea47dd543c101e7a7642f3 Mon Sep 17 00:00:00 2001
From: Anantha Krishnan <ananthk@codeaurora.org>
Date: Thu, 14 Aug 2014 12:41:57 +0530
Subject: [PATCH 13/25] bluetooth: Add support for ROME 3.0

Enable bluetooth firmware download mechanism for ROME 3.0

Change-Id: Ib9e4193da0882174c73c1c9ec0035a905b5c6ec8
Signed-off-by: Anantha Krishnan <ananthk@codeaurora.org>
---
 drivers/bluetooth/ath3k.c |   50 +++++++++++++++++++++++++++++++--------------
 1 file changed, 35 insertions(+), 15 deletions(-)

diff --git a/drivers/bluetooth/ath3k.c b/drivers/bluetooth/ath3k.c
index 8ea8614..0aad230 100644
--- a/drivers/bluetooth/ath3k.c
+++ b/drivers/bluetooth/ath3k.c
@@ -33,18 +33,24 @@
 #define VERSION "1.0"
 #define ATH3K_FIRMWARE	"ath3k-1.fw"
 
+#define ROME1_1_USB_RAMPATCH_FILE	"ar3k/rampatch_1.1.img"
+#define ROME1_1_USB_NVM_FILE		"ar3k/nvm_tlv_usb_1.1.bin"
+
 #define ROME2_1_USB_RAMPATCH_FILE	"ar3k/rampatch_tlv_usb_2.1.tlv"
 #define ROME2_1_USB_NVM_FILE		"ar3k/nvm_tlv_usb_2.1.bin"
 
-#define ROME1_1_USB_RAMPATCH_FILE	"ar3k/rampatch_1.1.img"
-#define ROME1_1_USB_NVM_FILE		"ar3k/nvm_tlv_usb_1.1.bin"
+#define ROME3_0_USB_RAMPATCH_FILE	"ar3k/rampatch_tlv_usb_3.0.tlv"
+#define ROME3_0_USB_NVM_FILE		"ar3k/nvm_tlv_usb_3.0.bin"
 
 #define ROME2_1_USB_RAMPATCH_HEADER	sizeof(struct rome2_1_version)
 #define ROME1_1_USB_RAMPATCH_HEADER	sizeof(struct rome1_1_version)
-#define ROME1_1_USB_NVM_HEADER		0x04
-#define ROME2_1_USB_NVM_HEADER		0x04
-#define ROME2_1_USB_CHIP_VERSION		0x200
+
+#define ROME1_1_USB_NVM_HEADER			0x04
+#define ROME2_1_USB_NVM_HEADER			0x04
+
 #define ROME1_1_USB_CHIP_VERSION		0x101
+#define ROME2_1_USB_CHIP_VERSION		0x200
+#define ROME3_0_USB_CHIP_VERSION		0x300
 
 #define ATH3K_DNLOAD				0x01
 #define ATH3K_GETSTATE				0x05
@@ -267,11 +273,17 @@ int get_rome_version(struct usb_device *udev)
 		BT_ERR("Failed to get Rome Firmware version");
 		return ret;
 	}
-	if ((fw_version.rom_version == ROME2_1_USB_CHIP_VERSION) ||
-		(fw_version.rom_version == ROME1_1_USB_CHIP_VERSION))
+
+	switch (fw_version.rom_version) {
+	case ROME1_1_USB_CHIP_VERSION:
+	case ROME2_1_USB_CHIP_VERSION:
+	case ROME3_0_USB_CHIP_VERSION:
 		ret = fw_version.rom_version;
-	else
+		break;
+	default:
 		ret = 0;
+		break;
+	}
 	return ret;
 }
 EXPORT_SYMBOL(get_rome_version);
@@ -397,6 +409,9 @@ static int ath3k_load_patch(struct usb_device *udev)
 	} else if (fw_version.rom_version == ROME2_1_USB_CHIP_VERSION) {
 		BT_DBG("Chip Detected as ROME2.1");
 		snprintf(filename, ATH3K_NAME_LEN, ROME2_1_USB_RAMPATCH_FILE);
+	} else if (fw_version.rom_version == ROME3_0_USB_CHIP_VERSION) {
+		BT_DBG("Chip Detected as ROME3.0");
+		snprintf(filename, ATH3K_NAME_LEN, ROME3_0_USB_RAMPATCH_FILE);
 	} else {
 		BT_DBG("Chip Detected as Ath3k");
 		snprintf(filename, ATH3K_NAME_LEN, "ar3k/AthrBT_0x%08x.dfu",
@@ -408,14 +423,15 @@ static int ath3k_load_patch(struct usb_device *udev)
 		return ret;
 	}
 
-	if (fw_version.rom_version == ROME2_1_USB_CHIP_VERSION) {
+	if ((fw_version.rom_version == ROME2_1_USB_CHIP_VERSION) ||
+		(fw_version.rom_version == ROME3_0_USB_CHIP_VERSION)) {
 		rome2_1_version = (struct rome2_1_version *) firmware->data;
 		pt_version.rom_version = rome2_1_version->build_ver;
 		pt_version.build_version = rome2_1_version->patch_ver;
-		BT_DBG("pt_ver.rom2.1_ver : 0x%x", pt_version.rom_version);
-		BT_DBG("pt_ver.build2.1_ver: 0x%x", pt_version.build_version);
-		BT_DBG("fw_ver.rom2.1_ver: 0x%x", fw_version.rom_version);
-		BT_DBG("fw_ver.build2.1_ver: 0x%x", fw_version.build_version);
+		BT_DBG("pt_ver.rome_ver : 0x%x", pt_version.rom_version);
+		BT_DBG("pt_ver.build_ver: 0x%x", pt_version.build_version);
+		BT_DBG("fw_ver.rom_ver: 0x%x", fw_version.rom_version);
+		BT_DBG("fw_ver.build_ver: 0x%x", fw_version.build_version);
 	} else if (fw_version.rom_version == ROME1_1_USB_CHIP_VERSION) {
 		rome1_1_version = (struct rome1_1_version *) firmware->data;
 		pt_version.build_version = rome1_1_version->build_ver;
@@ -437,7 +453,8 @@ static int ath3k_load_patch(struct usb_device *udev)
 		return -EINVAL;
 	}
 
-	if (fw_version.rom_version == ROME2_1_USB_CHIP_VERSION)
+	if ((fw_version.rom_version == ROME2_1_USB_CHIP_VERSION) ||
+		(fw_version.rom_version == ROME3_0_USB_CHIP_VERSION))
 		ret = ath3k_load_fwfile(udev, firmware,
 						ROME2_1_USB_RAMPATCH_HEADER);
 	else if (fw_version.rom_version == ROME1_1_USB_CHIP_VERSION)
@@ -497,6 +514,8 @@ static int ath3k_load_syscfg(struct usb_device *udev)
 
 	if (fw_version.rom_version == ROME2_1_USB_CHIP_VERSION)
 		snprintf(filename, ATH3K_NAME_LEN, ROME2_1_USB_NVM_FILE);
+	else if (fw_version.rom_version == ROME3_0_USB_CHIP_VERSION)
+		snprintf(filename, ATH3K_NAME_LEN, ROME3_0_USB_NVM_FILE);
 	else if (fw_version.rom_version == ROME1_1_USB_CHIP_VERSION)
 		snprintf(filename, ATH3K_NAME_LEN, ROME1_1_USB_NVM_FILE);
 	else
@@ -509,7 +528,8 @@ static int ath3k_load_syscfg(struct usb_device *udev)
 		return ret;
 	}
 
-	if (fw_version.rom_version == ROME2_1_USB_CHIP_VERSION)
+	if ((fw_version.rom_version == ROME2_1_USB_CHIP_VERSION) ||
+		(fw_version.rom_version == ROME3_0_USB_CHIP_VERSION))
 		ret = ath3k_load_fwfile(udev, firmware, ROME2_1_USB_NVM_HEADER);
 	else if (fw_version.rom_version == ROME1_1_USB_CHIP_VERSION)
 		ret = ath3k_load_fwfile(udev, firmware, ROME1_1_USB_NVM_HEADER);
-- 
1.7.9.5


From 9246e5c7c42df83099942e9de2d9174641b8a5c9 Mon Sep 17 00:00:00 2001
From: Anantha Krishnan <ananthk@codeaurora.org>
Date: Fri, 5 Sep 2014 18:06:49 +0530
Subject: [PATCH 14/25] bluetooth: Configure DUT as MASTER for outgoing
 connection requests

Request MASTER ONLY role while establishing connection with remote
devices. Post ACL establishment, update link policy by disabling
role switch. This would prevent remote devices from requesting
for role switch post ACL creation and will allow the DUT to be
in MASTER role always. This is done to satisy BTC requirements
for achieving better WLAN throughput and performance.

Change-Id: If3187d0e8359d70ffb12e63e397b621a7c1a6031
Signed-off-by: Anantha Krishnan <ananthk@codeaurora.org>
---
 include/net/bluetooth/hci_core.h |    1 +
 net/bluetooth/hci_conn.c         |   20 ++++++++++++++++++++
 net/bluetooth/hci_core.c         |    4 ++--
 net/bluetooth/hci_event.c        |    3 +++
 4 files changed, 26 insertions(+), 2 deletions(-)

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 7cb6d36..f677109 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -598,6 +598,7 @@ int hci_conn_check_secure(struct hci_conn *conn, __u8 sec_level);
 int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type);
 int hci_conn_change_link_key(struct hci_conn *conn);
 int hci_conn_switch_role(struct hci_conn *conn, __u8 role);
+int hci_cfg_link_policy(struct hci_conn *conn);
 
 void hci_conn_enter_active_mode(struct hci_conn *conn, __u8 force_active);
 
diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 6c7f363..64713af 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -96,6 +96,8 @@ static void hci_acl_create_connection(struct hci_conn *conn)
 	}
 
 	cp.pkt_type = cpu_to_le16(conn->pkt_type);
+	/* Allow DUT to be MASTER for allow outgoing connection requests */
+	hdev->link_mode |= HCI_LM_MASTER;
 	if (lmp_rswitch_capable(hdev) && !(hdev->link_mode & HCI_LM_MASTER))
 		cp.role_switch = 0x01;
 	else
@@ -784,6 +786,24 @@ int hci_conn_switch_role(struct hci_conn *conn, __u8 role)
 }
 EXPORT_SYMBOL(hci_conn_switch_role);
 
+/* Change ACL link policy */
+int hci_cfg_link_policy(struct hci_conn *conn)
+{
+	struct hci_cp_write_link_policy lp;
+
+	if (conn == NULL) {
+		BT_ERR("%s: NO HCI Connection handle available!", __func__);
+		return -ENODEV;
+	}
+	BT_INFO("%s: Disabling role switch on the ACL handle %d",
+		__func__, conn->handle);
+	lp.handle = conn->handle;
+	lp.policy = HCI_LP_HOLD|HCI_LP_SNIFF|HCI_LP_PARK;
+	hci_send_cmd(conn->hdev, HCI_OP_WRITE_LINK_POLICY, sizeof(lp), &lp);
+	return 0;
+}
+EXPORT_SYMBOL(hci_cfg_link_policy);
+
 /* Enter active mode */
 void hci_conn_enter_active_mode(struct hci_conn *conn, __u8 force_active)
 {
diff --git a/net/bluetooth/hci_core.c b/net/bluetooth/hci_core.c
index 5578897..9764e60 100644
--- a/net/bluetooth/hci_core.c
+++ b/net/bluetooth/hci_core.c
@@ -1414,7 +1414,7 @@ int hci_dev_cmd(unsigned int cmd, void __user *arg)
 
 	case HCISETLINKMODE:
 		hdev->link_mode = ((__u16) dr.dev_opt) &
-					(HCI_LM_MASTER | HCI_LM_ACCEPT);
+					(HCI_LM_MASTER);
 		break;
 
 	case HCISETPTYPE:
@@ -2124,7 +2124,7 @@ struct hci_dev *hci_alloc_dev(void)
 
 	hdev->pkt_type  = (HCI_DM1 | HCI_DH1 | HCI_HV1);
 	hdev->esco_type = (ESCO_HV1);
-	hdev->link_mode = (HCI_LM_ACCEPT);
+	hdev->link_mode = (HCI_LM_MASTER); /* Allow DUT to be in MASTER role */
 	hdev->io_capability = 0x03; /* No Input No Output */
 	hdev->inq_tx_power = HCI_TX_POWER_INVALID;
 	hdev->adv_tx_power = HCI_TX_POWER_INVALID;
diff --git a/net/bluetooth/hci_event.c b/net/bluetooth/hci_event.c
index f97baf4..2d55119 100644
--- a/net/bluetooth/hci_event.c
+++ b/net/bluetooth/hci_event.c
@@ -1726,6 +1726,9 @@ static void hci_conn_complete_evt(struct hci_dev *hdev, struct sk_buff *skb)
 			hci_send_cmd(hdev, HCI_OP_CHANGE_CONN_PTYPE, sizeof(cp),
 				     &cp);
 		}
+
+		/* Change the ACL LINK POLICY to disable role switch */
+		hci_cfg_link_policy(conn);
 	} else {
 		conn->state = BT_CLOSED;
 		if (conn->type == ACL_LINK)
-- 
1.7.9.5


From e193de1e6cdae70d57449a8d917f08c3614bc780 Mon Sep 17 00:00:00 2001
From: Rupesh Tatiya <rtatiya@codeaurora.org>
Date: Fri, 26 Sep 2014 17:59:09 +0530
Subject: [PATCH 16/25] bluetooth: Check for NULL pointers in input args

There is a possibility that line discipline recieves data before
variable proto is set which leads to kernel crash.
Check if proto is valid.

Change-Id: I09e4ca692ccef6dcc2f0acd78ce3847878d17188
Signed-off-by: Rupesh Tatiya <rtatiya@codeaurora.org>
---
 drivers/bluetooth/hci_ldisc.c |    5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/drivers/bluetooth/hci_ldisc.c b/drivers/bluetooth/hci_ldisc.c
index 836b1cd..c1cd153 100644
--- a/drivers/bluetooth/hci_ldisc.c
+++ b/drivers/bluetooth/hci_ldisc.c
@@ -380,12 +380,15 @@ static void hci_uart_tty_receive(struct tty_struct *tty, const u8 *data, char *f
 {
 	struct hci_uart *hu = (void *)tty->disc_data;
 
-	if (!hu || tty != hu->tty)
+	if (!hu || tty != hu->tty || !data)
 		return;
 
 	if (!test_bit(HCI_UART_PROTO_SET, &hu->flags))
 		return;
 
+	if (!hu->proto)
+		return;
+
 	spin_lock(&hu->rx_lock);
 	hu->proto->recv(hu, (void *) data, count);
 
-- 
1.7.9.5


From 4ff3c0e95c70a89341d9b50576404ae7b79b42f8 Mon Sep 17 00:00:00 2001
From: Kamal Negi <kamaln@codeaurora.org>
Date: Wed, 3 Dec 2014 18:39:56 +0530
Subject: [PATCH 17/25] bluetooth: Notify connection deletion only for
 SCO/ESCO links.

When SCO is active , if we create a connection to another remote
device and delete it, then the alternate setting for the ISOC
channel is getting disabled.

THis is a bug in the BTUSB driver which listens for connection
deletion notification for both ACL and SCO.

Hence, even if ACL disconnection happens with a different remote
device, we set the alternate setting of the currently active
ISOC endpoint to '0' which disables the ISOC endpoint.

As a result there are no further SCO data being sent to the
BT controller.

Change-Id: Ie33752794ee494ffbf29941278a643d8bd103077
CRs-Fixed: 764018
Signed-off-by: Kamal Negi <kamaln@codeaurora.org>
---
 net/bluetooth/hci_conn.c |    8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 64713af..aac45f0 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -1,6 +1,7 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
-   Copyright (c) 2000-2001, 2010, Code Aurora Forum. All rights reserved.
+   Copyright (c) 2000-2001, 2010, 2014, Code Aurora Forum. All rights
+   reserved.
 
    Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
 
@@ -455,8 +456,9 @@ int hci_conn_del(struct hci_conn *conn)
 		amp_mgr_put(conn->amp_mgr);
 
 	hci_conn_hash_del(hdev, conn);
-	if (hdev->notify)
-		hdev->notify(hdev, HCI_NOTIFY_CONN_DEL);
+	if (hdev->notify &&
+		(conn->type == SCO_LINK || conn->type == ESCO_LINK))
+			hdev->notify(hdev, HCI_NOTIFY_CONN_DEL);
 
 	skb_queue_purge(&conn->data_q);
 
-- 
1.7.9.5


From 24cdd2fab7e8dbf8f74865cd120b33a9185158dc Mon Sep 17 00:00:00 2001
From: Lukasz Rymanowski <lukasz.rymanowski@tieto.com>
Date: Thu, 14 Aug 2014 09:35:34 +0200
Subject: [PATCH 18/25] Bluetooth: Fix ERTM L2CAP resend packet

I-Frame which is going to be resend already has FCS field added and set
(if it was required). Adding additional FCS field calculated from data +
old FCS in resend function is incorrect. This patch fix that.

Issue has been found during PTS testing.

Change-Id: Iba211a180665c5f2fa2fa462f5d5c48e2d980a21
Signed-off-by: Lukasz Rymanowski <lukasz.rymanowski@tieto.com>
Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
Git-commit: 13cac15296afe7e42088ecfcd0f1d4b658248c46
Git-repo: git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
Signed-off-by: Kamal Negi <kamaln@codeaurora.org>
---
 net/bluetooth/l2cap_core.c |    8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

diff --git a/net/bluetooth/l2cap_core.c b/net/bluetooth/l2cap_core.c
index 68843a2..64881ca 100644
--- a/net/bluetooth/l2cap_core.c
+++ b/net/bluetooth/l2cap_core.c
@@ -2098,10 +2098,12 @@ static void l2cap_ertm_resend(struct l2cap_chan *chan)
 					   tx_skb->data + L2CAP_HDR_SIZE);
 		}
 
+		/* Update FCS */
 		if (chan->fcs == L2CAP_FCS_CRC16) {
-			u16 fcs = crc16(0, (u8 *) tx_skb->data, tx_skb->len);
-			put_unaligned_le16(fcs, skb_put(tx_skb,
-							L2CAP_FCS_SIZE));
+			u16 fcs = crc16(0, (u8 *) tx_skb->data,
+					tx_skb->len - L2CAP_FCS_SIZE);
+			put_unaligned_le16(fcs, skb_tail_pointer(tx_skb) -
+						L2CAP_FCS_SIZE);
 		}
 
 		l2cap_do_send(chan, tx_skb);
-- 
1.7.9.5


From 88651803e12e9983ca62dc21c272d69410b7d528 Mon Sep 17 00:00:00 2001
From: Seung-Woo Kim <sw0312.kim@samsung.com>
Date: Tue, 5 Nov 2013 18:46:33 +0900
Subject: [PATCH 19/25] Bluetooth: Fix crash in l2cap_chan_send after
 l2cap_chan_del

Removing a bond and disconnecting from a specific remote device
can cause l2cap_chan_send() is called after l2cap_chan_del() is
called. This causes following crash.

[ 1384.972086] Unable to handle kernel NULL pointer dereference at virtual address 00000008
[ 1384.972090] pgd = c0004000
[ 1384.972125] [00000008] *pgd=00000000
[ 1384.972137] Internal error: Oops: 17 [#1] PREEMPT SMP ARM
[ 1384.972144] Modules linked in:
[ 1384.972156] CPU: 0 PID: 841 Comm: krfcommd Not tainted 3.10.14-gdf22a71-dirty #435
[ 1384.972162] task: df29a100 ti: df178000 task.ti: df178000
[ 1384.972182] PC is at l2cap_create_basic_pdu+0x30/0x1ac
[ 1384.972191] LR is at l2cap_chan_send+0x100/0x1d4
[ 1384.972198] pc : [<c051d250>]    lr : [<c0521c78>]    psr: 40000113
[ 1384.972198] sp : df179d40  ip : c083a010  fp : 00000008
[ 1384.972202] r10: 00000004  r9 : 0000065a  r8 : 000003f5
[ 1384.972206] r7 : 00000000  r6 : 00000000  r5 : df179e84  r4 : da557000
[ 1384.972210] r3 : 00000000  r2 : 00000004  r1 : df179e84  r0 : 00000000
[ 1384.972215] Flags: nZcv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment kernel
[ 1384.972220] Control: 10c53c7d  Table: 5c8b004a  DAC: 00000015
[ 1384.972224] Process krfcommd (pid: 841, stack limit = 0xdf178238)
[ 1384.972229] Stack: (0xdf179d40 to 0xdf17a000)
[ 1384.972238] 9d40: 00000000 da557000 00000004 df179e84 00000004 000003f5 0000065a 00000000
[ 1384.972245] 9d60: 00000008 c0521c78 df179e84 da557000 00000004 da557204 de0c6800 df179e84
[ 1384.972253] 9d80: da557000 00000004 da557204 c0526b7c 00000004 df724000 df179e84 00000004
[ 1384.972260] 9da0: df179db0 df29a100 c083bc48 c045481c 00000001 00000000 00000000 00000000
[ 1384.972267] 9dc0: 00000000 df29a100 00000000 00000000 00000000 00000000 df179e10 00000000
[ 1384.972274] 9de0: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
[ 1384.972281] 9e00: 00000000 00000000 00000000 00000000 df179e4c c000ec80 c0b538c0 00000004
[ 1384.972288] 9e20: df724000 df178000 00000000 df179e84 c0b538c0 00000000 df178000 c07f4570
[ 1384.972295] 9e40: dcad9c00 df179e74 c07f4394 df179e60 df178000 00000000 df179e84 de247010
[ 1384.972303] 9e60: 00000043 c0454dec 00000001 00000004 df315c00 c0530598 00000004 df315c0c
[ 1384.972310] 9e80: ffffc32c 00000000 00000000 df179ea0 00000001 00000000 00000000 00000000
[ 1384.972317] 9ea0: df179ebc 00000004 df315c00 c05df838 00000000 c0530810 c07d08c0 d7017303
[ 1384.972325] 9ec0: 6ec245b9 00000000 df315c00 c0531b04 c07f3fe0 c07f4018 da67a300 df315c00
[ 1384.972332] 9ee0: 00000000 c05334e0 df315c00 df315b80 df315c00 de0c6800 da67a300 00000000
[ 1384.972339] 9f00: de0c684c c0533674 df204100 df315c00 df315c00 df204100 df315c00 c082b138
[ 1384.972347] 9f20: c053385c c0533754 a0000113 df178000 00000001 c083bc48 00000000 c053385c
[ 1384.972354] 9f40: 00000000 00000000 00000000 c05338c4 00000000 df9f0000 df9f5ee4 df179f6c
[ 1384.972360] 9f60: df178000 c0049db4 00000000 00000000 c07f3ff8 00000000 00000000 00000000
[ 1384.972368] 9f80: df179f80 df179f80 00000000 00000000 df179f90 df179f90 df9f5ee4 c0049cfc
[ 1384.972374] 9fa0: 00000000 00000000 00000000 c000f168 00000000 00000000 00000000 00000000
[ 1384.972381] 9fc0: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
[ 1384.972388] 9fe0: 00000000 00000000 00000000 00000000 00000013 00000000 00010000 00000600
[ 1384.972411] [<c051d250>] (l2cap_create_basic_pdu+0x30/0x1ac) from [<c0521c78>] (l2cap_chan_send+0x100/0x1d4)
[ 1384.972425] [<c0521c78>] (l2cap_chan_send+0x100/0x1d4) from [<c0526b7c>] (l2cap_sock_sendmsg+0xa8/0x104)
[ 1384.972440] [<c0526b7c>] (l2cap_sock_sendmsg+0xa8/0x104) from [<c045481c>] (sock_sendmsg+0xac/0xcc)
[ 1384.972453] [<c045481c>] (sock_sendmsg+0xac/0xcc) from [<c0454dec>] (kernel_sendmsg+0x2c/0x34)
[ 1384.972469] [<c0454dec>] (kernel_sendmsg+0x2c/0x34) from [<c0530598>] (rfcomm_send_frame+0x58/0x7c)
[ 1384.972481] [<c0530598>] (rfcomm_send_frame+0x58/0x7c) from [<c0530810>] (rfcomm_send_ua+0x98/0xbc)
[ 1384.972494] [<c0530810>] (rfcomm_send_ua+0x98/0xbc) from [<c0531b04>] (rfcomm_recv_disc+0xac/0x100)
[ 1384.972506] [<c0531b04>] (rfcomm_recv_disc+0xac/0x100) from [<c05334e0>] (rfcomm_recv_frame+0x144/0x264)
[ 1384.972519] [<c05334e0>] (rfcomm_recv_frame+0x144/0x264) from [<c0533674>] (rfcomm_process_rx+0x74/0xfc)
[ 1384.972531] [<c0533674>] (rfcomm_process_rx+0x74/0xfc) from [<c0533754>] (rfcomm_process_sessions+0x58/0x160)
[ 1384.972543] [<c0533754>] (rfcomm_process_sessions+0x58/0x160) from [<c05338c4>] (rfcomm_run+0x68/0x110)
[ 1384.972558] [<c05338c4>] (rfcomm_run+0x68/0x110) from [<c0049db4>] (kthread+0xb8/0xbc)
[ 1384.972576] [<c0049db4>] (kthread+0xb8/0xbc) from [<c000f168>] (ret_from_fork+0x14/0x2c)
[ 1384.972586] Code: e3100004 e1a07003 e5946000 1a000057 (e5969008)
[ 1384.972614] ---[ end trace 6170b7ce00144e8c ]---

Change-Id: If1f7e822500fb9f833517c4fbfc82e648b07c27c
Signed-off-by: Seung-Woo Kim <sw0312.kim@samsung.com>
Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
Git-commit: 31e8ce80baa7eaed9eec611deba982b24beed9e5
Git-repo: git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
Signed-off-by: Kamal Negi <kamaln@codeaurora.org>
---
 net/bluetooth/l2cap_core.c |    3 +++
 1 file changed, 3 insertions(+)

diff --git a/net/bluetooth/l2cap_core.c b/net/bluetooth/l2cap_core.c
index 64881ca..bc17114 100644
--- a/net/bluetooth/l2cap_core.c
+++ b/net/bluetooth/l2cap_core.c
@@ -2450,6 +2450,9 @@ int l2cap_chan_send(struct l2cap_chan *chan, struct msghdr *msg, size_t len,
 	int err;
 	struct sk_buff_head seg_queue;
 
+	if (!chan->conn)
+		return -ENOTCONN;
+
 	/* Connectionless channel */
 	if (chan->chan_type == L2CAP_CHAN_CONN_LESS) {
 		skb = l2cap_create_connless_pdu(chan, msg, len, priority);
-- 
1.7.9.5


From d5b1f67787107fb2a71733c2f44708b10c01b3ba Mon Sep 17 00:00:00 2001
From: Rupesh Tatiya <rtatiya@codeaurora.org>
Date: Tue, 23 Dec 2014 22:44:05 +0530
Subject: [PATCH 21/25] bluetooth: return on incorrect version or firmware
 download failure

if execution continues even after an error in get version or firmware
download, there can be page fault or memory corruption.

Change-Id: I3678fbc390376b81c1e10f426772428ad0c5d7ac
Signed-off-by: Rupesh Tatiya <rtatiya@codeaurora.org>
---
 drivers/bluetooth/ath3k.c         |  122 +++++++++++++++++++------------------
 drivers/bluetooth/ath3k.h         |   27 ++++++++
 drivers/bluetooth/btusb.c         |   25 +++++---
 include/net/bluetooth/bluetooth.h |    3 -
 4 files changed, 106 insertions(+), 71 deletions(-)
 create mode 100644 drivers/bluetooth/ath3k.h

diff --git a/drivers/bluetooth/ath3k.c b/drivers/bluetooth/ath3k.c
index c6e3f10..1d85a3e 100644
--- a/drivers/bluetooth/ath3k.c
+++ b/drivers/bluetooth/ath3k.c
@@ -30,6 +30,8 @@
 #include <linux/usb.h>
 #include <net/bluetooth/bluetooth.h>
 
+#include "ath3k.h"
+
 #define VERSION "1.0"
 #define ATH3K_FIRMWARE	"ath3k-1.fw"
 
@@ -71,14 +73,6 @@
 #define ATH3K_XTAL_FREQ_19P2			0x02
 #define ATH3K_NAME_LEN				0xFF
 
-struct ath3k_version {
-	unsigned int	rom_version;
-	unsigned int	build_version;
-	unsigned int	ram_version;
-	unsigned char	ref_clock;
-	unsigned char	reserved[0x07];
-};
-
 struct __packed rome1_1_version {
 	u8	type;
 	u8	length[3];
@@ -283,10 +277,15 @@ static int ath3k_get_version(struct usb_device *udev,
 	return ret;
 }
 
-int get_rome_version(struct usb_device *udev)
+int get_rome_version(struct usb_device *udev, struct ath3k_version *version)
 {
 	struct ath3k_version fw_version;
-	int ret = 0;
+	int ret = -1;
+
+	if (!version) {
+		BT_ERR("NULL output parameters");
+		return ret;
+	}
 
 	ret = ath3k_get_version(udev, &fw_version);
 	if (ret < 0) {
@@ -298,12 +297,15 @@ int get_rome_version(struct usb_device *udev)
 	case ROME1_1_USB_CHIP_VERSION:
 	case ROME2_1_USB_CHIP_VERSION:
 	case ROME3_0_USB_CHIP_VERSION:
-		ret = fw_version.rom_version;
+		memcpy(version, &fw_version, sizeof(struct ath3k_version));
+		ret = 0;
 		break;
 	default:
-		ret = 0;
+		BT_ERR("Unsupported ROME USB version");
+		ret = -1;
 		break;
 	}
+
 	return ret;
 }
 EXPORT_SYMBOL(get_rome_version);
@@ -393,12 +395,13 @@ static int ath3k_set_normal_mode(struct usb_device *udev)
 			NULL, 0, USB_CTRL_SET_TIMEOUT);
 }
 
-static int ath3k_load_patch(struct usb_device *udev)
+static int ath3k_load_patch(struct usb_device *udev,
+						struct ath3k_version *version)
 {
 	unsigned char fw_state;
 	char filename[ATH3K_NAME_LEN] = {0};
 	const struct firmware *firmware;
-	struct ath3k_version fw_version, pt_version;
+	struct ath3k_version pt_version;
 	struct rome2_1_version *rome2_1_version;
 	struct rome1_1_version *rome1_1_version;
 	int ret;
@@ -418,66 +421,67 @@ static int ath3k_load_patch(struct usb_device *udev)
 		BT_DBG("%s: Downloading RamPatch(fw_state: %d)", __func__,
 			fw_state);
 
-	ret = ath3k_get_version(udev, &fw_version);
-	if (ret < 0) {
-		BT_ERR("Can't get version to change to load ram patch err");
-		return ret;
-	}
-	if (fw_version.rom_version == ROME1_1_USB_CHIP_VERSION) {
+	switch (version->rom_version) {
+	case ROME1_1_USB_CHIP_VERSION:
 		BT_DBG("Chip Detected as ROME1.1");
 		snprintf(filename, ATH3K_NAME_LEN, ROME1_1_USB_RAMPATCH_FILE);
-	} else if (fw_version.rom_version == ROME2_1_USB_CHIP_VERSION) {
+		break;
+	case ROME2_1_USB_CHIP_VERSION:
 		BT_DBG("Chip Detected as ROME2.1");
 		snprintf(filename, ATH3K_NAME_LEN, ROME2_1_USB_RAMPATCH_FILE);
-	} else if (fw_version.rom_version == ROME3_0_USB_CHIP_VERSION) {
+		break;
+	case ROME3_0_USB_CHIP_VERSION:
 		BT_DBG("Chip Detected as ROME3.0");
 		snprintf(filename, ATH3K_NAME_LEN, ROME3_0_USB_RAMPATCH_FILE);
-	} else {
+		break;
+	default:
 		BT_DBG("Chip Detected as Ath3k");
 		snprintf(filename, ATH3K_NAME_LEN, "ar3k/AthrBT_0x%08x.dfu",
-		fw_version.rom_version);
+		version->rom_version);
+		break;
 	}
+
 	ret = request_firmware(&firmware, filename, &udev->dev);
 	if (ret < 0) {
 		BT_ERR("Patch file not found %s", filename);
 		return ret;
 	}
 
-	if ((fw_version.rom_version == ROME2_1_USB_CHIP_VERSION) ||
-		(fw_version.rom_version == ROME3_0_USB_CHIP_VERSION)) {
+	if ((version->rom_version == ROME2_1_USB_CHIP_VERSION) ||
+		(version->rom_version == ROME3_0_USB_CHIP_VERSION)) {
 		rome2_1_version = (struct rome2_1_version *) firmware->data;
 		pt_version.rom_version = rome2_1_version->build_ver;
 		pt_version.build_version = rome2_1_version->patch_ver;
 		BT_DBG("pt_ver.rome_ver : 0x%x", pt_version.rom_version);
 		BT_DBG("pt_ver.build_ver: 0x%x", pt_version.build_version);
-		BT_DBG("fw_ver.rom_ver: 0x%x", fw_version.rom_version);
-		BT_DBG("fw_ver.build_ver: 0x%x", fw_version.build_version);
-	} else if (fw_version.rom_version == ROME1_1_USB_CHIP_VERSION) {
+		BT_DBG("fw_ver.rom_ver: 0x%x", version->rom_version);
+		BT_DBG("fw_ver.build_ver: 0x%x", version->build_version);
+	} else if (version->rom_version == ROME1_1_USB_CHIP_VERSION) {
 		rome1_1_version = (struct rome1_1_version *) firmware->data;
 		pt_version.build_version = rome1_1_version->build_ver;
 		pt_version.rom_version = rome1_1_version->patch_ver;
 		BT_DBG("pt_ver.rom1.1_ver : 0x%x", pt_version.rom_version);
 		BT_DBG("pt_ver.build1.1_ver: 0x%x", pt_version.build_version);
-		BT_DBG("fw_ver.rom1.1_ver: 0x%x", fw_version.rom_version);
-		BT_DBG("fw_ver.build1.1_ver: 0x%x", fw_version.build_version);
+		BT_DBG("fw_ver.rom1.1_ver: 0x%x", version->rom_version);
+		BT_DBG("fw_ver.build1.1_ver: 0x%x", version->build_version);
 	} else {
 		pt_version.rom_version = *(int *)(firmware->data +
 						firmware->size - 8);
 		pt_version.build_version = *(int *)
 		(firmware->data + firmware->size - 4);
 	}
-	if ((pt_version.rom_version != fw_version.rom_version) ||
-		(pt_version.build_version <= fw_version.build_version)) {
+	if ((pt_version.rom_version != version->rom_version) ||
+		(pt_version.build_version <= version->build_version)) {
 		BT_ERR("Patch file version did not match with firmware");
 		release_firmware(firmware);
 		return -EINVAL;
 	}
 
-	if ((fw_version.rom_version == ROME2_1_USB_CHIP_VERSION) ||
-		(fw_version.rom_version == ROME3_0_USB_CHIP_VERSION))
+	if ((version->rom_version == ROME2_1_USB_CHIP_VERSION) ||
+		(version->rom_version == ROME3_0_USB_CHIP_VERSION))
 		ret = ath3k_load_fwfile(udev, firmware,
 						ROME2_1_USB_RAMPATCH_HEADER);
-	else if (fw_version.rom_version == ROME1_1_USB_CHIP_VERSION)
+	else if (version->rom_version == ROME1_1_USB_CHIP_VERSION)
 		ret = ath3k_load_fwfile(udev, firmware,
 						 ROME1_1_USB_RAMPATCH_HEADER);
 	else
@@ -488,12 +492,12 @@ static int ath3k_load_patch(struct usb_device *udev)
 	return ret;
 }
 
-static int ath3k_load_syscfg(struct usb_device *udev)
+static int ath3k_load_syscfg(struct usb_device *udev,
+						struct ath3k_version *version)
 {
 	unsigned char fw_state;
 	char filename[ATH3K_NAME_LEN] = {0};
 	const struct firmware *firmware;
-	struct ath3k_version fw_version;
 	int clk_value, ret;
 
 	ret = ath3k_get_state(udev, &fw_state);
@@ -510,14 +514,7 @@ static int ath3k_load_syscfg(struct usb_device *udev)
 	} else
 		BT_DBG("%s: Downloading NVM(fw_state: %d)", __func__, fw_state);
 
-	ret = ath3k_get_version(udev, &fw_version);
-	if (ret < 0) {
-		BT_ERR("Can't get version to change to load ram patch err");
-		return ret;
-	}
-
-	switch (fw_version.ref_clock) {
-
+	switch (version->ref_clock) {
 	case ATH3K_XTAL_FREQ_26M:
 		clk_value = 26;
 		break;
@@ -532,15 +529,15 @@ static int ath3k_load_syscfg(struct usb_device *udev)
 		break;
 	}
 
-	if (fw_version.rom_version == ROME2_1_USB_CHIP_VERSION)
+	if (version->rom_version == ROME2_1_USB_CHIP_VERSION)
 		snprintf(filename, ATH3K_NAME_LEN, ROME2_1_USB_NVM_FILE);
-	else if (fw_version.rom_version == ROME3_0_USB_CHIP_VERSION)
+	else if (version->rom_version == ROME3_0_USB_CHIP_VERSION)
 		snprintf(filename, ATH3K_NAME_LEN, ROME3_0_USB_NVM_FILE);
-	else if (fw_version.rom_version == ROME1_1_USB_CHIP_VERSION)
+	else if (version->rom_version == ROME1_1_USB_CHIP_VERSION)
 		snprintf(filename, ATH3K_NAME_LEN, ROME1_1_USB_NVM_FILE);
 	else
 		snprintf(filename, ATH3K_NAME_LEN, "ar3k/ramps_0x%08x_%d%s",
-			fw_version.rom_version, clk_value, ".dfu");
+			version->rom_version, clk_value, ".dfu");
 
 	ret = request_firmware(&firmware, filename, &udev->dev);
 	if (ret < 0) {
@@ -548,29 +545,29 @@ static int ath3k_load_syscfg(struct usb_device *udev)
 		return ret;
 	}
 
-	if ((fw_version.rom_version == ROME2_1_USB_CHIP_VERSION) ||
-		(fw_version.rom_version == ROME3_0_USB_CHIP_VERSION))
+	if ((version->rom_version == ROME2_1_USB_CHIP_VERSION) ||
+		(version->rom_version == ROME3_0_USB_CHIP_VERSION))
 		ret = ath3k_load_fwfile(udev, firmware, ROME2_1_USB_NVM_HEADER);
-	else if (fw_version.rom_version == ROME1_1_USB_CHIP_VERSION)
+	else if (version->rom_version == ROME1_1_USB_CHIP_VERSION)
 		ret = ath3k_load_fwfile(udev, firmware, ROME1_1_USB_NVM_HEADER);
 	else
 		ret = ath3k_load_fwfile(udev, firmware, FW_HDR_SIZE);
+
 	release_firmware(firmware);
 
 	return ret;
 }
 
-
-int rome_download(struct usb_device *udev)
+int rome_download(struct usb_device *udev, struct ath3k_version *version)
 {
 	int ret;
 
-	ret = ath3k_load_patch(udev);
+	ret = ath3k_load_patch(udev, version);
 	if (ret < 0) {
 		BT_ERR("Loading patch file failed");
 		return ret;
 	}
-	ret = ath3k_load_syscfg(udev);
+	ret = ath3k_load_syscfg(udev, version);
 	if (ret < 0) {
 		BT_ERR("Loading sysconfig file failed");
 		return ret;
@@ -579,21 +576,26 @@ int rome_download(struct usb_device *udev)
 	return ret;
 }
 EXPORT_SYMBOL(rome_download);
+
 static int ath3k_probe(struct usb_interface *intf,
 			const struct usb_device_id *id)
 {
 	const struct firmware *firmware;
 	struct usb_device *udev = interface_to_usbdev(intf);
 	int ret;
+	struct ath3k_version version;
 
 	BT_DBG("intf %p id %p", intf, id);
 
 	if (intf->cur_altsetting->desc.bInterfaceNumber != 0)
 		return -ENODEV;
-	if (get_rome_version(udev)) {
+
+	ret = get_rome_version(udev, &version);
+	if (!ret) {
 		BT_INFO("Rome detected, fw dnld will be triggered from btusb");
 		return -ENODEV;
 	}
+
 	/* match device ID in ath3k blacklist table */
 	if (!id->driver_info) {
 		const struct usb_device_id *match;
@@ -609,12 +611,12 @@ static int ath3k_probe(struct usb_interface *intf,
 		if (le16_to_cpu(udev->descriptor.bcdDevice) > 0x0001)
 			return -ENODEV;
 
-		ret = ath3k_load_patch(udev);
+		ret = ath3k_load_patch(udev, &version);
 		if (ret < 0) {
 			BT_ERR("Loading patch file failed");
 			return ret;
 		}
-		ret = ath3k_load_syscfg(udev);
+		ret = ath3k_load_syscfg(udev, &version);
 		if (ret < 0) {
 			BT_ERR("Loading sysconfig file failed");
 			return ret;
diff --git a/drivers/bluetooth/ath3k.h b/drivers/bluetooth/ath3k.h
new file mode 100644
index 0000000..86d247a
--- /dev/null
+++ b/drivers/bluetooth/ath3k.h
@@ -0,0 +1,27 @@
+/*
+ * Copyright (c) 2008-2009 Atheros Communications Inc.
+ * Copyright (c) 2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+*/
+
+#include <linux/usb.h>
+
+struct ath3k_version {
+	unsigned int	rom_version;
+	unsigned int	build_version;
+	unsigned int	ram_version;
+	unsigned char	ref_clock;
+	unsigned char	reserved[0x07];
+};
+
+int get_rome_version(struct usb_device *udev, struct ath3k_version *version);
+int rome_download(struct usb_device *udev, struct ath3k_version *version);
+
diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c
index 4d31349..5cb0c70 100644
--- a/drivers/bluetooth/btusb.c
+++ b/drivers/bluetooth/btusb.c
@@ -27,6 +27,8 @@
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
 
+#include "ath3k.h"
+
 #define VERSION "0.6"
 
 static bool ignore_dga;
@@ -1324,7 +1326,8 @@ static int btusb_probe(struct usb_interface *intf,
 	struct usb_endpoint_descriptor *ep_desc;
 	struct btusb_data *data;
 	struct hci_dev *hdev;
-	int i, version, err;
+	int i, err;
+	struct ath3k_version version;
 
 	BT_DBG("intf %p id %p", intf, id);
 
@@ -1353,18 +1356,24 @@ static int btusb_probe(struct usb_interface *intf,
 
 	if (id->driver_info & BTUSB_ATH3012) {
 		struct usb_device *udev = interface_to_usbdev(intf);
-
-		version = get_rome_version(udev);
-		BT_INFO("Rome Version: 0x%x",  version);
 		/* Old firmware would otherwise let ath3k driver load
 		 * patch and sysconfig files */
-		if (version)
-			rome_download(udev);
-		else if (le16_to_cpu(udev->descriptor.bcdDevice) <= 0x0001) {
-			BT_INFO("FW for ar3k is yet to be downloaded");
+		err = get_rome_version(udev, &version);
+		if (err < 0) {
+			if (le16_to_cpu(udev->descriptor.bcdDevice) <= 0x0001)
+				BT_INFO("FW for ar3k is yet to be downloaded");
+			else
+				BT_ERR("Failed to get ROME USB version");
+			return -ENODEV;
+		}
+		BT_INFO("Rome Version: 0x%x", version.rom_version);
+		err = rome_download(udev, &version);
+		if (err < 0) {
+			BT_ERR("Failed to download ROME firmware");
 			return -ENODEV;
 		}
 	}
+
 	data = devm_kzalloc(&intf->dev, sizeof(*data), GFP_KERNEL);
 	if (!data)
 		return -ENOMEM;
diff --git a/include/net/bluetooth/bluetooth.h b/include/net/bluetooth/bluetooth.h
index 5ad8266..f32ce80 100644
--- a/include/net/bluetooth/bluetooth.h
+++ b/include/net/bluetooth/bluetooth.h
@@ -346,7 +346,4 @@ void sco_exit(void);
 
 void bt_sock_reclassify_lock(struct sock *sk, int proto);
 
-int get_rome_version(struct usb_device *udev);
-int rome_download(struct usb_device *udev);
-
 #endif /* __BLUETOOTH_H */
-- 
1.7.9.5


From ec6ba25b59abd028e8104f18a6e1650332bdbf52 Mon Sep 17 00:00:00 2001
From: Kamal Negi <kamaln@codeaurora.org>
Date: Thu, 29 Jan 2015 13:25:02 +0530
Subject: [PATCH 22/25] bluetooth: Add support for Tufello 1.1

Enable mechanism to download the firmware for
Tufello 1.1

Change-Id: Ib1fa1c25f1772c1a42c7e636f4a82c2bca2ac0de
Signed-off-by: Kamal Negi <kamaln@codeaurora.org>
---
 drivers/bluetooth/ath3k.c |   34 +++++++++++++++++++++++++++++++---
 drivers/bluetooth/btusb.c |    1 +
 2 files changed, 32 insertions(+), 3 deletions(-)

diff --git a/drivers/bluetooth/ath3k.c b/drivers/bluetooth/ath3k.c
index 1d85a3e..b91efbe 100644
--- a/drivers/bluetooth/ath3k.c
+++ b/drivers/bluetooth/ath3k.c
@@ -44,6 +44,9 @@
 #define ROME3_0_USB_RAMPATCH_FILE	"ar3k/rampatch_tlv_usb_3.0.tlv"
 #define ROME3_0_USB_NVM_FILE		"ar3k/nvm_tlv_usb_3.0.bin"
 
+#define TF1_1_USB_RAMPATCH_FILE	"ar3k/rampatch_tlv_usb_tf_1.1.tlv"
+#define TF1_1_USB_NVM_FILE		"ar3k/nvm_tlv_usb_tf_1.1.bin"
+
 #define ROME2_1_USB_RAMPATCH_HEADER	sizeof(struct rome2_1_version)
 #define ROME1_1_USB_RAMPATCH_HEADER	sizeof(struct rome1_1_version)
 
@@ -53,7 +56,9 @@
 #define ROME1_1_USB_CHIP_VERSION		0x101
 #define ROME2_1_USB_CHIP_VERSION		0x200
 #define ROME3_0_USB_CHIP_VERSION		0x300
+#define ROME3_2_USB_CHIP_VERSION		0x302
 
+#define TF1_1_USB_PRODUCT_ID			0xe500
 #define ATH3K_DNLOAD				0x01
 #define ATH3K_GETSTATE				0x05
 #define ATH3K_SET_NORMAL_MODE			0x07
@@ -122,6 +127,7 @@ static struct usb_device_id ath3k_table[] = {
 	{ USB_DEVICE(0x0CF3, 0x3008) },
 	{ USB_DEVICE(0x0CF3, 0x311D) },
 	{ USB_DEVICE(0x0CF3, 0x817a) },
+	{ USB_DEVICE(0x0CF3, 0xe500) },
 	{ USB_DEVICE(0x13d3, 0x3375) },
 	{ USB_DEVICE(0x04CA, 0x3004) },
 	{ USB_DEVICE(0x04CA, 0x3005) },
@@ -297,6 +303,7 @@ int get_rome_version(struct usb_device *udev, struct ath3k_version *version)
 	case ROME1_1_USB_CHIP_VERSION:
 	case ROME2_1_USB_CHIP_VERSION:
 	case ROME3_0_USB_CHIP_VERSION:
+	case ROME3_2_USB_CHIP_VERSION:
 		memcpy(version, &fw_version, sizeof(struct ath3k_version));
 		ret = 0;
 		break;
@@ -434,6 +441,16 @@ static int ath3k_load_patch(struct usb_device *udev,
 		BT_DBG("Chip Detected as ROME3.0");
 		snprintf(filename, ATH3K_NAME_LEN, ROME3_0_USB_RAMPATCH_FILE);
 		break;
+	case ROME3_2_USB_CHIP_VERSION:
+		if (udev->descriptor.idProduct == TF1_1_USB_PRODUCT_ID) {
+			BT_DBG("Chip Detected as TF1.1");
+			snprintf(filename, ATH3K_NAME_LEN,
+						TF1_1_USB_RAMPATCH_FILE);
+		} else {
+			BT_INFO("Unsupported Chip");
+			return -ENODEV;
+		}
+		break;
 	default:
 		BT_DBG("Chip Detected as Ath3k");
 		snprintf(filename, ATH3K_NAME_LEN, "ar3k/AthrBT_0x%08x.dfu",
@@ -448,7 +465,8 @@ static int ath3k_load_patch(struct usb_device *udev,
 	}
 
 	if ((version->rom_version == ROME2_1_USB_CHIP_VERSION) ||
-		(version->rom_version == ROME3_0_USB_CHIP_VERSION)) {
+		(version->rom_version == ROME3_0_USB_CHIP_VERSION) ||
+		(version->rom_version == ROME3_2_USB_CHIP_VERSION)) {
 		rome2_1_version = (struct rome2_1_version *) firmware->data;
 		pt_version.rom_version = rome2_1_version->build_ver;
 		pt_version.build_version = rome2_1_version->patch_ver;
@@ -478,7 +496,8 @@ static int ath3k_load_patch(struct usb_device *udev,
 	}
 
 	if ((version->rom_version == ROME2_1_USB_CHIP_VERSION) ||
-		(version->rom_version == ROME3_0_USB_CHIP_VERSION))
+		(version->rom_version == ROME3_0_USB_CHIP_VERSION) ||
+		(version->rom_version == ROME3_2_USB_CHIP_VERSION))
 		ret = ath3k_load_fwfile(udev, firmware,
 						ROME2_1_USB_RAMPATCH_HEADER);
 	else if (version->rom_version == ROME1_1_USB_CHIP_VERSION)
@@ -533,6 +552,14 @@ static int ath3k_load_syscfg(struct usb_device *udev,
 		snprintf(filename, ATH3K_NAME_LEN, ROME2_1_USB_NVM_FILE);
 	else if (version->rom_version == ROME3_0_USB_CHIP_VERSION)
 		snprintf(filename, ATH3K_NAME_LEN, ROME3_0_USB_NVM_FILE);
+	else if (version->rom_version == ROME3_2_USB_CHIP_VERSION) {
+		if (udev->descriptor.idProduct == TF1_1_USB_PRODUCT_ID)
+			snprintf(filename, ATH3K_NAME_LEN, TF1_1_USB_NVM_FILE);
+		else {
+			BT_INFO("Unsupported Chip");
+			return -ENODEV;
+		}
+	}
 	else if (version->rom_version == ROME1_1_USB_CHIP_VERSION)
 		snprintf(filename, ATH3K_NAME_LEN, ROME1_1_USB_NVM_FILE);
 	else
@@ -546,7 +573,8 @@ static int ath3k_load_syscfg(struct usb_device *udev,
 	}
 
 	if ((version->rom_version == ROME2_1_USB_CHIP_VERSION) ||
-		(version->rom_version == ROME3_0_USB_CHIP_VERSION))
+		(version->rom_version == ROME3_0_USB_CHIP_VERSION) ||
+		(version->rom_version == ROME3_2_USB_CHIP_VERSION))
 		ret = ath3k_load_fwfile(udev, firmware, ROME2_1_USB_NVM_HEADER);
 	else if (version->rom_version == ROME1_1_USB_CHIP_VERSION)
 		ret = ath3k_load_fwfile(udev, firmware, ROME1_1_USB_NVM_HEADER);
diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c
index 5cb0c70..07d6a42c 100644
--- a/drivers/bluetooth/btusb.c
+++ b/drivers/bluetooth/btusb.c
@@ -140,6 +140,7 @@ static struct usb_device_id blacklist_table[] = {
 	{ USB_DEVICE(0x0cf3, 0x3008), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0cf3, 0x311d), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0cf3, 0x817a), .driver_info = BTUSB_ATH3012 },
+	{ USB_DEVICE(0x0cf3, 0xe500), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3375), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x3004), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x3005), .driver_info = BTUSB_ATH3012 },
-- 
1.7.9.5


From f3b9ba54b1af61b7a7a4abb4d6df91ea1faf0dc3 Mon Sep 17 00:00:00 2001
From: Rupesh Tatiya <rtatiya@codeaurora.org>
Date: Fri, 23 Jan 2015 18:29:46 +0530
Subject: [PATCH 23/25] Bluetooth: kill all the anchored URBs on USB device
 disconnect

When USB driver is unloaded (rmmod), kill all the URBs before
freeing up various data structs. If not done, URB callback might
lead to NULL pointer dereference or page fault.

Change-Id: Id719f090ae96845fac50b2d97dc7e698f39b5ce5
Signed-off-by: Rupesh Tatiya <rtatiya@codeaurora.org>
---
 drivers/bluetooth/btusb.c |    6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c
index 07d6a42c..3d4ce68 100644
--- a/drivers/bluetooth/btusb.c
+++ b/drivers/bluetooth/btusb.c
@@ -1509,6 +1509,12 @@ static void btusb_disconnect(struct usb_interface *intf)
 	if (!data)
 		return;
 
+	/* kill all the anchored urbs on USB disconnect */
+	usb_kill_anchored_urbs(&data->intr_anchor);
+	usb_kill_anchored_urbs(&data->bulk_anchor);
+	usb_kill_anchored_urbs(&data->isoc_anchor);
+	usb_kill_anchored_urbs(&data->tx_anchor);
+
 	hdev = data->hdev;
 	usb_set_intfdata(data->intf, NULL);
 
-- 
1.7.9.5


From 433501f6648d74a90d5c1b7d9e6ca41c5797635f Mon Sep 17 00:00:00 2001
From: Balvinder Singh <bpsingh@codeaurora.org>
Date: Mon, 19 Jan 2015 15:41:36 +0530
Subject: [PATCH 24/25] Bluetooth: Avoid Spurious AMP node access if not
 created

Added checks for avoiding the AMP nodes, incase of Spurious
access like data corruption during Rx from BT SOC

Change-Id: Ifc974750efe2082420f89f32580ed8ccd1924a3d
Signed-off-by: Balvinder Singh <bpsingh@codeaurora.org>
CRs-Fixed: 783934
---
 net/bluetooth/hci_event.c |    9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/net/bluetooth/hci_event.c b/net/bluetooth/hci_event.c
index 2d55119..d1dddbf1 100644
--- a/net/bluetooth/hci_event.c
+++ b/net/bluetooth/hci_event.c
@@ -3408,6 +3408,7 @@ static void hci_phy_link_complete_evt(struct hci_dev *hdev,
 {
 	struct hci_ev_phy_link_complete *ev = (void *) skb->data;
 	struct hci_conn *hcon, *bredr_hcon;
+	struct amp_mgr *mgr;
 
 	BT_DBG("%s handle 0x%2.2x status 0x%2.2x", hdev->name, ev->phy_handle,
 	       ev->status);
@@ -3426,6 +3427,14 @@ static void hci_phy_link_complete_evt(struct hci_dev *hdev,
 		return;
 	}
 
+	BT_DBG("hcon %p mgr %p", hcon, hcon->amp_mgr);
+
+	mgr = hcon->amp_mgr;
+	if (!(mgr && mgr->l2cap_conn && mgr->l2cap_conn->hcon)) {
+		hci_dev_unlock(hdev);
+		BT_DBG("Amp Manager is not Initialized");
+		return;
+	}
 	bredr_hcon = hcon->amp_mgr->l2cap_conn->hcon;
 
 	hcon->state = BT_CONNECTED;
-- 
1.7.9.5


From 3f4282e92a6ef9d226a56ec74f2be38a26c2f3d0 Mon Sep 17 00:00:00 2001
From: Rupesh Tatiya <rtatiya@codeaurora.org>
Date: Wed, 21 Jan 2015 19:55:35 +0530
Subject: [PATCH 25/25] Bluetooth: change cancel_delayed_work to
 cancel_delayed_work_sync

When bluetooth transport driver module is unloaded, it is possible
that workqueue is destroyed while callback for delayed work is
executing. Wait for that callback to complete before destroying that
workqueue.

Do not cancel work in the work callback function, else it will result
in deadlock.

Change-Id: I3471f6968315fef9ad0c5ce288b61db057ff8180
Signed-off-by: Rupesh Tatiya <rtatiya@codeaurora.org>
---
 net/bluetooth/hci_core.c |   13 +++++++++++--
 1 file changed, 11 insertions(+), 2 deletions(-)

diff --git a/net/bluetooth/hci_core.c b/net/bluetooth/hci_core.c
index d5cdda4..247067a 100644
--- a/net/bluetooth/hci_core.c
+++ b/net/bluetooth/hci_core.c
@@ -1203,6 +1203,10 @@ static int hci_dev_do_close(struct hci_dev *hdev)
 
 	cancel_work_sync(&hdev->le_scan);
 
+	/* do not call cancel_delayed_work_sync for power_off here as
+	 * hci_dev_do_close function is called from work handler which might
+	 * cause deadlock. Instead to it in hci_unregister_dev
+	*/
 	cancel_delayed_work(&hdev->power_off);
 
 	hci_req_cancel(hdev, ENODEV);
@@ -1219,13 +1223,13 @@ static int hci_dev_do_close(struct hci_dev *hdev)
 	flush_work(&hdev->rx_work);
 
 	if (hdev->discov_timeout > 0) {
-		cancel_delayed_work(&hdev->discov_off);
+		cancel_delayed_work_sync(&hdev->discov_off);
 		hdev->discov_timeout = 0;
 		clear_bit(HCI_DISCOVERABLE, &hdev->dev_flags);
 	}
 
 	if (test_and_clear_bit(HCI_SERVICE_CACHE, &hdev->dev_flags))
-		cancel_delayed_work(&hdev->service_cache);
+		cancel_delayed_work_sync(&hdev->service_cache);
 
 	cancel_delayed_work_sync(&hdev->le_scan_disable);
 
@@ -2287,6 +2291,11 @@ void hci_unregister_dev(struct hci_dev *hdev)
 
 	cancel_work_sync(&hdev->power_on);
 
+	/* hci_dev_do_close does not call cancel_delayed_work_sync on power_off
+	 * work, call it here while deregistration before wqs are destroyed
+	*/
+	cancel_delayed_work_sync(&hdev->power_off);
+
 	if (!test_bit(HCI_INIT, &hdev->flags) &&
 	    !test_bit(HCI_SETUP, &hdev->dev_flags)) {
 		hci_dev_lock(hdev);
-- 
1.7.9.5

